/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btAlignedAllocator.h"

int gNumAlignedAllocs = 0;
int gNumAlignedFree = 0;
int gTotalBytesAlignedAllocs = 0; //detect memory leaks

static void* btAllocDefault(size_t size)
{
    return malloc(size);
}

static void btFreeDefault(void* ptr)
{
    free(ptr);
}

static btAllocFunc* sAllocFunc = btAllocDefault;
static btFreeFunc* sFreeFunc = btFreeDefault;

#if defined(BT_HAS_ALIGNED_ALLOCATOR)
#include <malloc.h>
static void* btAlignedAllocDefault(size_t size, int alignment)
{
    return _aligned_malloc(size, (size_t)alignment);
}

static void btAlignedFreeDefault(void* ptr)
{
    _aligned_free(ptr);
}
#elif defined(__CELLOS_LV2__)
#include <stdlib.h>

static inline void* btAlignedAllocDefault(size_t size, int alignment)
{
    return memalign(alignment, size);
}

static inline void btAlignedFreeDefault(void* ptr)
{
    free(ptr);
}
#else
static inline void* btAlignedAllocDefault(size_t size, int alignment)
{
    void* ret;
    char* real;
    unsigned long offset;

    real = (char*)sAllocFunc(size + sizeof(void*) + (alignment - 1));
    if (real) {
        offset = (alignment - (unsigned long)(real + sizeof(void*))) & (alignment - 1);
        ret = (void*)((real + sizeof(void*)) + offset);
        *((void**)(ret)-1) = (void*)(real);
    }
    else {
        ret = (void*)(real);
    }
    return (ret);
}

static inline void btAlignedFreeDefault(void* ptr)
{
    void* real;

    if (ptr) {
        real = *((void**)(ptr)-1);
        sFreeFunc(real);
    }
}
#endif

static btAlignedAllocFunc* sAlignedAllocFunc = btAlignedAllocDefault;
static btAlignedFreeFunc* sAlignedFreeFunc = btAlignedFreeDefault;

void btAlignedAllocSetCustomAligned(btAlignedAllocFunc* allocFunc, btAlignedFreeFunc* freeFunc)
{
    sAlignedAllocFunc = allocFunc ? allocFunc : btAlignedAllocDefault;
    sAlignedFreeFunc = freeFunc ? freeFunc : btAlignedFreeDefault;
}

void btAlignedAllocSetCustom(btAllocFunc* allocFunc, btFreeFunc* freeFunc)
{
    sAllocFunc = allocFunc ? allocFunc : btAllocDefault;
    sFreeFunc = freeFunc ? freeFunc : btFreeDefault;
}

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS
//this generic allocator provides the total allocated number of bytes
#include <stdio.h>

void* btAlignedAllocInternal(size_t size, int alignment, int line, char* filename)
{
    void* ret;
    char* real;
    unsigned long offset;

    gTotalBytesAlignedAllocs += size;
    gNumAlignedAllocs++;

    real = (char*)sAllocFunc(size + 2 * sizeof(void*) + (alignment - 1));
    if (real) {
        offset = (alignment - (unsigned long)(real + 2 * sizeof(void*))) & (alignment - 1);
        ret = (void*)((real + 2 * sizeof(void*)) + offset);
        *((void**)(ret)-1) = (void*)(real);
        *((int*)(ret)-2) = size;
    }
    else {
        ret = (void*)(real); //??
    }

    printf("allocation#%d at address %x, from %s,line %d, size %d\n", gNumAlignedAllocs, real, filename, line, size);

    int* ptr = (int*)ret;
    *ptr = 12;
    return (ret);
}

void btAlignedFreeInternal(void* ptr, int line, char* filename)
{

    void* real;
    gNumAlignedFree++;

    if (ptr) {
        real = *((void**)(ptr)-1);
        int size = *((int*)(ptr)-2);
        gTotalBytesAlignedAllocs -= size;

        printf("free #%d at address %x, from %s,line %d, size %d\n", gNumAlignedFree, real, filename, line, size);

        sFreeFunc(real);
    }
    else {
        printf("NULL ptr\n");
    }
}

#else //BT_DEBUG_MEMORY_ALLOCATIONS

void* btAlignedAllocInternal(size_t size, int alignment)
{
    gNumAlignedAllocs++;
    void* ptr;
    ptr = sAlignedAllocFunc(size, alignment);
    //	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
    return ptr;
}

void btAlignedFreeInternal(void* ptr)
{
    if (!ptr) {
        return;
    }

    gNumAlignedFree++;
    //	printf("btAlignedFreeInternal %x\n",ptr);
    sAlignedFreeFunc(ptr);
}

#endif //BT_DEBUG_MEMORY_ALLOCATIONS 

/*
Stan Melax Convex Hull Computation
Copyright (c) 2003-2006 Stan Melax http://www.melax.com/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include <string.h>

#include "LinearMath/btConvexHull.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btVector3.h"





//----------------------------------

class int3
{
public:
 int x, y, z;
 int3() {};
 int3(int _x, int _y, int _z) { x = _x; y = _y; z = _z; }
 const int& operator[](int i) const { return (&x)[i]; }
 int& operator[](int i) { return (&x)[i]; }
};


//------- btPlane ----------


inline btPlane PlaneFlip(const btPlane &plane) { return btPlane(-plane.normal, -plane.dist); }
inline int operator==(const btPlane &a, const btPlane &b) { return (a.normal == b.normal && a.dist == b.dist); }
inline int coplanar(const btPlane &a, const btPlane &b) { return (a == b || a == PlaneFlip(b)); }


//--------- Utility Functions ------

btVector3  PlaneLineIntersection(const btPlane &plane, const btVector3 &p0, const btVector3 &p1);
btVector3  PlaneProject(const btPlane &plane, const btVector3 &point);

btVector3  ThreePlaneIntersection(const btPlane &p0, const btPlane &p1, const btPlane &p2);
btVector3  ThreePlaneIntersection(const btPlane &p0, const btPlane &p1, const btPlane &p2)
{
 btVector3 N1 = p0.normal;
 btVector3 N2 = p1.normal;
 btVector3 N3 = p2.normal;

 btVector3 n2n3; n2n3 = N2.cross(N3);
 btVector3 n3n1; n3n1 = N3.cross(N1);
 btVector3 n1n2; n1n2 = N1.cross(N2);

 btScalar quotient = (N1.dot(n2n3));

 btAssert(btFabs(quotient) > btScalar(0.000001));

 quotient = btScalar(-1.) / quotient;
 n2n3 *= p0.dist;
 n3n1 *= p1.dist;
 n1n2 *= p2.dist;
 btVector3 potentialVertex = n2n3;
 potentialVertex += n3n1;
 potentialVertex += n1n2;
 potentialVertex *= quotient;

 btVector3 result(potentialVertex.getX(), potentialVertex.getY(), potentialVertex.getZ());
 return result;

}

btScalar   DistanceBetweenLines(const btVector3 &ustart, const btVector3 &udir, const btVector3 &vstart, const btVector3 &vdir, btVector3 *upoint = NULL, btVector3 *vpoint = NULL);
btVector3  TriNormal(const btVector3 &v0, const btVector3 &v1, const btVector3 &v2);
btVector3  NormalOf(const btVector3 *vert, const int n);


btVector3 PlaneLineIntersection(const btPlane &plane, const btVector3 &p0, const btVector3 &p1)
{
 // returns the point where the line p0-p1 intersects the plane n&d
 btVector3 dif;
 dif = p1 - p0;
 btScalar dn = btDot(plane.normal, dif);
 btScalar t = -(plane.dist + btDot(plane.normal, p0)) / dn;
 return p0 + (dif*t);
}

btVector3 PlaneProject(const btPlane &plane, const btVector3 &point)
{
 return point - plane.normal * (btDot(point, plane.normal) + plane.dist);
}

btVector3 TriNormal(const btVector3 &v0, const btVector3 &v1, const btVector3 &v2)
{
 // return the normal of the triangle
 // inscribed by v0, v1, and v2
 btVector3 cp = btCross(v1 - v0, v2 - v1);
 btScalar m = cp.length();
 if (m == 0) return btVector3(1, 0, 0);
 return cp*(btScalar(1.0) / m);
}


btScalar DistanceBetweenLines(const btVector3 &ustart, const btVector3 &udir, const btVector3 &vstart, const btVector3 &vdir, btVector3 *upoint, btVector3 *vpoint)
{
 btVector3 cp;
 cp = btCross(udir, vdir).normalized();

 btScalar distu = -btDot(cp, ustart);
 btScalar distv = -btDot(cp, vstart);
 btScalar dist = (btScalar)fabs(distu - distv);
 if (upoint)
 {
  btPlane plane;
  plane.normal = btCross(vdir, cp).normalized();
  plane.dist = -btDot(plane.normal, vstart);
  *upoint = PlaneLineIntersection(plane, ustart, ustart + udir);
 }
 if (vpoint)
 {
  btPlane plane;
  plane.normal = btCross(udir, cp).normalized();
  plane.dist = -btDot(plane.normal, ustart);
  *vpoint = PlaneLineIntersection(plane, vstart, vstart + vdir);
 }
 return dist;
}







#define COPLANAR   (0)
#define UNDER      (1)
#define OVER       (2)
#define SPLIT      (OVER|UNDER)
#define PAPERWIDTH (btScalar(0.001))

btScalar planetestepsilon = PAPERWIDTH;



typedef ConvexH::HalfEdge HalfEdge;

ConvexH::ConvexH(int vertices_size, int edges_size, int facets_size)
{
 vertices.resize(vertices_size);
 edges.resize(edges_size);
 facets.resize(facets_size);
}


int PlaneTest(const btPlane &p, const btVector3 &v);
int PlaneTest(const btPlane &p, const btVector3 &v) {
 btScalar a = btDot(v, p.normal) + p.dist;
 int   flag = (a>planetestepsilon) ? OVER : ((a<-planetestepsilon) ? UNDER : COPLANAR);
 return flag;
}

int SplitTest(ConvexH &convex, const btPlane &plane);
int SplitTest(ConvexH &convex, const btPlane &plane) {
 int flag = 0;
 for (int i = 0; i<convex.vertices.size(); i++) {
  flag |= PlaneTest(plane, convex.vertices[i]);
 }
 return flag;
}

class VertFlag
{
public:
 unsigned char planetest;
 unsigned char junk;
 unsigned char undermap;
 unsigned char overmap;
};
class EdgeFlag
{
public:
 unsigned char planetest;
 unsigned char fixes;
 short undermap;
 short overmap;
};
class PlaneFlag
{
public:
 unsigned char undermap;
 unsigned char overmap;
};
class Coplanar {
public:
 unsigned short ea;
 unsigned char v0;
 unsigned char v1;
};








template<class T>
int maxdirfiltered(const T *p, int count, const T &dir, btAlignedObjectArray<int> &allow)
{
 btAssert(count);
 int m = -1;
 for (int i = 0; i<count; i++)
  if (allow[i])
  {
   if (m == -1 || btDot(p[i], dir)>btDot(p[m], dir))
    m = i;
  }
 btAssert(m != -1);
 return m;
}

btVector3 orth(const btVector3 &v);
btVector3 orth(const btVector3 &v)
{
 btVector3 a = btCross(v, btVector3(0, 0, 1));
 btVector3 b = btCross(v, btVector3(0, 1, 0));
 if (a.length() > b.length())
 {
  return a.normalized();
 }
 else {
  return b.normalized();
 }
}


template<class T>
int maxdirsterid(const T *p, int count, const T &dir, btAlignedObjectArray<int> &allow)
{
 int m = -1;
 while (m == -1)
 {
  m = maxdirfiltered(p, count, dir, allow);
  if (allow[m] == 3) return m;
  T u = orth(dir);
  T v = btCross(u, dir);
  int ma = -1;
  for (btScalar x = btScalar(0.0); x <= btScalar(360.0); x += btScalar(45.0))
  {
   btScalar s = btSin(SIMD_RADS_PER_DEG*(x));
   btScalar c = btCos(SIMD_RADS_PER_DEG*(x));
   int mb = maxdirfiltered(p, count, dir + (u*s + v*c)*btScalar(0.025), allow);
   if (ma == m && mb == m)
   {
    allow[m] = 3;
    return m;
   }
   if (ma != -1 && ma != mb)  // Yuck - this is really ugly
   {
    int mc = ma;
    for (btScalar xx = x - btScalar(40.0); xx <= x; xx += btScalar(5.0))
    {
     btScalar s = btSin(SIMD_RADS_PER_DEG*(xx));
     btScalar c = btCos(SIMD_RADS_PER_DEG*(xx));
     int md = maxdirfiltered(p, count, dir + (u*s + v*c)*btScalar(0.025), allow);
     if (mc == m && md == m)
     {
      allow[m] = 3;
      return m;
     }
     mc = md;
    }
   }
   ma = mb;
  }
  allow[m] = 0;
  m = -1;
 }
 btAssert(0);
 return m;
}




int operator ==(const int3 &a, const int3 &b);
int operator ==(const int3 &a, const int3 &b)
{
 for (int i = 0; i<3; i++)
 {
  if (a[i] != b[i]) return 0;
 }
 return 1;
}


int above(btVector3* vertices, const int3& t, const btVector3 &p, btScalar epsilon);
int above(btVector3* vertices, const int3& t, const btVector3 &p, btScalar epsilon)
{
 btVector3 n = TriNormal(vertices[t[0]], vertices[t[1]], vertices[t[2]]);
 return (btDot(n, p - vertices[t[0]]) > epsilon); // EPSILON???
}
int hasedge(const int3 &t, int a, int b);
int hasedge(const int3 &t, int a, int b)
{
 for (int i = 0; i<3; i++)
 {
  int i1 = (i + 1) % 3;
  if (t[i] == a && t[i1] == b) return 1;
 }
 return 0;
}
int hasvert(const int3 &t, int v);
int hasvert(const int3 &t, int v)
{
 return (t[0] == v || t[1] == v || t[2] == v);
}
int shareedge(const int3 &a, const int3 &b);
int shareedge(const int3 &a, const int3 &b)
{
 int i;
 for (i = 0; i<3; i++)
 {
  int i1 = (i + 1) % 3;
  if (hasedge(a, b[i1], b[i])) return 1;
 }
 return 0;
}

class btHullTriangle;



class btHullTriangle : public int3
{
public:
 int3 n;
 int id;
 int vmax;
 btScalar rise;
 btHullTriangle(int a, int b, int c) :int3(a, b, c), n(-1, -1, -1)
 {
  vmax = -1;
  rise = btScalar(0.0);
 }
 ~btHullTriangle()
 {
 }
 int &neib(int a, int b);
};


int &btHullTriangle::neib(int a, int b)
{
 static int er = -1;
 int i;
 for (i = 0; i<3; i++)
 {
  int i1 = (i + 1) % 3;
  int i2 = (i + 2) % 3;
  if ((*this)[i] == a && (*this)[i1] == b) return n[i2];
  if ((*this)[i] == b && (*this)[i1] == a) return n[i2];
 }
 btAssert(0);
 return er;
}
void HullLibrary::b2bfix(btHullTriangle* s, btHullTriangle*t)
{
 int i;
 for (i = 0; i<3; i++)
 {
  int i1 = (i + 1) % 3;
  int i2 = (i + 2) % 3;
  int a = (*s)[i1];
  int b = (*s)[i2];
  btAssert(m_tris[s->neib(a, b)]->neib(b, a) == s->id);
  btAssert(m_tris[t->neib(a, b)]->neib(b, a) == t->id);
  m_tris[s->neib(a, b)]->neib(b, a) = t->neib(b, a);
  m_tris[t->neib(b, a)]->neib(a, b) = s->neib(a, b);
 }
}

void HullLibrary::removeb2b(btHullTriangle* s, btHullTriangle*t)
{
 b2bfix(s, t);
 deAllocateTriangle(s);

 deAllocateTriangle(t);
}

void HullLibrary::checkit(btHullTriangle *t)
{
 (void)t;

 int i;
 btAssert(m_tris[t->id] == t);
 for (i = 0; i<3; i++)
 {
  int i1 = (i + 1) % 3;
  int i2 = (i + 2) % 3;
  int a = (*t)[i1];
  int b = (*t)[i2];

  // release compile fix
  (void)i1;
  (void)i2;
  (void)a;
  (void)b;

  btAssert(a != b);
  btAssert(m_tris[t->n[i]]->neib(b, a) == t->id);
 }
}

btHullTriangle*	HullLibrary::allocateTriangle(int a, int b, int c)
{
 void* mem = btAlignedAlloc(sizeof(btHullTriangle), 16);
 btHullTriangle* tr = new (mem)btHullTriangle(a, b, c);
 tr->id = m_tris.size();
 m_tris.push_back(tr);

 return tr;
}

void	HullLibrary::deAllocateTriangle(btHullTriangle* tri)
{
 btAssert(m_tris[tri->id] == tri);
 m_tris[tri->id] = NULL;
 tri->~btHullTriangle();
 btAlignedFree(tri);
}


void HullLibrary::extrude(btHullTriangle *t0, int v)
{
 int3 t = *t0;
 int n = m_tris.size();
 btHullTriangle* ta = allocateTriangle(v, t[1], t[2]);
 ta->n = int3(t0->n[0], n + 1, n + 2);
 m_tris[t0->n[0]]->neib(t[1], t[2]) = n + 0;
 btHullTriangle* tb = allocateTriangle(v, t[2], t[0]);
 tb->n = int3(t0->n[1], n + 2, n + 0);
 m_tris[t0->n[1]]->neib(t[2], t[0]) = n + 1;
 btHullTriangle* tc = allocateTriangle(v, t[0], t[1]);
 tc->n = int3(t0->n[2], n + 0, n + 1);
 m_tris[t0->n[2]]->neib(t[0], t[1]) = n + 2;
 checkit(ta);
 checkit(tb);
 checkit(tc);
 if (hasvert(*m_tris[ta->n[0]], v)) removeb2b(ta, m_tris[ta->n[0]]);
 if (hasvert(*m_tris[tb->n[0]], v)) removeb2b(tb, m_tris[tb->n[0]]);
 if (hasvert(*m_tris[tc->n[0]], v)) removeb2b(tc, m_tris[tc->n[0]]);
 deAllocateTriangle(t0);

}

btHullTriangle* HullLibrary::extrudable(btScalar epsilon)
{
 int i;
 btHullTriangle *t = NULL;
 for (i = 0; i<m_tris.size(); i++)
 {
  if (!t || (m_tris[i] && t->rise<m_tris[i]->rise))
  {
   t = m_tris[i];
  }
 }
 return (t->rise >epsilon) ? t : NULL;
}




int4 HullLibrary::FindSimplex(btVector3 *verts, int verts_count, btAlignedObjectArray<int> &allow)
{
 btVector3 basis[3];
 basis[0] = btVector3(btScalar(0.01), btScalar(0.02), btScalar(1.0));
 int p0 = maxdirsterid(verts, verts_count, basis[0], allow);
 int	p1 = maxdirsterid(verts, verts_count, -basis[0], allow);
 basis[0] = verts[p0] - verts[p1];
 if (p0 == p1 || basis[0] == btVector3(0, 0, 0))
  return int4(-1, -1, -1, -1);
 basis[1] = btCross(btVector3(btScalar(1), btScalar(0.02), btScalar(0)), basis[0]);
 basis[2] = btCross(btVector3(btScalar(-0.02), btScalar(1), btScalar(0)), basis[0]);
 if (basis[1].length() > basis[2].length())
 {
  basis[1].normalize();
 }
 else {
  basis[1] = basis[2];
  basis[1].normalize();
 }
 int p2 = maxdirsterid(verts, verts_count, basis[1], allow);
 if (p2 == p0 || p2 == p1)
 {
  p2 = maxdirsterid(verts, verts_count, -basis[1], allow);
 }
 if (p2 == p0 || p2 == p1)
  return int4(-1, -1, -1, -1);
 basis[1] = verts[p2] - verts[p0];
 basis[2] = btCross(basis[1], basis[0]).normalized();
 int p3 = maxdirsterid(verts, verts_count, basis[2], allow);
 if (p3 == p0 || p3 == p1 || p3 == p2) p3 = maxdirsterid(verts, verts_count, -basis[2], allow);
 if (p3 == p0 || p3 == p1 || p3 == p2)
  return int4(-1, -1, -1, -1);
 btAssert(!(p0 == p1 || p0 == p2 || p0 == p3 || p1 == p2 || p1 == p3 || p2 == p3));
 if (btDot(verts[p3] - verts[p0], btCross(verts[p1] - verts[p0], verts[p2] - verts[p0])) <0) { btSwap(p2, p3); }
 return int4(p0, p1, p2, p3);
}

int HullLibrary::calchullgen(btVector3 *verts, int verts_count, int vlimit)
{
 if (verts_count <4) return 0;
 if (vlimit == 0) vlimit = 1000000000;
 int j;
 btVector3 bmin(*verts), bmax(*verts);
 btAlignedObjectArray<int> isextreme;
 isextreme.reserve(verts_count);
 btAlignedObjectArray<int> allow;
 allow.reserve(verts_count);

 for (j = 0; j<verts_count; j++)
 {
  allow.push_back(1);
  isextreme.push_back(0);
  bmin.setMin(verts[j]);
  bmax.setMax(verts[j]);
 }
 btScalar epsilon = (bmax - bmin).length() * btScalar(0.001);
 btAssert(epsilon != 0.0);


 int4 p = FindSimplex(verts, verts_count, allow);
 if (p.x == -1) return 0; // simplex failed



 btVector3 center = (verts[p[0]] + verts[p[1]] + verts[p[2]] + verts[p[3]]) / btScalar(4.0);  // a valid interior point
 btHullTriangle *t0 = allocateTriangle(p[2], p[3], p[1]); t0->n = int3(2, 3, 1);
 btHullTriangle *t1 = allocateTriangle(p[3], p[2], p[0]); t1->n = int3(3, 2, 0);
 btHullTriangle *t2 = allocateTriangle(p[0], p[1], p[3]); t2->n = int3(0, 1, 3);
 btHullTriangle *t3 = allocateTriangle(p[1], p[0], p[2]); t3->n = int3(1, 0, 2);
 isextreme[p[0]] = isextreme[p[1]] = isextreme[p[2]] = isextreme[p[3]] = 1;
 checkit(t0); checkit(t1); checkit(t2); checkit(t3);

 for (j = 0; j<m_tris.size(); j++)
 {
  btHullTriangle *t = m_tris[j];
  btAssert(t);
  btAssert(t->vmax<0);
  btVector3 n = TriNormal(verts[(*t)[0]], verts[(*t)[1]], verts[(*t)[2]]);
  t->vmax = maxdirsterid(verts, verts_count, n, allow);
  t->rise = btDot(n, verts[t->vmax] - verts[(*t)[0]]);
 }
 btHullTriangle *te;
 vlimit -= 4;
 while (vlimit >0 && ((te = extrudable(epsilon)) != 0))
 {
  //int3 ti=*te;
  int v = te->vmax;
  btAssert(v != -1);
  btAssert(!isextreme[v]);  // wtf we've already done this vertex
  isextreme[v] = 1;
  //if(v==p0 || v==p1 || v==p2 || v==p3) continue; // done these already
  j = m_tris.size();
  while (j--) {
   if (!m_tris[j]) continue;
   int3 t = *m_tris[j];
   if (above(verts, t, verts[v], btScalar(0.01)*epsilon))
   {
    extrude(m_tris[j], v);
   }
  }
  // now check for those degenerate cases where we have a flipped triangle or a really skinny triangle
  j = m_tris.size();
  while (j--)
  {
   if (!m_tris[j]) continue;
   if (!hasvert(*m_tris[j], v)) break;
   int3 nt = *m_tris[j];
   if (above(verts, nt, center, btScalar(0.01)*epsilon) || btCross(verts[nt[1]] - verts[nt[0]], verts[nt[2]] - verts[nt[1]]).length()< epsilon*epsilon*btScalar(0.1))
   {
    btHullTriangle *nb = m_tris[m_tris[j]->n[0]];
    btAssert(nb); btAssert(!hasvert(*nb, v)); btAssert(nb->id<j);
    extrude(nb, v);
    j = m_tris.size();
   }
  }
  j = m_tris.size();
  while (j--)
  {
   btHullTriangle *t = m_tris[j];
   if (!t) continue;
   if (t->vmax >= 0) break;
   btVector3 n = TriNormal(verts[(*t)[0]], verts[(*t)[1]], verts[(*t)[2]]);
   t->vmax = maxdirsterid(verts, verts_count, n, allow);
   if (isextreme[t->vmax])
   {
    t->vmax = -1; // already done that vertex - algorithm needs to be able to terminate.
   }
   else
   {
    t->rise = btDot(n, verts[t->vmax] - verts[(*t)[0]]);
   }
  }
  vlimit--;
 }
 return 1;
}

int HullLibrary::calchull(btVector3 *verts, int verts_count, TUIntArray& tris_out, int &tris_count, int vlimit)
{
 int rc = calchullgen(verts, verts_count, vlimit);
 if (!rc) return 0;
 btAlignedObjectArray<int> ts;
 int i;

 for (i = 0; i<m_tris.size(); i++)
 {
  if (m_tris[i])
  {
   for (int j = 0; j<3; j++)
    ts.push_back((*m_tris[i])[j]);
   deAllocateTriangle(m_tris[i]);
  }
 }
 tris_count = ts.size() / 3;
 tris_out.resize(ts.size());

 for (i = 0; i<ts.size(); i++)
 {
  tris_out[i] = static_cast<unsigned int>(ts[i]);
 }
 m_tris.resize(0);

 return 1;
}





bool HullLibrary::ComputeHull(unsigned int vcount, const btVector3 *vertices, PHullResult &result, unsigned int vlimit)
{

 int    tris_count;
 int ret = calchull((btVector3 *)vertices, (int)vcount, result.m_Indices, tris_count, static_cast<int>(vlimit));
 if (!ret) return false;
 result.mIndexCount = (unsigned int)(tris_count * 3);
 result.mFaceCount = (unsigned int)tris_count;
 result.mVertices = (btVector3*)vertices;
 result.mVcount = (unsigned int)vcount;
 return true;

}


void ReleaseHull(PHullResult &result);
void ReleaseHull(PHullResult &result)
{
 if (result.m_Indices.size())
 {
  result.m_Indices.clear();
 }

 result.mVcount = 0;
 result.mIndexCount = 0;
 result.mVertices = 0;
}


//*********************************************************************
//*********************************************************************
//********  HullLib header
//*********************************************************************
//*********************************************************************

//*********************************************************************
//*********************************************************************
//********  HullLib implementation
//*********************************************************************
//*********************************************************************

HullError HullLibrary::CreateConvexHull(const HullDesc       &desc,           // describes the input request
 HullResult           &result)         // contains the resulst
{
 HullError ret = QE_FAIL;


 PHullResult hr;

 unsigned int vcount = desc.mVcount;
 if (vcount < 8) vcount = 8;

 btAlignedObjectArray<btVector3> vertexSource;
 vertexSource.resize(static_cast<int>(vcount));

 btVector3 scale;

 unsigned int ovcount;

 bool ok = CleanupVertices(desc.mVcount, desc.mVertices, desc.mVertexStride, ovcount, &vertexSource[0], desc.mNormalEpsilon, scale); // normalize point cloud, remove duplicates!

 if (ok)
 {


  //		if ( 1 ) // scale vertices back to their original size.
  {
   for (unsigned int i = 0; i<ovcount; i++)
   {
    btVector3& v = vertexSource[static_cast<int>(i)];
    v[0] *= scale[0];
    v[1] *= scale[1];
    v[2] *= scale[2];
   }
  }

  ok = ComputeHull(ovcount, &vertexSource[0], hr, desc.mMaxVertices);

  if (ok)
  {

   // re-index triangle mesh so it refers to only used vertices, rebuild a new vertex table.
   btAlignedObjectArray<btVector3>	vertexScratch;
   vertexScratch.resize(static_cast<int>(hr.mVcount));

   BringOutYourDead(hr.mVertices, hr.mVcount, &vertexScratch[0], ovcount, &hr.m_Indices[0], hr.mIndexCount);

   ret = QE_OK;

   if (desc.HasHullFlag(QF_TRIANGLES)) // if he wants the results as triangle!
   {
    result.mPolygons = false;
    result.mNumOutputVertices = ovcount;
    result.m_OutputVertices.resize(static_cast<int>(ovcount));
    result.mNumFaces = hr.mFaceCount;
    result.mNumIndices = hr.mIndexCount;

    result.m_Indices.resize(static_cast<int>(hr.mIndexCount));

    memcpy(&result.m_OutputVertices[0], &vertexScratch[0], sizeof(btVector3)*ovcount);

    if (desc.HasHullFlag(QF_REVERSE_ORDER))
    {

     const unsigned int *source = &hr.m_Indices[0];
     unsigned int *dest = &result.m_Indices[0];

     for (unsigned int i = 0; i<hr.mFaceCount; i++)
     {
      dest[0] = source[2];
      dest[1] = source[1];
      dest[2] = source[0];
      dest += 3;
      source += 3;
     }

    }
    else
    {
     memcpy(&result.m_Indices[0], &hr.m_Indices[0], sizeof(unsigned int)*hr.mIndexCount);
    }
   }
   else
   {
    result.mPolygons = true;
    result.mNumOutputVertices = ovcount;
    result.m_OutputVertices.resize(static_cast<int>(ovcount));
    result.mNumFaces = hr.mFaceCount;
    result.mNumIndices = hr.mIndexCount + hr.mFaceCount;
    result.m_Indices.resize(static_cast<int>(result.mNumIndices));
    memcpy(&result.m_OutputVertices[0], &vertexScratch[0], sizeof(btVector3)*ovcount);

    //				if ( 1 )
    {
     const unsigned int *source = &hr.m_Indices[0];
     unsigned int *dest = &result.m_Indices[0];
     for (unsigned int i = 0; i<hr.mFaceCount; i++)
     {
      dest[0] = 3;
      if (desc.HasHullFlag(QF_REVERSE_ORDER))
      {
       dest[1] = source[2];
       dest[2] = source[1];
       dest[3] = source[0];
      }
      else
      {
       dest[1] = source[0];
       dest[2] = source[1];
       dest[3] = source[2];
      }

      dest += 4;
      source += 3;
     }
    }
   }
   ReleaseHull(hr);
  }
 }

 return ret;
}



HullError HullLibrary::ReleaseResult(HullResult &result) // release memory allocated for this result, we are done with it.
{
 if (result.m_OutputVertices.size())
 {
  result.mNumOutputVertices = 0;
  result.m_OutputVertices.clear();
 }
 if (result.m_Indices.size())
 {
  result.mNumIndices = 0;
  result.m_Indices.clear();
 }
 return QE_OK;
}


static void addPoint(unsigned int &vcount, btVector3 *p, btScalar x, btScalar y, btScalar z)
{
 // XXX, might be broken
 btVector3& dest = p[vcount];
 dest[0] = x;
 dest[1] = y;
 dest[2] = z;
 vcount++;
}

btScalar GetDist(btScalar px, btScalar py, btScalar pz, const btScalar *p2);
btScalar GetDist(btScalar px, btScalar py, btScalar pz, const btScalar *p2)
{

 btScalar dx = px - p2[0];
 btScalar dy = py - p2[1];
 btScalar dz = pz - p2[2];

 return dx*dx + dy*dy + dz*dz;
}



bool  HullLibrary::CleanupVertices(unsigned int svcount,
 const btVector3 *svertices,
 unsigned int stride,
 unsigned int &vcount,       // output number of vertices
 btVector3 *vertices,                 // location to store the results.
 btScalar  normalepsilon,
 btVector3& scale)
{
 if (svcount == 0) return false;

 m_vertexIndexMapping.resize(0);


#define EPSILON btScalar(0.000001) /* close enough to consider two btScalaring point numbers to be 'the same'. */

 vcount = 0;

 btScalar recip[3] = { 0.f,0.f,0.f };

 if (scale)
 {
  scale[0] = 1;
  scale[1] = 1;
  scale[2] = 1;
 }

 btScalar bmin[3] = { FLT_MAX,  FLT_MAX,  FLT_MAX };
 btScalar bmax[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };

 const char *vtx = (const char *)svertices;

 //	if ( 1 )
 {
  for (unsigned int i = 0; i<svcount; i++)
  {
   const btScalar *p = (const btScalar *)vtx;

   vtx += stride;

   for (int j = 0; j<3; j++)
   {
    if (p[j] < bmin[j]) bmin[j] = p[j];
    if (p[j] > bmax[j]) bmax[j] = p[j];
   }
  }
 }

 btScalar dx = bmax[0] - bmin[0];
 btScalar dy = bmax[1] - bmin[1];
 btScalar dz = bmax[2] - bmin[2];

 btVector3 center;

 center[0] = dx*btScalar(0.5) + bmin[0];
 center[1] = dy*btScalar(0.5) + bmin[1];
 center[2] = dz*btScalar(0.5) + bmin[2];

 if (dx < EPSILON || dy < EPSILON || dz < EPSILON || svcount < 3)
 {

  btScalar len = FLT_MAX;

  if (dx > EPSILON && dx < len) len = dx;
  if (dy > EPSILON && dy < len) len = dy;
  if (dz > EPSILON && dz < len) len = dz;

  if (len == FLT_MAX)
  {
   dx = dy = dz = btScalar(0.01); // one centimeter
  }
  else
  {
   if (dx < EPSILON) dx = len * btScalar(0.05); // 1/5th the shortest non-zero edge.
   if (dy < EPSILON) dy = len * btScalar(0.05);
   if (dz < EPSILON) dz = len * btScalar(0.05);
  }

  btScalar x1 = center[0] - dx;
  btScalar x2 = center[0] + dx;

  btScalar y1 = center[1] - dy;
  btScalar y2 = center[1] + dy;

  btScalar z1 = center[2] - dz;
  btScalar z2 = center[2] + dz;

  addPoint(vcount, vertices, x1, y1, z1);
  addPoint(vcount, vertices, x2, y1, z1);
  addPoint(vcount, vertices, x2, y2, z1);
  addPoint(vcount, vertices, x1, y2, z1);
  addPoint(vcount, vertices, x1, y1, z2);
  addPoint(vcount, vertices, x2, y1, z2);
  addPoint(vcount, vertices, x2, y2, z2);
  addPoint(vcount, vertices, x1, y2, z2);

  return true; // return cube


 }
 else
 {
  if (scale)
  {
   scale[0] = dx;
   scale[1] = dy;
   scale[2] = dz;

   recip[0] = 1 / dx;
   recip[1] = 1 / dy;
   recip[2] = 1 / dz;

   center[0] *= recip[0];
   center[1] *= recip[1];
   center[2] *= recip[2];

  }

 }



 vtx = (const char *)svertices;

 for (unsigned int i = 0; i<svcount; i++)
 {
  const btVector3 *p = (const btVector3 *)vtx;
  vtx += stride;

  btScalar px = p->getX();
  btScalar py = p->getY();
  btScalar pz = p->getZ();

  if (scale)
  {
   px = px*recip[0]; // normalize
   py = py*recip[1]; // normalize
   pz = pz*recip[2]; // normalize
  }

  //		if ( 1 )
  {
   unsigned int j;

   for (j = 0; j<vcount; j++)
   {
    /// XXX might be broken
    btVector3& v = vertices[j];

    btScalar x = v[0];
    btScalar y = v[1];
    btScalar z = v[2];

    btScalar dx = btFabs(x - px);
    btScalar dy = btFabs(y - py);
    btScalar dz = btFabs(z - pz);

    if (dx < normalepsilon && dy < normalepsilon && dz < normalepsilon)
    {
     // ok, it is close enough to the old one
     // now let us see if it is further from the center of the point cloud than the one we already recorded.
     // in which case we keep this one instead.

     btScalar dist1 = GetDist(px, py, pz, center);
     btScalar dist2 = GetDist(v[0], v[1], v[2], center);

     if (dist1 > dist2)
     {
      v[0] = px;
      v[1] = py;
      v[2] = pz;

     }

     break;
    }
   }

   if (j == vcount)
   {
    btVector3& dest = vertices[vcount];
    dest[0] = px;
    dest[1] = py;
    dest[2] = pz;
    vcount++;
   }
   m_vertexIndexMapping.push_back(j);
  }
 }

 // ok..now make sure we didn't prune so many vertices it is now invalid.
 //	if ( 1 )
 {
  btScalar bmin[3] = { FLT_MAX,  FLT_MAX,  FLT_MAX };
  btScalar bmax[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };

  for (unsigned int i = 0; i<vcount; i++)
  {
   const btVector3& p = vertices[i];
   for (int j = 0; j<3; j++)
   {
    if (p[j] < bmin[j]) bmin[j] = p[j];
    if (p[j] > bmax[j]) bmax[j] = p[j];
   }
  }

  btScalar dx = bmax[0] - bmin[0];
  btScalar dy = bmax[1] - bmin[1];
  btScalar dz = bmax[2] - bmin[2];

  if (dx < EPSILON || dy < EPSILON || dz < EPSILON || vcount < 3)
  {
   btScalar cx = dx*btScalar(0.5) + bmin[0];
   btScalar cy = dy*btScalar(0.5) + bmin[1];
   btScalar cz = dz*btScalar(0.5) + bmin[2];

   btScalar len = FLT_MAX;

   if (dx >= EPSILON && dx < len) len = dx;
   if (dy >= EPSILON && dy < len) len = dy;
   if (dz >= EPSILON && dz < len) len = dz;

   if (len == FLT_MAX)
   {
    dx = dy = dz = btScalar(0.01); // one centimeter
   }
   else
   {
    if (dx < EPSILON) dx = len * btScalar(0.05); // 1/5th the shortest non-zero edge.
    if (dy < EPSILON) dy = len * btScalar(0.05);
    if (dz < EPSILON) dz = len * btScalar(0.05);
   }

   btScalar x1 = cx - dx;
   btScalar x2 = cx + dx;

   btScalar y1 = cy - dy;
   btScalar y2 = cy + dy;

   btScalar z1 = cz - dz;
   btScalar z2 = cz + dz;

   vcount = 0; // add box

   addPoint(vcount, vertices, x1, y1, z1);
   addPoint(vcount, vertices, x2, y1, z1);
   addPoint(vcount, vertices, x2, y2, z1);
   addPoint(vcount, vertices, x1, y2, z1);
   addPoint(vcount, vertices, x1, y1, z2);
   addPoint(vcount, vertices, x2, y1, z2);
   addPoint(vcount, vertices, x2, y2, z2);
   addPoint(vcount, vertices, x1, y2, z2);

   return true;
  }
 }

 return true;
}

void HullLibrary::BringOutYourDead(const btVector3* verts, unsigned int vcount, btVector3* overts, unsigned int &ocount, unsigned int *indices, unsigned indexcount)
{
 btAlignedObjectArray<int>tmpIndices;
 tmpIndices.resize(m_vertexIndexMapping.size());
 int i;

 for (i = 0; i<m_vertexIndexMapping.size(); i++)
 {
  tmpIndices[i] = m_vertexIndexMapping[i];
 }

 TUIntArray usedIndices;
 usedIndices.resize(static_cast<int>(vcount));
 memset(&usedIndices[0], 0, sizeof(unsigned int)*vcount);

 ocount = 0;

 for (i = 0; i<int(indexcount); i++)
 {
  unsigned int v = indices[i]; // original array index

  btAssert(v >= 0 && v < vcount);

  if (usedIndices[static_cast<int>(v)]) // if already remapped
  {
   indices[i] = usedIndices[static_cast<int>(v)] - 1; // index to new array
  }
  else
  {

   indices[i] = ocount;      // new index mapping

   overts[ocount][0] = verts[v][0]; // copy old vert to new vert array
   overts[ocount][1] = verts[v][1];
   overts[ocount][2] = verts[v][2];

   for (int k = 0; k<m_vertexIndexMapping.size(); k++)
   {
    if (tmpIndices[k] == int(v))
     m_vertexIndexMapping[k] = ocount;
   }

   ocount++; // increment output vert count

   btAssert(ocount >= 0 && ocount <= vcount);

   usedIndices[static_cast<int>(v)] = ocount; // assign new index remapping


  }
 }


}

/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include <string.h>

#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btVector3.h"

#ifdef __GNUC__
#include <stdint.h>
#elif defined(_MSC_VER)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
typedef int int32_t;
typedef long long int int64_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
#endif


//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif


//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS

#if defined(DEBUG_CONVEX_HULL) || defined(SHOW_ITERATIONS)
#include <stdio.h>
#endif

// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullInternal
{
public:

 class Point64
 {
 public:
  int64_t x;
  int64_t y;
  int64_t z;

  Point64(int64_t x, int64_t y, int64_t z) : x(x), y(y), z(z)
  {
  }

  bool isZero()
  {
   return (x == 0) && (y == 0) && (z == 0);
  }

  int64_t dot(const Point64& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }
 };

 class Point32
 {
 public:
  int32_t x;
  int32_t y;
  int32_t z;
  int index;

  Point32()
  {
  }

  Point32(int32_t x, int32_t y, int32_t z) : x(x), y(y), z(z), index(-1)
  {
  }

  bool operator==(const Point32& b) const
  {
   return (x == b.x) && (y == b.y) && (z == b.z);
  }

  bool operator!=(const Point32& b) const
  {
   return (x != b.x) || (y != b.y) || (z != b.z);
  }

  bool isZero()
  {
   return (x == 0) && (y == 0) && (z == 0);
  }

  Point64 cross(const Point32& b) const
  {
   return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
  }

  Point64 cross(const Point64& b) const
  {
   return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
  }

  int64_t dot(const Point32& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }

  int64_t dot(const Point64& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }

  Point32 operator+(const Point32& b) const
  {
   return Point32(x + b.x, y + b.y, z + b.z);
  }

  Point32 operator-(const Point32& b) const
  {
   return Point32(x - b.x, y - b.y, z - b.z);
  }
 };

 class Int128
 {
 public:
  uint64_t low;
  uint64_t high;

  Int128()
  {
  }

  Int128(uint64_t low, uint64_t high) : low(low), high(high)
  {
  }

  Int128(uint64_t low) : low(low), high(0)
  {
  }

  Int128(int64_t value) : low(value), high((value >= 0) ? 0 : (uint64_t)-1LL)
  {
  }

  static Int128 mul(int64_t a, int64_t b);

  static Int128 mul(uint64_t a, uint64_t b);

  Int128 operator-() const
  {
   return Int128((uint64_t)-(int64_t)low, ~high + (low == 0));
  }

  Int128 operator+(const Int128& b) const
  {
#ifdef USE_X86_64_ASM
   Int128 result;
   __asm__("addq %[bl], %[rl]\n\t"
    "adcq %[bh], %[rh]\n\t"
    : [rl] "=r" (result.low), [rh] "=r" (result.high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
   return result;
#else
   uint64_t lo = low + b.low;
   return Int128(lo, high + b.high + (lo < low));
#endif
  }

  Int128 operator-(const Int128& b) const
  {
#ifdef USE_X86_64_ASM
   Int128 result;
   __asm__("subq %[bl], %[rl]\n\t"
    "sbbq %[bh], %[rh]\n\t"
    : [rl] "=r" (result.low), [rh] "=r" (result.high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
   return result;
#else
   return *this + -b;
#endif
  }

  Int128& operator+=(const Int128& b)
  {
#ifdef USE_X86_64_ASM
   __asm__("addq %[bl], %[rl]\n\t"
    "adcq %[bh], %[rh]\n\t"
    : [rl] "=r" (low), [rh] "=r" (high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
#else
   uint64_t lo = low + b.low;
   if (lo < low)
   {
    ++high;
   }
   low = lo;
   high += b.high;
#endif
   return *this;
  }

  Int128& operator++()
  {
   if (++low == 0)
   {
    ++high;
   }
   return *this;
  }

  Int128 operator*(int64_t b) const;

  btScalar toScalar() const
  {
   return ((int64_t)high >= 0) ? btScalar(high) * (btScalar(0x100000000LL) * btScalar(0x100000000LL)) + btScalar(low)
    : -(-*this).toScalar();
  }

  int getSign() const
  {
   return ((int64_t)high < 0) ? -1 : (high || low) ? 1 : 0;
  }

  bool operator<(const Int128& b) const
  {
   return (high < b.high) || ((high == b.high) && (low < b.low));
  }

  int ucmp(const Int128&b) const
  {
   if (high < b.high)
   {
    return -1;
   }
   if (high > b.high)
   {
    return 1;
   }
   if (low < b.low)
   {
    return -1;
   }
   if (low > b.low)
   {
    return 1;
   }
   return 0;
  }
 };


 class Rational64
 {
 private:
  uint64_t m_numerator;
  uint64_t m_denominator;
  int sign;

 public:
  Rational64(int64_t numerator, int64_t denominator)
  {
   if (numerator > 0)
   {
    sign = 1;
    m_numerator = (uint64_t)numerator;
   }
   else if (numerator < 0)
   {
    sign = -1;
    m_numerator = (uint64_t)-numerator;
   }
   else
   {
    sign = 0;
    m_numerator = 0;
   }
   if (denominator > 0)
   {
    m_denominator = (uint64_t)denominator;
   }
   else if (denominator < 0)
   {
    sign = -sign;
    m_denominator = (uint64_t)-denominator;
   }
   else
   {
    m_denominator = 0;
   }
  }

  bool isNegativeInfinity() const
  {
   return (sign < 0) && (m_denominator == 0);
  }

  bool isNaN() const
  {
   return (sign == 0) && (m_denominator == 0);
  }

  int compare(const Rational64& b) const;

  btScalar toScalar() const
  {
   return sign * ((m_denominator == 0) ? SIMD_INFINITY : (btScalar)m_numerator / m_denominator);
  }
 };


 class Rational128
 {
 private:
  Int128 numerator;
  Int128 denominator;
  int sign;
  bool isInt64;

 public:
  Rational128(int64_t value)
  {
   if (value > 0)
   {
    sign = 1;
    this->numerator = value;
   }
   else if (value < 0)
   {
    sign = -1;
    this->numerator = -value;
   }
   else
   {
    sign = 0;
    this->numerator = (uint64_t)0;
   }
   this->denominator = (uint64_t)1;
   isInt64 = true;
  }

  Rational128(const Int128& numerator, const Int128& denominator)
  {
   sign = numerator.getSign();
   if (sign >= 0)
   {
    this->numerator = numerator;
   }
   else
   {
    this->numerator = -numerator;
   }
   int dsign = denominator.getSign();
   if (dsign >= 0)
   {
    this->denominator = denominator;
   }
   else
   {
    sign = -sign;
    this->denominator = -denominator;
   }
   isInt64 = false;
  }

  int compare(const Rational128& b) const;

  int compare(int64_t b) const;

  btScalar toScalar() const
  {
   return sign * ((denominator.getSign() == 0) ? SIMD_INFINITY : numerator.toScalar() / denominator.toScalar());
  }
 };

 class PointR128
 {
 public:
  Int128 x;
  Int128 y;
  Int128 z;
  Int128 denominator;

  PointR128()
  {
  }

  PointR128(Int128 x, Int128 y, Int128 z, Int128 denominator) : x(x), y(y), z(z), denominator(denominator)
  {
  }

  btScalar xvalue() const
  {
   return x.toScalar() / denominator.toScalar();
  }

  btScalar yvalue() const
  {
   return y.toScalar() / denominator.toScalar();
  }

  btScalar zvalue() const
  {
   return z.toScalar() / denominator.toScalar();
  }
 };


 class Edge;
 class Face;

 class Vertex
 {
 public:
  Vertex* next;
  Vertex* prev;
  Edge* edges;
  Face* firstNearbyFace;
  Face* lastNearbyFace;
  PointR128 point128;
  Point32 point;
  int copy;

  Vertex() : next(NULL), prev(NULL), edges(NULL), firstNearbyFace(NULL), lastNearbyFace(NULL), copy(-1)
  {
  }

#ifdef DEBUG_CONVEX_HULL
  void print()
  {
   printf("V%d (%d, %d, %d)", point.index, point.x, point.y, point.z);
  }

  void printGraph();
#endif

  Point32 operator-(const Vertex& b) const
  {
   return point - b.point;
  }

  Rational128 dot(const Point64& b) const
  {
   return (point.index >= 0) ? Rational128(point.dot(b))
    : Rational128(point128.x * b.x + point128.y * b.y + point128.z * b.z, point128.denominator);
  }

  btScalar xvalue() const
  {
   return (point.index >= 0) ? btScalar(point.x) : point128.xvalue();
  }

  btScalar yvalue() const
  {
   return (point.index >= 0) ? btScalar(point.y) : point128.yvalue();
  }

  btScalar zvalue() const
  {
   return (point.index >= 0) ? btScalar(point.z) : point128.zvalue();
  }

  void receiveNearbyFaces(Vertex* src)
  {
   if (lastNearbyFace)
   {
    lastNearbyFace->nextWithSameNearbyVertex = src->firstNearbyFace;
   }
   else
   {
    firstNearbyFace = src->firstNearbyFace;
   }
   if (src->lastNearbyFace)
   {
    lastNearbyFace = src->lastNearbyFace;
   }
   for (Face* f = src->firstNearbyFace; f; f = f->nextWithSameNearbyVertex)
   {
    btAssert(f->nearbyVertex == src);
    f->nearbyVertex = this;
   }
   src->firstNearbyFace = NULL;
   src->lastNearbyFace = NULL;
  }
 };


 class Edge
 {
 public:
  Edge* next;
  Edge* prev;
  Edge* reverse;
  Vertex* target;
  Face* face;
  int copy;

  ~Edge()
  {
   next = NULL;
   prev = NULL;
   reverse = NULL;
   target = NULL;
   face = NULL;
  }

  void link(Edge* n)
  {
   btAssert(reverse->target == n->reverse->target);
   next = n;
   n->prev = this;
  }

#ifdef DEBUG_CONVEX_HULL
  void print()
  {
   printf("E%p : %d -> %d,  n=%p p=%p   (0 %d\t%d\t%d) -> (%d %d %d)", this, reverse->target->point.index, target->point.index, next, prev,
    reverse->target->point.x, reverse->target->point.y, reverse->target->point.z, target->point.x, target->point.y, target->point.z);
  }
#endif
 };

 class Face
 {
 public:
  Face* next;
  Vertex* nearbyVertex;
  Face* nextWithSameNearbyVertex;
  Point32 origin;
  Point32 dir0;
  Point32 dir1;

  Face() : next(NULL), nearbyVertex(NULL), nextWithSameNearbyVertex(NULL)
  {
  }

  void init(Vertex* a, Vertex* b, Vertex* c)
  {
   nearbyVertex = a;
   origin = a->point;
   dir0 = *b - *a;
   dir1 = *c - *a;
   if (a->lastNearbyFace)
   {
    a->lastNearbyFace->nextWithSameNearbyVertex = this;
   }
   else
   {
    a->firstNearbyFace = this;
   }
   a->lastNearbyFace = this;
  }

  Point64 getNormal()
  {
   return dir0.cross(dir1);
  }
 };

 template<typename UWord, typename UHWord> class DMul
 {
 private:
  static uint32_t high(uint64_t value)
  {
   return (uint32_t)(value >> 32);
  }

  static uint32_t low(uint64_t value)
  {
   return (uint32_t)value;
  }

  static uint64_t mul(uint32_t a, uint32_t b)
  {
   return (uint64_t)a * (uint64_t)b;
  }

  static void shlHalf(uint64_t& value)
  {
   value <<= 32;
  }

  static uint64_t high(Int128 value)
  {
   return value.high;
  }

  static uint64_t low(Int128 value)
  {
   return value.low;
  }

  static Int128 mul(uint64_t a, uint64_t b)
  {
   return Int128::mul(a, b);
  }

  static void shlHalf(Int128& value)
  {
   value.high = value.low;
   value.low = 0;
  }

 public:

  static void mul(UWord a, UWord b, UWord& resLow, UWord& resHigh)
  {
   UWord p00 = mul(low(a), low(b));
   UWord p01 = mul(low(a), high(b));
   UWord p10 = mul(high(a), low(b));
   UWord p11 = mul(high(a), high(b));
   UWord p0110 = UWord(low(p01)) + UWord(low(p10));
   p11 += high(p01);
   p11 += high(p10);
   p11 += high(p0110);
   shlHalf(p0110);
   p00 += p0110;
   if (p00 < p0110)
   {
    ++p11;
   }
   resLow = p00;
   resHigh = p11;
  }
 };

private:

 class IntermediateHull
 {
 public:
  Vertex* minXy;
  Vertex* maxXy;
  Vertex* minYx;
  Vertex* maxYx;

  IntermediateHull() : minXy(NULL), maxXy(NULL), minYx(NULL), maxYx(NULL)
  {
  }

  void print();
 };

 enum Orientation { NONE, CLOCKWISE, COUNTER_CLOCKWISE };

 template <typename T> class PoolArray
 {
 private:
  T* array;
  int size;

 public:
  PoolArray<T>* next;

  PoolArray(int size) : size(size), next(NULL)
  {
   array = (T*)btAlignedAlloc(sizeof(T) * size, 16);
  }

  ~PoolArray()
  {
   btAlignedFree(array);
  }

  T* init()
  {
   T* o = array;
   for (int i = 0; i < size; i++, o++)
   {
    o->next = (i + 1 < size) ? o + 1 : NULL;
   }
   return array;
  }
 };

 template <typename T> class Pool
 {
 private:
  PoolArray<T>* arrays;
  PoolArray<T>* nextArray;
  T* freeObjects;
  int arraySize;

 public:
  Pool() : arrays(NULL), nextArray(NULL), freeObjects(NULL), arraySize(256)
  {
  }

  ~Pool()
  {
   while (arrays)
   {
    PoolArray<T>* p = arrays;
    arrays = p->next;
    p->~PoolArray<T>();
    btAlignedFree(p);
   }
  }

  void reset()
  {
   nextArray = arrays;
   freeObjects = NULL;
  }

  void setArraySize(int arraySize)
  {
   this->arraySize = arraySize;
  }

  T* newObject()
  {
   T* o = freeObjects;
   if (!o)
   {
    PoolArray<T>* p = nextArray;
    if (p)
    {
     nextArray = p->next;
    }
    else
    {
     p = new(btAlignedAlloc(sizeof(PoolArray<T>), 16)) PoolArray<T>(arraySize);
     p->next = arrays;
     arrays = p;
    }
    o = p->init();
   }
   freeObjects = o->next;
   return new(o) T();
  };

  void freeObject(T* object)
  {
   object->~T();
   object->next = freeObjects;
   freeObjects = object;
  }
 };

 btVector3 scaling;
 btVector3 center;
 Pool<Vertex> vertexPool;
 Pool<Edge> edgePool;
 Pool<Face> facePool;
 btAlignedObjectArray<Vertex*> originalVertices;
 int mergeStamp;
 int minAxis;
 int medAxis;
 int maxAxis;
 int usedEdgePairs;
 int maxUsedEdgePairs;

 static Orientation getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t);
 Edge* findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot);
 void findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1);

 Edge* newEdgePair(Vertex* from, Vertex* to);

 void removeEdgePair(Edge* edge)
 {
  Edge* n = edge->next;
  Edge* r = edge->reverse;

  btAssert(edge->target && r->target);

  if (n != edge)
  {
   n->prev = edge->prev;
   edge->prev->next = n;
   r->target->edges = n;
  }
  else
  {
   r->target->edges = NULL;
  }

  n = r->next;

  if (n != r)
  {
   n->prev = r->prev;
   r->prev->next = n;
   edge->target->edges = n;
  }
  else
  {
   edge->target->edges = NULL;
  }

  edgePool.freeObject(edge);
  edgePool.freeObject(r);
  usedEdgePairs--;
 }

 void computeInternal(int start, int end, IntermediateHull& result);

 bool mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1);

 void merge(IntermediateHull& h0, IntermediateHull& h1);

 btVector3 toBtVector(const Point32& v);

 btVector3 getBtNormal(Face* face);

 bool shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack);

public:
 Vertex* vertexList;

 void compute(const void* coords, bool doubleCoords, int stride, int count);

 btVector3 getCoordinates(const Vertex* v);

 btScalar shrink(btScalar amount, btScalar clampAmount);
};


btConvexHullInternal::Int128 btConvexHullInternal::Int128::operator*(int64_t b) const
{
 bool negative = (int64_t)high < 0;
 Int128 a = negative ? -*this : *this;
 if (b < 0)
 {
  negative = !negative;
  b = -b;
 }
 Int128 result = mul(a.low, (uint64_t)b);
 result.high += a.high * (uint64_t)b;
 return negative ? -result : result;
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(int64_t a, int64_t b)
{
 Int128 result;

#ifdef USE_X86_64_ASM
 __asm__("imulq %[b]"
  : "=a" (result.low), "=d" (result.high)
  : "0"(a), [b] "r"(b)
  : "cc");
 return result;

#else
 bool negative = a < 0;
 if (negative)
 {
  a = -a;
 }
 if (b < 0)
 {
  negative = !negative;
  b = -b;
 }
 DMul<uint64_t, uint32_t>::mul((uint64_t)a, (uint64_t)b, result.low, result.high);
 return negative ? -result : result;
#endif
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(uint64_t a, uint64_t b)
{
 Int128 result;

#ifdef USE_X86_64_ASM
 __asm__("mulq %[b]"
  : "=a" (result.low), "=d" (result.high)
  : "0"(a), [b] "r"(b)
  : "cc");

#else
 DMul<uint64_t, uint32_t>::mul(a, b, result.low, result.high);
#endif

 return result;
}

int btConvexHullInternal::Rational64::compare(const Rational64& b) const
{
 if (sign != b.sign)
 {
  return sign - b.sign;
 }
 else if (sign == 0)
 {
  return 0;
 }

 //	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;

#ifdef USE_X86_64_ASM

 int result;
 int64_t tmp;
 int64_t dummy;
 __asm__("mulq %[bn]\n\t"
  "movq %%rax, %[tmp]\n\t"
  "movq %%rdx, %%rbx\n\t"
  "movq %[tn], %%rax\n\t"
  "mulq %[bd]\n\t"
  "subq %[tmp], %%rax\n\t"
  "sbbq %%rbx, %%rdx\n\t" // rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
  "setnsb %%bh\n\t" // bh=1 if difference is non-negative, bh=0 otherwise
  "orq %%rdx, %%rax\n\t"
  "setnzb %%bl\n\t" // bl=1 if difference if non-zero, bl=0 if it is zero
  "decb %%bh\n\t" // now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
  "shll $16, %%ebx\n\t" // ebx has same sign as difference
  : "=&b"(result), [tmp] "=&r"(tmp), "=a"(dummy)
  : "a"(denominator), [bn] "g"(b.numerator), [tn] "g"(numerator), [bd] "g"(b.denominator)
  : "%rdx", "cc");
 return result ? result ^ sign // if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
                               // if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
  : 0;

#else

 return sign * Int128::mul(m_numerator, b.m_denominator).ucmp(Int128::mul(m_denominator, b.m_numerator));

#endif
}

int btConvexHullInternal::Rational128::compare(const Rational128& b) const
{
 if (sign != b.sign)
 {
  return sign - b.sign;
 }
 else if (sign == 0)
 {
  return 0;
 }
 if (isInt64)
 {
  return -b.compare(sign * (int64_t)numerator.low);
 }

 Int128 nbdLow, nbdHigh, dbnLow, dbnHigh;
 DMul<Int128, uint64_t>::mul(numerator, b.denominator, nbdLow, nbdHigh);
 DMul<Int128, uint64_t>::mul(denominator, b.numerator, dbnLow, dbnHigh);

 int cmp = nbdHigh.ucmp(dbnHigh);
 if (cmp)
 {
  return cmp * sign;
 }
 return nbdLow.ucmp(dbnLow) * sign;
}

int btConvexHullInternal::Rational128::compare(int64_t b) const
{
 if (isInt64)
 {
  int64_t a = sign * (int64_t)numerator.low;
  return (a > b) ? 1 : (a < b) ? -1 : 0;
 }
 if (b > 0)
 {
  if (sign <= 0)
  {
   return -1;
  }
 }
 else if (b < 0)
 {
  if (sign >= 0)
  {
   return 1;
  }
  b = -b;
 }
 else
 {
  return sign;
 }

 return numerator.ucmp(denominator * b) * sign;
}


btConvexHullInternal::Edge* btConvexHullInternal::newEdgePair(Vertex* from, Vertex* to)
{
 btAssert(from && to);
 Edge* e = edgePool.newObject();
 Edge* r = edgePool.newObject();
 e->reverse = r;
 r->reverse = e;
 e->copy = mergeStamp;
 r->copy = mergeStamp;
 e->target = to;
 r->target = from;
 e->face = NULL;
 r->face = NULL;
 usedEdgePairs++;
 if (usedEdgePairs > maxUsedEdgePairs)
 {
  maxUsedEdgePairs = usedEdgePairs;
 }
 return e;
}

bool btConvexHullInternal::mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1)
{
 Vertex* v0 = h0.maxYx;
 Vertex* v1 = h1.minYx;
 if ((v0->point.x == v1->point.x) && (v0->point.y == v1->point.y))
 {
  btAssert(v0->point.z < v1->point.z);
  Vertex* v1p = v1->prev;
  if (v1p == v1)
  {
   c0 = v0;
   if (v1->edges)
   {
    btAssert(v1->edges->next == v1->edges);
    v1 = v1->edges->target;
    btAssert(v1->edges->next == v1->edges);
   }
   c1 = v1;
   return false;
  }
  Vertex* v1n = v1->next;
  v1p->next = v1n;
  v1n->prev = v1p;
  if (v1 == h1.minXy)
  {
   if ((v1n->point.x < v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y < v1p->point.y)))
   {
    h1.minXy = v1n;
   }
   else
   {
    h1.minXy = v1p;
   }
  }
  if (v1 == h1.maxXy)
  {
   if ((v1n->point.x > v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y > v1p->point.y)))
   {
    h1.maxXy = v1n;
   }
   else
   {
    h1.maxXy = v1p;
   }
  }
 }

 v0 = h0.maxXy;
 v1 = h1.maxXy;
 Vertex* v00 = NULL;
 Vertex* v10 = NULL;
 int32_t sign = 1;

 for (int side = 0; side <= 1; side++)
 {
  int32_t dx = (v1->point.x - v0->point.x) * sign;
  if (dx > 0)
  {
   while (true)
   {
    int32_t dy = v1->point.y - v0->point.y;

    Vertex* w0 = side ? v0->next : v0->prev;
    if (w0 != v0)
    {
     int32_t dx0 = (w0->point.x - v0->point.x) * sign;
     int32_t dy0 = w0->point.y - v0->point.y;
     if ((dy0 <= 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx <= dy * dx0))))
     {
      v0 = w0;
      dx = (v1->point.x - v0->point.x) * sign;
      continue;
     }
    }

    Vertex* w1 = side ? v1->next : v1->prev;
    if (w1 != v1)
    {
     int32_t dx1 = (w1->point.x - v1->point.x) * sign;
     int32_t dy1 = w1->point.y - v1->point.y;
     int32_t dxn = (w1->point.x - v0->point.x) * sign;
     if ((dxn > 0) && (dy1 < 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx < dy * dx1))))
     {
      v1 = w1;
      dx = dxn;
      continue;
     }
    }

    break;
   }
  }
  else if (dx < 0)
  {
   while (true)
   {
    int32_t dy = v1->point.y - v0->point.y;

    Vertex* w1 = side ? v1->prev : v1->next;
    if (w1 != v1)
    {
     int32_t dx1 = (w1->point.x - v1->point.x) * sign;
     int32_t dy1 = w1->point.y - v1->point.y;
     if ((dy1 >= 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx <= dy * dx1))))
     {
      v1 = w1;
      dx = (v1->point.x - v0->point.x) * sign;
      continue;
     }
    }

    Vertex* w0 = side ? v0->prev : v0->next;
    if (w0 != v0)
    {
     int32_t dx0 = (w0->point.x - v0->point.x) * sign;
     int32_t dy0 = w0->point.y - v0->point.y;
     int32_t dxn = (v1->point.x - w0->point.x) * sign;
     if ((dxn < 0) && (dy0 > 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx < dy * dx0))))
     {
      v0 = w0;
      dx = dxn;
      continue;
     }
    }

    break;
   }
  }
  else
  {
   int32_t x = v0->point.x;
   int32_t y0 = v0->point.y;
   Vertex* w0 = v0;
   Vertex* t;
   while (((t = side ? w0->next : w0->prev) != v0) && (t->point.x == x) && (t->point.y <= y0))
   {
    w0 = t;
    y0 = t->point.y;
   }
   v0 = w0;

   int32_t y1 = v1->point.y;
   Vertex* w1 = v1;
   while (((t = side ? w1->prev : w1->next) != v1) && (t->point.x == x) && (t->point.y >= y1))
   {
    w1 = t;
    y1 = t->point.y;
   }
   v1 = w1;
  }

  if (side == 0)
  {
   v00 = v0;
   v10 = v1;

   v0 = h0.minXy;
   v1 = h1.minXy;
   sign = -1;
  }
 }

 v0->prev = v1;
 v1->next = v0;

 v00->next = v10;
 v10->prev = v00;

 if (h1.minXy->point.x < h0.minXy->point.x)
 {
  h0.minXy = h1.minXy;
 }
 if (h1.maxXy->point.x >= h0.maxXy->point.x)
 {
  h0.maxXy = h1.maxXy;
 }

 h0.maxYx = h1.maxYx;

 c0 = v00;
 c1 = v10;

 return true;
}

void btConvexHullInternal::computeInternal(int start, int end, IntermediateHull& result)
{
 int n = end - start;
 switch (n)
 {
 case 0:
  result.minXy = NULL;
  result.maxXy = NULL;
  result.minYx = NULL;
  result.maxYx = NULL;
  return;
 case 2:
 {
  Vertex* v = originalVertices[start];
  Vertex* w = v + 1;
  if (v->point != w->point)
  {
   int32_t dx = v->point.x - w->point.x;
   int32_t dy = v->point.y - w->point.y;

   if ((dx == 0) && (dy == 0))
   {
    if (v->point.z > w->point.z)
    {
     Vertex* t = w;
     w = v;
     v = t;
    }
    btAssert(v->point.z < w->point.z);
    v->next = v;
    v->prev = v;
    result.minXy = v;
    result.maxXy = v;
    result.minYx = v;
    result.maxYx = v;
   }
   else
   {
    v->next = w;
    v->prev = w;
    w->next = v;
    w->prev = v;

    if ((dx < 0) || ((dx == 0) && (dy < 0)))
    {
     result.minXy = v;
     result.maxXy = w;
    }
    else
    {
     result.minXy = w;
     result.maxXy = v;
    }

    if ((dy < 0) || ((dy == 0) && (dx < 0)))
    {
     result.minYx = v;
     result.maxYx = w;
    }
    else
    {
     result.minYx = w;
     result.maxYx = v;
    }
   }

   Edge* e = newEdgePair(v, w);
   e->link(e);
   v->edges = e;

   e = e->reverse;
   e->link(e);
   w->edges = e;

   return;
  }
  {
   Vertex* v = originalVertices[start];
   v->edges = NULL;
   v->next = v;
   v->prev = v;

   result.minXy = v;
   result.maxXy = v;
   result.minYx = v;
   result.maxYx = v;
  }

  return;
 }

 case 1:
 {
  Vertex* v = originalVertices[start];
  v->edges = NULL;
  v->next = v;
  v->prev = v;

  result.minXy = v;
  result.maxXy = v;
  result.minYx = v;
  result.maxYx = v;

  return;
 }
 }

 int split0 = start + n / 2;
 Point32 p = originalVertices[split0 - 1]->point;
 int split1 = split0;
 while ((split1 < end) && (originalVertices[split1]->point == p))
 {
  split1++;
 }
 computeInternal(start, split0, result);
 IntermediateHull hull1;
 computeInternal(split1, end, hull1);
#ifdef DEBUG_CONVEX_HULL
 printf("\n\nMerge\n");
 result.print();
 hull1.print();
#endif
 merge(result, hull1);
#ifdef DEBUG_CONVEX_HULL
 printf("\n  Result\n");
 result.print();
#endif
}

#ifdef DEBUG_CONVEX_HULL
void btConvexHullInternal::IntermediateHull::print()
{
 printf("    Hull\n");
 for (Vertex* v = minXy; v; )
 {
  printf("      ");
  v->print();
  if (v == maxXy)
  {
   printf(" maxXy");
  }
  if (v == minYx)
  {
   printf(" minYx");
  }
  if (v == maxYx)
  {
   printf(" maxYx");
  }
  if (v->next->prev != v)
  {
   printf(" Inconsistency");
  }
  printf("\n");
  v = v->next;
  if (v == minXy)
  {
   break;
  }
 }
 if (minXy)
 {
  minXy->copy = (minXy->copy == -1) ? -2 : -1;
  minXy->printGraph();
 }
}

void btConvexHullInternal::Vertex::printGraph()
{
 print();
 printf("\nEdges\n");
 Edge* e = edges;
 if (e)
 {
  do
  {
   e->print();
   printf("\n");
   e = e->next;
  } while (e != edges);
  do
  {
   Vertex* v = e->target;
   if (v->copy != copy)
   {
    v->copy = copy;
    v->printGraph();
   }
   e = e->next;
  } while (e != edges);
 }
}
#endif

btConvexHullInternal::Orientation btConvexHullInternal::getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t)
{
 btAssert(prev->reverse->target == next->reverse->target);
 if (prev->next == next)
 {
  if (prev->prev == next)
  {
   Point64 n = t.cross(s);
   Point64 m = (*prev->target - *next->reverse->target).cross(*next->target - *next->reverse->target);
   btAssert(!m.isZero());
   int64_t dot = n.dot(m);
   btAssert(dot != 0);
   return (dot > 0) ? COUNTER_CLOCKWISE : CLOCKWISE;
  }
  return COUNTER_CLOCKWISE;
 }
 else if (prev->prev == next)
 {
  return CLOCKWISE;
 }
 else
 {
  return NONE;
 }
}

btConvexHullInternal::Edge* btConvexHullInternal::findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot)
{
 Edge* minEdge = NULL;

#ifdef DEBUG_CONVEX_HULL
 printf("find max edge for %d\n", start->point.index);
#endif
 Edge* e = start->edges;
 if (e)
 {
  do
  {
   if (e->copy > mergeStamp)
   {
    Point32 t = *e->target - *start;
    Rational64 cot(t.dot(sxrxs), t.dot(rxs));
#ifdef DEBUG_CONVEX_HULL
    printf("      Angle is %f (%d) for ", (float)btAtan(cot.toScalar()), (int)cot.isNaN());
    e->print();
#endif
    if (cot.isNaN())
    {
     btAssert(ccw ? (t.dot(s) < 0) : (t.dot(s) > 0));
    }
    else
    {
     int cmp;
     if (minEdge == NULL)
     {
      minCot = cot;
      minEdge = e;
     }
     else if ((cmp = cot.compare(minCot)) < 0)
     {
      minCot = cot;
      minEdge = e;
     }
     else if ((cmp == 0) && (ccw == (getOrientation(minEdge, e, s, t) == COUNTER_CLOCKWISE)))
     {
      minEdge = e;
     }
    }
#ifdef DEBUG_CONVEX_HULL
    printf("\n");
#endif
   }
   e = e->next;
  } while (e != start->edges);
 }
 return minEdge;
}

void btConvexHullInternal::findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1)
{
 Edge* start0 = e0;
 Edge* start1 = e1;
 Point32 et0 = start0 ? start0->target->point : c0->point;
 Point32 et1 = start1 ? start1->target->point : c1->point;
 Point32 s = c1->point - c0->point;
 Point64 normal = ((start0 ? start0 : start1)->target->point - c0->point).cross(s);
 int64_t dist = c0->point.dot(normal);
 btAssert(!start1 || (start1->target->point.dot(normal) == dist));
 Point64 perp = s.cross(normal);
 btAssert(!perp.isZero());

#ifdef DEBUG_CONVEX_HULL
 printf("   Advancing %d %d  (%p %p, %d %d)\n", c0->point.index, c1->point.index, start0, start1, start0 ? start0->target->point.index : -1, start1 ? start1->target->point.index : -1);
#endif

 int64_t maxDot0 = et0.dot(perp);
 if (e0)
 {
  while (e0->target != stop0)
  {
   Edge* e = e0->reverse->prev;
   if (e->target->point.dot(normal) < dist)
   {
    break;
   }
   btAssert(e->target->point.dot(normal) == dist);
   if (e->copy == mergeStamp)
   {
    break;
   }
   int64_t dot = e->target->point.dot(perp);
   if (dot <= maxDot0)
   {
    break;
   }
   maxDot0 = dot;
   e0 = e;
   et0 = e->target->point;
  }
 }

 int64_t maxDot1 = et1.dot(perp);
 if (e1)
 {
  while (e1->target != stop1)
  {
   Edge* e = e1->reverse->next;
   if (e->target->point.dot(normal) < dist)
   {
    break;
   }
   btAssert(e->target->point.dot(normal) == dist);
   if (e->copy == mergeStamp)
   {
    break;
   }
   int64_t dot = e->target->point.dot(perp);
   if (dot <= maxDot1)
   {
    break;
   }
   maxDot1 = dot;
   e1 = e;
   et1 = e->target->point;
  }
 }

#ifdef DEBUG_CONVEX_HULL
 printf("   Starting at %d %d\n", et0.index, et1.index);
#endif

 int64_t dx = maxDot1 - maxDot0;
 if (dx > 0)
 {
  while (true)
  {
   int64_t dy = (et1 - et0).dot(s);

   if (e0 && (e0->target != stop0))
   {
    Edge* f0 = e0->next->reverse;
    if (f0->copy > mergeStamp)
    {
     int64_t dx0 = (f0->target->point - et0).dot(perp);
     int64_t dy0 = (f0->target->point - et0).dot(s);
     if ((dx0 == 0) ? (dy0 < 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) >= 0)))
     {
      et0 = f0->target->point;
      dx = (et1 - et0).dot(perp);
      e0 = (e0 == start0) ? NULL : f0;
      continue;
     }
    }
   }

   if (e1 && (e1->target != stop1))
   {
    Edge* f1 = e1->reverse->next;
    if (f1->copy > mergeStamp)
    {
     Point32 d1 = f1->target->point - et1;
     if (d1.dot(normal) == 0)
     {
      int64_t dx1 = d1.dot(perp);
      int64_t dy1 = d1.dot(s);
      int64_t dxn = (f1->target->point - et0).dot(perp);
      if ((dxn > 0) && ((dx1 == 0) ? (dy1 < 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) > 0))))
      {
       e1 = f1;
       et1 = e1->target->point;
       dx = dxn;
       continue;
      }
     }
     else
     {
      btAssert((e1 == start1) && (d1.dot(normal) < 0));
     }
    }
   }

   break;
  }
 }
 else if (dx < 0)
 {
  while (true)
  {
   int64_t dy = (et1 - et0).dot(s);

   if (e1 && (e1->target != stop1))
   {
    Edge* f1 = e1->prev->reverse;
    if (f1->copy > mergeStamp)
    {
     int64_t dx1 = (f1->target->point - et1).dot(perp);
     int64_t dy1 = (f1->target->point - et1).dot(s);
     if ((dx1 == 0) ? (dy1 > 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) <= 0)))
     {
      et1 = f1->target->point;
      dx = (et1 - et0).dot(perp);
      e1 = (e1 == start1) ? NULL : f1;
      continue;
     }
    }
   }

   if (e0 && (e0->target != stop0))
   {
    Edge* f0 = e0->reverse->prev;
    if (f0->copy > mergeStamp)
    {
     Point32 d0 = f0->target->point - et0;
     if (d0.dot(normal) == 0)
     {
      int64_t dx0 = d0.dot(perp);
      int64_t dy0 = d0.dot(s);
      int64_t dxn = (et1 - f0->target->point).dot(perp);
      if ((dxn < 0) && ((dx0 == 0) ? (dy0 > 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) < 0))))
      {
       e0 = f0;
       et0 = e0->target->point;
       dx = dxn;
       continue;
      }
     }
     else
     {
      btAssert((e0 == start0) && (d0.dot(normal) < 0));
     }
    }
   }

   break;
  }
 }
#ifdef DEBUG_CONVEX_HULL
 printf("   Advanced edges to %d %d\n", et0.index, et1.index);
#endif
}


void btConvexHullInternal::merge(IntermediateHull& h0, IntermediateHull& h1)
{
 if (!h1.maxXy)
 {
  return;
 }
 if (!h0.maxXy)
 {
  h0 = h1;
  return;
 }

 mergeStamp--;

 Vertex* c0 = NULL;
 Edge* toPrev0 = NULL;
 Edge* firstNew0 = NULL;
 Edge* pendingHead0 = NULL;
 Edge* pendingTail0 = NULL;
 Vertex* c1 = NULL;
 Edge* toPrev1 = NULL;
 Edge* firstNew1 = NULL;
 Edge* pendingHead1 = NULL;
 Edge* pendingTail1 = NULL;
 Point32 prevPoint;

 if (mergeProjection(h0, h1, c0, c1))
 {
  Point32 s = *c1 - *c0;
  Point64 normal = Point32(0, 0, -1).cross(s);
  Point64 t = s.cross(normal);
  btAssert(!t.isZero());

  Edge* e = c0->edges;
  Edge* start0 = NULL;
  if (e)
  {
   do
   {
    int64_t dot = (*e->target - *c0).dot(normal);
    btAssert(dot <= 0);
    if ((dot == 0) && ((*e->target - *c0).dot(t) > 0))
    {
     if (!start0 || (getOrientation(start0, e, s, Point32(0, 0, -1)) == CLOCKWISE))
     {
      start0 = e;
     }
    }
    e = e->next;
   } while (e != c0->edges);
  }

  e = c1->edges;
  Edge* start1 = NULL;
  if (e)
  {
   do
   {
    int64_t dot = (*e->target - *c1).dot(normal);
    btAssert(dot <= 0);
    if ((dot == 0) && ((*e->target - *c1).dot(t) > 0))
    {
     if (!start1 || (getOrientation(start1, e, s, Point32(0, 0, -1)) == COUNTER_CLOCKWISE))
     {
      start1 = e;
     }
    }
    e = e->next;
   } while (e != c1->edges);
  }

  if (start0 || start1)
  {
   findEdgeForCoplanarFaces(c0, c1, start0, start1, NULL, NULL);
   if (start0)
   {
    c0 = start0->target;
   }
   if (start1)
   {
    c1 = start1->target;
   }
  }

  prevPoint = c1->point;
  prevPoint.z++;
 }
 else
 {
  prevPoint = c1->point;
  prevPoint.x++;
 }

 Vertex* first0 = c0;
 Vertex* first1 = c1;
 bool firstRun = true;

 while (true)
 {
  Point32 s = *c1 - *c0;
  Point32 r = prevPoint - c0->point;
  Point64 rxs = r.cross(s);
  Point64 sxrxs = s.cross(rxs);

#ifdef DEBUG_CONVEX_HULL
  printf("\n  Checking %d %d\n", c0->point.index, c1->point.index);
#endif
  Rational64 minCot0(0, 0);
  Edge* min0 = findMaxAngle(false, c0, s, rxs, sxrxs, minCot0);
  Rational64 minCot1(0, 0);
  Edge* min1 = findMaxAngle(true, c1, s, rxs, sxrxs, minCot1);
  if (!min0 && !min1)
  {
   Edge* e = newEdgePair(c0, c1);
   e->link(e);
   c0->edges = e;

   e = e->reverse;
   e->link(e);
   c1->edges = e;
   return;
  }
  else
  {
   int cmp = !min0 ? 1 : !min1 ? -1 : minCot0.compare(minCot1);
#ifdef DEBUG_CONVEX_HULL
   printf("    -> Result %d\n", cmp);
#endif
   if (firstRun || ((cmp >= 0) ? !minCot1.isNegativeInfinity() : !minCot0.isNegativeInfinity()))
   {
    Edge* e = newEdgePair(c0, c1);
    if (pendingTail0)
    {
     pendingTail0->prev = e;
    }
    else
    {
     pendingHead0 = e;
    }
    e->next = pendingTail0;
    pendingTail0 = e;

    e = e->reverse;
    if (pendingTail1)
    {
     pendingTail1->next = e;
    }
    else
    {
     pendingHead1 = e;
    }
    e->prev = pendingTail1;
    pendingTail1 = e;
   }

   Edge* e0 = min0;
   Edge* e1 = min1;

#ifdef DEBUG_CONVEX_HULL
   printf("   Found min edges to %d %d\n", e0 ? e0->target->point.index : -1, e1 ? e1->target->point.index : -1);
#endif

   if (cmp == 0)
   {
    findEdgeForCoplanarFaces(c0, c1, e0, e1, NULL, NULL);
   }

   if ((cmp >= 0) && e1)
   {
    if (toPrev1)
    {
     for (Edge* e = toPrev1->next, *n = NULL; e != min1; e = n)
     {
      n = e->next;
      removeEdgePair(e);
     }
    }

    if (pendingTail1)
    {
     if (toPrev1)
     {
      toPrev1->link(pendingHead1);
     }
     else
     {
      min1->prev->link(pendingHead1);
      firstNew1 = pendingHead1;
     }
     pendingTail1->link(min1);
     pendingHead1 = NULL;
     pendingTail1 = NULL;
    }
    else if (!toPrev1)
    {
     firstNew1 = min1;
    }

    prevPoint = c1->point;
    c1 = e1->target;
    toPrev1 = e1->reverse;
   }

   if ((cmp <= 0) && e0)
   {
    if (toPrev0)
    {
     for (Edge* e = toPrev0->prev, *n = NULL; e != min0; e = n)
     {
      n = e->prev;
      removeEdgePair(e);
     }
    }

    if (pendingTail0)
    {
     if (toPrev0)
     {
      pendingHead0->link(toPrev0);
     }
     else
     {
      pendingHead0->link(min0->next);
      firstNew0 = pendingHead0;
     }
     min0->link(pendingTail0);
     pendingHead0 = NULL;
     pendingTail0 = NULL;
    }
    else if (!toPrev0)
    {
     firstNew0 = min0;
    }

    prevPoint = c0->point;
    c0 = e0->target;
    toPrev0 = e0->reverse;
   }
  }

  if ((c0 == first0) && (c1 == first1))
  {
   if (toPrev0 == NULL)
   {
    pendingHead0->link(pendingTail0);
    c0->edges = pendingTail0;
   }
   else
   {
    for (Edge* e = toPrev0->prev, *n = NULL; e != firstNew0; e = n)
    {
     n = e->prev;
     removeEdgePair(e);
    }
    if (pendingTail0)
    {
     pendingHead0->link(toPrev0);
     firstNew0->link(pendingTail0);
    }
   }

   if (toPrev1 == NULL)
   {
    pendingTail1->link(pendingHead1);
    c1->edges = pendingTail1;
   }
   else
   {
    for (Edge* e = toPrev1->next, *n = NULL; e != firstNew1; e = n)
    {
     n = e->next;
     removeEdgePair(e);
    }
    if (pendingTail1)
    {
     toPrev1->link(pendingHead1);
     pendingTail1->link(firstNew1);
    }
   }

   return;
  }

  firstRun = false;
 }
}

class pointCmp
{
public:

 bool operator() (const btConvexHullInternal::Point32& p, const btConvexHullInternal::Point32& q) const
 {
  return (p.y < q.y) || ((p.y == q.y) && ((p.x < q.x) || ((p.x == q.x) && (p.z < q.z))));
 }
};

void btConvexHullInternal::compute(const void* coords, bool doubleCoords, int stride, int count)
{
 btVector3 min(btScalar(1e30), btScalar(1e30), btScalar(1e30)), max(btScalar(-1e30), btScalar(-1e30), btScalar(-1e30));
 const char* ptr = (const char*)coords;
 if (doubleCoords)
 {
  for (int i = 0; i < count; i++)
  {
   const double* v = (const double*)ptr;
   btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
   ptr += stride;
   min.setMin(p);
   max.setMax(p);
  }
 }
 else
 {
  for (int i = 0; i < count; i++)
  {
   const float* v = (const float*)ptr;
   btVector3 p(v[0], v[1], v[2]);
   ptr += stride;
   min.setMin(p);
   max.setMax(p);
  }
 }

 btVector3 s = max - min;
 maxAxis = s.maxAxis();
 minAxis = s.minAxis();
 if (minAxis == maxAxis)
 {
  minAxis = (maxAxis + 1) % 3;
 }
 medAxis = 3 - maxAxis - minAxis;

 s /= btScalar(10216);
 if (((medAxis + 1) % 3) != maxAxis)
 {
  s *= -1;
 }
 scaling = s;

 if (s[0] != 0)
 {
  s[0] = btScalar(1) / s[0];
 }
 if (s[1] != 0)
 {
  s[1] = btScalar(1) / s[1];
 }
 if (s[2] != 0)
 {
  s[2] = btScalar(1) / s[2];
 }

 center = (min + max) * btScalar(0.5);

 btAlignedObjectArray<Point32> points;
 points.resize(count);
 ptr = (const char*)coords;
 if (doubleCoords)
 {
  for (int i = 0; i < count; i++)
  {
   const double* v = (const double*)ptr;
   btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
   ptr += stride;
   p = (p - center) * s;
   points[i].x = (int32_t)p[medAxis];
   points[i].y = (int32_t)p[maxAxis];
   points[i].z = (int32_t)p[minAxis];
   points[i].index = i;
  }
 }
 else
 {
  for (int i = 0; i < count; i++)
  {
   const float* v = (const float*)ptr;
   btVector3 p(v[0], v[1], v[2]);
   ptr += stride;
   p = (p - center) * s;
   points[i].x = (int32_t)p[medAxis];
   points[i].y = (int32_t)p[maxAxis];
   points[i].z = (int32_t)p[minAxis];
   points[i].index = i;
  }
 }
 points.quickSort(pointCmp());

 vertexPool.reset();
 vertexPool.setArraySize(count);
 originalVertices.resize(count);
 for (int i = 0; i < count; i++)
 {
  Vertex* v = vertexPool.newObject();
  v->edges = NULL;
  v->point = points[i];
  v->copy = -1;
  originalVertices[i] = v;
 }

 points.clear();

 edgePool.reset();
 edgePool.setArraySize(6 * count);

 usedEdgePairs = 0;
 maxUsedEdgePairs = 0;

 mergeStamp = -3;

 IntermediateHull hull;
 computeInternal(0, count, hull);
 vertexList = hull.minXy;
#ifdef DEBUG_CONVEX_HULL
 printf("max. edges %d (3v = %d)", maxUsedEdgePairs, 3 * count);
#endif
}

btVector3 btConvexHullInternal::toBtVector(const Point32& v)
{
 btVector3 p;
 p[medAxis] = btScalar(v.x);
 p[maxAxis] = btScalar(v.y);
 p[minAxis] = btScalar(v.z);
 return p * scaling;
}

btVector3 btConvexHullInternal::getBtNormal(Face* face)
{
 return toBtVector(face->dir0).cross(toBtVector(face->dir1)).normalized();
}

btVector3 btConvexHullInternal::getCoordinates(const Vertex* v)
{
 btVector3 p;
 p[medAxis] = v->xvalue();
 p[maxAxis] = v->yvalue();
 p[minAxis] = v->zvalue();
 return p * scaling + center;
}

btScalar btConvexHullInternal::shrink(btScalar amount, btScalar clampAmount)
{
 if (!vertexList)
 {
  return 0;
 }
 int stamp = --mergeStamp;
 btAlignedObjectArray<Vertex*> stack;
 vertexList->copy = stamp;
 stack.push_back(vertexList);
 btAlignedObjectArray<Face*> faces;

 Point32 ref = vertexList->point;
 Int128 hullCenterX(0, 0);
 Int128 hullCenterY(0, 0);
 Int128 hullCenterZ(0, 0);
 Int128 volume(0, 0);

 while (stack.size() > 0)
 {
  Vertex* v = stack[stack.size() - 1];
  stack.pop_back();
  Edge* e = v->edges;
  if (e)
  {
   do
   {
    if (e->target->copy != stamp)
    {
     e->target->copy = stamp;
     stack.push_back(e->target);
    }
    if (e->copy != stamp)
    {
     Face* face = facePool.newObject();
     face->init(e->target, e->reverse->prev->target, v);
     faces.push_back(face);
     Edge* f = e;

     Vertex* a = NULL;
     Vertex* b = NULL;
     do
     {
      if (a && b)
      {
       int64_t vol = (v->point - ref).dot((a->point - ref).cross(b->point - ref));
       btAssert(vol >= 0);
       Point32 c = v->point + a->point + b->point + ref;
       hullCenterX += vol * c.x;
       hullCenterY += vol * c.y;
       hullCenterZ += vol * c.z;
       volume += vol;
      }

      btAssert(f->copy != stamp);
      f->copy = stamp;
      f->face = face;

      a = b;
      b = f->target;

      f = f->reverse->prev;
     } while (f != e);
    }
    e = e->next;
   } while (e != v->edges);
  }
 }

 if (volume.getSign() <= 0)
 {
  return 0;
 }

 btVector3 hullCenter;
 hullCenter[medAxis] = hullCenterX.toScalar();
 hullCenter[maxAxis] = hullCenterY.toScalar();
 hullCenter[minAxis] = hullCenterZ.toScalar();
 hullCenter /= 4 * volume.toScalar();
 hullCenter *= scaling;

 int faceCount = faces.size();

 if (clampAmount > 0)
 {
  btScalar minDist = SIMD_INFINITY;
  for (int i = 0; i < faceCount; i++)
  {
   btVector3 normal = getBtNormal(faces[i]);
   btScalar dist = normal.dot(toBtVector(faces[i]->origin) - hullCenter);
   if (dist < minDist)
   {
    minDist = dist;
   }
  }

  if (minDist <= 0)
  {
   return 0;
  }

  amount = btMin(amount, minDist * clampAmount);
 }

 unsigned int seed = 243703;
 for (int i = 0; i < faceCount; i++, seed = 1664525 * seed + 1013904223)
 {
  btSwap(faces[i], faces[seed % faceCount]);
 }

 for (int i = 0; i < faceCount; i++)
 {
  if (!shiftFace(faces[i], amount, stack))
  {
   return -amount;
  }
 }

 return amount;
}

bool btConvexHullInternal::shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack)
{
 btVector3 origShift = getBtNormal(face) * -amount;
 if (scaling[0] != 0)
 {
  origShift[0] /= scaling[0];
 }
 if (scaling[1] != 0)
 {
  origShift[1] /= scaling[1];
 }
 if (scaling[2] != 0)
 {
  origShift[2] /= scaling[2];
 }
 Point32 shift((int32_t)origShift[medAxis], (int32_t)origShift[maxAxis], (int32_t)origShift[minAxis]);
 if (shift.isZero())
 {
  return true;
 }
 Point64 normal = face->getNormal();
#ifdef DEBUG_CONVEX_HULL
 printf("\nShrinking face (%d %d %d) (%d %d %d) (%d %d %d) by (%d %d %d)\n",
  face->origin.x, face->origin.y, face->origin.z, face->dir0.x, face->dir0.y, face->dir0.z, face->dir1.x, face->dir1.y, face->dir1.z, shift.x, shift.y, shift.z);
#endif
 int64_t origDot = face->origin.dot(normal);
 Point32 shiftedOrigin = face->origin + shift;
 int64_t shiftedDot = shiftedOrigin.dot(normal);
 btAssert(shiftedDot <= origDot);
 if (shiftedDot >= origDot)
 {
  return false;
 }

 Edge* intersection = NULL;

 Edge* startEdge = face->nearbyVertex->edges;
#ifdef DEBUG_CONVEX_HULL
 printf("Start edge is ");
 startEdge->print();
 printf(", normal is (%lld %lld %lld), shifted dot is %lld\n", normal.x, normal.y, normal.z, shiftedDot);
#endif
 Rational128 optDot = face->nearbyVertex->dot(normal);
 int cmp = optDot.compare(shiftedDot);
#ifdef SHOW_ITERATIONS
 int n = 0;
#endif
 if (cmp >= 0)
 {
  Edge* e = startEdge;
  do
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   Rational128 dot = e->target->dot(normal);
   btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
   printf("Moving downwards, edge is ");
   e->print();
   printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
   if (dot.compare(optDot) < 0)
   {
    int c = dot.compare(shiftedDot);
    optDot = dot;
    e = e->reverse;
    startEdge = e;
    if (c < 0)
    {
     intersection = e;
     break;
    }
    cmp = c;
   }
   e = e->prev;
  } while (e != startEdge);

  if (!intersection)
  {
   return false;
  }
 }
 else
 {
  Edge* e = startEdge;
  do
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   Rational128 dot = e->target->dot(normal);
   btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
   printf("Moving upwards, edge is ");
   e->print();
   printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
   if (dot.compare(optDot) > 0)
   {
    cmp = dot.compare(shiftedDot);
    if (cmp >= 0)
    {
     intersection = e;
     break;
    }
    optDot = dot;
    e = e->reverse;
    startEdge = e;
   }
   e = e->prev;
  } while (e != startEdge);

  if (!intersection)
  {
   return true;
  }
 }

#ifdef SHOW_ITERATIONS
 printf("Needed %d iterations to find initial intersection\n", n);
#endif

 if (cmp == 0)
 {
  Edge* e = intersection->reverse->next;
#ifdef SHOW_ITERATIONS
  n = 0;
#endif
  while (e->target->dot(normal).compare(shiftedDot) <= 0)
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   e = e->next;
   if (e == intersection->reverse)
   {
    return true;
   }
#ifdef DEBUG_CONVEX_HULL
   printf("Checking for outwards edge, current edge is ");
   e->print();
   printf("\n");
#endif
  }
#ifdef SHOW_ITERATIONS
  printf("Needed %d iterations to check for complete containment\n", n);
#endif
 }

 Edge* firstIntersection = NULL;
 Edge* faceEdge = NULL;
 Edge* firstFaceEdge = NULL;

#ifdef SHOW_ITERATIONS
 int m = 0;
#endif
 while (true)
 {
#ifdef SHOW_ITERATIONS
  m++;
#endif
#ifdef DEBUG_CONVEX_HULL
  printf("Intersecting edge is ");
  intersection->print();
  printf("\n");
#endif
  if (cmp == 0)
  {
   Edge* e = intersection->reverse->next;
   startEdge = e;
#ifdef SHOW_ITERATIONS
   n = 0;
#endif
   while (true)
   {
#ifdef SHOW_ITERATIONS
    n++;
#endif
    if (e->target->dot(normal).compare(shiftedDot) >= 0)
    {
     break;
    }
    intersection = e->reverse;
    e = e->next;
    if (e == startEdge)
    {
     return true;
    }
   }
#ifdef SHOW_ITERATIONS
   printf("Needed %d iterations to advance intersection\n", n);
#endif
  }

#ifdef DEBUG_CONVEX_HULL
  printf("Advanced intersecting edge to ");
  intersection->print();
  printf(", cmp = %d\n", cmp);
#endif

  if (!firstIntersection)
  {
   firstIntersection = intersection;
  }
  else if (intersection == firstIntersection)
  {
   break;
  }

  int prevCmp = cmp;
  Edge* prevIntersection = intersection;
  Edge* prevFaceEdge = faceEdge;

  Edge* e = intersection->reverse;
#ifdef SHOW_ITERATIONS
  n = 0;
#endif
  while (true)
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   e = e->reverse->prev;
   btAssert(e != intersection->reverse);
   cmp = e->target->dot(normal).compare(shiftedDot);
#ifdef DEBUG_CONVEX_HULL
   printf("Testing edge ");
   e->print();
   printf(" -> cmp = %d\n", cmp);
#endif
   if (cmp >= 0)
   {
    intersection = e;
    break;
   }
  }
#ifdef SHOW_ITERATIONS
  printf("Needed %d iterations to find other intersection of face\n", n);
#endif

  if (cmp > 0)
  {
   Vertex* removed = intersection->target;
   e = intersection->reverse;
   if (e->prev == e)
   {
    removed->edges = NULL;
   }
   else
   {
    removed->edges = e->prev;
    e->prev->link(e->next);
    e->link(e);
   }
#ifdef DEBUG_CONVEX_HULL
   printf("1: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif

   Point64 n0 = intersection->face->getNormal();
   Point64 n1 = intersection->reverse->face->getNormal();
   int64_t m00 = face->dir0.dot(n0);
   int64_t m01 = face->dir1.dot(n0);
   int64_t m10 = face->dir0.dot(n1);
   int64_t m11 = face->dir1.dot(n1);
   int64_t r0 = (intersection->face->origin - shiftedOrigin).dot(n0);
   int64_t r1 = (intersection->reverse->face->origin - shiftedOrigin).dot(n1);
   Int128 det = Int128::mul(m00, m11) - Int128::mul(m01, m10);
   btAssert(det.getSign() != 0);
   Vertex* v = vertexPool.newObject();
   v->point.index = -1;
   v->copy = -1;
   v->point128 = PointR128(Int128::mul(face->dir0.x * r0, m11) - Int128::mul(face->dir0.x * r1, m01)
    + Int128::mul(face->dir1.x * r1, m00) - Int128::mul(face->dir1.x * r0, m10) + det * shiftedOrigin.x,
    Int128::mul(face->dir0.y * r0, m11) - Int128::mul(face->dir0.y * r1, m01)
    + Int128::mul(face->dir1.y * r1, m00) - Int128::mul(face->dir1.y * r0, m10) + det * shiftedOrigin.y,
    Int128::mul(face->dir0.z * r0, m11) - Int128::mul(face->dir0.z * r1, m01)
    + Int128::mul(face->dir1.z * r1, m00) - Int128::mul(face->dir1.z * r0, m10) + det * shiftedOrigin.z,
    det);
   v->point.x = (int32_t)v->point128.xvalue();
   v->point.y = (int32_t)v->point128.yvalue();
   v->point.z = (int32_t)v->point128.zvalue();
   intersection->target = v;
   v->edges = e;

   stack.push_back(v);
   stack.push_back(removed);
   stack.push_back(NULL);
  }

  if (cmp || prevCmp || (prevIntersection->reverse->next->target != intersection->target))
  {
   faceEdge = newEdgePair(prevIntersection->target, intersection->target);
   if (prevCmp == 0)
   {
    faceEdge->link(prevIntersection->reverse->next);
   }
   if ((prevCmp == 0) || prevFaceEdge)
   {
    prevIntersection->reverse->link(faceEdge);
   }
   if (cmp == 0)
   {
    intersection->reverse->prev->link(faceEdge->reverse);
   }
   faceEdge->reverse->link(intersection->reverse);
  }
  else
  {
   faceEdge = prevIntersection->reverse->next;
  }

  if (prevFaceEdge)
  {
   if (prevCmp > 0)
   {
    faceEdge->link(prevFaceEdge->reverse);
   }
   else if (faceEdge != prevFaceEdge->reverse)
   {
    stack.push_back(prevFaceEdge->target);
    while (faceEdge->next != prevFaceEdge->reverse)
    {
     Vertex* removed = faceEdge->next->target;
     removeEdgePair(faceEdge->next);
     stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
     printf("2: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
    }
    stack.push_back(NULL);
   }
  }
  faceEdge->face = face;
  faceEdge->reverse->face = intersection->face;

  if (!firstFaceEdge)
  {
   firstFaceEdge = faceEdge;
  }
 }
#ifdef SHOW_ITERATIONS
 printf("Needed %d iterations to process all intersections\n", m);
#endif

 if (cmp > 0)
 {
  firstFaceEdge->reverse->target = faceEdge->target;
  firstIntersection->reverse->link(firstFaceEdge);
  firstFaceEdge->link(faceEdge->reverse);
 }
 else if (firstFaceEdge != faceEdge->reverse)
 {
  stack.push_back(faceEdge->target);
  while (firstFaceEdge->next != faceEdge->reverse)
  {
   Vertex* removed = firstFaceEdge->next->target;
   removeEdgePair(firstFaceEdge->next);
   stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
   printf("3: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
  }
  stack.push_back(NULL);
 }

 btAssert(stack.size() > 0);
 vertexList = stack[0];

#ifdef DEBUG_CONVEX_HULL
 printf("Removing part\n");
#endif
#ifdef SHOW_ITERATIONS
 n = 0;
#endif
 int pos = 0;
 while (pos < stack.size())
 {
  int end = stack.size();
  while (pos < end)
  {
   Vertex* kept = stack[pos++];
#ifdef DEBUG_CONVEX_HULL
   kept->print();
#endif
   bool deeper = false;
   Vertex* removed;
   while ((removed = stack[pos++]) != NULL)
   {
#ifdef SHOW_ITERATIONS
    n++;
#endif
    kept->receiveNearbyFaces(removed);
    while (removed->edges)
    {
     if (!deeper)
     {
      deeper = true;
      stack.push_back(kept);
     }
     stack.push_back(removed->edges->target);
     removeEdgePair(removed->edges);
    }
   }
   if (deeper)
   {
    stack.push_back(NULL);
   }
  }
 }
#ifdef SHOW_ITERATIONS
 printf("Needed %d iterations to remove part\n", n);
#endif

 stack.resize(0);
 face->origin = shiftedOrigin;

 return true;
}


static int getVertexCopy(btConvexHullInternal::Vertex* vertex, btAlignedObjectArray<btConvexHullInternal::Vertex*>& vertices)
{
 int index = vertex->copy;
 if (index < 0)
 {
  index = vertices.size();
  vertex->copy = index;
  vertices.push_back(vertex);
#ifdef DEBUG_CONVEX_HULL
  printf("Vertex %d gets index *%d\n", vertex->point.index, index);
#endif
 }
 return index;
}

btScalar btConvexHullComputer::compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
{
 if (count <= 0)
 {
  vertices.clear();
  edges.clear();
  faces.clear();
  return 0;
 }

 btConvexHullInternal hull;
 hull.compute(coords, doubleCoords, stride, count);

 btScalar shift = 0;
 if ((shrink > 0) && ((shift = hull.shrink(shrink, shrinkClamp)) < 0))
 {
  vertices.clear();
  edges.clear();
  faces.clear();
  return shift;
 }

 vertices.resize(0);
 edges.resize(0);
 faces.resize(0);

 btAlignedObjectArray<btConvexHullInternal::Vertex*> oldVertices;
 getVertexCopy(hull.vertexList, oldVertices);
 int copied = 0;
 while (copied < oldVertices.size())
 {
  btConvexHullInternal::Vertex* v = oldVertices[copied];
  vertices.push_back(hull.getCoordinates(v));
  btConvexHullInternal::Edge* firstEdge = v->edges;
  if (firstEdge)
  {
   int firstCopy = -1;
   int prevCopy = -1;
   btConvexHullInternal::Edge* e = firstEdge;
   do
   {
    if (e->copy < 0)
    {
     int s = edges.size();
     edges.push_back(Edge());
     edges.push_back(Edge());
     Edge* c = &edges[s];
     Edge* r = &edges[s + 1];
     e->copy = s;
     e->reverse->copy = s + 1;
     c->reverse = 1;
     r->reverse = -1;
     c->targetVertex = getVertexCopy(e->target, oldVertices);
     r->targetVertex = copied;
#ifdef DEBUG_CONVEX_HULL
     printf("      CREATE: Vertex *%d has edge to *%d\n", copied, c->getTargetVertex());
#endif
    }
    if (prevCopy >= 0)
    {
     edges[e->copy].next = prevCopy - e->copy;
    }
    else
    {
     firstCopy = e->copy;
    }
    prevCopy = e->copy;
    e = e->next;
   } while (e != firstEdge);
   edges[firstCopy].next = prevCopy - firstCopy;
  }
  copied++;
 }

 for (int i = 0; i < copied; i++)
 {
  btConvexHullInternal::Vertex* v = oldVertices[i];
  btConvexHullInternal::Edge* firstEdge = v->edges;
  if (firstEdge)
  {
   btConvexHullInternal::Edge* e = firstEdge;
   do
   {
    if (e->copy >= 0)
    {
#ifdef DEBUG_CONVEX_HULL
     printf("Vertex *%d has edge to *%d\n", i, edges[e->copy].getTargetVertex());
#endif
     faces.push_back(e->copy);
     btConvexHullInternal::Edge* f = e;
     do
     {
#ifdef DEBUG_CONVEX_HULL
      printf("   Face *%d\n", edges[f->copy].getTargetVertex());
#endif
      f->copy = -1;
      f = f->reverse->prev;
     } while (f != e);
    }
    e = e->next;
   } while (e != firstEdge);
  }
 }

 return shift;
}

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "LinearMath/btGeometryUtil.h"


/*
Make sure this dummy function never changes so that it
can be used by probes that are checking whether the
library is actually installed.
*/
extern "C"
{
 void btBulletMathProbe();

 void btBulletMathProbe() {}
}


bool	btGeometryUtil::isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar	margin)
{
 int numbrushes = planeEquations.size();
 for (int i = 0; i<numbrushes; i++)
 {
  const btVector3& N1 = planeEquations[i];
  btScalar dist = btScalar(N1.dot(point)) + btScalar(N1[3]) - margin;
  if (dist>btScalar(0.))
  {
   return false;
  }
 }
 return true;

}


bool	btGeometryUtil::areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar	margin)
{
 int numvertices = vertices.size();
 for (int i = 0; i<numvertices; i++)
 {
  const btVector3& N1 = vertices[i];
  btScalar dist = btScalar(planeNormal.dot(N1)) + btScalar(planeNormal[3]) - margin;
  if (dist>btScalar(0.))
  {
   return false;
  }
 }
 return true;
}

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations);

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations)
{
 int numbrushes = planeEquations.size();
 for (int i = 0; i<numbrushes; i++)
 {
  const btVector3& N1 = planeEquations[i];
  if (planeEquation.dot(N1) > btScalar(0.999))
  {
   return false;
  }
 }
 return true;
}

void	btGeometryUtil::getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut)
{
 const int numvertices = vertices.size();
 // brute force:
 for (int i = 0; i<numvertices; i++)
 {
  const btVector3& N1 = vertices[i];


  for (int j = i + 1; j<numvertices; j++)
  {
   const btVector3& N2 = vertices[j];

   for (int k = j + 1; k<numvertices; k++)
   {

    const btVector3& N3 = vertices[k];

    btVector3 planeEquation, edge0, edge1;
    edge0 = N2 - N1;
    edge1 = N3 - N1;
    btScalar normalSign = btScalar(1.);
    for (int ww = 0; ww<2; ww++)
    {
     planeEquation = normalSign * edge0.cross(edge1);
     if (planeEquation.length2() > btScalar(0.0001))
     {
      planeEquation.normalize();
      if (notExist(planeEquation, planeEquationsOut))
      {
       planeEquation[3] = -planeEquation.dot(N1);

       //check if inside, and replace supportingVertexOut if needed
       if (areVerticesBehindPlane(planeEquation, vertices, btScalar(0.01)))
       {
        planeEquationsOut.push_back(planeEquation);
       }
      }
     }
     normalSign = btScalar(-1.);
    }

   }
  }
 }

}

void	btGeometryUtil::getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut)
{
 const int numbrushes = planeEquations.size();
 // brute force:
 for (int i = 0; i<numbrushes; i++)
 {
  const btVector3& N1 = planeEquations[i];


  for (int j = i + 1; j<numbrushes; j++)
  {
   const btVector3& N2 = planeEquations[j];

   for (int k = j + 1; k<numbrushes; k++)
   {

    const btVector3& N3 = planeEquations[k];

    btVector3 n2n3; n2n3 = N2.cross(N3);
    btVector3 n3n1; n3n1 = N3.cross(N1);
    btVector3 n1n2; n1n2 = N1.cross(N2);

    if ((n2n3.length2() > btScalar(0.0001)) &&
     (n3n1.length2() > btScalar(0.0001)) &&
     (n1n2.length2() > btScalar(0.0001)))
    {
     //point P out of 3 plane equations:

     //	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )  
     //P =  -------------------------------------------------------------------------  
     //   N1 . ( N2 * N3 )  


     btScalar quotient = (N1.dot(n2n3));
     if (btFabs(quotient) > btScalar(0.000001))
     {
      quotient = btScalar(-1.) / quotient;
      n2n3 *= N1[3];
      n3n1 *= N2[3];
      n1n2 *= N3[3];
      btVector3 potentialVertex = n2n3;
      potentialVertex += n3n1;
      potentialVertex += n1n2;
      potentialVertex *= quotient;

      //check if inside, and replace supportingVertexOut if needed
      if (isPointInsidePlanes(planeEquations, potentialVertex, btScalar(0.01)))
      {
       verticesOut.push_back(potentialVertex);
      }
     }
    }
   }
  }
 }
}

#include "LinearMath/btPolarDecomposition.h"
#include "LinearMath/btMinMax.h"

namespace
{
 btScalar abs_column_sum(const btMatrix3x3& a, int i)
 {
  return btFabs(a[0][i]) + btFabs(a[1][i]) + btFabs(a[2][i]);
 }

 btScalar abs_row_sum(const btMatrix3x3& a, int i)
 {
  return btFabs(a[i][0]) + btFabs(a[i][1]) + btFabs(a[i][2]);
 }

 btScalar p1_norm(const btMatrix3x3& a)
 {
  const btScalar sum0 = abs_column_sum(a, 0);
  const btScalar sum1 = abs_column_sum(a, 1);
  const btScalar sum2 = abs_column_sum(a, 2);
  return btMax(btMax(sum0, sum1), sum2);
 }

 btScalar pinf_norm(const btMatrix3x3& a)
 {
  const btScalar sum0 = abs_row_sum(a, 0);
  const btScalar sum1 = abs_row_sum(a, 1);
  const btScalar sum2 = abs_row_sum(a, 2);
  return btMax(btMax(sum0, sum1), sum2);
 }
}



btPolarDecomposition::btPolarDecomposition(btScalar tolerance, unsigned int maxIterations)
 : m_tolerance(tolerance)
 , m_maxIterations(maxIterations)
{
}

unsigned int btPolarDecomposition::decompose(const btMatrix3x3& a, btMatrix3x3& u, btMatrix3x3& h) const
{
 // Use the 'u' and 'h' matrices for intermediate calculations
 u = a;
 h = a.inverse();

 for (unsigned int i = 0; i < m_maxIterations; ++i)
 {
  const btScalar h_1 = p1_norm(h);
  const btScalar h_inf = pinf_norm(h);
  const btScalar u_1 = p1_norm(u);
  const btScalar u_inf = pinf_norm(u);

  const btScalar h_norm = h_1 * h_inf;
  const btScalar u_norm = u_1 * u_inf;

  // The matrix is effectively singular so we cannot invert it
  if (btFuzzyZero(h_norm) || btFuzzyZero(u_norm))
   break;

  const btScalar gamma = btPow(h_norm / u_norm, 0.25f);
  const btScalar inv_gamma = btScalar(1.0) / gamma;

  // Determine the delta to 'u'
  const btMatrix3x3 delta = (u * (gamma - btScalar(2.0)) + h.transpose() * inv_gamma) * btScalar(0.5);

  // Update the matrices
  u += delta;
  h = u.inverse();

  // Check for convergence
  if (p1_norm(delta) <= m_tolerance * u_1)
  {
   h = u.transpose() * a;
   h = (h + h.transpose()) * 0.5;
   return i;
  }
 }

 // The algorithm has failed to converge to the specified tolerance, but we
 // want to make sure that the matrices returned are in the right form.
 h = u.transpose() * a;
 h = (h + h.transpose()) * 0.5;

 return m_maxIterations;
}

unsigned int btPolarDecomposition::maxIterations() const
{
 return m_maxIterations;
}

unsigned int polarDecompose(const btMatrix3x3& a, btMatrix3x3& u, btMatrix3x3& h)
{
 static btPolarDecomposition polar;
 return polar.decompose(a, u, h);
}


/*

***************************************************************************************************
**
** profile.cpp
**
** Real-Time Hierarchical Profiling for Game Programming Gems 3
**
** by Greg Hjelstrom & Byon Garrabrant
**
***************************************************************************************************/

// Credits: The Clock class was inspired by the Timer classes in
// Ogre (www.ogre3d.org).

#include "LinearMath/btQuickprof.h"
#include "LinearMath/btThreads.h"




#ifdef __CELLOS_LV2__
#include <sys/sys_time.h>
#include <sys/time_util.h>
#include <stdio.h>
#endif

#if defined (SUNOS) || defined (__SUNOS__)
#include <stdio.h>
#endif
#ifdef __APPLE__
#include <mach/mach_time.h>
#include <TargetConditionals.h>
#endif

#if defined(WIN32) || defined(_WIN32)

#define BT_USE_WINDOWS_TIMERS
#define WIN32_LEAN_AND_MEAN
#define NOWINRES
#define NOMCX
#define NOIME

#ifdef _XBOX
#include <Xtl.h>
#else //_XBOX
#include <windows.h>

#if WINVER <0x0602
#define GetTickCount64 GetTickCount
#endif

#endif //_XBOX

#include <time.h>


#else //_WIN32
#include <sys/time.h>

#ifdef BT_LINUX_REALTIME
//required linking against rt (librt)
#include <time.h>
#endif //BT_LINUX_REALTIME

#endif //_WIN32

#define mymin(a,b) (a > b ? a : b)

struct btClockData
{

#ifdef BT_USE_WINDOWS_TIMERS
 LARGE_INTEGER mClockFrequency;
 LONGLONG mStartTick;
 LARGE_INTEGER mStartTime;
#else
#ifdef __CELLOS_LV2__
 uint64_t	mStartTime;
#else
#ifdef __APPLE__
 uint64_t mStartTimeNano;
#endif
 struct timeval mStartTime;
#endif
#endif //__CELLOS_LV2__

};

///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
btClock::btClock()
{
 m_data = new btClockData;
#ifdef BT_USE_WINDOWS_TIMERS
 QueryPerformanceFrequency(&m_data->mClockFrequency);
#endif
 reset();
}

btClock::~btClock()
{
 delete m_data;
}

btClock::btClock(const btClock& other)
{
 m_data = new btClockData;
 *m_data = *other.m_data;
}

btClock& btClock::operator=(const btClock& other)
{
 *m_data = *other.m_data;
 return *this;
}


/// Resets the initial reference time.
void btClock::reset()
{
#ifdef BT_USE_WINDOWS_TIMERS
 QueryPerformanceCounter(&m_data->mStartTime);
 m_data->mStartTick = GetTickCount64();
#else
#ifdef __CELLOS_LV2__

 typedef uint64_t  ClockSize;
 ClockSize newTime;
 //__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
 SYS_TIMEBASE_GET(newTime);
 m_data->mStartTime = newTime;
#else
#ifdef __APPLE__
 m_data->mStartTimeNano = mach_absolute_time();
#endif
 gettimeofday(&m_data->mStartTime, 0);
#endif
#endif
}

/// Returns the time in ms since the last call to reset or since
/// the btClock was created.
unsigned long long int btClock::getTimeMilliseconds()
{
#ifdef BT_USE_WINDOWS_TIMERS
 LARGE_INTEGER currentTime;
 QueryPerformanceCounter(&currentTime);
 LONGLONG elapsedTime = currentTime.QuadPart -
  m_data->mStartTime.QuadPart;
 // Compute the number of millisecond ticks elapsed.
 unsigned long msecTicks = (unsigned long)(1000 * elapsedTime /
  m_data->mClockFrequency.QuadPart);

 return msecTicks;
#else

#ifdef __CELLOS_LV2__
 uint64_t freq = sys_time_get_timebase_frequency();
 double dFreq = ((double)freq) / 1000.0;
 typedef uint64_t  ClockSize;
 ClockSize newTime;
 SYS_TIMEBASE_GET(newTime);
 //__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");

 return (unsigned long int)((double(newTime - m_data->mStartTime)) / dFreq);
#else

 struct timeval currentTime;
 gettimeofday(&currentTime, 0);
 return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000 +
  (currentTime.tv_usec - m_data->mStartTime.tv_usec) / 1000;
#endif //__CELLOS_LV2__
#endif
}

/// Returns the time in us since the last call to reset or since
/// the Clock was created.
unsigned long long int btClock::getTimeMicroseconds()
{
#ifdef BT_USE_WINDOWS_TIMERS
 //see https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx	
 LARGE_INTEGER currentTime, elapsedTime;

 QueryPerformanceCounter(&currentTime);
 elapsedTime.QuadPart = currentTime.QuadPart -
  m_data->mStartTime.QuadPart;
 elapsedTime.QuadPart *= 1000000;
 elapsedTime.QuadPart /= m_data->mClockFrequency.QuadPart;

 return (unsigned long long) elapsedTime.QuadPart;
#else

#ifdef __CELLOS_LV2__
 uint64_t freq = sys_time_get_timebase_frequency();
 double dFreq = ((double)freq) / 1000000.0;
 typedef uint64_t  ClockSize;
 ClockSize newTime;
 //__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
 SYS_TIMEBASE_GET(newTime);

 return (unsigned long int)((double(newTime - m_data->mStartTime)) / dFreq);
#else

 struct timeval currentTime;
 gettimeofday(&currentTime, 0);
 return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000000 +
  (currentTime.tv_usec - m_data->mStartTime.tv_usec);
#endif//__CELLOS_LV2__
#endif
}

unsigned long long int btClock::getTimeNanoseconds()
{
#ifdef BT_USE_WINDOWS_TIMERS
 //see https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx
 LARGE_INTEGER currentTime, elapsedTime;

 QueryPerformanceCounter(&currentTime);
 elapsedTime.QuadPart = currentTime.QuadPart -
  m_data->mStartTime.QuadPart;
 elapsedTime.QuadPart *= 1000000000;
 elapsedTime.QuadPart /= m_data->mClockFrequency.QuadPart;

 return (unsigned long long) elapsedTime.QuadPart;
#else

#ifdef __CELLOS_LV2__
 uint64_t freq = sys_time_get_timebase_frequency();
 double dFreq = ((double)freq) / 1e9;
 typedef uint64_t  ClockSize;
 ClockSize newTime;
 //__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
 SYS_TIMEBASE_GET(newTime);

 return (unsigned long int)((double(newTime - m_data->mStartTime)) / dFreq);
#else
#ifdef __APPLE__
 uint64_t ticks = mach_absolute_time() - m_data->mStartTimeNano;
 static long double conversion = 0.0L;
 if (0.0L == conversion)
 {
  // attempt to get conversion to nanoseconds
  mach_timebase_info_data_t info;
  int err = mach_timebase_info(&info);
  if (err)
  {
   btAssert(0);
   conversion = 1.;
  }
  conversion = info.numer / info.denom;
 }
 return (ticks * conversion);


#else//__APPLE__

#ifdef BT_LINUX_REALTIME
 timespec ts;
 clock_gettime(CLOCK_REALTIME, &ts);
 return 1000000000 * ts.tv_sec + ts.tv_nsec;
#else
 struct timeval currentTime;
 gettimeofday(&currentTime, 0);
 return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1e9 +
  (currentTime.tv_usec - m_data->mStartTime.tv_usec) * 1000;
#endif //BT_LINUX_REALTIME

#endif//__APPLE__
#endif//__CELLOS_LV2__
#endif 
}


/// Returns the time in s since the last call to reset or since 
/// the Clock was created.
btScalar btClock::getTimeSeconds()
{
 static const btScalar microseconds_to_seconds = btScalar(0.000001);
 return btScalar(getTimeMicroseconds()) * microseconds_to_seconds;
}

#ifndef BT_NO_PROFILE


static btClock gProfileClock;


inline void Profile_Get_Ticks(unsigned long int * ticks)
{
 *ticks = (unsigned long int)gProfileClock.getTimeMicroseconds();
}

inline float Profile_Get_Tick_Rate(void)
{
 //	return 1000000.f;
 return 1000.f;

}


/***************************************************************************************************
**
** CProfileNode
**
***************************************************************************************************/

/***********************************************************************************************
* INPUT:                                                                                      *
* name - pointer to a static string which is the name of this profile node                    *
* parent - parent pointer                                                                     *
*                                                                                             *
* WARNINGS:                                                                                   *
* The name is assumed to be a static pointer, only the pointer is stored and compared for     *
* efficiency reasons.                                                                         *
*=============================================================================================*/
CProfileNode::CProfileNode(const char * name, CProfileNode * parent) :
 Name(name),
 TotalCalls(0),
 TotalTime(0),
 StartTime(0),
 RecursionCounter(0),
 Parent(parent),
 Child(NULL),
 Sibling(NULL),
 m_userPtr(0)
{
 Reset();
}


void	CProfileNode::CleanupMemory()
{
 delete (Child);
 Child = NULL;
 delete (Sibling);
 Sibling = NULL;
}

CProfileNode::~CProfileNode(void)
{
 CleanupMemory();
}


/***********************************************************************************************
* INPUT:                                                                                      *
* name - static string pointer to the name of the node we are searching for                   *
*                                                                                             *
* WARNINGS:                                                                                   *
* All profile names are assumed to be static strings so this function uses pointer compares   *
* to find the named node.                                                                     *
*=============================================================================================*/
CProfileNode * CProfileNode::Get_Sub_Node(const char * name)
{
 // Try to find this sub node
 CProfileNode * child = Child;
 while (child) {
  if (child->Name == name) {
   return child;
  }
  child = child->Sibling;
 }

 // We didn't find it, so add it

 CProfileNode * node = new CProfileNode(name, this);
 node->Sibling = Child;
 Child = node;
 return node;
}


void	CProfileNode::Reset(void)
{
 TotalCalls = 0;
 TotalTime = 0.0f;


 if (Child) {
  Child->Reset();
 }
 if (Sibling) {
  Sibling->Reset();
 }
}


void	CProfileNode::Call(void)
{
 TotalCalls++;
 if (RecursionCounter++ == 0) {
  Profile_Get_Ticks(&StartTime);
 }
}


bool	CProfileNode::Return(void)
{
 if (--RecursionCounter == 0 && TotalCalls != 0) {
  unsigned long int time;
  Profile_Get_Ticks(&time);

  time -= StartTime;
  TotalTime += (float)time / Profile_Get_Tick_Rate();
 }
 return (RecursionCounter == 0);
}


/***************************************************************************************************
**
** CProfileIterator
**
***************************************************************************************************/
CProfileIterator::CProfileIterator(CProfileNode * start)
{
 CurrentParent = start;
 CurrentChild = CurrentParent->Get_Child();
}


void	CProfileIterator::First(void)
{
 CurrentChild = CurrentParent->Get_Child();
}


void	CProfileIterator::Next(void)
{
 CurrentChild = CurrentChild->Get_Sibling();
}


bool	CProfileIterator::Is_Done(void)
{
 return CurrentChild == NULL;
}


void	CProfileIterator::Enter_Child(int index)
{
 CurrentChild = CurrentParent->Get_Child();
 while ((CurrentChild != NULL) && (index != 0)) {
  index--;
  CurrentChild = CurrentChild->Get_Sibling();
 }

 if (CurrentChild != NULL) {
  CurrentParent = CurrentChild;
  CurrentChild = CurrentParent->Get_Child();
 }
}


void	CProfileIterator::Enter_Parent(void)
{
 if (CurrentParent->Get_Parent() != NULL) {
  CurrentParent = CurrentParent->Get_Parent();
 }
 CurrentChild = CurrentParent->Get_Child();
}


/***************************************************************************************************
**
** CProfileManager
**
***************************************************************************************************/




CProfileNode	gRoots[BT_QUICKPROF_MAX_THREAD_COUNT] = {
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),
 CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL),CProfileNode("Root",NULL)
};


CProfileNode* gCurrentNodes[BT_QUICKPROF_MAX_THREAD_COUNT] =
{
 &gRoots[0],	&gRoots[1],	&gRoots[2],	&gRoots[3],
 &gRoots[4],	&gRoots[5],	&gRoots[6],	&gRoots[7],
 &gRoots[8],	&gRoots[9],	&gRoots[10],	&gRoots[11],
 &gRoots[12],	&gRoots[13],	&gRoots[14],	&gRoots[15],
 &gRoots[16],	&gRoots[17],	&gRoots[18],	&gRoots[19],
 &gRoots[20],	&gRoots[21],	&gRoots[22],	&gRoots[23],
 &gRoots[24],	&gRoots[25],	&gRoots[26],	&gRoots[27],
 &gRoots[28],	&gRoots[29],	&gRoots[30],	&gRoots[31],
 &gRoots[32],	&gRoots[33],	&gRoots[34],	&gRoots[35],
 &gRoots[36],	&gRoots[37],	&gRoots[38],	&gRoots[39],
 &gRoots[40],	&gRoots[41],	&gRoots[42],	&gRoots[43],
 &gRoots[44],	&gRoots[45],	&gRoots[46],	&gRoots[47],
 &gRoots[48],	&gRoots[49],	&gRoots[50],	&gRoots[51],
 &gRoots[52],	&gRoots[53],	&gRoots[54],	&gRoots[55],
 &gRoots[56],	&gRoots[57],	&gRoots[58],	&gRoots[59],
 &gRoots[60],	&gRoots[61],	&gRoots[62],	&gRoots[63],
};


int				CProfileManager::FrameCounter = 0;
unsigned long int			CProfileManager::ResetTime = 0;

CProfileIterator *	CProfileManager::Get_Iterator(void)
{

 int threadIndex = btQuickprofGetCurrentThreadIndex2();
 if ((threadIndex<0) || threadIndex >= BT_QUICKPROF_MAX_THREAD_COUNT)
  return 0;

 return new CProfileIterator(&gRoots[threadIndex]);
}

void						CProfileManager::CleanupMemory(void)
{
 for (int i = 0; i<BT_QUICKPROF_MAX_THREAD_COUNT; i++)
 {
  gRoots[i].CleanupMemory();
 }
}


/***********************************************************************************************
* CProfileManager::Start_Profile -- Begin a named profile                                    *
*                                                                                             *
* Steps one level deeper into the tree, if a child already exists with the specified name     *
* then it accumulates the profiling; otherwise a new child node is added to the profile tree. *
*                                                                                             *
* INPUT:                                                                                      *
* name - name of this profiling record                                                        *
*                                                                                             *
* WARNINGS:                                                                                   *
* The string used is assumed to be a static string; pointer compares are used throughout      *
* the profiling code for efficiency.                                                          *
*=============================================================================================*/
void	CProfileManager::Start_Profile(const char * name)
{
 int threadIndex = btQuickprofGetCurrentThreadIndex2();
 if ((threadIndex<0) || threadIndex >= BT_QUICKPROF_MAX_THREAD_COUNT)
  return;

 if (name != gCurrentNodes[threadIndex]->Get_Name()) {
  gCurrentNodes[threadIndex] = gCurrentNodes[threadIndex]->Get_Sub_Node(name);
 }

 gCurrentNodes[threadIndex]->Call();
}


/***********************************************************************************************
* CProfileManager::Stop_Profile -- Stop timing and record the results.                       *
*=============================================================================================*/
void	CProfileManager::Stop_Profile(void)
{
 int threadIndex = btQuickprofGetCurrentThreadIndex2();
 if ((threadIndex<0) || threadIndex >= BT_QUICKPROF_MAX_THREAD_COUNT)
  return;

 // Return will indicate whether we should back up to our parent (we may
 // be profiling a recursive function)
 if (gCurrentNodes[threadIndex]->Return()) {
  gCurrentNodes[threadIndex] = gCurrentNodes[threadIndex]->Get_Parent();
 }
}






/***********************************************************************************************
* CProfileManager::Reset -- Reset the contents of the profiling system                       *
*                                                                                             *
*    This resets everything except for the tree structure.  All of the timing data is reset.  *
*=============================================================================================*/
void	CProfileManager::Reset(void)
{
 gProfileClock.reset();
 int threadIndex = btQuickprofGetCurrentThreadIndex2();
 if ((threadIndex<0) || threadIndex >= BT_QUICKPROF_MAX_THREAD_COUNT)
  return;
 gRoots[threadIndex].Reset();
 gRoots[threadIndex].Call();
 FrameCounter = 0;
 Profile_Get_Ticks(&ResetTime);
}


/***********************************************************************************************
* CProfileManager::Increment_Frame_Counter -- Increment the frame counter                    *
*=============================================================================================*/
void CProfileManager::Increment_Frame_Counter(void)
{
 FrameCounter++;
}


/***********************************************************************************************
* CProfileManager::Get_Time_Since_Reset -- returns the elapsed time since last reset         *
*=============================================================================================*/
float CProfileManager::Get_Time_Since_Reset(void)
{
 unsigned long int time;
 Profile_Get_Ticks(&time);
 time -= ResetTime;
 return (float)time / Profile_Get_Tick_Rate();
}

#include <stdio.h>

void	CProfileManager::dumpRecursive(CProfileIterator* profileIterator, int spacing)
{
 profileIterator->First();
 if (profileIterator->Is_Done())
  return;

 float accumulated_time = 0, parent_time = profileIterator->Is_Root() ? CProfileManager::Get_Time_Since_Reset() : profileIterator->Get_Current_Parent_Total_Time();
 int i;
 int frames_since_reset = CProfileManager::Get_Frame_Count_Since_Reset();
 for (i = 0; i<spacing; i++)	printf(".");
 printf("----------------------------------\n");
 for (i = 0; i<spacing; i++)	printf(".");
 printf("Profiling: %s (total running time: %.3f ms) ---\n", profileIterator->Get_Current_Parent_Name(), parent_time);
 float totalTime = 0.f;


 int numChildren = 0;

 for (i = 0; !profileIterator->Is_Done(); i++, profileIterator->Next())
 {
  numChildren++;
  float current_total_time = profileIterator->Get_Current_Total_Time();
  accumulated_time += current_total_time;
  float fraction = parent_time > SIMD_EPSILON ? (current_total_time / parent_time) * 100 : 0.f;
  {
   int i;	for (i = 0; i<spacing; i++)	printf(".");
  }
  printf("%d -- %s (%.2f %%) :: %.3f ms / frame (%d calls)\n", i, profileIterator->Get_Current_Name(), fraction, (current_total_time / (double)frames_since_reset), profileIterator->Get_Current_Total_Calls());
  totalTime += current_total_time;
  //recurse into children
 }

 if (parent_time < accumulated_time)
 {
  //printf("what's wrong\n");
 }
 for (i = 0; i<spacing; i++)	printf(".");
 printf("%s (%.3f %%) :: %.3f ms\n", "Unaccounted:", parent_time > SIMD_EPSILON ? ((parent_time - accumulated_time) / parent_time) * 100 : 0.f, parent_time - accumulated_time);

 for (i = 0; i<numChildren; i++)
 {
  profileIterator->Enter_Child(i);
  dumpRecursive(profileIterator, spacing + 3);
  profileIterator->Enter_Parent();
 }
}



void	CProfileManager::dumpAll()
{
 CProfileIterator* profileIterator = 0;
 profileIterator = CProfileManager::Get_Iterator();

 dumpRecursive(profileIterator, 0);

 CProfileManager::Release_Iterator(profileIterator);
}




unsigned int btQuickprofGetCurrentThreadIndex2()
{
#if BT_THREADSAFE
 return btGetCurrentThreadIndex();
#else // #if BT_THREADSAFE
 const unsigned int kNullIndex = ~0U;
#ifdef _WIN32
#if defined(__MINGW32__) || defined(__MINGW64__)
 static __thread unsigned int sThreadIndex = kNullIndex;
#else
 __declspec(thread) static unsigned int sThreadIndex = kNullIndex;
#endif
#else
#ifdef __APPLE__
#if TARGET_OS_IPHONE
 unsigned int sThreadIndex = 0;
 return -1;
#else
 static __thread unsigned int sThreadIndex = kNullIndex;
#endif
#else//__APPLE__
#if __linux__
 static __thread unsigned int sThreadIndex = kNullIndex;
#else
 unsigned int sThreadIndex = 0;
 return -1;
#endif
#endif//__APPLE__

#endif
 static int gThreadCounter = 0;

 if (sThreadIndex == kNullIndex)
 {
  sThreadIndex = gThreadCounter++;
 }
 return sThreadIndex;
#endif // #else // #if BT_THREADSAFE
}

void	btEnterProfileZoneDefault(const char* name)
{
 CProfileManager::Start_Profile(name);
}
void	btLeaveProfileZoneDefault()
{
 CProfileManager::Stop_Profile();
}


#else
void	btEnterProfileZoneDefault(const char* name)
{
}
void	btLeaveProfileZoneDefault()
{
}
#endif //BT_NO_PROFILE





static btEnterProfileZoneFunc* bts_enterFunc = btEnterProfileZoneDefault;
static btLeaveProfileZoneFunc* bts_leaveFunc = btLeaveProfileZoneDefault;

void btEnterProfileZone(const char* name)
{
 (bts_enterFunc)(name);
}
void btLeaveProfileZone()
{
 (bts_leaveFunc)();
}

btEnterProfileZoneFunc* btGetCurrentEnterProfileZoneFunc()
{
 return bts_enterFunc;
}
btLeaveProfileZoneFunc* btGetCurrentLeaveProfileZoneFunc()
{
 return bts_leaveFunc;
}


void btSetCustomEnterProfileZoneFunc(btEnterProfileZoneFunc* enterFunc)
{
 bts_enterFunc = enterFunc;
}
void btSetCustomLeaveProfileZoneFunc(btLeaveProfileZoneFunc* leaveFunc)
{
 bts_leaveFunc = leaveFunc;
}

CProfileSample::CProfileSample(const char * name)
{
 btEnterProfileZone(name);
}

CProfileSample::~CProfileSample(void)
{
 btLeaveProfileZone();
}

char sBulletDNAstr[] = {
 char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-124),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
 char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
 char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
 char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
 char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
 char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
 char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
 char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
 char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
 char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
 char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
 char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
 char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
 char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
 char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
 char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
 char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
 char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
 char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
 char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
 char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
 char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
 char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
 char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
 char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
 char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
 char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
 char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
 char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
 char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
 char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
 char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
 char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
 char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
 char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
 char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
 char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
 char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
 char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
 char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
 char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
 char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
 char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
 char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
 char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
 char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
 char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
 char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
 char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
 char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
 char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
 char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
 char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
 char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
 char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
 char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
 char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
 char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
 char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
 char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
 char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
 char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(103),char(105),char(109),char(112),char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),
 char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),
 char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),
 char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),
 char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),
 char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),
 char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),
 char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),
 char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),char(101),char(115),char(115),char(105),char(110),char(103),char(84),
 char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),
 char(105),char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),
 char(95),char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),
 char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),
 char(97),char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),
 char(116),char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),
 char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),
 char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
 char(110),char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),
 char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),
 char(118),char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),
 char(110),char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),
 char(100),char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),
 char(110),char(103),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),
 char(114),char(114),char(111),char(114),char(82),char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),
 char(109),char(95),char(101),char(114),char(112),char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),
 char(108),char(67),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),
 char(101),char(110),char(101),char(116),char(114),char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),
 char(112),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),
 char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(97),
 char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(115),
 char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),
 char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(117),char(109),char(73),
 char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(77),char(111),
 char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(82),
 char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(66),char(97),char(116),char(99),char(104),
 char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),
 char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),
 char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),
 char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(84),char(101),char(110),
 char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),
 char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),
 char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),
 char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(103),char(114),char(97),
 char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
 char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),char(97),char(108),char(0),char(109),char(95),char(116),char(111),
 char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(84),char(111),char(114),char(113),
 char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(108),
 char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
 char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),
 char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(100),
 char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),
 char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
 char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),
 char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),
 char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),
 char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
 char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(82),char(111),char(119),char(115),char(0),char(110),
 char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),char(114),char(98),char(66),char(0),char(109),char(95),char(111),
 char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),
 char(116),char(114),char(97),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),
 char(100),char(98),char(97),char(99),char(107),char(0),char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),
 char(115),char(101),char(0),char(109),char(95),char(100),char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),
 char(105),char(115),char(97),char(98),char(108),char(101),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),
 char(101),char(101),char(110),char(76),char(105),char(110),char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),
 char(101),char(114),char(114),char(105),char(100),char(101),char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),
 char(108),char(115),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),
 char(98),char(108),char(101),char(100),char(0),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),
 char(112),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),
 char(105),char(118),char(111),char(116),char(73),char(110),char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),
 char(95),char(114),char(98),char(65),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),
 char(0),char(109),char(95),char(117),char(115),char(101),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
 char(65),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),
 char(97),char(98),char(108),char(101),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),
 char(111),char(116),char(111),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),
 char(95),char(109),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),
 char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),
 char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),
 char(95),char(98),char(105),char(97),char(115),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),
 char(116),char(105),char(111),char(110),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),
 char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),
 char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),
 char(97),char(110),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),
 char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(117),char(115),char(101),char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),
 char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),
 char(111),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),
 char(54),char(100),char(111),char(102),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),
 char(98),char(108),char(101),char(100),char(91),char(54),char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),
 char(109),char(80),char(111),char(105),char(110),char(116),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),
 char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),
 char(97),char(109),char(112),char(105),char(110),char(103),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),
 char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),
 char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
 char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),
 char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
 char(97),char(114),char(77),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),
 char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),
 char(109),char(80),char(111),char(105),char(110),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),
 char(101),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
 char(114),char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),
 char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),
 char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
 char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),
 char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),
 char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),
 char(117),char(108),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),
 char(111),char(116),char(111),char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),
 char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),
 char(117),char(108),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),
 char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),
 char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),
 char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),
 char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),
 char(108),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),
 char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),
 char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),
 char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),
 char(100),char(101),char(114),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),
 char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),
 char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
 char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),
 char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),
 char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),
 char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),
 char(109),char(95),char(97),char(99),char(99),char(117),char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),
 char(95),char(110),char(111),char(114),char(109),char(97),char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),
 char(97),char(99),char(104),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),
 char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),
 char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),
 char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),
 char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),
 char(114),char(101),char(115),char(116),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),
 char(0),char(109),char(95),char(99),char(48),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),
 char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
 char(100),char(101),char(120),char(0),char(109),char(95),char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),
 char(117),char(109),char(103),char(97),char(114),char(116),char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),
 char(116),char(0),char(109),char(95),char(112),char(114),char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),
 char(101),char(0),char(109),char(95),char(100),char(121),char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(112),char(111),char(115),char(101),char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),
 char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),
 char(101),char(116),char(105),char(99),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
 char(109),char(95),char(115),char(111),char(102),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),
 char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),
 char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
 char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
 char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),
 char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),
 char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),
 char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),
 char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),
 char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),
 char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
 char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(100),char(114),char(105),char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),
 char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),
 char(95),char(114),char(111),char(116),char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),
 char(95),char(99),char(111),char(109),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),
 char(95),char(119),char(101),char(105),char(103),char(104),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),
 char(111),char(110),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),
 char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),
 char(109),char(101),char(120),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),
 char(118),char(119),char(105),char(0),char(109),char(95),char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),
 char(95),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),
 char(95),char(97),char(118),char(0),char(42),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),
 char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),
 char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(78),char(111),char(100),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),
 char(109),char(95),char(105),char(100),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),
 char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),
 char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),
 char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),
 char(116),char(99),char(104),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),
 char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),
 char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),
 char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),
 char(95),char(99),char(111),char(108),char(108),char(105),char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),
 char(100),char(101),char(120),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),
 char(66),char(0),char(109),char(95),char(114),char(101),char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),
 char(115),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),
 char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),
 char(121),char(112),char(101),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),
 char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),
 char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),
 char(109),char(95),char(108),char(105),char(110),char(107),char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),
 char(116),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),
 char(115),char(0),char(42),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),
 char(110),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(76),char(105),char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),
 char(0),char(109),char(95),char(110),char(117),char(109),char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),
 char(117),char(109),char(65),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),
 char(101),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),
 char(110),char(102),char(105),char(103),char(0),char(109),char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),
 char(84),char(111),char(84),char(104),char(105),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),
 char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),
 char(80),char(105),char(118),char(111),char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),
 char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),
 char(95),char(106),char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),
 char(109),char(95),char(108),char(105),char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(108),char(105),char(110),char(107),
 char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),char(67),char(111),
 char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),char(109),char(95),
 char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),
 char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),char(109),char(112),
 char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
 char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(106),char(111),
 char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(77),
 char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),char(78),char(97),
 char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(108),
 char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),char(100),char(105),
 char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(73),char(110),char(101),char(114),char(116),char(105),char(97),
 char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(78),
 char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),
 char(84),char(89),char(80),char(69),char(95),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
 char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
 char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
 char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
 char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
 char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
 char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
 char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
 char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
 char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
 char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
 char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
 char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
 char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
 char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
 char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
 char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
 char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
 char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
 char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
 char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
 char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(71),char(73),char(109),char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),
 char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),
 char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),char(111),
 char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),
 char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(70),
 char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),
 char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
 char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),char(114),
 char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),
 char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),char(112),
 char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),
 char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),
 char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),
 char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
 char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),
 char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
 char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),
 char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),
 char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
 char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
 char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(50),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),
 char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
 char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),char(114),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),
 char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),char(114),
 char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),char(101),
 char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),char(83),
 char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
 char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
 char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),
 char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),
 char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),char(66),
 char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),char(66),
 char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
 char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),char(111),
 char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),
 char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),char(12),char(0),char(36),char(0),char(8),char(0),char(16),char(0),
 char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),
 char(16),char(0),char(84),char(0),char(-124),char(0),char(12),char(0),char(52),char(0),char(52),char(0),char(20),char(0),char(64),char(0),char(4),char(0),char(4),char(0),
 char(8),char(0),char(4),char(0),char(32),char(0),char(28),char(0),char(60),char(0),char(56),char(0),char(76),char(0),char(76),char(0),char(24),char(0),char(60),char(0),
 char(60),char(0),char(60),char(0),char(16),char(0),char(64),char(0),char(68),char(0),char(-32),char(1),char(8),char(1),char(-104),char(0),char(88),char(0),char(-72),char(0),
 char(104),char(0),char(-16),char(1),char(-80),char(3),char(8),char(0),char(52),char(0),char(52),char(0),char(0),char(0),char(68),char(0),char(84),char(0),char(-124),char(0),
 char(116),char(0),char(92),char(1),char(-36),char(0),char(-116),char(1),char(124),char(1),char(-44),char(0),char(-4),char(0),char(-52),char(1),char(92),char(1),char(116),char(2),
 char(-124),char(2),char(-76),char(4),char(-52),char(0),char(108),char(1),char(92),char(0),char(-116),char(0),char(16),char(0),char(100),char(0),char(20),char(0),char(36),char(0),
 char(100),char(0),char(92),char(0),char(104),char(0),char(-64),char(0),char(92),char(1),char(104),char(0),char(-76),char(1),char(-16),char(2),char(-120),char(1),char(-64),char(0),
 char(100),char(0),char(0),char(0),char(83),char(84),char(82),char(67),char(84),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),
 char(4),char(0),char(1),char(0),char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),
 char(10),char(0),char(5),char(0),char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),
 char(7),char(0),char(8),char(0),char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
 char(16),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),
 char(14),char(0),char(9),char(0),char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),
 char(18),char(0),char(10),char(0),char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),
 char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),
 char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),
 char(14),char(0),char(16),char(0),char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),
 char(0),char(0),char(21),char(0),char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),
 char(25),char(0),char(12),char(0),char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),
 char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),
 char(21),char(0),char(32),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),
 char(14),char(0),char(24),char(0),char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),
 char(4),char(0),char(29),char(0),char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),
 char(21),char(0),char(32),char(0),char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),
 char(28),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),
 char(0),char(0),char(21),char(0),char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),
 char(7),char(0),char(43),char(0),char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),
 char(31),char(0),char(4),char(0),char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),
 char(32),char(0),char(1),char(0),char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),
 char(34),char(0),char(2),char(0),char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),
 char(0),char(0),char(53),char(0),char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),
 char(34),char(0),char(57),char(0),char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),
 char(37),char(0),char(4),char(0),char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),
 char(38),char(0),char(7),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),
 char(39),char(0),char(68),char(0),char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),
 char(13),char(0),char(39),char(0),char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),
 char(7),char(0),char(74),char(0),char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),
 char(7),char(0),char(43),char(0),char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),
 char(44),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),
 char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),
 char(7),char(0),char(80),char(0),char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),
 char(4),char(0),char(84),char(0),char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),
 char(7),char(0),char(89),char(0),char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),
 char(4),char(0),char(94),char(0),char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(5),char(0),char(27),char(0),char(38),char(0),
 char(37),char(0),char(65),char(0),char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(96),char(0),char(48),char(0),char(5),char(0),
 char(29),char(0),char(47),char(0),char(13),char(0),char(97),char(0),char(14),char(0),char(98),char(0),char(4),char(0),char(99),char(0),char(0),char(0),char(100),char(0),
 char(49),char(0),char(27),char(0),char(9),char(0),char(101),char(0),char(9),char(0),char(102),char(0),char(27),char(0),char(103),char(0),char(0),char(0),char(35),char(0),
 char(20),char(0),char(104),char(0),char(20),char(0),char(105),char(0),char(14),char(0),char(106),char(0),char(14),char(0),char(107),char(0),char(14),char(0),char(108),char(0),
 char(8),char(0),char(109),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(111),char(0),char(8),char(0),char(112),char(0),char(8),char(0),char(113),char(0),
 char(8),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),char(8),char(0),char(118),char(0),
 char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),char(4),char(0),char(123),char(0),
 char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(0),char(0),char(37),char(0),char(50),char(0),char(27),char(0),char(9),char(0),char(101),char(0),
 char(9),char(0),char(102),char(0),char(27),char(0),char(103),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(104),char(0),char(19),char(0),char(105),char(0),
 char(13),char(0),char(106),char(0),char(13),char(0),char(107),char(0),char(13),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(7),char(0),char(110),char(0),
 char(7),char(0),char(111),char(0),char(7),char(0),char(112),char(0),char(7),char(0),char(113),char(0),char(7),char(0),char(114),char(0),char(7),char(0),char(115),char(0),
 char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),char(7),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),
 char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),char(4),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),
 char(0),char(0),char(37),char(0),char(51),char(0),char(22),char(0),char(8),char(0),char(126),char(0),char(8),char(0),char(127),char(0),char(8),char(0),char(111),char(0),
 char(8),char(0),char(-128),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),
 char(8),char(0),char(-124),char(0),char(8),char(0),char(-123),char(0),char(8),char(0),char(-122),char(0),char(8),char(0),char(-121),char(0),char(8),char(0),char(-120),char(0),
 char(8),char(0),char(-119),char(0),char(8),char(0),char(-118),char(0),char(8),char(0),char(-117),char(0),char(4),char(0),char(-116),char(0),char(4),char(0),char(-115),char(0),
 char(4),char(0),char(-114),char(0),char(4),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(52),char(0),char(22),char(0),
 char(7),char(0),char(126),char(0),char(7),char(0),char(127),char(0),char(7),char(0),char(111),char(0),char(7),char(0),char(-128),char(0),char(7),char(0),char(115),char(0),
 char(7),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(7),char(0),char(-124),char(0),char(7),char(0),char(-123),char(0),
 char(7),char(0),char(-122),char(0),char(7),char(0),char(-121),char(0),char(7),char(0),char(-120),char(0),char(7),char(0),char(-119),char(0),char(7),char(0),char(-118),char(0),
 char(7),char(0),char(-117),char(0),char(4),char(0),char(-116),char(0),char(4),char(0),char(-115),char(0),char(4),char(0),char(-114),char(0),char(4),char(0),char(-113),char(0),
 char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(53),char(0),char(2),char(0),char(51),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),
 char(54),char(0),char(2),char(0),char(52),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(55),char(0),char(21),char(0),char(50),char(0),char(-109),char(0),
 char(17),char(0),char(-108),char(0),char(13),char(0),char(-107),char(0),char(13),char(0),char(-106),char(0),char(13),char(0),char(-105),char(0),char(13),char(0),char(-104),char(0),
 char(13),char(0),char(-110),char(0),char(13),char(0),char(-103),char(0),char(13),char(0),char(-102),char(0),char(13),char(0),char(-101),char(0),char(13),char(0),char(-100),char(0),
 char(7),char(0),char(-99),char(0),char(7),char(0),char(-98),char(0),char(7),char(0),char(-97),char(0),char(7),char(0),char(-96),char(0),char(7),char(0),char(-95),char(0),
 char(7),char(0),char(-94),char(0),char(7),char(0),char(-93),char(0),char(7),char(0),char(-92),char(0),char(7),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),
 char(56),char(0),char(22),char(0),char(49),char(0),char(-109),char(0),char(18),char(0),char(-108),char(0),char(14),char(0),char(-107),char(0),char(14),char(0),char(-106),char(0),
 char(14),char(0),char(-105),char(0),char(14),char(0),char(-104),char(0),char(14),char(0),char(-110),char(0),char(14),char(0),char(-103),char(0),char(14),char(0),char(-102),char(0),
 char(14),char(0),char(-101),char(0),char(14),char(0),char(-100),char(0),char(8),char(0),char(-99),char(0),char(8),char(0),char(-98),char(0),char(8),char(0),char(-97),char(0),
 char(8),char(0),char(-96),char(0),char(8),char(0),char(-95),char(0),char(8),char(0),char(-94),char(0),char(8),char(0),char(-93),char(0),char(8),char(0),char(-92),char(0),
 char(8),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),char(0),char(0),char(37),char(0),char(57),char(0),char(2),char(0),char(4),char(0),char(-89),char(0),
 char(4),char(0),char(-88),char(0),char(58),char(0),char(13),char(0),char(55),char(0),char(-87),char(0),char(55),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),
 char(4),char(0),char(-85),char(0),char(4),char(0),char(-84),char(0),char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),
 char(7),char(0),char(-80),char(0),char(4),char(0),char(-79),char(0),char(4),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),
 char(59),char(0),char(13),char(0),char(60),char(0),char(-87),char(0),char(60),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-85),char(0),
 char(4),char(0),char(-84),char(0),char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),
 char(4),char(0),char(-79),char(0),char(4),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),char(61),char(0),char(14),char(0),
 char(56),char(0),char(-87),char(0),char(56),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-85),char(0),char(4),char(0),char(-84),char(0),
 char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(4),char(0),char(-79),char(0),
 char(4),char(0),char(-78),char(0),char(8),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),char(0),char(0),char(-75),char(0),char(62),char(0),char(3),char(0),
 char(59),char(0),char(-74),char(0),char(13),char(0),char(-73),char(0),char(13),char(0),char(-72),char(0),char(63),char(0),char(3),char(0),char(61),char(0),char(-74),char(0),
 char(14),char(0),char(-73),char(0),char(14),char(0),char(-72),char(0),char(64),char(0),char(3),char(0),char(59),char(0),char(-74),char(0),char(14),char(0),char(-73),char(0),
 char(14),char(0),char(-72),char(0),char(65),char(0),char(13),char(0),char(59),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),
 char(4),char(0),char(-69),char(0),char(4),char(0),char(-68),char(0),char(4),char(0),char(-67),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(-65),char(0),
 char(7),char(0),char(-64),char(0),char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),
 char(66),char(0),char(13),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(4),char(0),char(-69),char(0),
 char(4),char(0),char(-68),char(0),char(4),char(0),char(-67),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(-65),char(0),char(7),char(0),char(-64),char(0),
 char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),char(67),char(0),char(14),char(0),
 char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(4),char(0),char(-69),char(0),char(4),char(0),char(-68),char(0),
 char(4),char(0),char(-67),char(0),char(8),char(0),char(-66),char(0),char(8),char(0),char(-65),char(0),char(8),char(0),char(-64),char(0),char(8),char(0),char(-63),char(0),
 char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),char(8),char(0),char(-60),char(0),char(0),char(0),char(-59),char(0),char(68),char(0),char(10),char(0),
 char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),
 char(8),char(0),char(-56),char(0),char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),char(8),char(0),char(-60),char(0),char(8),char(0),char(127),char(0),
 char(69),char(0),char(11),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(7),char(0),char(-58),char(0),
 char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),
 char(7),char(0),char(127),char(0),char(0),char(0),char(21),char(0),char(70),char(0),char(9),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),
 char(19),char(0),char(-70),char(0),char(13),char(0),char(-55),char(0),char(13),char(0),char(-54),char(0),char(13),char(0),char(-53),char(0),char(13),char(0),char(-52),char(0),
 char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(71),char(0),char(9),char(0),char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),
 char(20),char(0),char(-70),char(0),char(14),char(0),char(-55),char(0),char(14),char(0),char(-54),char(0),char(14),char(0),char(-53),char(0),char(14),char(0),char(-52),char(0),
 char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(72),char(0),char(5),char(0),char(70),char(0),char(-49),char(0),char(4),char(0),char(-48),char(0),
 char(7),char(0),char(-47),char(0),char(7),char(0),char(-46),char(0),char(7),char(0),char(-45),char(0),char(73),char(0),char(5),char(0),char(71),char(0),char(-49),char(0),
 char(4),char(0),char(-48),char(0),char(8),char(0),char(-47),char(0),char(8),char(0),char(-46),char(0),char(8),char(0),char(-45),char(0),char(74),char(0),char(41),char(0),
 char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(13),char(0),char(-55),char(0),char(13),char(0),char(-54),char(0),
 char(13),char(0),char(-44),char(0),char(13),char(0),char(-43),char(0),char(13),char(0),char(-42),char(0),char(13),char(0),char(-41),char(0),char(13),char(0),char(-40),char(0),
 char(13),char(0),char(-39),char(0),char(13),char(0),char(-38),char(0),char(13),char(0),char(-37),char(0),char(13),char(0),char(-36),char(0),char(13),char(0),char(-35),char(0),
 char(13),char(0),char(-34),char(0),char(0),char(0),char(-33),char(0),char(0),char(0),char(-32),char(0),char(0),char(0),char(-31),char(0),char(0),char(0),char(-30),char(0),
 char(0),char(0),char(-29),char(0),char(0),char(0),char(-59),char(0),char(13),char(0),char(-53),char(0),char(13),char(0),char(-52),char(0),char(13),char(0),char(-28),char(0),
 char(13),char(0),char(-27),char(0),char(13),char(0),char(-26),char(0),char(13),char(0),char(-25),char(0),char(13),char(0),char(-24),char(0),char(13),char(0),char(-23),char(0),
 char(13),char(0),char(-22),char(0),char(13),char(0),char(-21),char(0),char(13),char(0),char(-20),char(0),char(13),char(0),char(-19),char(0),char(13),char(0),char(-18),char(0),
 char(0),char(0),char(-17),char(0),char(0),char(0),char(-16),char(0),char(0),char(0),char(-15),char(0),char(0),char(0),char(-14),char(0),char(0),char(0),char(-13),char(0),
 char(4),char(0),char(-12),char(0),char(75),char(0),char(41),char(0),char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),
 char(14),char(0),char(-55),char(0),char(14),char(0),char(-54),char(0),char(14),char(0),char(-44),char(0),char(14),char(0),char(-43),char(0),char(14),char(0),char(-42),char(0),
 char(14),char(0),char(-41),char(0),char(14),char(0),char(-40),char(0),char(14),char(0),char(-39),char(0),char(14),char(0),char(-38),char(0),char(14),char(0),char(-37),char(0),
 char(14),char(0),char(-36),char(0),char(14),char(0),char(-35),char(0),char(14),char(0),char(-34),char(0),char(0),char(0),char(-33),char(0),char(0),char(0),char(-32),char(0),
 char(0),char(0),char(-31),char(0),char(0),char(0),char(-30),char(0),char(0),char(0),char(-29),char(0),char(0),char(0),char(-59),char(0),char(14),char(0),char(-53),char(0),
 char(14),char(0),char(-52),char(0),char(14),char(0),char(-28),char(0),char(14),char(0),char(-27),char(0),char(14),char(0),char(-26),char(0),char(14),char(0),char(-25),char(0),
 char(14),char(0),char(-24),char(0),char(14),char(0),char(-23),char(0),char(14),char(0),char(-22),char(0),char(14),char(0),char(-21),char(0),char(14),char(0),char(-20),char(0),
 char(14),char(0),char(-19),char(0),char(14),char(0),char(-18),char(0),char(0),char(0),char(-17),char(0),char(0),char(0),char(-16),char(0),char(0),char(0),char(-15),char(0),
 char(0),char(0),char(-14),char(0),char(0),char(0),char(-13),char(0),char(4),char(0),char(-12),char(0),char(76),char(0),char(9),char(0),char(59),char(0),char(-74),char(0),
 char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
 char(7),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(77),char(0),char(9),char(0),char(61),char(0),char(-74),char(0),
 char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(8),char(0),char(-55),char(0),char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),
 char(8),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(78),char(0),char(5),char(0),char(58),char(0),char(-74),char(0),
 char(13),char(0),char(-11),char(0),char(13),char(0),char(-10),char(0),char(7),char(0),char(-9),char(0),char(0),char(0),char(37),char(0),char(79),char(0),char(4),char(0),
 char(61),char(0),char(-74),char(0),char(14),char(0),char(-11),char(0),char(14),char(0),char(-10),char(0),char(8),char(0),char(-9),char(0),char(80),char(0),char(4),char(0),
 char(7),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),char(7),char(0),char(-6),char(0),char(4),char(0),char(79),char(0),char(81),char(0),char(10),char(0),
 char(80),char(0),char(-5),char(0),char(13),char(0),char(-4),char(0),char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),
 char(13),char(0),char(0),char(1),char(7),char(0),char(-99),char(0),char(7),char(0),char(1),char(1),char(4),char(0),char(2),char(1),char(4),char(0),char(53),char(0),
 char(82),char(0),char(4),char(0),char(80),char(0),char(-5),char(0),char(4),char(0),char(3),char(1),char(7),char(0),char(4),char(1),char(4),char(0),char(5),char(1),
 char(83),char(0),char(4),char(0),char(13),char(0),char(0),char(1),char(80),char(0),char(-5),char(0),char(4),char(0),char(6),char(1),char(7),char(0),char(7),char(1),
 char(84),char(0),char(7),char(0),char(13),char(0),char(8),char(1),char(80),char(0),char(-5),char(0),char(4),char(0),char(9),char(1),char(7),char(0),char(10),char(1),
 char(7),char(0),char(11),char(1),char(7),char(0),char(12),char(1),char(4),char(0),char(53),char(0),char(85),char(0),char(6),char(0),char(17),char(0),char(13),char(1),
 char(13),char(0),char(11),char(1),char(13),char(0),char(14),char(1),char(60),char(0),char(15),char(1),char(4),char(0),char(16),char(1),char(7),char(0),char(12),char(1),
 char(86),char(0),char(26),char(0),char(4),char(0),char(17),char(1),char(7),char(0),char(18),char(1),char(7),char(0),char(127),char(0),char(7),char(0),char(19),char(1),
 char(7),char(0),char(20),char(1),char(7),char(0),char(21),char(1),char(7),char(0),char(22),char(1),char(7),char(0),char(23),char(1),char(7),char(0),char(24),char(1),
 char(7),char(0),char(25),char(1),char(7),char(0),char(26),char(1),char(7),char(0),char(27),char(1),char(7),char(0),char(28),char(1),char(7),char(0),char(29),char(1),
 char(7),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(7),char(0),char(32),char(1),char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),
 char(7),char(0),char(35),char(1),char(7),char(0),char(36),char(1),char(4),char(0),char(37),char(1),char(4),char(0),char(38),char(1),char(4),char(0),char(39),char(1),
 char(4),char(0),char(40),char(1),char(4),char(0),char(120),char(0),char(87),char(0),char(12),char(0),char(17),char(0),char(41),char(1),char(17),char(0),char(42),char(1),
 char(17),char(0),char(43),char(1),char(13),char(0),char(44),char(1),char(13),char(0),char(45),char(1),char(7),char(0),char(46),char(1),char(4),char(0),char(47),char(1),
 char(4),char(0),char(48),char(1),char(4),char(0),char(49),char(1),char(4),char(0),char(50),char(1),char(7),char(0),char(10),char(1),char(4),char(0),char(53),char(0),
 char(88),char(0),char(27),char(0),char(19),char(0),char(51),char(1),char(17),char(0),char(52),char(1),char(17),char(0),char(53),char(1),char(13),char(0),char(44),char(1),
 char(13),char(0),char(54),char(1),char(13),char(0),char(55),char(1),char(13),char(0),char(56),char(1),char(13),char(0),char(57),char(1),char(13),char(0),char(58),char(1),
 char(4),char(0),char(59),char(1),char(7),char(0),char(60),char(1),char(4),char(0),char(61),char(1),char(4),char(0),char(62),char(1),char(4),char(0),char(63),char(1),
 char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),char(4),char(0),char(66),char(1),char(4),char(0),char(67),char(1),char(7),char(0),char(68),char(1),
 char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),
 char(4),char(0),char(74),char(1),char(4),char(0),char(75),char(1),char(4),char(0),char(76),char(1),char(89),char(0),char(12),char(0),char(9),char(0),char(77),char(1),
 char(9),char(0),char(78),char(1),char(13),char(0),char(79),char(1),char(7),char(0),char(80),char(1),char(7),char(0),char(-125),char(0),char(7),char(0),char(81),char(1),
 char(4),char(0),char(82),char(1),char(13),char(0),char(83),char(1),char(4),char(0),char(84),char(1),char(4),char(0),char(85),char(1),char(4),char(0),char(86),char(1),
 char(4),char(0),char(53),char(0),char(90),char(0),char(19),char(0),char(50),char(0),char(-109),char(0),char(87),char(0),char(87),char(1),char(80),char(0),char(88),char(1),
 char(81),char(0),char(89),char(1),char(82),char(0),char(90),char(1),char(83),char(0),char(91),char(1),char(84),char(0),char(92),char(1),char(85),char(0),char(93),char(1),
 char(88),char(0),char(94),char(1),char(89),char(0),char(95),char(1),char(4),char(0),char(96),char(1),char(4),char(0),char(62),char(1),char(4),char(0),char(97),char(1),
 char(4),char(0),char(98),char(1),char(4),char(0),char(99),char(1),char(4),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),
 char(86),char(0),char(103),char(1),char(91),char(0),char(24),char(0),char(16),char(0),char(104),char(1),char(14),char(0),char(105),char(1),char(14),char(0),char(106),char(1),
 char(14),char(0),char(107),char(1),char(14),char(0),char(108),char(1),char(14),char(0),char(109),char(1),char(8),char(0),char(110),char(1),char(4),char(0),char(111),char(1),
 char(4),char(0),char(86),char(1),char(4),char(0),char(112),char(1),char(4),char(0),char(113),char(1),char(8),char(0),char(114),char(1),char(8),char(0),char(115),char(1),
 char(8),char(0),char(116),char(1),char(8),char(0),char(117),char(1),char(8),char(0),char(118),char(1),char(8),char(0),char(119),char(1),char(8),char(0),char(120),char(1),
 char(8),char(0),char(121),char(1),char(8),char(0),char(122),char(1),char(0),char(0),char(123),char(1),char(0),char(0),char(124),char(1),char(49),char(0),char(125),char(1),
 char(0),char(0),char(126),char(1),char(92),char(0),char(24),char(0),char(15),char(0),char(104),char(1),char(13),char(0),char(105),char(1),char(13),char(0),char(106),char(1),
 char(13),char(0),char(107),char(1),char(13),char(0),char(108),char(1),char(13),char(0),char(109),char(1),char(4),char(0),char(112),char(1),char(7),char(0),char(110),char(1),
 char(4),char(0),char(111),char(1),char(4),char(0),char(86),char(1),char(7),char(0),char(114),char(1),char(7),char(0),char(115),char(1),char(7),char(0),char(116),char(1),
 char(4),char(0),char(113),char(1),char(7),char(0),char(117),char(1),char(7),char(0),char(118),char(1),char(7),char(0),char(119),char(1),char(7),char(0),char(120),char(1),
 char(7),char(0),char(121),char(1),char(7),char(0),char(122),char(1),char(0),char(0),char(123),char(1),char(0),char(0),char(124),char(1),char(50),char(0),char(125),char(1),
 char(0),char(0),char(126),char(1),char(93),char(0),char(9),char(0),char(20),char(0),char(127),char(1),char(14),char(0),char(-128),char(1),char(8),char(0),char(-127),char(1),
 char(0),char(0),char(-126),char(1),char(91),char(0),char(90),char(1),char(49),char(0),char(-125),char(1),char(0),char(0),char(126),char(1),char(4),char(0),char(97),char(1),
 char(0),char(0),char(37),char(0),char(94),char(0),char(7),char(0),char(0),char(0),char(-126),char(1),char(92),char(0),char(90),char(1),char(50),char(0),char(-125),char(1),
 char(19),char(0),char(127),char(1),char(13),char(0),char(-128),char(1),char(7),char(0),char(-127),char(1),char(4),char(0),char(97),char(1), };
int sBulletDNAlen = sizeof(sBulletDNAstr);

char sBulletDNAstr64[] = {
 char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-124),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
 char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
 char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
 char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
 char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
 char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
 char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
 char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
 char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
 char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
 char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
 char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
 char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
 char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
 char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
 char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
 char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
 char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
 char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
 char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
 char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
 char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
 char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
 char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
 char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
 char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
 char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
 char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
 char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
 char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
 char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
 char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
 char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
 char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
 char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
 char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
 char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
 char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
 char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
 char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
 char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
 char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
 char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
 char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
 char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
 char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
 char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
 char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
 char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
 char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
 char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
 char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
 char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
 char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
 char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
 char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
 char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
 char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
 char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
 char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
 char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
 char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(103),char(105),char(109),char(112),char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),
 char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),
 char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),
 char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),
 char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),
 char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),
 char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),
 char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),
 char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),char(101),char(115),char(115),char(105),char(110),char(103),char(84),
 char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),
 char(105),char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),
 char(95),char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),
 char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),
 char(97),char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),
 char(116),char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),
 char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),
 char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
 char(110),char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),
 char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),
 char(118),char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),
 char(110),char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),
 char(100),char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),
 char(110),char(103),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),
 char(114),char(114),char(111),char(114),char(82),char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),
 char(109),char(95),char(101),char(114),char(112),char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),
 char(108),char(67),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),
 char(101),char(110),char(101),char(116),char(114),char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),
 char(112),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),
 char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(97),
 char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(115),
 char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),
 char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(117),char(109),char(73),
 char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(77),char(111),
 char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(82),
 char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(66),char(97),char(116),char(99),char(104),
 char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),
 char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),
 char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),
 char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(84),char(101),char(110),
 char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),
 char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),
 char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),
 char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(103),char(114),char(97),
 char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
 char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),char(97),char(108),char(0),char(109),char(95),char(116),char(111),
 char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(84),char(111),char(114),char(113),
 char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(108),
 char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
 char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),
 char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(100),
 char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),
 char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
 char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),
 char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),
 char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),
 char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
 char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(82),char(111),char(119),char(115),char(0),char(110),
 char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),char(114),char(98),char(66),char(0),char(109),char(95),char(111),
 char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),
 char(116),char(114),char(97),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),
 char(100),char(98),char(97),char(99),char(107),char(0),char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),
 char(115),char(101),char(0),char(109),char(95),char(100),char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),
 char(105),char(115),char(97),char(98),char(108),char(101),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),
 char(101),char(101),char(110),char(76),char(105),char(110),char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),
 char(101),char(114),char(114),char(105),char(100),char(101),char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),
 char(108),char(115),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),
 char(98),char(108),char(101),char(100),char(0),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),
 char(112),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),
 char(105),char(118),char(111),char(116),char(73),char(110),char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),
 char(95),char(114),char(98),char(65),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),
 char(0),char(109),char(95),char(117),char(115),char(101),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
 char(65),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),
 char(97),char(98),char(108),char(101),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),
 char(111),char(116),char(111),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),
 char(95),char(109),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),
 char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),
 char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),
 char(95),char(98),char(105),char(97),char(115),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),
 char(116),char(105),char(111),char(110),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),
 char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),
 char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),
 char(97),char(110),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),
 char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),
 char(0),char(109),char(95),char(117),char(115),char(101),char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),
 char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),
 char(111),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),
 char(54),char(100),char(111),char(102),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),
 char(98),char(108),char(101),char(100),char(91),char(54),char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),
 char(109),char(80),char(111),char(105),char(110),char(116),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),
 char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),
 char(97),char(109),char(112),char(105),char(110),char(103),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),
 char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),
 char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
 char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),
 char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
 char(97),char(114),char(77),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),
 char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),
 char(109),char(80),char(111),char(105),char(110),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),
 char(101),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
 char(114),char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),
 char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),
 char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),
 char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
 char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),
 char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),
 char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),
 char(117),char(108),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),
 char(111),char(116),char(111),char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),
 char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),
 char(117),char(108),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),
 char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
 char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),
 char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),
 char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),
 char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),
 char(108),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),
 char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),
 char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),
 char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),
 char(100),char(101),char(114),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),
 char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),
 char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
 char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),
 char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),
 char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),
 char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),
 char(109),char(95),char(97),char(99),char(99),char(117),char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),
 char(95),char(110),char(111),char(114),char(109),char(97),char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),
 char(97),char(99),char(104),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),
 char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),
 char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),
 char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),
 char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),
 char(114),char(101),char(115),char(116),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),
 char(0),char(109),char(95),char(99),char(48),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),
 char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
 char(100),char(101),char(120),char(0),char(109),char(95),char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),
 char(117),char(109),char(103),char(97),char(114),char(116),char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),
 char(116),char(0),char(109),char(95),char(112),char(114),char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),
 char(101),char(0),char(109),char(95),char(100),char(121),char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(112),char(111),char(115),char(101),char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),
 char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),
 char(101),char(116),char(105),char(99),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
 char(109),char(95),char(115),char(111),char(102),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),
 char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),
 char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
 char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
 char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),
 char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),
 char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),
 char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),
 char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),
 char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),
 char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
 char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(100),char(114),char(105),char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),
 char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),
 char(95),char(114),char(111),char(116),char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),
 char(95),char(99),char(111),char(109),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),
 char(95),char(119),char(101),char(105),char(103),char(104),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),
 char(111),char(110),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),
 char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),
 char(109),char(101),char(120),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),
 char(118),char(119),char(105),char(0),char(109),char(95),char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),
 char(95),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),
 char(95),char(97),char(118),char(0),char(42),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),
 char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),
 char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(78),char(111),char(100),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),
 char(109),char(95),char(105),char(100),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),
 char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),
 char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),
 char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),
 char(116),char(99),char(104),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),
 char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),
 char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),
 char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),
 char(95),char(99),char(111),char(108),char(108),char(105),char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),
 char(100),char(101),char(120),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),
 char(66),char(0),char(109),char(95),char(114),char(101),char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),
 char(115),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),
 char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),
 char(121),char(112),char(101),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),
 char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),
 char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),
 char(109),char(95),char(108),char(105),char(110),char(107),char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),
 char(116),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),
 char(115),char(0),char(42),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),
 char(110),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(76),char(105),char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),
 char(0),char(109),char(95),char(110),char(117),char(109),char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),
 char(117),char(109),char(65),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),
 char(101),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),
 char(110),char(102),char(105),char(103),char(0),char(109),char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),
 char(84),char(111),char(84),char(104),char(105),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),
 char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),
 char(80),char(105),char(118),char(111),char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),
 char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),
 char(95),char(106),char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),
 char(109),char(95),char(108),char(105),char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(108),char(105),char(110),char(107),
 char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),char(67),char(111),
 char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),char(109),char(95),
 char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),
 char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),char(109),char(112),
 char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),
 char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
 char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(106),char(111),
 char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(77),
 char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),char(78),char(97),
 char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(108),
 char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),char(100),char(105),
 char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(73),char(110),char(101),char(114),char(116),char(105),char(97),
 char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(78),
 char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),
 char(84),char(89),char(80),char(69),char(95),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
 char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
 char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
 char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
 char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
 char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
 char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
 char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
 char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
 char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
 char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
 char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
 char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
 char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
 char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
 char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
 char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
 char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
 char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
 char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
 char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
 char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
 char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(71),char(73),char(109),char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),
 char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),
 char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),
 char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),char(111),
 char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),
 char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(70),
 char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),
 char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
 char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),char(114),
 char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),
 char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),char(112),
 char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),
 char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),
 char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),
 char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
 char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),
 char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
 char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),
 char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),
 char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
 char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
 char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(50),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),
 char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
 char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),char(114),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),
 char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),char(114),
 char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),char(101),
 char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),char(83),
 char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
 char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
 char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),
 char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),
 char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),char(66),
 char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),char(66),
 char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
 char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),char(68),
 char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),char(111),
 char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),
 char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),char(16),char(0),char(48),char(0),char(16),char(0),char(16),char(0),
 char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),
 char(16),char(0),char(96),char(0),char(-112),char(0),char(16),char(0),char(56),char(0),char(56),char(0),char(20),char(0),char(72),char(0),char(4),char(0),char(4),char(0),
 char(8),char(0),char(4),char(0),char(56),char(0),char(32),char(0),char(80),char(0),char(72),char(0),char(96),char(0),char(80),char(0),char(32),char(0),char(64),char(0),
 char(64),char(0),char(64),char(0),char(16),char(0),char(72),char(0),char(80),char(0),char(-16),char(1),char(24),char(1),char(-104),char(0),char(88),char(0),char(-72),char(0),
 char(104),char(0),char(0),char(2),char(-64),char(3),char(8),char(0),char(64),char(0),char(64),char(0),char(0),char(0),char(80),char(0),char(96),char(0),char(-112),char(0),
 char(-128),char(0),char(104),char(1),char(-24),char(0),char(-104),char(1),char(-120),char(1),char(-32),char(0),char(8),char(1),char(-40),char(1),char(104),char(1),char(-128),char(2),
 char(-112),char(2),char(-64),char(4),char(-40),char(0),char(120),char(1),char(104),char(0),char(-104),char(0),char(16),char(0),char(104),char(0),char(24),char(0),char(40),char(0),
 char(104),char(0),char(96),char(0),char(104),char(0),char(-56),char(0),char(104),char(1),char(112),char(0),char(-24),char(1),char(0),char(3),char(-104),char(1),char(-48),char(0),
 char(112),char(0),char(0),char(0),char(83),char(84),char(82),char(67),char(84),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),
 char(4),char(0),char(1),char(0),char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),
 char(10),char(0),char(5),char(0),char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),
 char(7),char(0),char(8),char(0),char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
 char(16),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),
 char(14),char(0),char(9),char(0),char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),
 char(18),char(0),char(10),char(0),char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),
 char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),
 char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),
 char(14),char(0),char(16),char(0),char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),
 char(0),char(0),char(21),char(0),char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),
 char(25),char(0),char(12),char(0),char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),
 char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),
 char(21),char(0),char(32),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),
 char(14),char(0),char(24),char(0),char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),
 char(4),char(0),char(29),char(0),char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),
 char(21),char(0),char(32),char(0),char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),
 char(28),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),
 char(0),char(0),char(21),char(0),char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),
 char(7),char(0),char(43),char(0),char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),
 char(31),char(0),char(4),char(0),char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),
 char(32),char(0),char(1),char(0),char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),
 char(34),char(0),char(2),char(0),char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),
 char(0),char(0),char(53),char(0),char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),
 char(34),char(0),char(57),char(0),char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),
 char(37),char(0),char(4),char(0),char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),
 char(38),char(0),char(7),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),
 char(39),char(0),char(68),char(0),char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),
 char(13),char(0),char(39),char(0),char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),
 char(7),char(0),char(74),char(0),char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),
 char(7),char(0),char(43),char(0),char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),
 char(44),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),
 char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),
 char(7),char(0),char(80),char(0),char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),
 char(4),char(0),char(84),char(0),char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),
 char(7),char(0),char(89),char(0),char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),
 char(4),char(0),char(94),char(0),char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(5),char(0),char(27),char(0),char(38),char(0),
 char(37),char(0),char(65),char(0),char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(96),char(0),char(48),char(0),char(5),char(0),
 char(29),char(0),char(47),char(0),char(13),char(0),char(97),char(0),char(14),char(0),char(98),char(0),char(4),char(0),char(99),char(0),char(0),char(0),char(100),char(0),
 char(49),char(0),char(27),char(0),char(9),char(0),char(101),char(0),char(9),char(0),char(102),char(0),char(27),char(0),char(103),char(0),char(0),char(0),char(35),char(0),
 char(20),char(0),char(104),char(0),char(20),char(0),char(105),char(0),char(14),char(0),char(106),char(0),char(14),char(0),char(107),char(0),char(14),char(0),char(108),char(0),
 char(8),char(0),char(109),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(111),char(0),char(8),char(0),char(112),char(0),char(8),char(0),char(113),char(0),
 char(8),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),char(8),char(0),char(118),char(0),
 char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),char(4),char(0),char(123),char(0),
 char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(0),char(0),char(37),char(0),char(50),char(0),char(27),char(0),char(9),char(0),char(101),char(0),
 char(9),char(0),char(102),char(0),char(27),char(0),char(103),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(104),char(0),char(19),char(0),char(105),char(0),
 char(13),char(0),char(106),char(0),char(13),char(0),char(107),char(0),char(13),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(7),char(0),char(110),char(0),
 char(7),char(0),char(111),char(0),char(7),char(0),char(112),char(0),char(7),char(0),char(113),char(0),char(7),char(0),char(114),char(0),char(7),char(0),char(115),char(0),
 char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),char(7),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),
 char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),char(4),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),
 char(0),char(0),char(37),char(0),char(51),char(0),char(22),char(0),char(8),char(0),char(126),char(0),char(8),char(0),char(127),char(0),char(8),char(0),char(111),char(0),
 char(8),char(0),char(-128),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),
 char(8),char(0),char(-124),char(0),char(8),char(0),char(-123),char(0),char(8),char(0),char(-122),char(0),char(8),char(0),char(-121),char(0),char(8),char(0),char(-120),char(0),
 char(8),char(0),char(-119),char(0),char(8),char(0),char(-118),char(0),char(8),char(0),char(-117),char(0),char(4),char(0),char(-116),char(0),char(4),char(0),char(-115),char(0),
 char(4),char(0),char(-114),char(0),char(4),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(52),char(0),char(22),char(0),
 char(7),char(0),char(126),char(0),char(7),char(0),char(127),char(0),char(7),char(0),char(111),char(0),char(7),char(0),char(-128),char(0),char(7),char(0),char(115),char(0),
 char(7),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(7),char(0),char(-124),char(0),char(7),char(0),char(-123),char(0),
 char(7),char(0),char(-122),char(0),char(7),char(0),char(-121),char(0),char(7),char(0),char(-120),char(0),char(7),char(0),char(-119),char(0),char(7),char(0),char(-118),char(0),
 char(7),char(0),char(-117),char(0),char(4),char(0),char(-116),char(0),char(4),char(0),char(-115),char(0),char(4),char(0),char(-114),char(0),char(4),char(0),char(-113),char(0),
 char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(53),char(0),char(2),char(0),char(51),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),
 char(54),char(0),char(2),char(0),char(52),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(55),char(0),char(21),char(0),char(50),char(0),char(-109),char(0),
 char(17),char(0),char(-108),char(0),char(13),char(0),char(-107),char(0),char(13),char(0),char(-106),char(0),char(13),char(0),char(-105),char(0),char(13),char(0),char(-104),char(0),
 char(13),char(0),char(-110),char(0),char(13),char(0),char(-103),char(0),char(13),char(0),char(-102),char(0),char(13),char(0),char(-101),char(0),char(13),char(0),char(-100),char(0),
 char(7),char(0),char(-99),char(0),char(7),char(0),char(-98),char(0),char(7),char(0),char(-97),char(0),char(7),char(0),char(-96),char(0),char(7),char(0),char(-95),char(0),
 char(7),char(0),char(-94),char(0),char(7),char(0),char(-93),char(0),char(7),char(0),char(-92),char(0),char(7),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),
 char(56),char(0),char(22),char(0),char(49),char(0),char(-109),char(0),char(18),char(0),char(-108),char(0),char(14),char(0),char(-107),char(0),char(14),char(0),char(-106),char(0),
 char(14),char(0),char(-105),char(0),char(14),char(0),char(-104),char(0),char(14),char(0),char(-110),char(0),char(14),char(0),char(-103),char(0),char(14),char(0),char(-102),char(0),
 char(14),char(0),char(-101),char(0),char(14),char(0),char(-100),char(0),char(8),char(0),char(-99),char(0),char(8),char(0),char(-98),char(0),char(8),char(0),char(-97),char(0),
 char(8),char(0),char(-96),char(0),char(8),char(0),char(-95),char(0),char(8),char(0),char(-94),char(0),char(8),char(0),char(-93),char(0),char(8),char(0),char(-92),char(0),
 char(8),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),char(0),char(0),char(37),char(0),char(57),char(0),char(2),char(0),char(4),char(0),char(-89),char(0),
 char(4),char(0),char(-88),char(0),char(58),char(0),char(13),char(0),char(55),char(0),char(-87),char(0),char(55),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),
 char(4),char(0),char(-85),char(0),char(4),char(0),char(-84),char(0),char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),
 char(7),char(0),char(-80),char(0),char(4),char(0),char(-79),char(0),char(4),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),
 char(59),char(0),char(13),char(0),char(60),char(0),char(-87),char(0),char(60),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-85),char(0),
 char(4),char(0),char(-84),char(0),char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),
 char(4),char(0),char(-79),char(0),char(4),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),char(61),char(0),char(14),char(0),
 char(56),char(0),char(-87),char(0),char(56),char(0),char(-86),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-85),char(0),char(4),char(0),char(-84),char(0),
 char(4),char(0),char(-83),char(0),char(4),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(4),char(0),char(-79),char(0),
 char(4),char(0),char(-78),char(0),char(8),char(0),char(-77),char(0),char(4),char(0),char(-76),char(0),char(0),char(0),char(-75),char(0),char(62),char(0),char(3),char(0),
 char(59),char(0),char(-74),char(0),char(13),char(0),char(-73),char(0),char(13),char(0),char(-72),char(0),char(63),char(0),char(3),char(0),char(61),char(0),char(-74),char(0),
 char(14),char(0),char(-73),char(0),char(14),char(0),char(-72),char(0),char(64),char(0),char(3),char(0),char(59),char(0),char(-74),char(0),char(14),char(0),char(-73),char(0),
 char(14),char(0),char(-72),char(0),char(65),char(0),char(13),char(0),char(59),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),
 char(4),char(0),char(-69),char(0),char(4),char(0),char(-68),char(0),char(4),char(0),char(-67),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(-65),char(0),
 char(7),char(0),char(-64),char(0),char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),
 char(66),char(0),char(13),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(4),char(0),char(-69),char(0),
 char(4),char(0),char(-68),char(0),char(4),char(0),char(-67),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(-65),char(0),char(7),char(0),char(-64),char(0),
 char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),char(67),char(0),char(14),char(0),
 char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(4),char(0),char(-69),char(0),char(4),char(0),char(-68),char(0),
 char(4),char(0),char(-67),char(0),char(8),char(0),char(-66),char(0),char(8),char(0),char(-65),char(0),char(8),char(0),char(-64),char(0),char(8),char(0),char(-63),char(0),
 char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),char(8),char(0),char(-60),char(0),char(0),char(0),char(-59),char(0),char(68),char(0),char(10),char(0),
 char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),
 char(8),char(0),char(-56),char(0),char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),char(8),char(0),char(-60),char(0),char(8),char(0),char(127),char(0),
 char(69),char(0),char(11),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(7),char(0),char(-58),char(0),
 char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),
 char(7),char(0),char(127),char(0),char(0),char(0),char(21),char(0),char(70),char(0),char(9),char(0),char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),
 char(19),char(0),char(-70),char(0),char(13),char(0),char(-55),char(0),char(13),char(0),char(-54),char(0),char(13),char(0),char(-53),char(0),char(13),char(0),char(-52),char(0),
 char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(71),char(0),char(9),char(0),char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),
 char(20),char(0),char(-70),char(0),char(14),char(0),char(-55),char(0),char(14),char(0),char(-54),char(0),char(14),char(0),char(-53),char(0),char(14),char(0),char(-52),char(0),
 char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(72),char(0),char(5),char(0),char(70),char(0),char(-49),char(0),char(4),char(0),char(-48),char(0),
 char(7),char(0),char(-47),char(0),char(7),char(0),char(-46),char(0),char(7),char(0),char(-45),char(0),char(73),char(0),char(5),char(0),char(71),char(0),char(-49),char(0),
 char(4),char(0),char(-48),char(0),char(8),char(0),char(-47),char(0),char(8),char(0),char(-46),char(0),char(8),char(0),char(-45),char(0),char(74),char(0),char(41),char(0),
 char(59),char(0),char(-74),char(0),char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(13),char(0),char(-55),char(0),char(13),char(0),char(-54),char(0),
 char(13),char(0),char(-44),char(0),char(13),char(0),char(-43),char(0),char(13),char(0),char(-42),char(0),char(13),char(0),char(-41),char(0),char(13),char(0),char(-40),char(0),
 char(13),char(0),char(-39),char(0),char(13),char(0),char(-38),char(0),char(13),char(0),char(-37),char(0),char(13),char(0),char(-36),char(0),char(13),char(0),char(-35),char(0),
 char(13),char(0),char(-34),char(0),char(0),char(0),char(-33),char(0),char(0),char(0),char(-32),char(0),char(0),char(0),char(-31),char(0),char(0),char(0),char(-30),char(0),
 char(0),char(0),char(-29),char(0),char(0),char(0),char(-59),char(0),char(13),char(0),char(-53),char(0),char(13),char(0),char(-52),char(0),char(13),char(0),char(-28),char(0),
 char(13),char(0),char(-27),char(0),char(13),char(0),char(-26),char(0),char(13),char(0),char(-25),char(0),char(13),char(0),char(-24),char(0),char(13),char(0),char(-23),char(0),
 char(13),char(0),char(-22),char(0),char(13),char(0),char(-21),char(0),char(13),char(0),char(-20),char(0),char(13),char(0),char(-19),char(0),char(13),char(0),char(-18),char(0),
 char(0),char(0),char(-17),char(0),char(0),char(0),char(-16),char(0),char(0),char(0),char(-15),char(0),char(0),char(0),char(-14),char(0),char(0),char(0),char(-13),char(0),
 char(4),char(0),char(-12),char(0),char(75),char(0),char(41),char(0),char(61),char(0),char(-74),char(0),char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),
 char(14),char(0),char(-55),char(0),char(14),char(0),char(-54),char(0),char(14),char(0),char(-44),char(0),char(14),char(0),char(-43),char(0),char(14),char(0),char(-42),char(0),
 char(14),char(0),char(-41),char(0),char(14),char(0),char(-40),char(0),char(14),char(0),char(-39),char(0),char(14),char(0),char(-38),char(0),char(14),char(0),char(-37),char(0),
 char(14),char(0),char(-36),char(0),char(14),char(0),char(-35),char(0),char(14),char(0),char(-34),char(0),char(0),char(0),char(-33),char(0),char(0),char(0),char(-32),char(0),
 char(0),char(0),char(-31),char(0),char(0),char(0),char(-30),char(0),char(0),char(0),char(-29),char(0),char(0),char(0),char(-59),char(0),char(14),char(0),char(-53),char(0),
 char(14),char(0),char(-52),char(0),char(14),char(0),char(-28),char(0),char(14),char(0),char(-27),char(0),char(14),char(0),char(-26),char(0),char(14),char(0),char(-25),char(0),
 char(14),char(0),char(-24),char(0),char(14),char(0),char(-23),char(0),char(14),char(0),char(-22),char(0),char(14),char(0),char(-21),char(0),char(14),char(0),char(-20),char(0),
 char(14),char(0),char(-19),char(0),char(14),char(0),char(-18),char(0),char(0),char(0),char(-17),char(0),char(0),char(0),char(-16),char(0),char(0),char(0),char(-15),char(0),
 char(0),char(0),char(-14),char(0),char(0),char(0),char(-13),char(0),char(4),char(0),char(-12),char(0),char(76),char(0),char(9),char(0),char(59),char(0),char(-74),char(0),
 char(19),char(0),char(-71),char(0),char(19),char(0),char(-70),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
 char(7),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(77),char(0),char(9),char(0),char(61),char(0),char(-74),char(0),
 char(20),char(0),char(-71),char(0),char(20),char(0),char(-70),char(0),char(8),char(0),char(-55),char(0),char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),
 char(8),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(78),char(0),char(5),char(0),char(58),char(0),char(-74),char(0),
 char(13),char(0),char(-11),char(0),char(13),char(0),char(-10),char(0),char(7),char(0),char(-9),char(0),char(0),char(0),char(37),char(0),char(79),char(0),char(4),char(0),
 char(61),char(0),char(-74),char(0),char(14),char(0),char(-11),char(0),char(14),char(0),char(-10),char(0),char(8),char(0),char(-9),char(0),char(80),char(0),char(4),char(0),
 char(7),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),char(7),char(0),char(-6),char(0),char(4),char(0),char(79),char(0),char(81),char(0),char(10),char(0),
 char(80),char(0),char(-5),char(0),char(13),char(0),char(-4),char(0),char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),
 char(13),char(0),char(0),char(1),char(7),char(0),char(-99),char(0),char(7),char(0),char(1),char(1),char(4),char(0),char(2),char(1),char(4),char(0),char(53),char(0),
 char(82),char(0),char(4),char(0),char(80),char(0),char(-5),char(0),char(4),char(0),char(3),char(1),char(7),char(0),char(4),char(1),char(4),char(0),char(5),char(1),
 char(83),char(0),char(4),char(0),char(13),char(0),char(0),char(1),char(80),char(0),char(-5),char(0),char(4),char(0),char(6),char(1),char(7),char(0),char(7),char(1),
 char(84),char(0),char(7),char(0),char(13),char(0),char(8),char(1),char(80),char(0),char(-5),char(0),char(4),char(0),char(9),char(1),char(7),char(0),char(10),char(1),
 char(7),char(0),char(11),char(1),char(7),char(0),char(12),char(1),char(4),char(0),char(53),char(0),char(85),char(0),char(6),char(0),char(17),char(0),char(13),char(1),
 char(13),char(0),char(11),char(1),char(13),char(0),char(14),char(1),char(60),char(0),char(15),char(1),char(4),char(0),char(16),char(1),char(7),char(0),char(12),char(1),
 char(86),char(0),char(26),char(0),char(4),char(0),char(17),char(1),char(7),char(0),char(18),char(1),char(7),char(0),char(127),char(0),char(7),char(0),char(19),char(1),
 char(7),char(0),char(20),char(1),char(7),char(0),char(21),char(1),char(7),char(0),char(22),char(1),char(7),char(0),char(23),char(1),char(7),char(0),char(24),char(1),
 char(7),char(0),char(25),char(1),char(7),char(0),char(26),char(1),char(7),char(0),char(27),char(1),char(7),char(0),char(28),char(1),char(7),char(0),char(29),char(1),
 char(7),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(7),char(0),char(32),char(1),char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),
 char(7),char(0),char(35),char(1),char(7),char(0),char(36),char(1),char(4),char(0),char(37),char(1),char(4),char(0),char(38),char(1),char(4),char(0),char(39),char(1),
 char(4),char(0),char(40),char(1),char(4),char(0),char(120),char(0),char(87),char(0),char(12),char(0),char(17),char(0),char(41),char(1),char(17),char(0),char(42),char(1),
 char(17),char(0),char(43),char(1),char(13),char(0),char(44),char(1),char(13),char(0),char(45),char(1),char(7),char(0),char(46),char(1),char(4),char(0),char(47),char(1),
 char(4),char(0),char(48),char(1),char(4),char(0),char(49),char(1),char(4),char(0),char(50),char(1),char(7),char(0),char(10),char(1),char(4),char(0),char(53),char(0),
 char(88),char(0),char(27),char(0),char(19),char(0),char(51),char(1),char(17),char(0),char(52),char(1),char(17),char(0),char(53),char(1),char(13),char(0),char(44),char(1),
 char(13),char(0),char(54),char(1),char(13),char(0),char(55),char(1),char(13),char(0),char(56),char(1),char(13),char(0),char(57),char(1),char(13),char(0),char(58),char(1),
 char(4),char(0),char(59),char(1),char(7),char(0),char(60),char(1),char(4),char(0),char(61),char(1),char(4),char(0),char(62),char(1),char(4),char(0),char(63),char(1),
 char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),char(4),char(0),char(66),char(1),char(4),char(0),char(67),char(1),char(7),char(0),char(68),char(1),
 char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),
 char(4),char(0),char(74),char(1),char(4),char(0),char(75),char(1),char(4),char(0),char(76),char(1),char(89),char(0),char(12),char(0),char(9),char(0),char(77),char(1),
 char(9),char(0),char(78),char(1),char(13),char(0),char(79),char(1),char(7),char(0),char(80),char(1),char(7),char(0),char(-125),char(0),char(7),char(0),char(81),char(1),
 char(4),char(0),char(82),char(1),char(13),char(0),char(83),char(1),char(4),char(0),char(84),char(1),char(4),char(0),char(85),char(1),char(4),char(0),char(86),char(1),
 char(4),char(0),char(53),char(0),char(90),char(0),char(19),char(0),char(50),char(0),char(-109),char(0),char(87),char(0),char(87),char(1),char(80),char(0),char(88),char(1),
 char(81),char(0),char(89),char(1),char(82),char(0),char(90),char(1),char(83),char(0),char(91),char(1),char(84),char(0),char(92),char(1),char(85),char(0),char(93),char(1),
 char(88),char(0),char(94),char(1),char(89),char(0),char(95),char(1),char(4),char(0),char(96),char(1),char(4),char(0),char(62),char(1),char(4),char(0),char(97),char(1),
 char(4),char(0),char(98),char(1),char(4),char(0),char(99),char(1),char(4),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),
 char(86),char(0),char(103),char(1),char(91),char(0),char(24),char(0),char(16),char(0),char(104),char(1),char(14),char(0),char(105),char(1),char(14),char(0),char(106),char(1),
 char(14),char(0),char(107),char(1),char(14),char(0),char(108),char(1),char(14),char(0),char(109),char(1),char(8),char(0),char(110),char(1),char(4),char(0),char(111),char(1),
 char(4),char(0),char(86),char(1),char(4),char(0),char(112),char(1),char(4),char(0),char(113),char(1),char(8),char(0),char(114),char(1),char(8),char(0),char(115),char(1),
 char(8),char(0),char(116),char(1),char(8),char(0),char(117),char(1),char(8),char(0),char(118),char(1),char(8),char(0),char(119),char(1),char(8),char(0),char(120),char(1),
 char(8),char(0),char(121),char(1),char(8),char(0),char(122),char(1),char(0),char(0),char(123),char(1),char(0),char(0),char(124),char(1),char(49),char(0),char(125),char(1),
 char(0),char(0),char(126),char(1),char(92),char(0),char(24),char(0),char(15),char(0),char(104),char(1),char(13),char(0),char(105),char(1),char(13),char(0),char(106),char(1),
 char(13),char(0),char(107),char(1),char(13),char(0),char(108),char(1),char(13),char(0),char(109),char(1),char(4),char(0),char(112),char(1),char(7),char(0),char(110),char(1),
 char(4),char(0),char(111),char(1),char(4),char(0),char(86),char(1),char(7),char(0),char(114),char(1),char(7),char(0),char(115),char(1),char(7),char(0),char(116),char(1),
 char(4),char(0),char(113),char(1),char(7),char(0),char(117),char(1),char(7),char(0),char(118),char(1),char(7),char(0),char(119),char(1),char(7),char(0),char(120),char(1),
 char(7),char(0),char(121),char(1),char(7),char(0),char(122),char(1),char(0),char(0),char(123),char(1),char(0),char(0),char(124),char(1),char(50),char(0),char(125),char(1),
 char(0),char(0),char(126),char(1),char(93),char(0),char(9),char(0),char(20),char(0),char(127),char(1),char(14),char(0),char(-128),char(1),char(8),char(0),char(-127),char(1),
 char(0),char(0),char(-126),char(1),char(91),char(0),char(90),char(1),char(49),char(0),char(-125),char(1),char(0),char(0),char(126),char(1),char(4),char(0),char(97),char(1),
 char(0),char(0),char(37),char(0),char(94),char(0),char(7),char(0),char(0),char(0),char(-126),char(1),char(92),char(0),char(90),char(1),char(50),char(0),char(-125),char(1),
 char(19),char(0),char(127),char(1),char(13),char(0),char(-128),char(1),char(7),char(0),char(-127),char(1),char(4),char(0),char(97),char(1), };
int sBulletDNAlen64 = sizeof(sBulletDNAstr64);

/*
Copyright (c) 2003-2014 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btThreads.h"
#include "LinearMath/btQuickprof.h"
#include <algorithm>  // for min and max


#if BT_USE_OPENMP && BT_THREADSAFE

#include <omp.h>

#endif // #if BT_USE_OPENMP && BT_THREADSAFE


#if BT_USE_PPL && BT_THREADSAFE

// use Microsoft Parallel Patterns Library (installed with Visual Studio 2010 and later)
#include <ppl.h>  // if you get a compile error here, check whether your version of Visual Studio includes PPL
// Visual Studio 2010 and later should come with it
#include <concrtrm.h>  // for GetProcessorCount()

#endif // #if BT_USE_PPL && BT_THREADSAFE


#if BT_USE_TBB && BT_THREADSAFE

// use Intel Threading Building Blocks for thread management
#define __TBB_NO_IMPLICIT_LINKAGE 1
#include <tbb/tbb.h>
#include <tbb/task_scheduler_init.h>
#include <tbb/parallel_for.h>
#include <tbb/blocked_range.h>

#endif // #if BT_USE_TBB && BT_THREADSAFE


#if BT_THREADSAFE
//
// Lightweight spin-mutex based on atomics
// Using ordinary system-provided mutexes like Windows critical sections was noticeably slower
// presumably because when it fails to lock at first it would sleep the thread and trigger costly
// context switching.
// 

#if __cplusplus >= 201103L

// for anything claiming full C++11 compliance, use C++11 atomics
// on GCC or Clang you need to compile with -std=c++11
#define USE_CPP11_ATOMICS 1

#elif defined( _MSC_VER )

// on MSVC, use intrinsics instead
#define USE_MSVC_INTRINSICS 1

#elif defined( __GNUC__ ) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7))

// available since GCC 4.7 and some versions of clang
// todo: check for clang
#define USE_GCC_BUILTIN_ATOMICS 1

#elif defined( __GNUC__ ) && (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)

// available since GCC 4.1
#define USE_GCC_BUILTIN_ATOMICS_OLD 1

#endif


#if USE_CPP11_ATOMICS

#include <atomic>
#include <thread>

#define THREAD_LOCAL_STATIC thread_local static

bool btSpinMutex::tryLock()
{
 std::atomic<int>* aDest = reinterpret_cast<std::atomic<int>*>(&mLock);
 int expected = 0;
 return std::atomic_compare_exchange_weak_explicit(aDest, &expected, int(1), std::memory_order_acq_rel, std::memory_order_acquire);
}

void btSpinMutex::lock()
{
 // note: this lock does not sleep the thread.
 while (!tryLock())
 {
  // spin
 }
}

void btSpinMutex::unlock()
{
 std::atomic<int>* aDest = reinterpret_cast<std::atomic<int>*>(&mLock);
 std::atomic_store_explicit(aDest, int(0), std::memory_order_release);
}


#elif USE_MSVC_INTRINSICS

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <intrin.h>

#define THREAD_LOCAL_STATIC __declspec( thread ) static


bool btSpinMutex::tryLock()
{
 volatile long* aDest = reinterpret_cast<long*>(&mLock);
 return (0 == _InterlockedCompareExchange(aDest, 1, 0));
}

void btSpinMutex::lock()
{
 // note: this lock does not sleep the thread
 while (!tryLock())
 {
  // spin
 }
}

void btSpinMutex::unlock()
{
 volatile long* aDest = reinterpret_cast<long*>(&mLock);
 _InterlockedExchange(aDest, 0);
}

#elif USE_GCC_BUILTIN_ATOMICS

#define THREAD_LOCAL_STATIC static __thread


bool btSpinMutex::tryLock()
{
 int expected = 0;
 bool weak = false;
 const int memOrderSuccess = __ATOMIC_ACQ_REL;
 const int memOrderFail = __ATOMIC_ACQUIRE;
 return __atomic_compare_exchange_n(&mLock, &expected, int(1), weak, memOrderSuccess, memOrderFail);
}

void btSpinMutex::lock()
{
 // note: this lock does not sleep the thread
 while (!tryLock())
 {
  // spin
 }
}

void btSpinMutex::unlock()
{
 __atomic_store_n(&mLock, int(0), __ATOMIC_RELEASE);
}

#elif USE_GCC_BUILTIN_ATOMICS_OLD


#define THREAD_LOCAL_STATIC static __thread

bool btSpinMutex::tryLock()
{
 return __sync_bool_compare_and_swap(&mLock, int(0), int(1));
}

void btSpinMutex::lock()
{
 // note: this lock does not sleep the thread
 while (!tryLock())
 {
  // spin
 }
}

void btSpinMutex::unlock()
{
 // write 0
 __sync_fetch_and_and(&mLock, int(0));
}

#else //#elif USE_MSVC_INTRINSICS

#error "no threading primitives defined -- unknown platform"

#endif  //#else //#elif USE_MSVC_INTRINSICS

#else //#if BT_THREADSAFE

// These should not be called ever
void btSpinMutex::lock()
{
 btAssert(!"unimplemented btSpinMutex::lock() called");
}

void btSpinMutex::unlock()
{
 btAssert(!"unimplemented btSpinMutex::unlock() called");
}

bool btSpinMutex::tryLock()
{
 btAssert(!"unimplemented btSpinMutex::tryLock() called");
 return true;
}

#define THREAD_LOCAL_STATIC static

#endif // #else //#if BT_THREADSAFE


struct ThreadsafeCounter
{
 unsigned int mCounter;
 btSpinMutex mMutex;

 ThreadsafeCounter()
 {
  mCounter = 0;
  --mCounter; // first count should come back 0
 }

 unsigned int getNext()
 {
  // no need to optimize this with atomics, it is only called ONCE per thread!
  mMutex.lock();
  mCounter++;
  if (mCounter >= BT_MAX_THREAD_COUNT)
  {
   btAssert(!"thread counter exceeded");
   // wrap back to the first worker index
   mCounter = 1;
  }
  unsigned int val = mCounter;
  mMutex.unlock();
  return val;
 }
};


static btITaskScheduler* gBtTaskScheduler;
static int gThreadsRunningCounter = 0;  // useful for detecting if we are trying to do nested parallel-for calls
static btSpinMutex gThreadsRunningCounterMutex;
static ThreadsafeCounter gThreadCounter;


//
// BT_DETECT_BAD_THREAD_INDEX tries to detect when there are multiple threads assigned the same thread index.
//
// BT_DETECT_BAD_THREAD_INDEX is a developer option to test if
// certain assumptions about how the task scheduler manages its threads
// holds true.
// The main assumption is:
//   - when the threadpool is resized, the task scheduler either
//      1. destroys all worker threads and creates all new ones in the correct number, OR
//      2. never destroys a worker thread
//
// We make that assumption because we can't easily enumerate the worker threads of a task scheduler
// to assign nice sequential thread-indexes. We also do not get notified if a worker thread is destroyed,
// so we can't tell when a thread-index is no longer being used.
// We allocate thread-indexes as needed with a sequential global thread counter.
//
// Our simple thread-counting scheme falls apart if the task scheduler destroys some threads but
// continues to re-use other threads and the application repeatedly resizes the thread pool of the 
// task scheduler.
// In order to prevent the thread-counter from exceeding the global max (BT_MAX_THREAD_COUNT), we
// wrap the thread counter back to 1. This should only happen if the worker threads have all been
// destroyed and re-created.
//
// BT_DETECT_BAD_THREAD_INDEX only works for Win32 right now,
// but could be adapted to work with pthreads
#define BT_DETECT_BAD_THREAD_INDEX 0

#if BT_DETECT_BAD_THREAD_INDEX

typedef DWORD ThreadId_t;
const static ThreadId_t kInvalidThreadId = 0;
ThreadId_t gDebugThreadIds[BT_MAX_THREAD_COUNT];

static ThreadId_t getDebugThreadId()
{
 return GetCurrentThreadId();
}

#endif // #if BT_DETECT_BAD_THREAD_INDEX


// return a unique index per thread, main thread is 0, worker threads are in [1, BT_MAX_THREAD_COUNT)
unsigned int btGetCurrentThreadIndex()
{
 const unsigned int kNullIndex = ~0U;
 THREAD_LOCAL_STATIC unsigned int sThreadIndex = kNullIndex;
 if (sThreadIndex == kNullIndex)
 {
  sThreadIndex = gThreadCounter.getNext();
  btAssert(sThreadIndex < BT_MAX_THREAD_COUNT);
 }
#if BT_DETECT_BAD_THREAD_INDEX
 if (gBtTaskScheduler && sThreadIndex > 0)
 {
  ThreadId_t tid = getDebugThreadId();
  // if not set
  if (gDebugThreadIds[sThreadIndex] == kInvalidThreadId)
  {
   // set it
   gDebugThreadIds[sThreadIndex] = tid;
  }
  else
  {
   if (gDebugThreadIds[sThreadIndex] != tid)
   {
    // this could indicate the task scheduler is breaking our assumptions about
    // how threads are managed when threadpool is resized
    btAssert(!"there are 2 or more threads with the same thread-index!");
    __debugbreak();
   }
  }
 }
#endif // #if BT_DETECT_BAD_THREAD_INDEX
 return sThreadIndex;
}

bool btIsMainThread()
{
 return btGetCurrentThreadIndex() == 0;
}

void btResetThreadIndexCounter()
{
 // for when all current worker threads are destroyed
 btAssert(btIsMainThread());
 gThreadCounter.mCounter = 0;
}

btITaskScheduler::btITaskScheduler(const char* name)
{
 m_name = name;
 m_savedThreadCounter = 0;
 m_isActive = false;
}

void btITaskScheduler::activate()
{
 // gThreadCounter is used to assign a thread-index to each worker thread in a task scheduler.
 // The main thread is always thread-index 0, and worker threads are numbered from 1 to 63 (BT_MAX_THREAD_COUNT-1)
 // The thread-indexes need to be unique amongst the threads that can be running simultaneously.
 // Since only one task scheduler can be used at a time, it is OK for a pair of threads that belong to different
 // task schedulers to share the same thread index because they can't be running at the same time.
 // So each task scheduler needs to keep its own thread counter value
 if (!m_isActive)
 {
  gThreadCounter.mCounter = m_savedThreadCounter;  // restore saved thread counter
  m_isActive = true;
 }
}

void btITaskScheduler::deactivate()
{
 if (m_isActive)
 {
  m_savedThreadCounter = gThreadCounter.mCounter;  // save thread counter
  m_isActive = false;
 }
}

void btPushThreadsAreRunning()
{
 gThreadsRunningCounterMutex.lock();
 gThreadsRunningCounter++;
 gThreadsRunningCounterMutex.unlock();
}

void btPopThreadsAreRunning()
{
 gThreadsRunningCounterMutex.lock();
 gThreadsRunningCounter--;
 gThreadsRunningCounterMutex.unlock();
}

bool btThreadsAreRunning()
{
 return gThreadsRunningCounter != 0;
}


void btSetTaskScheduler(btITaskScheduler* ts)
{
 int threadId = btGetCurrentThreadIndex();  // make sure we call this on main thread at least once before any workers run
 if (threadId != 0)
 {
  btAssert(!"btSetTaskScheduler must be called from the main thread!");
  return;
 }
 if (gBtTaskScheduler)
 {
  // deactivate old task scheduler
  gBtTaskScheduler->deactivate();
 }
 gBtTaskScheduler = ts;
 if (ts)
 {
  // activate new task scheduler
  ts->activate();
 }
}


btITaskScheduler* btGetTaskScheduler()
{
 return gBtTaskScheduler;
}


void btParallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body)
{
#if BT_THREADSAFE

#if BT_DETECT_BAD_THREAD_INDEX
 if (!btThreadsAreRunning())
 {
  // clear out thread ids
  for (int i = 0; i < BT_MAX_THREAD_COUNT; ++i)
  {
   gDebugThreadIds[i] = kInvalidThreadId;
  }
 }
#endif // #if BT_DETECT_BAD_THREAD_INDEX

 btAssert(gBtTaskScheduler != NULL);  // call btSetTaskScheduler() with a valid task scheduler first!
 gBtTaskScheduler->parallelFor(iBegin, iEnd, grainSize, body);

#else // #if BT_THREADSAFE

 // non-parallel version of btParallelFor
 btAssert(!"called btParallelFor in non-threadsafe build. enable BT_THREADSAFE");
 body.forLoop(iBegin, iEnd);

#endif// #if BT_THREADSAFE
}


///
/// btTaskSchedulerSequential -- non-threaded implementation of task scheduler
///                              (really just useful for testing performance of single threaded vs multi)
///
class btTaskSchedulerSequential : public btITaskScheduler
{
public:
 btTaskSchedulerSequential() : btITaskScheduler("Sequential") {}
 virtual int getMaxNumThreads() const BT_OVERRIDE { return 1; }
 virtual int getNumThreads() const BT_OVERRIDE { return 1; }
 virtual void setNumThreads(int numThreads) BT_OVERRIDE {}
 virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
 {
  BT_PROFILE("parallelFor_sequential");
  body.forLoop(iBegin, iEnd);
 }
};


#if BT_USE_OPENMP && BT_THREADSAFE
///
/// btTaskSchedulerOpenMP -- wrapper around OpenMP task scheduler
///
class btTaskSchedulerOpenMP : public btITaskScheduler
{
 int m_numThreads;
public:
 btTaskSchedulerOpenMP() : btITaskScheduler("OpenMP")
 {
  m_numThreads = 0;
 }
 virtual int getMaxNumThreads() const BT_OVERRIDE
 {
  return omp_get_max_threads();
 }
 virtual int getNumThreads() const BT_OVERRIDE
 {
  return m_numThreads;
 }
 virtual void setNumThreads(int numThreads) BT_OVERRIDE
 {
  // With OpenMP, because it is a standard with various implementations, we can't
  // know for sure if every implementation has the same behavior of destroying all
  // previous threads when resizing the threadpool
  m_numThreads = (std::max)(1, (std::min)(int(BT_MAX_THREAD_COUNT), numThreads));
  omp_set_num_threads(1);  // hopefully, all previous threads get destroyed here
  omp_set_num_threads(m_numThreads);
  m_savedThreadCounter = 0;
  if (m_isActive)
  {
   btResetThreadIndexCounter();
  }
 }
 virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
 {
  BT_PROFILE("parallelFor_OpenMP");
  btPushThreadsAreRunning();
#pragma omp parallel for schedule( static, 1 )
  for (int i = iBegin; i < iEnd; i += grainSize)
  {
   BT_PROFILE("OpenMP_job");
   body.forLoop(i, (std::min)(i + grainSize, iEnd));
  }
  btPopThreadsAreRunning();
 }
};
#endif // #if BT_USE_OPENMP && BT_THREADSAFE


#if BT_USE_TBB && BT_THREADSAFE
///
/// btTaskSchedulerTBB -- wrapper around Intel Threaded Building Blocks task scheduler
///
class btTaskSchedulerTBB : public btITaskScheduler
{
 int m_numThreads;
 tbb::task_scheduler_init* m_tbbSchedulerInit;

public:
 btTaskSchedulerTBB() : btITaskScheduler("IntelTBB")
 {
  m_numThreads = 0;
  m_tbbSchedulerInit = NULL;
 }
 ~btTaskSchedulerTBB()
 {
  if (m_tbbSchedulerInit)
  {
   delete m_tbbSchedulerInit;
   m_tbbSchedulerInit = NULL;
  }
 }

 virtual int getMaxNumThreads() const BT_OVERRIDE
 {
  return tbb::task_scheduler_init::default_num_threads();
 }
 virtual int getNumThreads() const BT_OVERRIDE
 {
  return m_numThreads;
 }
 virtual void setNumThreads(int numThreads) BT_OVERRIDE
 {
  m_numThreads = (std::max)(1, (std::min)(int(BT_MAX_THREAD_COUNT), numThreads));
  if (m_tbbSchedulerInit)
  {
   // destroys all previous threads
   delete m_tbbSchedulerInit;
   m_tbbSchedulerInit = NULL;
  }
  m_tbbSchedulerInit = new tbb::task_scheduler_init(m_numThreads);
  m_savedThreadCounter = 0;
  if (m_isActive)
  {
   btResetThreadIndexCounter();
  }
 }
 struct BodyAdapter
 {
  const btIParallelForBody* mBody;

  void operator()(const tbb::blocked_range<int>& range) const
  {
   BT_PROFILE("TBB_job");
   mBody->forLoop(range.begin(), range.end());
  }
 };
 virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
 {
  BT_PROFILE("parallelFor_TBB");
  // TBB dispatch
  BodyAdapter tbbBody;
  tbbBody.mBody = &body;
  btPushThreadsAreRunning();
  tbb::parallel_for(tbb::blocked_range<int>(iBegin, iEnd, grainSize),
   tbbBody,
   tbb::simple_partitioner()
  );
  btPopThreadsAreRunning();
 }
};
#endif // #if BT_USE_TBB && BT_THREADSAFE


#if BT_USE_PPL && BT_THREADSAFE
///
/// btTaskSchedulerPPL -- wrapper around Microsoft Parallel Patterns Lib task scheduler
///
class btTaskSchedulerPPL : public btITaskScheduler
{
 int m_numThreads;
public:
 btTaskSchedulerPPL() : btITaskScheduler("PPL")
 {
  m_numThreads = 0;
 }
 virtual int getMaxNumThreads() const BT_OVERRIDE
 {
  return concurrency::GetProcessorCount();
 }
 virtual int getNumThreads() const BT_OVERRIDE
 {
  return m_numThreads;
 }
 virtual void setNumThreads(int numThreads) BT_OVERRIDE
 {
  // capping the thread count for PPL due to a thread-index issue
  const int maxThreadCount = (std::min)(int(BT_MAX_THREAD_COUNT), 31);
  m_numThreads = (std::max)(1, (std::min)(maxThreadCount, numThreads));
  using namespace concurrency;
  if (CurrentScheduler::Id() != -1)
  {
   CurrentScheduler::Detach();
  }
  SchedulerPolicy policy;
  {
   // PPL seems to destroy threads when threadpool is shrunk, but keeps reusing old threads
   // force it to destroy old threads
   policy.SetConcurrencyLimits(1, 1);
   CurrentScheduler::Create(policy);
   CurrentScheduler::Detach();
  }
  policy.SetConcurrencyLimits(m_numThreads, m_numThreads);
  CurrentScheduler::Create(policy);
  m_savedThreadCounter = 0;
  if (m_isActive)
  {
   btResetThreadIndexCounter();
  }
 }
 struct BodyAdapter
 {
  const btIParallelForBody* mBody;
  int mGrainSize;
  int mIndexEnd;

  void operator()(int i) const
  {
   BT_PROFILE("PPL_job");
   mBody->forLoop(i, (std::min)(i + mGrainSize, mIndexEnd));
  }
 };
 virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
 {
  BT_PROFILE("parallelFor_PPL");
  // PPL dispatch
  BodyAdapter pplBody;
  pplBody.mBody = &body;
  pplBody.mGrainSize = grainSize;
  pplBody.mIndexEnd = iEnd;
  btPushThreadsAreRunning();
  // note: MSVC 2010 doesn't support partitioner args, so avoid them
  concurrency::parallel_for(iBegin,
   iEnd,
   grainSize,
   pplBody
  );
  btPopThreadsAreRunning();
 }
};
#endif // #if BT_USE_PPL && BT_THREADSAFE


// create a non-threaded task scheduler (always available)
btITaskScheduler* btGetSequentialTaskScheduler()
{
 static btTaskSchedulerSequential sTaskScheduler;
 return &sTaskScheduler;
}


// create an OpenMP task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetOpenMPTaskScheduler()
{
#if BT_USE_OPENMP && BT_THREADSAFE
 static btTaskSchedulerOpenMP sTaskScheduler;
 return &sTaskScheduler;
#else
 return NULL;
#endif
}


// create an Intel TBB task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetTBBTaskScheduler()
{
#if BT_USE_TBB && BT_THREADSAFE
 static btTaskSchedulerTBB sTaskScheduler;
 return &sTaskScheduler;
#else
 return NULL;
#endif
}


// create a PPL task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetPPLTaskScheduler()
{
#if BT_USE_PPL && BT_THREADSAFE
 static btTaskSchedulerPPL sTaskScheduler;
 return &sTaskScheduler;
#else
 return NULL;
#endif
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
///b3DynamicBvh implementation by Nathanael Presson

#include "Bullet3Collision/BroadPhaseCollision/b3DynamicBvh.h"

//
typedef b3AlignedObjectArray<b3DbvtNode*>			b3NodeArray;
typedef b3AlignedObjectArray<const b3DbvtNode*>	b3ConstNodeArray;

//
struct b3DbvtNodeEnumerator : b3DynamicBvh::ICollide
{
 b3ConstNodeArray	nodes;
 void Process(const b3DbvtNode* n) { nodes.push_back(n); }
};

//
static B3_DBVT_INLINE int			b3IndexOf(const b3DbvtNode* node)
{
 return(node->parent->childs[1] == node);
}

//
static B3_DBVT_INLINE b3DbvtVolume	b3Merge(const b3DbvtVolume& a,
 const b3DbvtVolume& b)
{
#if (B3_DBVT_MERGE_IMPL==B3_DBVT_IMPL_SSE)
 B3_ATTRIBUTE_ALIGNED16(char locals[sizeof(b3DbvtAabbMm)]);
 b3DbvtVolume&	res = *(b3DbvtVolume*)locals;
#else
 b3DbvtVolume	res;
#endif
 b3Merge(a, b, res);
 return(res);
}

// volume+edge lengths
static B3_DBVT_INLINE b3Scalar		b3Size(const b3DbvtVolume& a)
{
 const b3Vector3	edges = a.Lengths();
 return(edges.x*edges.y*edges.z +
  edges.x + edges.y + edges.z);
}

//
static void						b3GetMaxDepth(const b3DbvtNode* node, int depth, int& maxdepth)
{
 if (node->isinternal())
 {
  b3GetMaxDepth(node->childs[0], depth + 1, maxdepth);
  b3GetMaxDepth(node->childs[1], depth + 1, maxdepth);
 }
 else maxdepth = b3Max(maxdepth, depth);
}

//
static B3_DBVT_INLINE void			b3DeleteNode(b3DynamicBvh* pdbvt,
 b3DbvtNode* node)
{
 b3AlignedFree(pdbvt->m_free);
 pdbvt->m_free = node;
}

//
static void						b3RecurseDeleteNode(b3DynamicBvh* pdbvt,
 b3DbvtNode* node)
{
 if (!node->isleaf())
 {
  b3RecurseDeleteNode(pdbvt, node->childs[0]);
  b3RecurseDeleteNode(pdbvt, node->childs[1]);
 }
 if (node == pdbvt->m_root) pdbvt->m_root = 0;
 b3DeleteNode(pdbvt, node);
}

//
static B3_DBVT_INLINE b3DbvtNode*	b3CreateNode(b3DynamicBvh* pdbvt,
 b3DbvtNode* parent,
 void* data)
{
 b3DbvtNode*	node;
 if (pdbvt->m_free)
 {
  node = pdbvt->m_free; pdbvt->m_free = 0;
 }
 else
 {
  node = new(b3AlignedAlloc(sizeof(b3DbvtNode), 16)) b3DbvtNode();
 }
 node->parent = parent;
 node->data = data;
 node->childs[1] = 0;
 return(node);
}

//
static B3_DBVT_INLINE b3DbvtNode*	b3CreateNode(b3DynamicBvh* pdbvt,
 b3DbvtNode* parent,
 const b3DbvtVolume& volume,
 void* data)
{
 b3DbvtNode*	node = b3CreateNode(pdbvt, parent, data);
 node->volume = volume;
 return(node);
}

//
static B3_DBVT_INLINE b3DbvtNode*	b3CreateNode(b3DynamicBvh* pdbvt,
 b3DbvtNode* parent,
 const b3DbvtVolume& volume0,
 const b3DbvtVolume& volume1,
 void* data)
{
 b3DbvtNode*	node = b3CreateNode(pdbvt, parent, data);
 b3Merge(volume0, volume1, node->volume);
 return(node);
}

//
static void						b3InsertLeaf(b3DynamicBvh* pdbvt,
 b3DbvtNode* root,
 b3DbvtNode* leaf)
{
 if (!pdbvt->m_root)
 {
  pdbvt->m_root = leaf;
  leaf->parent = 0;
 }
 else
 {
  if (!root->isleaf())
  {
   do {
    root = root->childs[b3Select(leaf->volume,
     root->childs[0]->volume,
     root->childs[1]->volume)];
   } while (!root->isleaf());
  }
  b3DbvtNode*	prev = root->parent;
  b3DbvtNode*	node = b3CreateNode(pdbvt, prev, leaf->volume, root->volume, 0);
  if (prev)
  {
   prev->childs[b3IndexOf(root)] = node;
   node->childs[0] = root; root->parent = node;
   node->childs[1] = leaf; leaf->parent = node;
   do {
    if (!prev->volume.Contain(node->volume))
     b3Merge(prev->childs[0]->volume, prev->childs[1]->volume, prev->volume);
    else
     break;
    node = prev;
   } while (0 != (prev = node->parent));
  }
  else
  {
   node->childs[0] = root; root->parent = node;
   node->childs[1] = leaf; leaf->parent = node;
   pdbvt->m_root = node;
  }
 }
}

//
static b3DbvtNode*				b3RemoveLeaf(b3DynamicBvh* pdbvt,
 b3DbvtNode* leaf)
{
 if (leaf == pdbvt->m_root)
 {
  pdbvt->m_root = 0;
  return(0);
 }
 else
 {
  b3DbvtNode*	parent = leaf->parent;
  b3DbvtNode*	prev = parent->parent;
  b3DbvtNode*	sibling = parent->childs[1 - b3IndexOf(leaf)];
  if (prev)
  {
   prev->childs[b3IndexOf(parent)] = sibling;
   sibling->parent = prev;
   b3DeleteNode(pdbvt, parent);
   while (prev)
   {
    const b3DbvtVolume	pb = prev->volume;
    b3Merge(prev->childs[0]->volume, prev->childs[1]->volume, prev->volume);
    if (b3NotEqual(pb, prev->volume))
    {
     prev = prev->parent;
    }
    else break;
   }
   return(prev ? prev : pdbvt->m_root);
  }
  else
  {
   pdbvt->m_root = sibling;
   sibling->parent = 0;
   b3DeleteNode(pdbvt, parent);
   return(pdbvt->m_root);
  }
 }
}

//
static void						b3FetchLeaves(b3DynamicBvh* pdbvt,
 b3DbvtNode* root,
 b3NodeArray& leaves,
 int depth = -1)
{
 if (root->isinternal() && depth)
 {
  b3FetchLeaves(pdbvt, root->childs[0], leaves, depth - 1);
  b3FetchLeaves(pdbvt, root->childs[1], leaves, depth - 1);
  b3DeleteNode(pdbvt, root);
 }
 else
 {
  leaves.push_back(root);
 }
}

static bool						b3LeftOfAxis(const b3DbvtNode* node,
 const b3Vector3& org,
 const b3Vector3& axis)
{
 return b3Dot(axis, node->volume.Center() - org) <= 0;
}

// Partitions leaves such that leaves[0, n) are on the
// left of axis, and leaves[n, count) are on the right
// of axis. returns N.
static int						b3Split(b3DbvtNode** leaves,
 int count,
 const b3Vector3& org,
 const b3Vector3& axis)
{
 int begin = 0;
 int end = count;
 for (;;)
 {
  while (begin != end && b3LeftOfAxis(leaves[begin], org, axis))
  {
   ++begin;
  }

  if (begin == end)
  {
   break;
  }

  while (begin != end && !b3LeftOfAxis(leaves[end - 1], org, axis))
  {
   --end;
  }

  if (begin == end)
  {
   break;
  }

  // swap out of place nodes
  --end;
  b3DbvtNode* temp = leaves[begin];
  leaves[begin] = leaves[end];
  leaves[end] = temp;
  ++begin;
 }

 return begin;
}

//
static b3DbvtVolume				b3Bounds(b3DbvtNode** leaves,
 int count)
{
#if B3_DBVT_MERGE_IMPL==B3_DBVT_IMPL_SSE
 B3_ATTRIBUTE_ALIGNED16(char	locals[sizeof(b3DbvtVolume)]);
 b3DbvtVolume&	volume = *(b3DbvtVolume*)locals;
 volume = leaves[0]->volume;
#else
 b3DbvtVolume volume = leaves[0]->volume;
#endif
 for (int i = 1, ni = count; i<ni; ++i)
 {
  b3Merge(volume, leaves[i]->volume, volume);
 }
 return(volume);
}

//
static void						b3BottomUp(b3DynamicBvh* pdbvt,
 b3DbvtNode** leaves,
 int count)
{
 while (count>1)
 {
  b3Scalar	minsize = B3_INFINITY;
  int			minidx[2] = { -1,-1 };
  for (int i = 0; i<count; ++i)
  {
   for (int j = i + 1; j<count; ++j)
   {
    const b3Scalar	sz = b3Size(b3Merge(leaves[i]->volume, leaves[j]->volume));
    if (sz<minsize)
    {
     minsize = sz;
     minidx[0] = i;
     minidx[1] = j;
    }
   }
  }
  b3DbvtNode*	n[] = { leaves[minidx[0]],leaves[minidx[1]] };
  b3DbvtNode*	p = b3CreateNode(pdbvt, 0, n[0]->volume, n[1]->volume, 0);
  p->childs[0] = n[0];
  p->childs[1] = n[1];
  n[0]->parent = p;
  n[1]->parent = p;
  leaves[minidx[0]] = p;
  leaves[minidx[1]] = leaves[count - 1];
  --count;
 }
}

//
static b3DbvtNode*			b3TopDown(b3DynamicBvh* pdbvt,
 b3DbvtNode** leaves,
 int count,
 int bu_treshold)
{
 static const b3Vector3	axis[] = { b3MakeVector3(1,0,0),
  b3MakeVector3(0,1,0),
  b3MakeVector3(0,0,1) };
 b3Assert(bu_treshold>1);
 if (count>1)
 {
  if (count>bu_treshold)
  {
   const b3DbvtVolume	vol = b3Bounds(leaves, count);
   const b3Vector3			org = vol.Center();
   int						partition;
   int						bestaxis = -1;
   int						bestmidp = count;
   int						splitcount[3][2] = { { 0,0 },{ 0,0 },{ 0,0 } };
   int i;
   for (i = 0; i<count; ++i)
   {
    const b3Vector3	x = leaves[i]->volume.Center() - org;
    for (int j = 0; j<3; ++j)
    {
     ++splitcount[j][b3Dot(x, axis[j])>0 ? 1 : 0];
    }
   }
   for (i = 0; i<3; ++i)
   {
    if ((splitcount[i][0]>0) && (splitcount[i][1]>0))
    {
     const int	midp = (int)b3Fabs(b3Scalar(splitcount[i][0] - splitcount[i][1]));
     if (midp<bestmidp)
     {
      bestaxis = i;
      bestmidp = midp;
     }
    }
   }
   if (bestaxis >= 0)
   {
    partition = b3Split(leaves, count, org, axis[bestaxis]);
    b3Assert(partition != 0 && partition != count);
   }
   else
   {
    partition = count / 2 + 1;
   }
   b3DbvtNode*	node = b3CreateNode(pdbvt, 0, vol, 0);
   node->childs[0] = b3TopDown(pdbvt, &leaves[0], partition, bu_treshold);
   node->childs[1] = b3TopDown(pdbvt, &leaves[partition], count - partition, bu_treshold);
   node->childs[0]->parent = node;
   node->childs[1]->parent = node;
   return(node);
  }
  else
  {
   b3BottomUp(pdbvt, leaves, count);
   return(leaves[0]);
  }
 }
 return(leaves[0]);
}

//
static B3_DBVT_INLINE b3DbvtNode*	b3Sort(b3DbvtNode* n, b3DbvtNode*& r)
{
 b3DbvtNode*	p = n->parent;
 b3Assert(n->isinternal());
 if (p>n)
 {
  const int		i = b3IndexOf(n);
  const int		j = 1 - i;
  b3DbvtNode*	s = p->childs[j];
  b3DbvtNode*	q = p->parent;
  b3Assert(n == p->childs[i]);
  if (q) q->childs[b3IndexOf(p)] = n; else r = n;
  s->parent = n;
  p->parent = n;
  n->parent = q;
  p->childs[0] = n->childs[0];
  p->childs[1] = n->childs[1];
  n->childs[0]->parent = p;
  n->childs[1]->parent = p;
  n->childs[i] = p;
  n->childs[j] = s;
  b3Swap(p->volume, n->volume);
  return(p);
 }
 return(n);
}

#if 0
static B3_DBVT_INLINE b3DbvtNode*	walkup(b3DbvtNode* n, int count)
{
 while (n && (count--)) n = n->parent;
 return(n);
}
#endif

//
// Api
//

//
b3DynamicBvh::b3DynamicBvh()
{
 m_root = 0;
 m_free = 0;
 m_lkhd = -1;
 m_leaves = 0;
 m_opath = 0;
}

//
b3DynamicBvh::~b3DynamicBvh()
{
 clear();
}

//
void			b3DynamicBvh::clear()
{
 if (m_root)
  b3RecurseDeleteNode(this, m_root);
 b3AlignedFree(m_free);
 m_free = 0;
 m_lkhd = -1;
 m_stkStack.clear();
 m_opath = 0;

}

//
void			b3DynamicBvh::optimizeBottomUp()
{
 if (m_root)
 {
  b3NodeArray leaves;
  leaves.reserve(m_leaves);
  b3FetchLeaves(this, m_root, leaves);
  b3BottomUp(this, &leaves[0], leaves.size());
  m_root = leaves[0];
 }
}

//
void			b3DynamicBvh::optimizeTopDown(int bu_treshold)
{
 if (m_root)
 {
  b3NodeArray	leaves;
  leaves.reserve(m_leaves);
  b3FetchLeaves(this, m_root, leaves);
  m_root = b3TopDown(this, &leaves[0], leaves.size(), bu_treshold);
 }
}

//
void			b3DynamicBvh::optimizeIncremental(int passes)
{
 if (passes<0) passes = m_leaves;
 if (m_root && (passes>0))
 {
  do {
   b3DbvtNode*		node = m_root;
   unsigned	bit = 0;
   while (node->isinternal())
   {
    node = b3Sort(node, m_root)->childs[(m_opath >> bit) & 1];
    bit = (bit + 1)&(sizeof(unsigned) * 8 - 1);
   }
   update(node);
   ++m_opath;
  } while (--passes);
 }
}

//
b3DbvtNode*	b3DynamicBvh::insert(const b3DbvtVolume& volume, void* data)
{
 b3DbvtNode*	leaf = b3CreateNode(this, 0, volume, data);
 b3InsertLeaf(this, m_root, leaf);
 ++m_leaves;
 return(leaf);
}

//
void			b3DynamicBvh::update(b3DbvtNode* leaf, int lookahead)
{
 b3DbvtNode*	root = b3RemoveLeaf(this, leaf);
 if (root)
 {
  if (lookahead >= 0)
  {
   for (int i = 0; (i<lookahead) && root->parent; ++i)
   {
    root = root->parent;
   }
  }
  else root = m_root;
 }
 b3InsertLeaf(this, root, leaf);
}

//
void			b3DynamicBvh::update(b3DbvtNode* leaf, b3DbvtVolume& volume)
{
 b3DbvtNode*	root = b3RemoveLeaf(this, leaf);
 if (root)
 {
  if (m_lkhd >= 0)
  {
   for (int i = 0; (i<m_lkhd) && root->parent; ++i)
   {
    root = root->parent;
   }
  }
  else root = m_root;
 }
 leaf->volume = volume;
 b3InsertLeaf(this, root, leaf);
}

//
bool			b3DynamicBvh::update(b3DbvtNode* leaf, b3DbvtVolume& volume, const b3Vector3& velocity, b3Scalar margin)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.Expand(b3MakeVector3(margin, margin, margin));
 volume.SignedExpand(velocity);
 update(leaf, volume);
 return(true);
}

//
bool			b3DynamicBvh::update(b3DbvtNode* leaf, b3DbvtVolume& volume, const b3Vector3& velocity)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.SignedExpand(velocity);
 update(leaf, volume);
 return(true);
}

//
bool			b3DynamicBvh::update(b3DbvtNode* leaf, b3DbvtVolume& volume, b3Scalar margin)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.Expand(b3MakeVector3(margin, margin, margin));
 update(leaf, volume);
 return(true);
}

//
void			b3DynamicBvh::remove(b3DbvtNode* leaf)
{
 b3RemoveLeaf(this, leaf);
 b3DeleteNode(this, leaf);
 --m_leaves;
}

//
void			b3DynamicBvh::write(IWriter* iwriter) const
{
 b3DbvtNodeEnumerator	nodes;
 nodes.nodes.reserve(m_leaves * 2);
 enumNodes(m_root, nodes);
 iwriter->Prepare(m_root, nodes.nodes.size());
 for (int i = 0; i<nodes.nodes.size(); ++i)
 {
  const b3DbvtNode* n = nodes.nodes[i];
  int			p = -1;
  if (n->parent) p = nodes.nodes.findLinearSearch(n->parent);
  if (n->isinternal())
  {
   const int	c0 = nodes.nodes.findLinearSearch(n->childs[0]);
   const int	c1 = nodes.nodes.findLinearSearch(n->childs[1]);
   iwriter->WriteNode(n, i, p, c0, c1);
  }
  else
  {
   iwriter->WriteLeaf(n, i, p);
  }
 }
}

//
void			b3DynamicBvh::clone(b3DynamicBvh& dest, IClone* iclone) const
{
 dest.clear();
 if (m_root != 0)
 {
  b3AlignedObjectArray<sStkCLN>	stack;
  stack.reserve(m_leaves);
  stack.push_back(sStkCLN(m_root, 0));
  do {
   const int		i = stack.size() - 1;
   const sStkCLN	e = stack[i];
   b3DbvtNode*			n = b3CreateNode(&dest, e.parent, e.node->volume, e.node->data);
   stack.pop_back();
   if (e.parent != 0)
    e.parent->childs[i & 1] = n;
   else
    dest.m_root = n;
   if (e.node->isinternal())
   {
    stack.push_back(sStkCLN(e.node->childs[0], n));
    stack.push_back(sStkCLN(e.node->childs[1], n));
   }
   else
   {
    iclone->CloneLeaf(n);
   }
  } while (stack.size()>0);
 }
}

//
int				b3DynamicBvh::maxdepth(const b3DbvtNode* node)
{
 int	depth = 0;
 if (node) b3GetMaxDepth(node, 1, depth);
 return(depth);
}

//
int				b3DynamicBvh::countLeaves(const b3DbvtNode* node)
{
 if (node->isinternal())
  return(countLeaves(node->childs[0]) + countLeaves(node->childs[1]));
 else
  return(1);
}

//
void			b3DynamicBvh::extractLeaves(const b3DbvtNode* node, b3AlignedObjectArray<const b3DbvtNode*>& leaves)
{
 if (node->isinternal())
 {
  extractLeaves(node->childs[0], leaves);
  extractLeaves(node->childs[1], leaves);
 }
 else
 {
  leaves.push_back(node);
 }
}

//
#if B3_DBVT_ENABLE_BENCHMARK

#include <stdio.h>
#include <stdlib.h>


/*
q6600,2.4ghz

/Ox /Ob2 /Oi /Ot /I "." /I "..\.." /I "..\..\src" /D "NDEBUG" /D "_LIB" /D "_WINDOWS" /D "_CRT_SECURE_NO_DEPRECATE" /D "_CRT_NONSTDC_NO_DEPRECATE" /D "WIN32"
/GF /FD /MT /GS- /Gy /arch:SSE2 /Zc:wchar_t- /Fp"..\..\out\release8\build\libbulletcollision\libbulletcollision.pch"
/Fo"..\..\out\release8\build\libbulletcollision\\"
/Fd"..\..\out\release8\build\libbulletcollision\bulletcollision.pdb"
/W3 /nologo /c /Wp64 /Zi /errorReport:prompt

Benchmarking dbvt...
World scale: 100.000000
Extents base: 1.000000
Extents range: 4.000000
Leaves: 8192
sizeof(b3DbvtVolume): 32 bytes
sizeof(b3DbvtNode):   44 bytes
[1] b3DbvtVolume intersections: 3499 ms (-1%)
[2] b3DbvtVolume merges: 1934 ms (0%)
[3] b3DynamicBvh::collideTT: 5485 ms (-21%)
[4] b3DynamicBvh::collideTT self: 2814 ms (-20%)
[5] b3DynamicBvh::collideTT xform: 7379 ms (-1%)
[6] b3DynamicBvh::collideTT xform,self: 7270 ms (-2%)
[7] b3DynamicBvh::rayTest: 6314 ms (0%),(332143 r/s)
[8] insert/remove: 2093 ms (0%),(1001983 ir/s)
[9] updates (teleport): 1879 ms (-3%),(1116100 u/s)
[10] updates (jitter): 1244 ms (-4%),(1685813 u/s)
[11] optimize (incremental): 2514 ms (0%),(1668000 o/s)
[12] b3DbvtVolume notequal: 3659 ms (0%)
[13] culling(OCL+fullsort): 2218 ms (0%),(461 t/s)
[14] culling(OCL+qsort): 3688 ms (5%),(2221 t/s)
[15] culling(KDOP+qsort): 1139 ms (-1%),(7192 t/s)
[16] insert/remove batch(256): 5092 ms (0%),(823704 bir/s)
[17] b3DbvtVolume select: 3419 ms (0%)
*/

struct b3DbvtBenchmark
{
 struct NilPolicy : b3DynamicBvh::ICollide
 {
  NilPolicy() : m_pcount(0), m_depth(-B3_INFINITY), m_checksort(true) {}
  void	Process(const b3DbvtNode*, const b3DbvtNode*) { ++m_pcount; }
  void	Process(const b3DbvtNode*) { ++m_pcount; }
  void	Process(const b3DbvtNode*, b3Scalar depth)
  {
   ++m_pcount;
   if (m_checksort)
   {
    if (depth >= m_depth) m_depth = depth; else printf("wrong depth: %f (should be >= %f)\r\n", depth, m_depth);
   }
  }
  int			m_pcount;
  b3Scalar	m_depth;
  bool		m_checksort;
 };
 struct P14 : b3DynamicBvh::ICollide
 {
  struct Node
  {
   const b3DbvtNode*	leaf;
   b3Scalar			depth;
  };
  void Process(const b3DbvtNode* leaf, b3Scalar depth)
  {
   Node	n;
   n.leaf = leaf;
   n.depth = depth;
  }
  static int sortfnc(const Node& a, const Node& b)
  {
   if (a.depth<b.depth) return(+1);
   if (a.depth>b.depth) return(-1);
   return(0);
  }
  b3AlignedObjectArray<Node>		m_nodes;
 };
 struct P15 : b3DynamicBvh::ICollide
 {
  struct Node
  {
   const b3DbvtNode*	leaf;
   b3Scalar			depth;
  };
  void Process(const b3DbvtNode* leaf)
  {
   Node	n;
   n.leaf = leaf;
   n.depth = dot(leaf->volume.Center(), m_axis);
  }
  static int sortfnc(const Node& a, const Node& b)
  {
   if (a.depth<b.depth) return(+1);
   if (a.depth>b.depth) return(-1);
   return(0);
  }
  b3AlignedObjectArray<Node>		m_nodes;
  b3Vector3						m_axis;
 };
 static b3Scalar			RandUnit()
 {
  return(rand() / (b3Scalar)RAND_MAX);
 }
 static b3Vector3		RandVector3()
 {
  return(b3Vector3(RandUnit(), RandUnit(), RandUnit()));
 }
 static b3Vector3		RandVector3(b3Scalar cs)
 {
  return(RandVector3()*cs - b3Vector3(cs, cs, cs) / 2);
 }
 static b3DbvtVolume	RandVolume(b3Scalar cs, b3Scalar eb, b3Scalar es)
 {
  return(b3DbvtVolume::FromCE(RandVector3(cs), b3Vector3(eb, eb, eb) + RandVector3()*es));
 }
 static b3Transform		RandTransform(b3Scalar cs)
 {
  b3Transform	t;
  t.setOrigin(RandVector3(cs));
  t.setRotation(b3Quaternion(RandUnit()*B3_PI * 2, RandUnit()*B3_PI * 2, RandUnit()*B3_PI * 2).normalized());
  return(t);
 }
 static void				RandTree(b3Scalar cs, b3Scalar eb, b3Scalar es, int leaves, b3DynamicBvh& dbvt)
 {
  dbvt.clear();
  for (int i = 0; i<leaves; ++i)
  {
   dbvt.insert(RandVolume(cs, eb, es), 0);
  }
 }
};

void			b3DynamicBvh::benchmark()
{
 static const b3Scalar	cfgVolumeCenterScale = 100;
 static const b3Scalar	cfgVolumeExentsBase = 1;
 static const b3Scalar	cfgVolumeExentsScale = 4;
 static const int		cfgLeaves = 8192;
 static const bool		cfgEnable = true;

 //[1] b3DbvtVolume intersections
 bool					cfgBenchmark1_Enable = cfgEnable;
 static const int		cfgBenchmark1_Iterations = 8;
 static const int		cfgBenchmark1_Reference = 3499;
 //[2] b3DbvtVolume merges
 bool					cfgBenchmark2_Enable = cfgEnable;
 static const int		cfgBenchmark2_Iterations = 4;
 static const int		cfgBenchmark2_Reference = 1945;
 //[3] b3DynamicBvh::collideTT
 bool					cfgBenchmark3_Enable = cfgEnable;
 static const int		cfgBenchmark3_Iterations = 512;
 static const int		cfgBenchmark3_Reference = 5485;
 //[4] b3DynamicBvh::collideTT self
 bool					cfgBenchmark4_Enable = cfgEnable;
 static const int		cfgBenchmark4_Iterations = 512;
 static const int		cfgBenchmark4_Reference = 2814;
 //[5] b3DynamicBvh::collideTT xform
 bool					cfgBenchmark5_Enable = cfgEnable;
 static const int		cfgBenchmark5_Iterations = 512;
 static const b3Scalar	cfgBenchmark5_OffsetScale = 2;
 static const int		cfgBenchmark5_Reference = 7379;
 //[6] b3DynamicBvh::collideTT xform,self
 bool					cfgBenchmark6_Enable = cfgEnable;
 static const int		cfgBenchmark6_Iterations = 512;
 static const b3Scalar	cfgBenchmark6_OffsetScale = 2;
 static const int		cfgBenchmark6_Reference = 7270;
 //[7] b3DynamicBvh::rayTest
 bool					cfgBenchmark7_Enable = cfgEnable;
 static const int		cfgBenchmark7_Passes = 32;
 static const int		cfgBenchmark7_Iterations = 65536;
 static const int		cfgBenchmark7_Reference = 6307;
 //[8] insert/remove
 bool					cfgBenchmark8_Enable = cfgEnable;
 static const int		cfgBenchmark8_Passes = 32;
 static const int		cfgBenchmark8_Iterations = 65536;
 static const int		cfgBenchmark8_Reference = 2105;
 //[9] updates (teleport)
 bool					cfgBenchmark9_Enable = cfgEnable;
 static const int		cfgBenchmark9_Passes = 32;
 static const int		cfgBenchmark9_Iterations = 65536;
 static const int		cfgBenchmark9_Reference = 1879;
 //[10] updates (jitter)
 bool					cfgBenchmark10_Enable = cfgEnable;
 static const b3Scalar	cfgBenchmark10_Scale = cfgVolumeCenterScale / 10000;
 static const int		cfgBenchmark10_Passes = 32;
 static const int		cfgBenchmark10_Iterations = 65536;
 static const int		cfgBenchmark10_Reference = 1244;
 //[11] optimize (incremental)
 bool					cfgBenchmark11_Enable = cfgEnable;
 static const int		cfgBenchmark11_Passes = 64;
 static const int		cfgBenchmark11_Iterations = 65536;
 static const int		cfgBenchmark11_Reference = 2510;
 //[12] b3DbvtVolume notequal
 bool					cfgBenchmark12_Enable = cfgEnable;
 static const int		cfgBenchmark12_Iterations = 32;
 static const int		cfgBenchmark12_Reference = 3677;
 //[13] culling(OCL+fullsort)
 bool					cfgBenchmark13_Enable = cfgEnable;
 static const int		cfgBenchmark13_Iterations = 1024;
 static const int		cfgBenchmark13_Reference = 2231;
 //[14] culling(OCL+qsort)
 bool					cfgBenchmark14_Enable = cfgEnable;
 static const int		cfgBenchmark14_Iterations = 8192;
 static const int		cfgBenchmark14_Reference = 3500;
 //[15] culling(KDOP+qsort)
 bool					cfgBenchmark15_Enable = cfgEnable;
 static const int		cfgBenchmark15_Iterations = 8192;
 static const int		cfgBenchmark15_Reference = 1151;
 //[16] insert/remove batch
 bool					cfgBenchmark16_Enable = cfgEnable;
 static const int		cfgBenchmark16_BatchCount = 256;
 static const int		cfgBenchmark16_Passes = 16384;
 static const int		cfgBenchmark16_Reference = 5138;
 //[17] select
 bool					cfgBenchmark17_Enable = cfgEnable;
 static const int		cfgBenchmark17_Iterations = 4;
 static const int		cfgBenchmark17_Reference = 3390;

 b3Clock					wallclock;
 printf("Benchmarking dbvt...\r\n");
 printf("\tWorld scale: %f\r\n", cfgVolumeCenterScale);
 printf("\tExtents base: %f\r\n", cfgVolumeExentsBase);
 printf("\tExtents range: %f\r\n", cfgVolumeExentsScale);
 printf("\tLeaves: %u\r\n", cfgLeaves);
 printf("\tsizeof(b3DbvtVolume): %u bytes\r\n", sizeof(b3DbvtVolume));
 printf("\tsizeof(b3DbvtNode):   %u bytes\r\n", sizeof(b3DbvtNode));
 if (cfgBenchmark1_Enable)
 {// Benchmark 1	
  srand(380843);
  b3AlignedObjectArray<b3DbvtVolume>	volumes;
  b3AlignedObjectArray<bool>			results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[1] b3DbvtVolume intersections: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark1_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     results[k] = Intersect(volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark1_Reference) * 100 / time);
 }
 if (cfgBenchmark2_Enable)
 {// Benchmark 2	
  srand(380843);
  b3AlignedObjectArray<b3DbvtVolume>	volumes;
  b3AlignedObjectArray<b3DbvtVolume>	results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[2] b3DbvtVolume merges: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark2_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     Merge(volumes[j], volumes[k], results[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark2_Reference) * 100 / time);
 }
 if (cfgBenchmark3_Enable)
 {// Benchmark 3	
  srand(380843);
  b3DynamicBvh						dbvt[2];
  b3DbvtBenchmark::NilPolicy	policy;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[0]);
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[1]);
  dbvt[0].optimizeTopDown();
  dbvt[1].optimizeTopDown();
  printf("[3] b3DynamicBvh::collideTT: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark3_Iterations; ++i)
  {
   b3DynamicBvh::collideTT(dbvt[0].m_root, dbvt[1].m_root, policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark3_Reference) * 100 / time);
 }
 if (cfgBenchmark4_Enable)
 {// Benchmark 4
  srand(380843);
  b3DynamicBvh						dbvt;
  b3DbvtBenchmark::NilPolicy	policy;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[4] b3DynamicBvh::collideTT self: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark4_Iterations; ++i)
  {
   b3DynamicBvh::collideTT(dbvt.m_root, dbvt.m_root, policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark4_Reference) * 100 / time);
 }
 if (cfgBenchmark5_Enable)
 {// Benchmark 5	
  srand(380843);
  b3DynamicBvh								dbvt[2];
  b3AlignedObjectArray<b3Transform>	transforms;
  b3DbvtBenchmark::NilPolicy			policy;
  transforms.resize(cfgBenchmark5_Iterations);
  for (int i = 0; i<transforms.size(); ++i)
  {
   transforms[i] = b3DbvtBenchmark::RandTransform(cfgVolumeCenterScale*cfgBenchmark5_OffsetScale);
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[0]);
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[1]);
  dbvt[0].optimizeTopDown();
  dbvt[1].optimizeTopDown();
  printf("[5] b3DynamicBvh::collideTT xform: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark5_Iterations; ++i)
  {
   b3DynamicBvh::collideTT(dbvt[0].m_root, dbvt[1].m_root, transforms[i], policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark5_Reference) * 100 / time);
 }
 if (cfgBenchmark6_Enable)
 {// Benchmark 6	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3Transform>	transforms;
  b3DbvtBenchmark::NilPolicy			policy;
  transforms.resize(cfgBenchmark6_Iterations);
  for (int i = 0; i<transforms.size(); ++i)
  {
   transforms[i] = b3DbvtBenchmark::RandTransform(cfgVolumeCenterScale*cfgBenchmark6_OffsetScale);
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[6] b3DynamicBvh::collideTT xform,self: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark6_Iterations; ++i)
  {
   b3DynamicBvh::collideTT(dbvt.m_root, dbvt.m_root, transforms[i], policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark6_Reference) * 100 / time);
 }
 if (cfgBenchmark7_Enable)
 {// Benchmark 7	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3Vector3>		rayorg;
  b3AlignedObjectArray<b3Vector3>		raydir;
  b3DbvtBenchmark::NilPolicy			policy;
  rayorg.resize(cfgBenchmark7_Iterations);
  raydir.resize(cfgBenchmark7_Iterations);
  for (int i = 0; i<rayorg.size(); ++i)
  {
   rayorg[i] = b3DbvtBenchmark::RandVector3(cfgVolumeCenterScale * 2);
   raydir[i] = b3DbvtBenchmark::RandVector3(cfgVolumeCenterScale * 2);
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[7] b3DynamicBvh::rayTest: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark7_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark7_Iterations; ++j)
   {
    b3DynamicBvh::rayTest(dbvt.m_root, rayorg[j], rayorg[j] + raydir[j], policy);
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  unsigned	rays = cfgBenchmark7_Passes*cfgBenchmark7_Iterations;
  printf("%u ms (%i%%),(%u r/s)\r\n", time, (time - cfgBenchmark7_Reference) * 100 / time, (rays * 1000) / time);
 }
 if (cfgBenchmark8_Enable)
 {// Benchmark 8	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[8] insert/remove: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark8_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark8_Iterations; ++j)
   {
    dbvt.remove(dbvt.insert(b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale), 0));
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	ir = cfgBenchmark8_Passes*cfgBenchmark8_Iterations;
  printf("%u ms (%i%%),(%u ir/s)\r\n", time, (time - cfgBenchmark8_Reference) * 100 / time, ir * 1000 / time);
 }
 if (cfgBenchmark9_Enable)
 {// Benchmark 9	
  srand(380843);
  b3DynamicBvh										dbvt;
  b3AlignedObjectArray<const b3DbvtNode*>	leaves;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  dbvt.extractLeaves(dbvt.m_root, leaves);
  printf("[9] updates (teleport): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark9_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark9_Iterations; ++j)
   {
    dbvt.update(const_cast<b3DbvtNode*>(leaves[rand() % cfgLeaves]),
     b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale));
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	up = cfgBenchmark9_Passes*cfgBenchmark9_Iterations;
  printf("%u ms (%i%%),(%u u/s)\r\n", time, (time - cfgBenchmark9_Reference) * 100 / time, up * 1000 / time);
 }
 if (cfgBenchmark10_Enable)
 {// Benchmark 10	
  srand(380843);
  b3DynamicBvh										dbvt;
  b3AlignedObjectArray<const b3DbvtNode*>	leaves;
  b3AlignedObjectArray<b3Vector3>				vectors;
  vectors.resize(cfgBenchmark10_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (b3DbvtBenchmark::RandVector3() * 2 - b3Vector3(1, 1, 1))*cfgBenchmark10_Scale;
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  dbvt.extractLeaves(dbvt.m_root, leaves);
  printf("[10] updates (jitter): ");
  wallclock.reset();

  for (int i = 0; i<cfgBenchmark10_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark10_Iterations; ++j)
   {
    const b3Vector3&	d = vectors[j];
    b3DbvtNode*		l = const_cast<b3DbvtNode*>(leaves[rand() % cfgLeaves]);
    b3DbvtVolume		v = b3DbvtVolume::FromMM(l->volume.Mins() + d, l->volume.Maxs() + d);
    dbvt.update(l, v);
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	up = cfgBenchmark10_Passes*cfgBenchmark10_Iterations;
  printf("%u ms (%i%%),(%u u/s)\r\n", time, (time - cfgBenchmark10_Reference) * 100 / time, up * 1000 / time);
 }
 if (cfgBenchmark11_Enable)
 {// Benchmark 11	
  srand(380843);
  b3DynamicBvh										dbvt;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[11] optimize (incremental): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark11_Passes; ++i)
  {
   dbvt.optimizeIncremental(cfgBenchmark11_Iterations);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	op = cfgBenchmark11_Passes*cfgBenchmark11_Iterations;
  printf("%u ms (%i%%),(%u o/s)\r\n", time, (time - cfgBenchmark11_Reference) * 100 / time, op / time * 1000);
 }
 if (cfgBenchmark12_Enable)
 {// Benchmark 12	
  srand(380843);
  b3AlignedObjectArray<b3DbvtVolume>	volumes;
  b3AlignedObjectArray<bool>				results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[12] b3DbvtVolume notequal: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark12_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     results[k] = NotEqual(volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark12_Reference) * 100 / time);
 }
 if (cfgBenchmark13_Enable)
 {// Benchmark 13	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3Vector3>		vectors;
  b3DbvtBenchmark::NilPolicy			policy;
  vectors.resize(cfgBenchmark13_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (b3DbvtBenchmark::RandVector3() * 2 - b3Vector3(1, 1, 1)).normalized();
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[13] culling(OCL+fullsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark13_Iterations; ++i)
  {
   static const b3Scalar	offset = 0;
   policy.m_depth = -B3_INFINITY;
   dbvt.collideOCL(dbvt.m_root, &vectors[i], &offset, vectors[i], 1, policy);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark13_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark13_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark14_Enable)
 {// Benchmark 14	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3Vector3>		vectors;
  b3DbvtBenchmark::P14				policy;
  vectors.resize(cfgBenchmark14_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (b3DbvtBenchmark::RandVector3() * 2 - b3Vector3(1, 1, 1)).normalized();
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  policy.m_nodes.reserve(cfgLeaves);
  printf("[14] culling(OCL+qsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark14_Iterations; ++i)
  {
   static const b3Scalar	offset = 0;
   policy.m_nodes.resize(0);
   dbvt.collideOCL(dbvt.m_root, &vectors[i], &offset, vectors[i], 1, policy, false);
   policy.m_nodes.quickSort(b3DbvtBenchmark::P14::sortfnc);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark14_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark14_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark15_Enable)
 {// Benchmark 15	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3Vector3>		vectors;
  b3DbvtBenchmark::P15				policy;
  vectors.resize(cfgBenchmark15_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (b3DbvtBenchmark::RandVector3() * 2 - b3Vector3(1, 1, 1)).normalized();
  }
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  policy.m_nodes.reserve(cfgLeaves);
  printf("[15] culling(KDOP+qsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark15_Iterations; ++i)
  {
   static const b3Scalar	offset = 0;
   policy.m_nodes.resize(0);
   policy.m_axis = vectors[i];
   dbvt.collideKDOP(dbvt.m_root, &vectors[i], &offset, 1, policy);
   policy.m_nodes.quickSort(b3DbvtBenchmark::P15::sortfnc);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark15_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark15_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark16_Enable)
 {// Benchmark 16	
  srand(380843);
  b3DynamicBvh								dbvt;
  b3AlignedObjectArray<b3DbvtNode*>	batch;
  b3DbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  batch.reserve(cfgBenchmark16_BatchCount);
  printf("[16] insert/remove batch(%u): ", cfgBenchmark16_BatchCount);
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark16_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark16_BatchCount; ++j)
   {
    batch.push_back(dbvt.insert(b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale), 0));
   }
   for (int j = 0; j<cfgBenchmark16_BatchCount; ++j)
   {
    dbvt.remove(batch[j]);
   }
   batch.resize(0);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	ir = cfgBenchmark16_Passes*cfgBenchmark16_BatchCount;
  printf("%u ms (%i%%),(%u bir/s)\r\n", time, (time - cfgBenchmark16_Reference) * 100 / time, int(ir*1000.0 / time));
 }
 if (cfgBenchmark17_Enable)
 {// Benchmark 17
  srand(380843);
  b3AlignedObjectArray<b3DbvtVolume>	volumes;
  b3AlignedObjectArray<int>			results;
  b3AlignedObjectArray<int>			indices;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  indices.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   indices[i] = i;
   volumes[i] = b3DbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  for (int i = 0; i<cfgLeaves; ++i)
  {
   b3Swap(indices[i], indices[rand() % cfgLeaves]);
  }
  printf("[17] b3DbvtVolume select: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark17_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     const int idx = indices[k];
     results[idx] = Select(volumes[idx], volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark17_Reference) * 100 / time);
 }
 printf("\r\n\r\n");
}
#endif 

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///b3DynamicBvhBroadphase implementation by Nathanael Presson

#include "Bullet3Collision/BroadPhaseCollision/b3DynamicBvhBroadphase.h"
#include "Bullet3Collision/BroadPhaseCollision/b3OverlappingPair.h"

//
// Profiling
//

#if B3_DBVT_BP_PROFILE||B3_DBVT_BP_ENABLE_BENCHMARK
#include <stdio.h>
#endif

#if B3_DBVT_BP_PROFILE
struct	b3ProfileScope
{
 __forceinline b3ProfileScope(b3Clock& clock, unsigned long& value) :
  m_clock(&clock), m_value(&value), m_base(clock.getTimeMicroseconds())
 {
 }
 __forceinline ~b3ProfileScope()
 {
  (*m_value) += m_clock->getTimeMicroseconds() - m_base;
 }
 b3Clock*		m_clock;
 unsigned long*	m_value;
 unsigned long	m_base;
};
#define	b3SPC(_value_)	b3ProfileScope	spc_scope(m_clock,_value_)
#else
#define	b3SPC(_value_)
#endif

//
// Helpers
//

//
template <typename T>
static inline void	b3ListAppend(T* item, T*& list)
{
 item->links[0] = 0;
 item->links[1] = list;
 if (list) list->links[0] = item;
 list = item;
}

//
template <typename T>
static inline void	b3ListRemove(T* item, T*& list)
{
 if (item->links[0]) item->links[0]->links[1] = item->links[1]; else list = item->links[1];
 if (item->links[1]) item->links[1]->links[0] = item->links[0];
}

//
template <typename T>
static inline int	b3ListCount(T* root)
{
 int	n = 0;
 while (root) { ++n; root = root->links[1]; }
 return(n);
}

//
template <typename T>
static inline void	b3Clear(T& value)
{
 static const struct ZeroDummy : T {} zerodummy;
 value = zerodummy;
}

//
// Colliders
//

/* Tree collider	*/
struct	b3DbvtTreeCollider : b3DynamicBvh::ICollide
{
 b3DynamicBvhBroadphase*	pbp;
 b3DbvtProxy*		proxy;
 b3DbvtTreeCollider(b3DynamicBvhBroadphase* p) : pbp(p) {}
 void	Process(const b3DbvtNode* na, const b3DbvtNode* nb)
 {
  if (na != nb)
  {
   b3DbvtProxy*	pa = (b3DbvtProxy*)na->data;
   b3DbvtProxy*	pb = (b3DbvtProxy*)nb->data;
#if B3_DBVT_BP_SORTPAIRS
   if (pa->m_uniqueId>pb->m_uniqueId)
    b3Swap(pa, pb);
#endif
   pbp->m_paircache->addOverlappingPair(pa->getUid(), pb->getUid());
   ++pbp->m_newpairs;
  }
 }
 void	Process(const b3DbvtNode* n)
 {
  Process(n, proxy->leaf);
 }
};

//
// b3DynamicBvhBroadphase
//

//
b3DynamicBvhBroadphase::b3DynamicBvhBroadphase(int proxyCapacity, b3OverlappingPairCache* paircache)
{
 m_deferedcollide = false;
 m_needcleanup = true;
 m_releasepaircache = (paircache != 0) ? false : true;
 m_prediction = 0;
 m_stageCurrent = 0;
 m_fixedleft = 0;
 m_fupdates = 1;
 m_dupdates = 0;
 m_cupdates = 10;
 m_newpairs = 1;
 m_updates_call = 0;
 m_updates_done = 0;
 m_updates_ratio = 0;
 m_paircache = paircache ? paircache : new(b3AlignedAlloc(sizeof(b3HashedOverlappingPairCache), 16)) b3HashedOverlappingPairCache();

 m_pid = 0;
 m_cid = 0;
 for (int i = 0; i <= STAGECOUNT; ++i)
 {
  m_stageRoots[i] = 0;
 }
#if B3_DBVT_BP_PROFILE
 b3Clear(m_profiling);
#endif
 m_proxies.resize(proxyCapacity);
}

//
b3DynamicBvhBroadphase::~b3DynamicBvhBroadphase()
{
 if (m_releasepaircache)
 {
  m_paircache->~b3OverlappingPairCache();
  b3AlignedFree(m_paircache);
 }
}

//
b3BroadphaseProxy*				b3DynamicBvhBroadphase::createProxy(const b3Vector3& aabbMin,
 const b3Vector3& aabbMax,
 int objectId,
 void* userPtr,
 int collisionFilterGroup,
 int collisionFilterMask)
{
 b3DbvtProxy* mem = &m_proxies[objectId];
 b3DbvtProxy*		proxy = new(mem) b3DbvtProxy(aabbMin, aabbMax, userPtr,
  collisionFilterGroup,
  collisionFilterMask);

 b3DbvtAabbMm aabb = b3DbvtVolume::FromMM(aabbMin, aabbMax);

 //bproxy->aabb			=	b3DbvtVolume::FromMM(aabbMin,aabbMax);
 proxy->stage = m_stageCurrent;
 proxy->m_uniqueId = objectId;
 proxy->leaf = m_sets[0].insert(aabb, proxy);
 b3ListAppend(proxy, m_stageRoots[m_stageCurrent]);
 if (!m_deferedcollide)
 {
  b3DbvtTreeCollider	collider(this);
  collider.proxy = proxy;
  m_sets[0].collideTV(m_sets[0].m_root, aabb, collider);
  m_sets[1].collideTV(m_sets[1].m_root, aabb, collider);
 }
 return(proxy);
}

//
void							b3DynamicBvhBroadphase::destroyProxy(b3BroadphaseProxy* absproxy,
 b3Dispatcher* dispatcher)
{
 b3DbvtProxy*	proxy = (b3DbvtProxy*)absproxy;
 if (proxy->stage == STAGECOUNT)
  m_sets[1].remove(proxy->leaf);
 else
  m_sets[0].remove(proxy->leaf);
 b3ListRemove(proxy, m_stageRoots[proxy->stage]);
 m_paircache->removeOverlappingPairsContainingProxy(proxy->getUid(), dispatcher);

 m_needcleanup = true;
}

void	b3DynamicBvhBroadphase::getAabb(int objectId, b3Vector3& aabbMin, b3Vector3& aabbMax) const
{
 const b3DbvtProxy*						proxy = &m_proxies[objectId];
 aabbMin = proxy->m_aabbMin;
 aabbMax = proxy->m_aabbMax;
}
/*
void	b3DynamicBvhBroadphase::getAabb(b3BroadphaseProxy* absproxy,b3Vector3& aabbMin, b3Vector3& aabbMax ) const
{
b3DbvtProxy*						proxy=(b3DbvtProxy*)absproxy;
aabbMin = proxy->m_aabbMin;
aabbMax = proxy->m_aabbMax;
}
*/


struct	BroadphaseRayTester : b3DynamicBvh::ICollide
{
 b3BroadphaseRayCallback& m_rayCallback;
 BroadphaseRayTester(b3BroadphaseRayCallback& orgCallback)
  :m_rayCallback(orgCallback)
 {
 }
 void					Process(const b3DbvtNode* leaf)
 {
  b3DbvtProxy*	proxy = (b3DbvtProxy*)leaf->data;
  m_rayCallback.process(proxy);
 }
};

void	b3DynamicBvhBroadphase::rayTest(const b3Vector3& rayFrom, const b3Vector3& rayTo, b3BroadphaseRayCallback& rayCallback, const b3Vector3& aabbMin, const b3Vector3& aabbMax)
{
 BroadphaseRayTester callback(rayCallback);

 m_sets[0].rayTestInternal(m_sets[0].m_root,
  rayFrom,
  rayTo,
  rayCallback.m_rayDirectionInverse,
  rayCallback.m_signs,
  rayCallback.m_lambda_max,
  aabbMin,
  aabbMax,
  callback);

 m_sets[1].rayTestInternal(m_sets[1].m_root,
  rayFrom,
  rayTo,
  rayCallback.m_rayDirectionInverse,
  rayCallback.m_signs,
  rayCallback.m_lambda_max,
  aabbMin,
  aabbMax,
  callback);

}


struct	BroadphaseAabbTester : b3DynamicBvh::ICollide
{
 b3BroadphaseAabbCallback& m_aabbCallback;
 BroadphaseAabbTester(b3BroadphaseAabbCallback& orgCallback)
  :m_aabbCallback(orgCallback)
 {
 }
 void					Process(const b3DbvtNode* leaf)
 {
  b3DbvtProxy*	proxy = (b3DbvtProxy*)leaf->data;
  m_aabbCallback.process(proxy);
 }
};

void	b3DynamicBvhBroadphase::aabbTest(const b3Vector3& aabbMin, const b3Vector3& aabbMax, b3BroadphaseAabbCallback& aabbCallback)
{
 BroadphaseAabbTester callback(aabbCallback);

 const B3_ATTRIBUTE_ALIGNED16(b3DbvtVolume)	bounds = b3DbvtVolume::FromMM(aabbMin, aabbMax);
 //process all children, that overlap with  the given AABB bounds
 m_sets[0].collideTV(m_sets[0].m_root, bounds, callback);
 m_sets[1].collideTV(m_sets[1].m_root, bounds, callback);

}



//
void							b3DynamicBvhBroadphase::setAabb(int objectId,
 const b3Vector3& aabbMin,
 const b3Vector3& aabbMax,
 b3Dispatcher* /*dispatcher*/)
{
 b3DbvtProxy*						proxy = &m_proxies[objectId];
 //	b3DbvtProxy*						proxy=(b3DbvtProxy*)absproxy;
 B3_ATTRIBUTE_ALIGNED16(b3DbvtVolume)	aabb = b3DbvtVolume::FromMM(aabbMin, aabbMax);
#if B3_DBVT_BP_PREVENTFALSEUPDATE
 if (b3NotEqual(aabb, proxy->leaf->volume))
#endif
 {
  bool	docollide = false;
  if (proxy->stage == STAGECOUNT)
  {/* fixed -> dynamic set	*/
   m_sets[1].remove(proxy->leaf);
   proxy->leaf = m_sets[0].insert(aabb, proxy);
   docollide = true;
  }
  else
  {/* dynamic set				*/
   ++m_updates_call;
   if (b3Intersect(proxy->leaf->volume, aabb))
   {/* Moving				*/

    const b3Vector3	delta = aabbMin - proxy->m_aabbMin;
    b3Vector3		velocity(((proxy->m_aabbMax - proxy->m_aabbMin) / 2)*m_prediction);
    if (delta[0]<0) velocity[0] = -velocity[0];
    if (delta[1]<0) velocity[1] = -velocity[1];
    if (delta[2]<0) velocity[2] = -velocity[2];
    if (
#ifdef B3_DBVT_BP_MARGIN				
     m_sets[0].update(proxy->leaf, aabb, velocity, B3_DBVT_BP_MARGIN)
#else
     m_sets[0].update(proxy->leaf, aabb, velocity)
#endif
     )
    {
     ++m_updates_done;
     docollide = true;
    }
   }
   else
   {/* Teleporting			*/
    m_sets[0].update(proxy->leaf, aabb);
    ++m_updates_done;
    docollide = true;
   }
  }
  b3ListRemove(proxy, m_stageRoots[proxy->stage]);
  proxy->m_aabbMin = aabbMin;
  proxy->m_aabbMax = aabbMax;
  proxy->stage = m_stageCurrent;
  b3ListAppend(proxy, m_stageRoots[m_stageCurrent]);
  if (docollide)
  {
   m_needcleanup = true;
   if (!m_deferedcollide)
   {
    b3DbvtTreeCollider	collider(this);
    m_sets[1].collideTTpersistentStack(m_sets[1].m_root, proxy->leaf, collider);
    m_sets[0].collideTTpersistentStack(m_sets[0].m_root, proxy->leaf, collider);
   }
  }
 }
}


//
void							b3DynamicBvhBroadphase::setAabbForceUpdate(b3BroadphaseProxy* absproxy,
 const b3Vector3& aabbMin,
 const b3Vector3& aabbMax,
 b3Dispatcher* /*dispatcher*/)
{
 b3DbvtProxy*						proxy = (b3DbvtProxy*)absproxy;
 B3_ATTRIBUTE_ALIGNED16(b3DbvtVolume)	aabb = b3DbvtVolume::FromMM(aabbMin, aabbMax);
 bool	docollide = false;
 if (proxy->stage == STAGECOUNT)
 {/* fixed -> dynamic set	*/
  m_sets[1].remove(proxy->leaf);
  proxy->leaf = m_sets[0].insert(aabb, proxy);
  docollide = true;
 }
 else
 {/* dynamic set				*/
  ++m_updates_call;
  /* Teleporting			*/
  m_sets[0].update(proxy->leaf, aabb);
  ++m_updates_done;
  docollide = true;
 }
 b3ListRemove(proxy, m_stageRoots[proxy->stage]);
 proxy->m_aabbMin = aabbMin;
 proxy->m_aabbMax = aabbMax;
 proxy->stage = m_stageCurrent;
 b3ListAppend(proxy, m_stageRoots[m_stageCurrent]);
 if (docollide)
 {
  m_needcleanup = true;
  if (!m_deferedcollide)
  {
   b3DbvtTreeCollider	collider(this);
   m_sets[1].collideTTpersistentStack(m_sets[1].m_root, proxy->leaf, collider);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, proxy->leaf, collider);
  }
 }
}

//
void							b3DynamicBvhBroadphase::calculateOverlappingPairs(b3Dispatcher* dispatcher)
{
 collide(dispatcher);
#if B3_DBVT_BP_PROFILE
 if (0 == (m_pid%B3_DBVT_BP_PROFILING_RATE))
 {
  printf("fixed(%u) dynamics(%u) pairs(%u)\r\n", m_sets[1].m_leaves, m_sets[0].m_leaves, m_paircache->getNumOverlappingPairs());
  unsigned int	total = m_profiling.m_total;
  if (total <= 0) total = 1;
  printf("ddcollide: %u%% (%uus)\r\n", (50 + m_profiling.m_ddcollide * 100) / total, m_profiling.m_ddcollide / B3_DBVT_BP_PROFILING_RATE);
  printf("fdcollide: %u%% (%uus)\r\n", (50 + m_profiling.m_fdcollide * 100) / total, m_profiling.m_fdcollide / B3_DBVT_BP_PROFILING_RATE);
  printf("cleanup:   %u%% (%uus)\r\n", (50 + m_profiling.m_cleanup * 100) / total, m_profiling.m_cleanup / B3_DBVT_BP_PROFILING_RATE);
  printf("total:     %uus\r\n", total / B3_DBVT_BP_PROFILING_RATE);
  const unsigned long	sum = m_profiling.m_ddcollide +
   m_profiling.m_fdcollide +
   m_profiling.m_cleanup;
  printf("leaked: %u%% (%uus)\r\n", 100 - ((50 + sum * 100) / total), (total - sum) / B3_DBVT_BP_PROFILING_RATE);
  printf("job counts: %u%%\r\n", (m_profiling.m_jobcount * 100) / ((m_sets[0].m_leaves + m_sets[1].m_leaves)*B3_DBVT_BP_PROFILING_RATE));
  b3Clear(m_profiling);
  m_clock.reset();
 }
#endif

 performDeferredRemoval(dispatcher);

}

void b3DynamicBvhBroadphase::performDeferredRemoval(b3Dispatcher* dispatcher)
{

 if (m_paircache->hasDeferredRemoval())
 {

  b3BroadphasePairArray&	overlappingPairArray = m_paircache->getOverlappingPairArray();

  //perform a sort, to find duplicates and to sort 'invalid' pairs to the end
  overlappingPairArray.quickSort(b3BroadphasePairSortPredicate());

  int invalidPair = 0;


  int i;

  b3BroadphasePair previousPair = b3MakeBroadphasePair(-1, -1);



  for (i = 0; i<overlappingPairArray.size(); i++)
  {

   b3BroadphasePair& pair = overlappingPairArray[i];

   bool isDuplicate = (pair == previousPair);

   previousPair = pair;

   bool needsRemoval = false;

   if (!isDuplicate)
   {
    //important to perform AABB check that is consistent with the broadphase
    b3DbvtProxy*		pa = &m_proxies[pair.x];
    b3DbvtProxy*		pb = &m_proxies[pair.y];
    bool hasOverlap = b3Intersect(pa->leaf->volume, pb->leaf->volume);

    if (hasOverlap)
    {
     needsRemoval = false;
    }
    else
    {
     needsRemoval = true;
    }
   }
   else
   {
    //remove duplicate
    needsRemoval = true;
    //should have no algorithm
   }

   if (needsRemoval)
   {
    m_paircache->cleanOverlappingPair(pair, dispatcher);

    pair.x = -1;
    pair.y = -1;
    invalidPair++;
   }

  }

  //perform a sort, to sort 'invalid' pairs to the end
  overlappingPairArray.quickSort(b3BroadphasePairSortPredicate());
  overlappingPairArray.resize(overlappingPairArray.size() - invalidPair);
 }
}

//
void							b3DynamicBvhBroadphase::collide(b3Dispatcher* dispatcher)
{
 /*printf("---------------------------------------------------------\n");
 printf("m_sets[0].m_leaves=%d\n",m_sets[0].m_leaves);
 printf("m_sets[1].m_leaves=%d\n",m_sets[1].m_leaves);
 printf("numPairs = %d\n",getOverlappingPairCache()->getNumOverlappingPairs());
 {
 int i;
 for (i=0;i<getOverlappingPairCache()->getNumOverlappingPairs();i++)
 {
 printf("pair[%d]=(%d,%d),",i,getOverlappingPairCache()->getOverlappingPairArray()[i].m_pProxy0->getUid(),
 getOverlappingPairCache()->getOverlappingPairArray()[i].m_pProxy1->getUid());
 }
 printf("\n");
 }
 */



 b3SPC(m_profiling.m_total);
 /* optimize				*/
 m_sets[0].optimizeIncremental(1 + (m_sets[0].m_leaves*m_dupdates) / 100);
 if (m_fixedleft)
 {
  const int count = 1 + (m_sets[1].m_leaves*m_fupdates) / 100;
  m_sets[1].optimizeIncremental(1 + (m_sets[1].m_leaves*m_fupdates) / 100);
  m_fixedleft = b3Max<int>(0, m_fixedleft - count);
 }
 /* dynamic -> fixed set	*/
 m_stageCurrent = (m_stageCurrent + 1) % STAGECOUNT;
 b3DbvtProxy*	current = m_stageRoots[m_stageCurrent];
 if (current)
 {
  b3DbvtTreeCollider	collider(this);
  do {
   b3DbvtProxy*	next = current->links[1];
   b3ListRemove(current, m_stageRoots[current->stage]);
   b3ListAppend(current, m_stageRoots[STAGECOUNT]);
#if B3_DBVT_BP_ACCURATESLEEPING
   m_paircache->removeOverlappingPairsContainingProxy(current, dispatcher);
   collider.proxy = current;
   b3DynamicBvh::collideTV(m_sets[0].m_root, current->aabb, collider);
   b3DynamicBvh::collideTV(m_sets[1].m_root, current->aabb, collider);
#endif
   m_sets[0].remove(current->leaf);
   B3_ATTRIBUTE_ALIGNED16(b3DbvtVolume)	curAabb = b3DbvtVolume::FromMM(current->m_aabbMin, current->m_aabbMax);
   current->leaf = m_sets[1].insert(curAabb, current);
   current->stage = STAGECOUNT;
   current = next;
  } while (current);
  m_fixedleft = m_sets[1].m_leaves;
  m_needcleanup = true;
 }
 /* collide dynamics		*/
 {
  b3DbvtTreeCollider	collider(this);
  if (m_deferedcollide)
  {
   b3SPC(m_profiling.m_fdcollide);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, m_sets[1].m_root, collider);
  }
  if (m_deferedcollide)
  {
   b3SPC(m_profiling.m_ddcollide);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, m_sets[0].m_root, collider);
  }
 }
 /* clean up				*/
 if (m_needcleanup)
 {
  b3SPC(m_profiling.m_cleanup);
  b3BroadphasePairArray&	pairs = m_paircache->getOverlappingPairArray();
  if (pairs.size()>0)
  {

   int			ni = b3Min(pairs.size(), b3Max<int>(m_newpairs, (pairs.size()*m_cupdates) / 100));
   for (int i = 0; i<ni; ++i)
   {
    b3BroadphasePair&	p = pairs[(m_cid + i) % pairs.size()];
    b3DbvtProxy*		pa = &m_proxies[p.x];
    b3DbvtProxy*		pb = &m_proxies[p.y];
    if (!b3Intersect(pa->leaf->volume, pb->leaf->volume))
    {
#if B3_DBVT_BP_SORTPAIRS
     if (pa->m_uniqueId>pb->m_uniqueId)
      b3Swap(pa, pb);
#endif
     m_paircache->removeOverlappingPair(pa->getUid(), pb->getUid(), dispatcher);
     --ni; --i;
    }
   }
   if (pairs.size()>0) m_cid = (m_cid + ni) % pairs.size(); else m_cid = 0;
  }
 }
 ++m_pid;
 m_newpairs = 1;
 m_needcleanup = false;
 if (m_updates_call>0)
 {
  m_updates_ratio = m_updates_done / (b3Scalar)m_updates_call;
 }
 else
 {
  m_updates_ratio = 0;
 }
 m_updates_done /= 2;
 m_updates_call /= 2;
}

//
void							b3DynamicBvhBroadphase::optimize()
{
 m_sets[0].optimizeTopDown();
 m_sets[1].optimizeTopDown();
}

//
b3OverlappingPairCache*			b3DynamicBvhBroadphase::getOverlappingPairCache()
{
 return(m_paircache);
}

//
const b3OverlappingPairCache*	b3DynamicBvhBroadphase::getOverlappingPairCache() const
{
 return(m_paircache);
}

//
void							b3DynamicBvhBroadphase::getBroadphaseAabb(b3Vector3& aabbMin, b3Vector3& aabbMax) const
{

 B3_ATTRIBUTE_ALIGNED16(b3DbvtVolume)	bounds;

 if (!m_sets[0].empty())
  if (!m_sets[1].empty())	b3Merge(m_sets[0].m_root->volume,
   m_sets[1].m_root->volume, bounds);
  else
   bounds = m_sets[0].m_root->volume;
 else if (!m_sets[1].empty())	bounds = m_sets[1].m_root->volume;
 else
  bounds = b3DbvtVolume::FromCR(b3MakeVector3(0, 0, 0), 0);
 aabbMin = bounds.Mins();
 aabbMax = bounds.Maxs();
}

void b3DynamicBvhBroadphase::resetPool(b3Dispatcher* dispatcher)
{

 int totalObjects = m_sets[0].m_leaves + m_sets[1].m_leaves;
 if (!totalObjects)
 {
  //reset internal dynamic tree data structures
  m_sets[0].clear();
  m_sets[1].clear();

  m_deferedcollide = false;
  m_needcleanup = true;
  m_stageCurrent = 0;
  m_fixedleft = 0;
  m_fupdates = 1;
  m_dupdates = 0;
  m_cupdates = 10;
  m_newpairs = 1;
  m_updates_call = 0;
  m_updates_done = 0;
  m_updates_ratio = 0;

  m_pid = 0;
  m_cid = 0;
  for (int i = 0; i <= STAGECOUNT; ++i)
  {
   m_stageRoots[i] = 0;
  }
 }
}

//
void							b3DynamicBvhBroadphase::printStats()
{}

//
#if B3_DBVT_BP_ENABLE_BENCHMARK

struct	b3BroadphaseBenchmark
{
 struct	Experiment
 {
  const char*			name;
  int					object_count;
  int					update_count;
  int					spawn_count;
  int					iterations;
  b3Scalar			speed;
  b3Scalar			amplitude;
 };
 struct	Object
 {
  b3Vector3			center;
  b3Vector3			extents;
  b3BroadphaseProxy*	proxy;
  b3Scalar			time;
  void				update(b3Scalar speed, b3Scalar amplitude, b3BroadphaseInterface* pbi)
  {
   time += speed;
   center[0] = b3Cos(time*(b3Scalar)2.17)*amplitude +
    b3Sin(time)*amplitude / 2;
   center[1] = b3Cos(time*(b3Scalar)1.38)*amplitude +
    b3Sin(time)*amplitude;
   center[2] = b3Sin(time*(b3Scalar)0.777)*amplitude;
   pbi->setAabb(proxy, center - extents, center + extents, 0);
  }
 };
 static int		UnsignedRand(int range = RAND_MAX - 1) { return(rand() % (range + 1)); }
 static b3Scalar	UnitRand() { return(UnsignedRand(16384) / (b3Scalar)16384); }
 static void		OutputTime(const char* name, b3Clock& c, unsigned count = 0)
 {
  const unsigned long	us = c.getTimeMicroseconds();
  const unsigned long	ms = (us + 500) / 1000;
  const b3Scalar		sec = us / (b3Scalar)(1000 * 1000);
  if (count>0)
   printf("%s : %u us (%u ms), %.2f/s\r\n", name, us, ms, count / sec);
  else
   printf("%s : %u us (%u ms)\r\n", name, us, ms);
 }
};

void							b3DynamicBvhBroadphase::benchmark(b3BroadphaseInterface* pbi)
{
 static const b3BroadphaseBenchmark::Experiment		experiments[] =
 {
  { "1024o.10%",1024,10,0,8192,(b3Scalar)0.005,(b3Scalar)100 },
  /*{"4096o.10%",4096,10,0,8192,(b3Scalar)0.005,(b3Scalar)100},
  {"8192o.10%",8192,10,0,8192,(b3Scalar)0.005,(b3Scalar)100},*/
 };
 static const int										nexperiments = sizeof(experiments) / sizeof(experiments[0]);
 b3AlignedObjectArray<b3BroadphaseBenchmark::Object*>	objects;
 b3Clock													wallclock;
 /* Begin			*/
 for (int iexp = 0; iexp<nexperiments; ++iexp)
 {
  const b3BroadphaseBenchmark::Experiment&	experiment = experiments[iexp];
  const int									object_count = experiment.object_count;
  const int									update_count = (object_count*experiment.update_count) / 100;
  const int									spawn_count = (object_count*experiment.spawn_count) / 100;
  const b3Scalar								speed = experiment.speed;
  const b3Scalar								amplitude = experiment.amplitude;
  printf("Experiment #%u '%s':\r\n", iexp, experiment.name);
  printf("\tObjects: %u\r\n", object_count);
  printf("\tUpdate: %u\r\n", update_count);
  printf("\tSpawn: %u\r\n", spawn_count);
  printf("\tSpeed: %f\r\n", speed);
  printf("\tAmplitude: %f\r\n", amplitude);
  srand(180673);
  /* Create objects	*/
  wallclock.reset();
  objects.reserve(object_count);
  for (int i = 0; i<object_count; ++i)
  {
   b3BroadphaseBenchmark::Object*	po = new b3BroadphaseBenchmark::Object();
   po->center[0] = b3BroadphaseBenchmark::UnitRand() * 50;
   po->center[1] = b3BroadphaseBenchmark::UnitRand() * 50;
   po->center[2] = b3BroadphaseBenchmark::UnitRand() * 50;
   po->extents[0] = b3BroadphaseBenchmark::UnitRand() * 2 + 2;
   po->extents[1] = b3BroadphaseBenchmark::UnitRand() * 2 + 2;
   po->extents[2] = b3BroadphaseBenchmark::UnitRand() * 2 + 2;
   po->time = b3BroadphaseBenchmark::UnitRand() * 2000;
   po->proxy = pbi->createProxy(po->center - po->extents, po->center + po->extents, 0, po, 1, 1, 0, 0);
   objects.push_back(po);
  }
  b3BroadphaseBenchmark::OutputTime("\tInitialization", wallclock);
  /* First update		*/
  wallclock.reset();
  for (int i = 0; i<objects.size(); ++i)
  {
   objects[i]->update(speed, amplitude, pbi);
  }
  b3BroadphaseBenchmark::OutputTime("\tFirst update", wallclock);
  /* Updates			*/
  wallclock.reset();
  for (int i = 0; i<experiment.iterations; ++i)
  {
   for (int j = 0; j<update_count; ++j)
   {
    objects[j]->update(speed, amplitude, pbi);
   }
   pbi->calculateOverlappingPairs(0);
  }
  b3BroadphaseBenchmark::OutputTime("\tUpdate", wallclock, experiment.iterations);
  /* Clean up			*/
  wallclock.reset();
  for (int i = 0; i<objects.size(); ++i)
  {
   pbi->destroyProxy(objects[i]->proxy, 0);
   delete objects[i];
  }
  objects.resize(0);
  b3BroadphaseBenchmark::OutputTime("\tRelease", wallclock);
 }

}
#else
/*void							b3DynamicBvhBroadphase::benchmark(b3BroadphaseInterface*)
{}
*/
#endif

#if B3_DBVT_BP_PROFILE
#undef	b3SPC
#endif

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "Bullet3Collision/BroadPhaseCollision/b3OverlappingPairCache.h"

//#include "b3Dispatcher.h"
//#include "b3CollisionAlgorithm.h"
#include "Bullet3Geometry/b3AabbUtil.h"

#include <stdio.h>

int	b3g_overlappingPairs = 0;
int b3g_removePairs = 0;
int b3g_addedPairs = 0;
int b3g_findPairs = 0;




b3HashedOverlappingPairCache::b3HashedOverlappingPairCache() :
 m_overlapFilterCallback(0)
 //,	m_blockedForChanges(false)
{
 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
 growTables();
}




b3HashedOverlappingPairCache::~b3HashedOverlappingPairCache()
{
}



void	b3HashedOverlappingPairCache::cleanOverlappingPair(b3BroadphasePair& pair, b3Dispatcher* dispatcher)
{
 /*	if (pair.m_algorithm)
 {
 {
 pair.m_algorithm->~b3CollisionAlgorithm();
 dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
 pair.m_algorithm=0;
 }
 }
 */

}




void	b3HashedOverlappingPairCache::cleanProxyFromPairs(int proxy, b3Dispatcher* dispatcher)
{

 class	CleanPairCallback : public b3OverlapCallback
 {
  int m_cleanProxy;
  b3OverlappingPairCache*	m_pairCache;
  b3Dispatcher* m_dispatcher;

 public:
  CleanPairCallback(int cleanProxy, b3OverlappingPairCache* pairCache, b3Dispatcher* dispatcher)
   :m_cleanProxy(cleanProxy),
   m_pairCache(pairCache),
   m_dispatcher(dispatcher)
  {
  }
  virtual	bool	processOverlap(b3BroadphasePair& pair)
  {
   if ((pair.x == m_cleanProxy) ||
    (pair.y == m_cleanProxy))
   {
    m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
   }
   return false;
  }

 };

 CleanPairCallback cleanPairs(proxy, this, dispatcher);

 processAllOverlappingPairs(&cleanPairs, dispatcher);

}




void	b3HashedOverlappingPairCache::removeOverlappingPairsContainingProxy(int proxy, b3Dispatcher* dispatcher)
{

 class	RemovePairCallback : public b3OverlapCallback
 {
  int m_obsoleteProxy;

 public:
  RemovePairCallback(int obsoleteProxy)
   :m_obsoleteProxy(obsoleteProxy)
  {
  }
  virtual	bool	processOverlap(b3BroadphasePair& pair)
  {
   return ((pair.x == m_obsoleteProxy) ||
    (pair.y == m_obsoleteProxy));
  }

 };


 RemovePairCallback removeCallback(proxy);

 processAllOverlappingPairs(&removeCallback, dispatcher);
}





b3BroadphasePair* b3HashedOverlappingPairCache::findPair(int proxy0, int proxy1)
{
 b3g_findPairs++;
 if (proxy0 >proxy1)
  b3Swap(proxy0, proxy1);
 int proxyId1 = proxy0;
 int proxyId2 = proxy1;

 /*if (proxyId1 > proxyId2)
 b3Swap(proxyId1, proxyId2);*/

 int hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

 if (hash >= m_hashTable.size())
 {
  return NULL;
 }

 int index = m_hashTable[hash];
 while (index != B3_NULL_PAIR && equalsPair(m_overlappingPairArray[index], proxyId1, proxyId2) == false)
 {
  index = m_next[index];
 }

 if (index == B3_NULL_PAIR)
 {
  return NULL;
 }

 b3Assert(index < m_overlappingPairArray.size());

 return &m_overlappingPairArray[index];
}

//#include <stdio.h>

void	b3HashedOverlappingPairCache::growTables()
{

 int newCapacity = m_overlappingPairArray.capacity();

 if (m_hashTable.size() < newCapacity)
 {
  //grow hashtable and next table
  int curHashtableSize = m_hashTable.size();

  m_hashTable.resize(newCapacity);
  m_next.resize(newCapacity);


  int i;

  for (i = 0; i < newCapacity; ++i)
  {
   m_hashTable[i] = B3_NULL_PAIR;
  }
  for (i = 0; i < newCapacity; ++i)
  {
   m_next[i] = B3_NULL_PAIR;
  }

  for (i = 0; i<curHashtableSize; i++)
  {

   const b3BroadphasePair& pair = m_overlappingPairArray[i];
   int proxyId1 = pair.x;
   int proxyId2 = pair.y;
   /*if (proxyId1 > proxyId2)
   b3Swap(proxyId1, proxyId2);*/
   int	hashValue = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask
   m_next[i] = m_hashTable[hashValue];
   m_hashTable[hashValue] = i;
  }


 }
}

b3BroadphasePair* b3HashedOverlappingPairCache::internalAddPair(int proxy0, int proxy1)
{
 if (proxy0>proxy1)
  b3Swap(proxy0, proxy1);
 int proxyId1 = proxy0;
 int proxyId2 = proxy1;

 /*if (proxyId1 > proxyId2)
 b3Swap(proxyId1, proxyId2);*/

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask


 b3BroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
 if (pair != NULL)
 {
  return pair;
 }
 /*for(int i=0;i<m_overlappingPairArray.size();++i)
 {
 if(	(m_overlappingPairArray[i].m_pProxy0==proxy0)&&
 (m_overlappingPairArray[i].m_pProxy1==proxy1))
 {
 printf("Adding duplicated %u<>%u\r\n",proxyId1,proxyId2);
 internalFindPair(proxy0, proxy1, hash);
 }
 }*/
 int count = m_overlappingPairArray.size();
 int oldCapacity = m_overlappingPairArray.capacity();
 pair = &m_overlappingPairArray.expandNonInitializing();

 //this is where we add an actual pair, so also call the 'ghost'
 //	if (m_ghostPairCallback)
 //		m_ghostPairCallback->addOverlappingPair(proxy0,proxy1);

 int newCapacity = m_overlappingPairArray.capacity();

 if (oldCapacity < newCapacity)
 {
  growTables();
  //hash with new capacity
  hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));
 }

 *pair = b3MakeBroadphasePair(proxy0, proxy1);

 //	pair->m_pProxy0 = proxy0;
 //	pair->m_pProxy1 = proxy1;
 //pair->m_algorithm = 0;
 //pair->m_internalTmpValue = 0;


 m_next[count] = m_hashTable[hash];
 m_hashTable[hash] = count;

 return pair;
}



void* b3HashedOverlappingPairCache::removeOverlappingPair(int proxy0, int proxy1, b3Dispatcher* dispatcher)
{
 b3g_removePairs++;
 if (proxy0>proxy1)
  b3Swap(proxy0, proxy1);
 int proxyId1 = proxy0;
 int proxyId2 = proxy1;

 /*if (proxyId1 > proxyId2)
 b3Swap(proxyId1, proxyId2);*/

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

 b3BroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
 if (pair == NULL)
 {
  return 0;
 }

 cleanOverlappingPair(*pair, dispatcher);



 int pairIndex = int(pair - &m_overlappingPairArray[0]);
 b3Assert(pairIndex < m_overlappingPairArray.size());

 // Remove the pair from the hash table.
 int index = m_hashTable[hash];
 b3Assert(index != B3_NULL_PAIR);

 int previous = B3_NULL_PAIR;
 while (index != pairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != B3_NULL_PAIR)
 {
  b3Assert(m_next[previous] == pairIndex);
  m_next[previous] = m_next[pairIndex];
 }
 else
 {
  m_hashTable[hash] = m_next[pairIndex];
 }

 // We now move the last pair into spot of the
 // pair being removed. We need to fix the hash
 // table indices to support the move.

 int lastPairIndex = m_overlappingPairArray.size() - 1;

 //if (m_ghostPairCallback)
 //	m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1,dispatcher);

 // If the removed pair is the last pair, we are done.
 if (lastPairIndex == pairIndex)
 {
  m_overlappingPairArray.pop_back();
  return 0;
 }

 // Remove the last pair from the hash table.
 const b3BroadphasePair* last = &m_overlappingPairArray[lastPairIndex];
 /* missing swap here too, Nat. */
 int lastHash = static_cast<int>(getHash(static_cast<unsigned int>(last->x), static_cast<unsigned int>(last->y)) & (m_overlappingPairArray.capacity() - 1));

 index = m_hashTable[lastHash];
 b3Assert(index != B3_NULL_PAIR);

 previous = B3_NULL_PAIR;
 while (index != lastPairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != B3_NULL_PAIR)
 {
  b3Assert(m_next[previous] == lastPairIndex);
  m_next[previous] = m_next[lastPairIndex];
 }
 else
 {
  m_hashTable[lastHash] = m_next[lastPairIndex];
 }

 // Copy the last pair into the remove pair's spot.
 m_overlappingPairArray[pairIndex] = m_overlappingPairArray[lastPairIndex];

 // Insert the last pair into the hash table
 m_next[pairIndex] = m_hashTable[lastHash];
 m_hashTable[lastHash] = pairIndex;

 m_overlappingPairArray.pop_back();

 return 0;
}
//#include <stdio.h>

void	b3HashedOverlappingPairCache::processAllOverlappingPairs(b3OverlapCallback* callback, b3Dispatcher* dispatcher)
{

 int i;

 //	printf("m_overlappingPairArray.size()=%d\n",m_overlappingPairArray.size());
 for (i = 0; i<m_overlappingPairArray.size();)
 {

  b3BroadphasePair* pair = &m_overlappingPairArray[i];
  if (callback->processOverlap(*pair))
  {
   removeOverlappingPair(pair->x, pair->y, dispatcher);

   b3g_overlappingPairs--;
  }
  else
  {
   i++;
  }
 }
}





void	b3HashedOverlappingPairCache::sortOverlappingPairs(b3Dispatcher* dispatcher)
{
 ///need to keep hashmap in sync with pair address, so rebuild all
 b3BroadphasePairArray tmpPairs;
 int i;
 for (i = 0; i<m_overlappingPairArray.size(); i++)
 {
  tmpPairs.push_back(m_overlappingPairArray[i]);
 }

 for (i = 0; i<tmpPairs.size(); i++)
 {
  removeOverlappingPair(tmpPairs[i].x, tmpPairs[i].y, dispatcher);
 }

 for (i = 0; i < m_next.size(); i++)
 {
  m_next[i] = B3_NULL_PAIR;
 }

 tmpPairs.quickSort(b3BroadphasePairSortPredicate());

 for (i = 0; i<tmpPairs.size(); i++)
 {
  addOverlappingPair(tmpPairs[i].x, tmpPairs[i].y);
 }


}


void*	b3SortedOverlappingPairCache::removeOverlappingPair(int proxy0, int proxy1, b3Dispatcher* dispatcher)
{
 if (!hasDeferredRemoval())
 {
  b3BroadphasePair findPair = b3MakeBroadphasePair(proxy0, proxy1);


  int findIndex = m_overlappingPairArray.findLinearSearch(findPair);
  if (findIndex < m_overlappingPairArray.size())
  {
   b3g_overlappingPairs--;
   b3BroadphasePair& pair = m_overlappingPairArray[findIndex];

   cleanOverlappingPair(pair, dispatcher);
   //if (m_ghostPairCallback)
   //	m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1,dispatcher);

   m_overlappingPairArray.swap(findIndex, m_overlappingPairArray.capacity() - 1);
   m_overlappingPairArray.pop_back();
   return 0;
  }
 }

 return 0;
}








b3BroadphasePair*	b3SortedOverlappingPairCache::addOverlappingPair(int proxy0, int proxy1)
{
 //don't add overlap with own
 b3Assert(proxy0 != proxy1);

 if (!needsBroadphaseCollision(proxy0, proxy1))
  return 0;

 b3BroadphasePair* pair = &m_overlappingPairArray.expandNonInitializing();
 *pair = b3MakeBroadphasePair(proxy0, proxy1);


 b3g_overlappingPairs++;
 b3g_addedPairs++;

 //	if (m_ghostPairCallback)
 //		m_ghostPairCallback->addOverlappingPair(proxy0, proxy1);
 return pair;

}

///this findPair becomes really slow. Either sort the list to speedup the query, or
///use a different solution. It is mainly used for Removing overlapping pairs. Removal could be delayed.
///we could keep a linked list in each proxy, and store pair in one of the proxies (with lowest memory address)
///Also we can use a 2D bitmap, which can be useful for a future GPU implementation
b3BroadphasePair*	b3SortedOverlappingPairCache::findPair(int proxy0, int proxy1)
{
 if (!needsBroadphaseCollision(proxy0, proxy1))
  return 0;

 b3BroadphasePair tmpPair = b3MakeBroadphasePair(proxy0, proxy1);
 int findIndex = m_overlappingPairArray.findLinearSearch(tmpPair);

 if (findIndex < m_overlappingPairArray.size())
 {
  //b3Assert(it != m_overlappingPairSet.end());
  b3BroadphasePair* pair = &m_overlappingPairArray[findIndex];
  return pair;
 }
 return 0;
}










//#include <stdio.h>

void	b3SortedOverlappingPairCache::processAllOverlappingPairs(b3OverlapCallback* callback, b3Dispatcher* dispatcher)
{

 int i;

 for (i = 0; i<m_overlappingPairArray.size();)
 {

  b3BroadphasePair* pair = &m_overlappingPairArray[i];
  if (callback->processOverlap(*pair))
  {
   cleanOverlappingPair(*pair, dispatcher);
   pair->x = -1;
   pair->y = -1;
   m_overlappingPairArray.swap(i, m_overlappingPairArray.size() - 1);
   m_overlappingPairArray.pop_back();
   b3g_overlappingPairs--;
  }
  else
  {
   i++;
  }
 }
}




b3SortedOverlappingPairCache::b3SortedOverlappingPairCache() :
 m_blockedForChanges(false),
 m_hasDeferredRemoval(true),
 m_overlapFilterCallback(0)

{
 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
}

b3SortedOverlappingPairCache::~b3SortedOverlappingPairCache()
{
}

void	b3SortedOverlappingPairCache::cleanOverlappingPair(b3BroadphasePair& pair, b3Dispatcher* dispatcher)
{
 /*	if (pair.m_algorithm)
 {
 {
 pair.m_algorithm->~b3CollisionAlgorithm();
 dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
 pair.m_algorithm=0;
 b3g_removePairs--;
 }
 }
 */
}


void	b3SortedOverlappingPairCache::cleanProxyFromPairs(int proxy, b3Dispatcher* dispatcher)
{

 class	CleanPairCallback : public b3OverlapCallback
 {
  int m_cleanProxy;
  b3OverlappingPairCache*	m_pairCache;
  b3Dispatcher* m_dispatcher;

 public:
  CleanPairCallback(int cleanProxy, b3OverlappingPairCache* pairCache, b3Dispatcher* dispatcher)
   :m_cleanProxy(cleanProxy),
   m_pairCache(pairCache),
   m_dispatcher(dispatcher)
  {
  }
  virtual	bool	processOverlap(b3BroadphasePair& pair)
  {
   if ((pair.x == m_cleanProxy) ||
    (pair.y == m_cleanProxy))
   {
    m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
   }
   return false;
  }

 };

 CleanPairCallback cleanPairs(proxy, this, dispatcher);

 processAllOverlappingPairs(&cleanPairs, dispatcher);

}


void	b3SortedOverlappingPairCache::removeOverlappingPairsContainingProxy(int proxy, b3Dispatcher* dispatcher)
{

 class	RemovePairCallback : public b3OverlapCallback
 {
  int m_obsoleteProxy;

 public:
  RemovePairCallback(int obsoleteProxy)
   :m_obsoleteProxy(obsoleteProxy)
  {
  }
  virtual	bool	processOverlap(b3BroadphasePair& pair)
  {
   return ((pair.x == m_obsoleteProxy) ||
    (pair.y == m_obsoleteProxy));
  }

 };

 RemovePairCallback removeCallback(proxy);

 processAllOverlappingPairs(&removeCallback, dispatcher);
}

void	b3SortedOverlappingPairCache::sortOverlappingPairs(b3Dispatcher* dispatcher)
{
 //should already be sorted
}

/*
Copyright (c) 2012 Advanced Micro Devices, Inc.

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
//Originally written by Erwin Coumans


#include "Bullet3Collision/NarrowPhaseCollision/b3ConvexUtility.h"
#include "Bullet3Geometry/b3ConvexHullComputer.h"
#include "Bullet3Geometry/b3GrahamScan2dConvexHull.h"
#include "Bullet3Common/b3Quaternion.h"
#include "Bullet3Common/b3HashMap.h"





b3ConvexUtility::~b3ConvexUtility()
{
}

bool	b3ConvexUtility::initializePolyhedralFeatures(const b3Vector3* orgVertices, int numPoints, bool mergeCoplanarTriangles)
{



 b3ConvexHullComputer conv;
 conv.compute(&orgVertices[0].getX(), sizeof(b3Vector3), numPoints, 0.f, 0.f);

 b3AlignedObjectArray<b3Vector3> faceNormals;
 int numFaces = conv.faces.size();
 faceNormals.resize(numFaces);
 b3ConvexHullComputer* convexUtil = &conv;


 b3AlignedObjectArray<b3MyFace>	tmpFaces;
 tmpFaces.resize(numFaces);

 int numVertices = convexUtil->vertices.size();
 m_vertices.resize(numVertices);
 for (int p = 0; p<numVertices; p++)
 {
  m_vertices[p] = convexUtil->vertices[p];
 }


 for (int i = 0; i<numFaces; i++)
 {
  int face = convexUtil->faces[i];
  //printf("face=%d\n",face);
  const b3ConvexHullComputer::Edge*  firstEdge = &convexUtil->edges[face];
  const b3ConvexHullComputer::Edge*  edge = firstEdge;

  b3Vector3 edges[3];
  int numEdges = 0;
  //compute face normals

  do
  {

   int src = edge->getSourceVertex();
   tmpFaces[i].m_indices.push_back(src);
   int targ = edge->getTargetVertex();
   b3Vector3 wa = convexUtil->vertices[src];

   b3Vector3 wb = convexUtil->vertices[targ];
   b3Vector3 newEdge = wb - wa;
   newEdge.normalize();
   if (numEdges<2)
    edges[numEdges++] = newEdge;

   edge = edge->getNextEdgeOfFace();
  } while (edge != firstEdge);

  b3Scalar planeEq = 1e30f;


  if (numEdges == 2)
  {
   faceNormals[i] = edges[0].cross(edges[1]);
   faceNormals[i].normalize();
   tmpFaces[i].m_plane[0] = faceNormals[i].getX();
   tmpFaces[i].m_plane[1] = faceNormals[i].getY();
   tmpFaces[i].m_plane[2] = faceNormals[i].getZ();
   tmpFaces[i].m_plane[3] = planeEq;

  }
  else
  {
   b3Assert(0);//degenerate?
   faceNormals[i].setZero();
  }

  for (int v = 0; v<tmpFaces[i].m_indices.size(); v++)
  {
   b3Scalar eq = m_vertices[tmpFaces[i].m_indices[v]].dot(faceNormals[i]);
   if (planeEq>eq)
   {
    planeEq = eq;
   }
  }
  tmpFaces[i].m_plane[3] = -planeEq;
 }

 //merge coplanar faces and copy them to m_polyhedron

 b3Scalar faceWeldThreshold = 0.999f;
 b3AlignedObjectArray<int> todoFaces;
 for (int i = 0; i<tmpFaces.size(); i++)
  todoFaces.push_back(i);

 while (todoFaces.size())
 {
  b3AlignedObjectArray<int> coplanarFaceGroup;
  int refFace = todoFaces[todoFaces.size() - 1];

  coplanarFaceGroup.push_back(refFace);
  b3MyFace& faceA = tmpFaces[refFace];
  todoFaces.pop_back();

  b3Vector3 faceNormalA = b3MakeVector3(faceA.m_plane[0], faceA.m_plane[1], faceA.m_plane[2]);
  for (int j = todoFaces.size() - 1; j >= 0; j--)
  {
   int i = todoFaces[j];
   b3MyFace& faceB = tmpFaces[i];
   b3Vector3 faceNormalB = b3MakeVector3(faceB.m_plane[0], faceB.m_plane[1], faceB.m_plane[2]);
   if (faceNormalA.dot(faceNormalB)>faceWeldThreshold)
   {
    coplanarFaceGroup.push_back(i);
    todoFaces.remove(i);
   }
  }


  bool did_merge = false;
  if (coplanarFaceGroup.size()>1)
  {
   //do the merge: use Graham Scan 2d convex hull

   b3AlignedObjectArray<b3GrahamVector3> orgpoints;
   b3Vector3 averageFaceNormal = b3MakeVector3(0, 0, 0);

   for (int i = 0; i<coplanarFaceGroup.size(); i++)
   {
    //				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);

    b3MyFace& face = tmpFaces[coplanarFaceGroup[i]];
    b3Vector3 faceNormal = b3MakeVector3(face.m_plane[0], face.m_plane[1], face.m_plane[2]);
    averageFaceNormal += faceNormal;
    for (int f = 0; f<face.m_indices.size(); f++)
    {
     int orgIndex = face.m_indices[f];
     b3Vector3 pt = m_vertices[orgIndex];

     bool found = false;

     for (int i = 0; i<orgpoints.size(); i++)
     {
      //if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
      if (orgpoints[i].m_orgIndex == orgIndex)
      {
       found = true;
       break;
      }
     }
     if (!found)
      orgpoints.push_back(b3GrahamVector3(pt, orgIndex));
    }
   }



   b3MyFace combinedFace;
   for (int i = 0; i<4; i++)
    combinedFace.m_plane[i] = tmpFaces[coplanarFaceGroup[0]].m_plane[i];

   b3AlignedObjectArray<b3GrahamVector3> hull;

   averageFaceNormal.normalize();
   b3GrahamScanConvexHull2D(orgpoints, hull, averageFaceNormal);

   for (int i = 0; i<hull.size(); i++)
   {
    combinedFace.m_indices.push_back(hull[i].m_orgIndex);
    for (int k = 0; k < orgpoints.size(); k++)
    {
     if (orgpoints[k].m_orgIndex == hull[i].m_orgIndex)
     {
      orgpoints[k].m_orgIndex = -1; // invalidate...
      break;
     }
    }
   }

   // are there rejected vertices?
   bool reject_merge = false;



   for (int i = 0; i < orgpoints.size(); i++) {
    if (orgpoints[i].m_orgIndex == -1)
     continue; // this is in the hull...
               // this vertex is rejected -- is anybody else using this vertex?
    for (int j = 0; j < tmpFaces.size(); j++) {

     b3MyFace& face = tmpFaces[j];
     // is this a face of the current coplanar group?
     bool is_in_current_group = false;
     for (int k = 0; k < coplanarFaceGroup.size(); k++) {
      if (coplanarFaceGroup[k] == j) {
       is_in_current_group = true;
       break;
      }
     }
     if (is_in_current_group) // ignore this face...
      continue;
     // does this face use this rejected vertex?
     for (int v = 0; v < face.m_indices.size(); v++) {
      if (face.m_indices[v] == orgpoints[i].m_orgIndex) {
       // this rejected vertex is used in another face -- reject merge
       reject_merge = true;
       break;
      }
     }
     if (reject_merge)
      break;
    }
    if (reject_merge)
     break;
   }

   if (!reject_merge)
   {
    // do this merge!
    did_merge = true;
    m_faces.push_back(combinedFace);
   }
  }
  if (!did_merge)
  {
   for (int i = 0; i<coplanarFaceGroup.size(); i++)
   {
    b3MyFace face = tmpFaces[coplanarFaceGroup[i]];
    m_faces.push_back(face);
   }

  }



 }

 initialize();

 return true;
}






inline bool IsAlmostZero(const b3Vector3& v)
{
 if (fabsf(v.getX())>1e-6 || fabsf(v.getY())>1e-6 || fabsf(v.getZ())>1e-6)	return false;
 return true;
}

struct b3InternalVertexPair
{
 b3InternalVertexPair(short int v0, short int v1)
  :m_v0(v0),
  m_v1(v1)
 {
  if (m_v1>m_v0)
   b3Swap(m_v0, m_v1);
 }
 short int m_v0;
 short int m_v1;
 int getHash() const
 {
  return m_v0 + (m_v1 << 16);
 }
 bool equals(const b3InternalVertexPair& other) const
 {
  return m_v0 == other.m_v0 && m_v1 == other.m_v1;
 }
};

struct b3InternalEdge
{
 b3InternalEdge()
  :m_face0(-1),
  m_face1(-1)
 {
 }
 short int m_face0;
 short int m_face1;
};

//

#ifdef TEST_INTERNAL_OBJECTS
bool b3ConvexUtility::testContainment() const
{
 for (int p = 0; p<8; p++)
 {
  b3Vector3 LocalPt;
  if (p == 0)		LocalPt = m_localCenter + b3Vector3(m_extents[0], m_extents[1], m_extents[2]);
  else if (p == 1)	LocalPt = m_localCenter + b3Vector3(m_extents[0], m_extents[1], -m_extents[2]);
  else if (p == 2)	LocalPt = m_localCenter + b3Vector3(m_extents[0], -m_extents[1], m_extents[2]);
  else if (p == 3)	LocalPt = m_localCenter + b3Vector3(m_extents[0], -m_extents[1], -m_extents[2]);
  else if (p == 4)	LocalPt = m_localCenter + b3Vector3(-m_extents[0], m_extents[1], m_extents[2]);
  else if (p == 5)	LocalPt = m_localCenter + b3Vector3(-m_extents[0], m_extents[1], -m_extents[2]);
  else if (p == 6)	LocalPt = m_localCenter + b3Vector3(-m_extents[0], -m_extents[1], m_extents[2]);
  else if (p == 7)	LocalPt = m_localCenter + b3Vector3(-m_extents[0], -m_extents[1], -m_extents[2]);

  for (int i = 0; i<m_faces.size(); i++)
  {
   const b3Vector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
   const b3Scalar d = LocalPt.dot(Normal) + m_faces[i].m_plane[3];
   if (d>0.0f)
    return false;
  }
 }
 return true;
}
#endif

void	b3ConvexUtility::initialize()
{

 b3HashMap<b3InternalVertexPair, b3InternalEdge> edges;

 b3Scalar TotalArea = 0.0f;

 m_localCenter.setValue(0, 0, 0);
 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  int NbTris = numVertices;
  for (int j = 0; j<NbTris; j++)
  {
   int k = (j + 1) % numVertices;
   b3InternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
   b3InternalEdge* edptr = edges.find(vp);
   b3Vector3 edge = m_vertices[vp.m_v1] - m_vertices[vp.m_v0];
   edge.normalize();

   bool found = false;
   b3Vector3 diff, diff2;

   for (int p = 0; p<m_uniqueEdges.size(); p++)
   {
    diff = m_uniqueEdges[p] - edge;
    diff2 = m_uniqueEdges[p] + edge;

    //	if ((diff.length2()==0.f) || 
    //	(diff2.length2()==0.f))

    if (IsAlmostZero(diff) ||
     IsAlmostZero(diff2))
    {
     found = true;
     break;
    }
   }

   if (!found)
   {
    m_uniqueEdges.push_back(edge);
   }

   if (edptr)
   {
    //TBD: figure out why I added this assert
    //				b3Assert(edptr->m_face0>=0);
    //			b3Assert(edptr->m_face1<0);
    edptr->m_face1 = i;
   }
   else
   {
    b3InternalEdge ed;
    ed.m_face0 = i;
    edges.insert(vp, ed);
   }
  }
 }

#ifdef USE_CONNECTED_FACES
 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  m_faces[i].m_connectedFaces.resize(numVertices);

  for (int j = 0; j<numVertices; j++)
  {
   int k = (j + 1) % numVertices;
   b3InternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
   b3InternalEdge* edptr = edges.find(vp);
   b3Assert(edptr);
   b3Assert(edptr->m_face0 >= 0);
   b3Assert(edptr->m_face1 >= 0);

   int connectedFace = (edptr->m_face0 == i) ? edptr->m_face1 : edptr->m_face0;
   m_faces[i].m_connectedFaces[j] = connectedFace;
  }
 }
#endif//USE_CONNECTED_FACES

 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  int NbTris = numVertices - 2;

  const b3Vector3& p0 = m_vertices[m_faces[i].m_indices[0]];
  for (int j = 1; j <= NbTris; j++)
  {
   int k = (j + 1) % numVertices;
   const b3Vector3& p1 = m_vertices[m_faces[i].m_indices[j]];
   const b3Vector3& p2 = m_vertices[m_faces[i].m_indices[k]];
   b3Scalar Area = ((p0 - p1).cross(p0 - p2)).length() * 0.5f;
   b3Vector3 Center = (p0 + p1 + p2) / 3.0f;
   m_localCenter += Area * Center;
   TotalArea += Area;
  }
 }
 m_localCenter /= TotalArea;




#ifdef TEST_INTERNAL_OBJECTS
 if (1)
 {
  m_radius = FLT_MAX;
  for (int i = 0; i<m_faces.size(); i++)
  {
   const b3Vector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
   const b3Scalar dist = b3Fabs(m_localCenter.dot(Normal) + m_faces[i].m_plane[3]);
   if (dist<m_radius)
    m_radius = dist;
  }


  b3Scalar MinX = FLT_MAX;
  b3Scalar MinY = FLT_MAX;
  b3Scalar MinZ = FLT_MAX;
  b3Scalar MaxX = -FLT_MAX;
  b3Scalar MaxY = -FLT_MAX;
  b3Scalar MaxZ = -FLT_MAX;
  for (int i = 0; i<m_vertices.size(); i++)
  {
   const b3Vector3& pt = m_vertices[i];
   if (pt.getX()<MinX)	MinX = pt.getX();
   if (pt.getX()>MaxX)	MaxX = pt.getX();
   if (pt.getY()<MinY)	MinY = pt.getY();
   if (pt.getY()>MaxY)	MaxY = pt.getY();
   if (pt.getZ()<MinZ)	MinZ = pt.getZ();
   if (pt.getZ()>MaxZ)	MaxZ = pt.getZ();
  }
  mC.setValue(MaxX + MinX, MaxY + MinY, MaxZ + MinZ);
  mE.setValue(MaxX - MinX, MaxY - MinY, MaxZ - MinZ);



  //		const b3Scalar r = m_radius / sqrtf(2.0f);
  const b3Scalar r = m_radius / sqrtf(3.0f);
  const int LargestExtent = mE.maxAxis();
  const b3Scalar Step = (mE[LargestExtent] * 0.5f - r) / 1024.0f;
  m_extents[0] = m_extents[1] = m_extents[2] = r;
  m_extents[LargestExtent] = mE[LargestExtent] * 0.5f;
  bool FoundBox = false;
  for (int j = 0; j<1024; j++)
  {
   if (testContainment())
   {
    FoundBox = true;
    break;
   }

   m_extents[LargestExtent] -= Step;
  }
  if (!FoundBox)
  {
   m_extents[0] = m_extents[1] = m_extents[2] = r;
  }
  else
  {
   // Refine the box
   const b3Scalar Step = (m_radius - r) / 1024.0f;
   const int e0 = (1 << LargestExtent) & 3;
   const int e1 = (1 << e0) & 3;

   for (int j = 0; j<1024; j++)
   {
    const b3Scalar Saved0 = m_extents[e0];
    const b3Scalar Saved1 = m_extents[e1];
    m_extents[e0] += Step;
    m_extents[e1] += Step;

    if (!testContainment())
    {
     m_extents[e0] = Saved0;
     m_extents[e1] = Saved1;
     break;
    }
   }
  }
 }
#endif
}

#include "Bullet3Collision/NarrowPhaseCollision/b3CpuNarrowPhase.h"
#include "Bullet3Collision/NarrowPhaseCollision/b3ConvexUtility.h"
#include "Bullet3Collision/NarrowPhaseCollision/b3Config.h"

#include "Bullet3Collision/NarrowPhaseCollision/shared/b3ConvexPolyhedronData.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3ContactConvexConvexSAT.h"


struct b3CpuNarrowPhaseInternalData
{
 b3AlignedObjectArray<b3Aabb> m_localShapeAABBCPU;
 b3AlignedObjectArray<b3Collidable>	m_collidablesCPU;
 b3AlignedObjectArray<b3ConvexUtility*> m_convexData;
 b3Config m_config;


 b3AlignedObjectArray<b3ConvexPolyhedronData> m_convexPolyhedra;
 b3AlignedObjectArray<b3Vector3> m_uniqueEdges;
 b3AlignedObjectArray<b3Vector3> m_convexVertices;
 b3AlignedObjectArray<int> m_convexIndices;
 b3AlignedObjectArray<b3GpuFace> m_convexFaces;

 b3AlignedObjectArray<b3Contact4Data> m_contacts;

 int	m_numAcceleratedShapes;
};


const b3AlignedObjectArray<b3Contact4Data>& b3CpuNarrowPhase::getContacts() const
{
 return m_data->m_contacts;
}

b3Collidable& b3CpuNarrowPhase::getCollidableCpu(int collidableIndex)
{
 return m_data->m_collidablesCPU[collidableIndex];
}

const b3Collidable& b3CpuNarrowPhase::getCollidableCpu(int collidableIndex) const
{
 return m_data->m_collidablesCPU[collidableIndex];
}


b3CpuNarrowPhase::b3CpuNarrowPhase(const struct b3Config& config)
{
 m_data = new b3CpuNarrowPhaseInternalData;
 m_data->m_config = config;
 m_data->m_numAcceleratedShapes = 0;
}

b3CpuNarrowPhase::~b3CpuNarrowPhase()
{
 delete m_data;
}

void b3CpuNarrowPhase::computeContacts(b3AlignedObjectArray<b3Int4>& pairs, b3AlignedObjectArray<b3Aabb>& aabbsWorldSpace, b3AlignedObjectArray<b3RigidBodyData>& bodies)
{
 int nPairs = pairs.size();
 int numContacts = 0;
 int maxContactCapacity = m_data->m_config.m_maxContactCapacity;
 m_data->m_contacts.resize(maxContactCapacity);

 for (int i = 0; i<nPairs; i++)
 {
  int bodyIndexA = pairs[i].x;
  int bodyIndexB = pairs[i].y;
  int collidableIndexA = bodies[bodyIndexA].m_collidableIdx;
  int collidableIndexB = bodies[bodyIndexB].m_collidableIdx;

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_SPHERE &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)
  {
   //			computeContactSphereConvex(i,bodyIndexA,bodyIndexB,collidableIndexA,collidableIndexB,&bodies[0],
   //				&m_data->m_collidablesCPU[0],&hostConvexData[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_SPHERE)
  {
   //			computeContactSphereConvex(i,bodyIndexB,bodyIndexA,collidableIndexB,collidableIndexA,&bodies[0],
   //				&m_data->m_collidablesCPU[0],&hostConvexData[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
   //printf("convex-sphere\n");

  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_PLANE)
  {
   //			computeContactPlaneConvex(i,bodyIndexB,bodyIndexA,collidableIndexB,collidableIndexA,&bodies[0],
   //			&m_data->m_collidablesCPU[0],&hostConvexData[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
   //			printf("convex-plane\n");

  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_PLANE &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)
  {
   //			computeContactPlaneConvex(i,bodyIndexA,bodyIndexB,collidableIndexA,collidableIndexB,&bodies[0],
   //			&m_data->m_collidablesCPU[0],&hostConvexData[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
   //			printf("plane-convex\n");

  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS)
  {
   //			computeContactCompoundCompound(i,bodyIndexB,bodyIndexA,collidableIndexB,collidableIndexA,&bodies[0],
   //			&m_data->m_collidablesCPU[0],&hostConvexData[0],&cpuChildShapes[0], hostAabbsWorldSpace,hostAabbsLocalSpace,hostVertices,hostUniqueEdges,hostIndices,hostFaces,&hostContacts[0],
   //			nContacts,maxContactCapacity,treeNodesCPU,subTreesCPU,bvhInfoCPU);	
   //			printf("convex-plane\n");

  }


  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_PLANE)
  {
   //			computeContactPlaneCompound(i,bodyIndexB,bodyIndexA,collidableIndexB,collidableIndexA,&bodies[0],
   //			&m_data->m_collidablesCPU[0],&hostConvexData[0],&cpuChildShapes[0], &hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
   //			printf("convex-plane\n");

  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_PLANE &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS)
  {
   //			computeContactPlaneCompound(i,bodyIndexA,bodyIndexB,collidableIndexA,collidableIndexB,&bodies[0],
   //			&m_data->m_collidablesCPU[0],&hostConvexData[0],&cpuChildShapes[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);
   //			printf("plane-convex\n");

  }

  if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&
   m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)
  {
   //printf("pairs[i].z=%d\n",pairs[i].z);
   //int contactIndex = computeContactConvexConvex2(i,bodyIndexA,bodyIndexB,collidableIndexA,collidableIndexB,bodies,
   //		m_data->m_collidablesCPU,hostConvexData,hostVertices,hostUniqueEdges,hostIndices,hostFaces,hostContacts,nContacts,maxContactCapacity,oldHostContacts);
   int contactIndex = b3ContactConvexConvexSAT(i, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, bodies,
    m_data->m_collidablesCPU, m_data->m_convexPolyhedra, m_data->m_convexVertices, m_data->m_uniqueEdges, m_data->m_convexIndices, m_data->m_convexFaces, m_data->m_contacts, numContacts, maxContactCapacity);


   if (contactIndex >= 0)
   {
    pairs[i].z = contactIndex;
   }
   //			printf("plane-convex\n");

  }


 }

 m_data->m_contacts.resize(numContacts);
}

int	b3CpuNarrowPhase::registerConvexHullShape(b3ConvexUtility* utilPtr)
{
 int collidableIndex = allocateCollidable();
 if (collidableIndex<0)
  return collidableIndex;


 b3Collidable& col = m_data->m_collidablesCPU[collidableIndex];
 col.m_shapeType = SHAPE_CONVEX_HULL;
 col.m_shapeIndex = -1;


 {
  b3Vector3 localCenter = b3MakeVector3(0, 0, 0);
  for (int i = 0; i<utilPtr->m_vertices.size(); i++)
   localCenter += utilPtr->m_vertices[i];
  localCenter *= (1.f / utilPtr->m_vertices.size());
  utilPtr->m_localCenter = localCenter;

  col.m_shapeIndex = registerConvexHullShapeInternal(utilPtr, col);
 }

 if (col.m_shapeIndex >= 0)
 {
  b3Aabb aabb;

  b3Vector3 myAabbMin = b3MakeVector3(1e30f, 1e30f, 1e30f);
  b3Vector3 myAabbMax = b3MakeVector3(-1e30f, -1e30f, -1e30f);

  for (int i = 0; i<utilPtr->m_vertices.size(); i++)
  {
   myAabbMin.setMin(utilPtr->m_vertices[i]);
   myAabbMax.setMax(utilPtr->m_vertices[i]);
  }
  aabb.m_min[0] = myAabbMin[0];
  aabb.m_min[1] = myAabbMin[1];
  aabb.m_min[2] = myAabbMin[2];
  aabb.m_minIndices[3] = 0;

  aabb.m_max[0] = myAabbMax[0];
  aabb.m_max[1] = myAabbMax[1];
  aabb.m_max[2] = myAabbMax[2];
  aabb.m_signedMaxIndices[3] = 0;

  m_data->m_localShapeAABBCPU.push_back(aabb);

 }

 return collidableIndex;
}

int	b3CpuNarrowPhase::allocateCollidable()
{
 int curSize = m_data->m_collidablesCPU.size();
 if (curSize<m_data->m_config.m_maxConvexShapes)
 {
  m_data->m_collidablesCPU.expand();
  return curSize;
 }
 else
 {
  b3Error("allocateCollidable out-of-range %d\n", m_data->m_config.m_maxConvexShapes);
 }
 return -1;

}

int	b3CpuNarrowPhase::registerConvexHullShape(const float* vertices, int strideInBytes, int numVertices, const float* scaling)
{
 b3AlignedObjectArray<b3Vector3> verts;

 unsigned char* vts = (unsigned char*)vertices;
 for (int i = 0; i<numVertices; i++)
 {
  float* vertex = (float*)&vts[i*strideInBytes];
  verts.push_back(b3MakeVector3(vertex[0] * scaling[0], vertex[1] * scaling[1], vertex[2] * scaling[2]));
 }

 b3ConvexUtility* utilPtr = new b3ConvexUtility();
 bool merge = true;
 if (numVertices)
 {
  utilPtr->initializePolyhedralFeatures(&verts[0], verts.size(), merge);
 }

 int collidableIndex = registerConvexHullShape(utilPtr);

 delete utilPtr;
 return collidableIndex;
}


int b3CpuNarrowPhase::registerConvexHullShapeInternal(b3ConvexUtility* convexPtr, b3Collidable& col)
{

 m_data->m_convexData.resize(m_data->m_numAcceleratedShapes + 1);
 m_data->m_convexPolyhedra.resize(m_data->m_numAcceleratedShapes + 1);


 b3ConvexPolyhedronData& convex = m_data->m_convexPolyhedra.at(m_data->m_convexPolyhedra.size() - 1);
 convex.mC = convexPtr->mC;
 convex.mE = convexPtr->mE;
 convex.m_extents = convexPtr->m_extents;
 convex.m_localCenter = convexPtr->m_localCenter;
 convex.m_radius = convexPtr->m_radius;

 convex.m_numUniqueEdges = convexPtr->m_uniqueEdges.size();
 int edgeOffset = m_data->m_uniqueEdges.size();
 convex.m_uniqueEdgesOffset = edgeOffset;

 m_data->m_uniqueEdges.resize(edgeOffset + convex.m_numUniqueEdges);

 //convex data here
 int i;
 for (i = 0; i<convexPtr->m_uniqueEdges.size(); i++)
 {
  m_data->m_uniqueEdges[edgeOffset + i] = convexPtr->m_uniqueEdges[i];
 }

 int faceOffset = m_data->m_convexFaces.size();
 convex.m_faceOffset = faceOffset;
 convex.m_numFaces = convexPtr->m_faces.size();

 m_data->m_convexFaces.resize(faceOffset + convex.m_numFaces);


 for (i = 0; i<convexPtr->m_faces.size(); i++)
 {
  m_data->m_convexFaces[convex.m_faceOffset + i].m_plane = b3MakeVector3(convexPtr->m_faces[i].m_plane[0],
   convexPtr->m_faces[i].m_plane[1],
   convexPtr->m_faces[i].m_plane[2],
   convexPtr->m_faces[i].m_plane[3]);


  int indexOffset = m_data->m_convexIndices.size();
  int numIndices = convexPtr->m_faces[i].m_indices.size();
  m_data->m_convexFaces[convex.m_faceOffset + i].m_numIndices = numIndices;
  m_data->m_convexFaces[convex.m_faceOffset + i].m_indexOffset = indexOffset;
  m_data->m_convexIndices.resize(indexOffset + numIndices);
  for (int p = 0; p<numIndices; p++)
  {
   m_data->m_convexIndices[indexOffset + p] = convexPtr->m_faces[i].m_indices[p];
  }
 }

 convex.m_numVertices = convexPtr->m_vertices.size();
 int vertexOffset = m_data->m_convexVertices.size();
 convex.m_vertexOffset = vertexOffset;

 m_data->m_convexVertices.resize(vertexOffset + convex.m_numVertices);
 for (int i = 0; i<convexPtr->m_vertices.size(); i++)
 {
  m_data->m_convexVertices[vertexOffset + i] = convexPtr->m_vertices[i];
 }

 (m_data->m_convexData)[m_data->m_numAcceleratedShapes] = convexPtr;



 return m_data->m_numAcceleratedShapes++;
}

const b3Aabb& b3CpuNarrowPhase::getLocalSpaceAabb(int collidableIndex) const
{
 return m_data->m_localShapeAABBCPU[collidableIndex];
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "Bullet3Common/b3AlignedAllocator.h"

int b3g_numAlignedAllocs = 0;
int b3g_numAlignedFree = 0;
int b3g_totalBytesAlignedAllocs = 0;//detect memory leaks

static void *b3AllocDefault(size_t size)
{
 return malloc(size);
}

static void b3FreeDefault(void *ptr)
{
 free(ptr);
}

static b3AllocFunc* b3s_allocFunc = b3AllocDefault;
static b3FreeFunc* b3s_freeFunc = b3FreeDefault;



#if defined (B3_HAS_ALIGNED_ALLOCATOR)
#include <malloc.h>
static void *b3AlignedAllocDefault(size_t size, int alignment)
{
 return _aligned_malloc(size, (size_t)alignment);
}

static void b3AlignedFreeDefault(void *ptr)
{
 _aligned_free(ptr);
}
#elif defined(__CELLOS_LV2__)
#include <stdlib.h>

static inline void *b3AlignedAllocDefault(size_t size, int alignment)
{
 return memalign(alignment, size);
}

static inline void b3AlignedFreeDefault(void *ptr)
{
 free(ptr);
}
#else





static inline void *b3AlignedAllocDefault(size_t size, int alignment)
{
 void *ret;
 char *real;
 real = (char *)b3s_allocFunc(size + sizeof(void *) + (alignment - 1));
 if (real) {
  ret = b3AlignPointer(real + sizeof(void *), alignment);
  *((void **)(ret)-1) = (void *)(real);
 }
 else {
  ret = (void *)(real);
 }
 return (ret);
}

static inline void b3AlignedFreeDefault(void *ptr)
{
 void* real;

 if (ptr) {
  real = *((void **)(ptr)-1);
  b3s_freeFunc(real);
 }
}
#endif


static b3AlignedAllocFunc* b3s_alignedAllocFunc = b3AlignedAllocDefault;
static b3AlignedFreeFunc* b3s_alignedFreeFunc = b3AlignedFreeDefault;

void b3AlignedAllocSetCustomAligned(b3AlignedAllocFunc *allocFunc, b3AlignedFreeFunc *freeFunc)
{
 b3s_alignedAllocFunc = allocFunc ? allocFunc : b3AlignedAllocDefault;
 b3s_alignedFreeFunc = freeFunc ? freeFunc : b3AlignedFreeDefault;
}

void b3AlignedAllocSetCustom(b3AllocFunc *allocFunc, b3FreeFunc *freeFunc)
{
 b3s_allocFunc = allocFunc ? allocFunc : b3AllocDefault;
 b3s_freeFunc = freeFunc ? freeFunc : b3FreeDefault;
}

#ifdef B3_DEBUG_MEMORY_ALLOCATIONS
//this generic allocator provides the total allocated number of bytes
#include <stdio.h>

void*   b3AlignedAllocInternal(size_t size, int alignment, int line, char* filename)
{
 void *ret;
 char *real;

 b3g_totalBytesAlignedAllocs += size;
 b3g_numAlignedAllocs++;


 real = (char *)b3s_allocFunc(size + 2 * sizeof(void *) + (alignment - 1));
 if (real) {
  ret = (void*)b3AlignPointer(real + 2 * sizeof(void *), alignment);
  *((void **)(ret)-1) = (void *)(real);
  *((int*)(ret)-2) = size;

 }
 else {
  ret = (void *)(real);//??
 }

 b3Printf("allocation#%d at address %x, from %s,line %d, size %d\n", b3g_numAlignedAllocs, real, filename, line, size);

 int* ptr = (int*)ret;
 *ptr = 12;
 return (ret);
}

void    b3AlignedFreeInternal(void* ptr, int line, char* filename)
{

 void* real;
 b3g_numAlignedFree++;

 if (ptr) {
  real = *((void **)(ptr)-1);
  int size = *((int*)(ptr)-2);
  b3g_totalBytesAlignedAllocs -= size;

  b3Printf("free #%d at address %x, from %s,line %d, size %d\n", b3g_numAlignedFree, real, filename, line, size);

  b3s_freeFunc(real);
 }
 else
 {
  b3Printf("NULL ptr\n");
 }
}

#else //B3_DEBUG_MEMORY_ALLOCATIONS

void*	b3AlignedAllocInternal(size_t size, int alignment)
{
 b3g_numAlignedAllocs++;
 void* ptr;
 ptr = b3s_alignedAllocFunc(size, alignment);
 //	b3Printf("b3AlignedAllocInternal %d, %x\n",size,ptr);
 return ptr;
}

void	b3AlignedFreeInternal(void* ptr)
{
 if (!ptr)
 {
  return;
 }

 b3g_numAlignedFree++;
 //	b3Printf("b3AlignedFreeInternal %x\n",ptr);
 b3s_alignedFreeFunc(ptr);
}

#endif //B3_DEBUG_MEMORY_ALLOCATIONS

/*
Copyright (c) 2013 Advanced Micro Devices, Inc.

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
//Originally written by Erwin Coumans

#include "Bullet3Common/b3Logging.h"

#include <stdio.h>
#include <stdarg.h>

#ifdef _WIN32
#include <windows.h>
#endif //_WIN32


void b3PrintfFuncDefault(const char* msg)
{
#ifdef _WIN32
 OutputDebugStringA(msg);
#endif
 printf("%s", msg);
 //is this portable?
 fflush(stdout);
}

void b3WarningMessageFuncDefault(const char* msg)
{
#ifdef _WIN32
 OutputDebugStringA(msg);
#endif
 printf("%s", msg);
 //is this portable?
 fflush(stdout);

}


void b3ErrorMessageFuncDefault(const char* msg)
{
#ifdef _WIN32
 OutputDebugStringA(msg);
#endif
 printf("%s", msg);

 //is this portable?
 fflush(stdout);

}



static b3PrintfFunc* b3s_printfFunc = b3PrintfFuncDefault;
static b3WarningMessageFunc* b3s_warningMessageFunc = b3WarningMessageFuncDefault;
static b3ErrorMessageFunc* b3s_errorMessageFunc = b3ErrorMessageFuncDefault;


///The developer can route b3Printf output using their own implementation
void b3SetCustomPrintfFunc(b3PrintfFunc* printfFunc)
{
 b3s_printfFunc = printfFunc;
}
void b3SetCustomWarningMessageFunc(b3PrintfFunc* warningMessageFunc)
{
 b3s_warningMessageFunc = warningMessageFunc;
}
void b3SetCustomErrorMessageFunc(b3PrintfFunc* errorMessageFunc)
{
 b3s_errorMessageFunc = errorMessageFunc;
}

//#define B3_MAX_DEBUG_STRING_LENGTH 2048
#define B3_MAX_DEBUG_STRING_LENGTH 32768


void b3OutputPrintfVarArgsInternal(const char *str, ...)
{
 char strDebug[B3_MAX_DEBUG_STRING_LENGTH] = { 0 };
 va_list argList;
 va_start(argList, str);
#ifdef _MSC_VER
 vsprintf_s(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#else
 vsnprintf(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#endif
 (b3s_printfFunc)(strDebug);
 va_end(argList);
}
void b3OutputWarningMessageVarArgsInternal(const char *str, ...)
{
 char strDebug[B3_MAX_DEBUG_STRING_LENGTH] = { 0 };
 va_list argList;
 va_start(argList, str);
#ifdef _MSC_VER
 vsprintf_s(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#else
 vsnprintf(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#endif
 (b3s_warningMessageFunc)(strDebug);
 va_end(argList);
}
void b3OutputErrorMessageVarArgsInternal(const char *str, ...)
{

 char strDebug[B3_MAX_DEBUG_STRING_LENGTH] = { 0 };
 va_list argList;
 va_start(argList, str);
#ifdef _MSC_VER
 vsprintf_s(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#else
 vsnprintf(strDebug, B3_MAX_DEBUG_STRING_LENGTH, str, argList);
#endif
 (b3s_errorMessageFunc)(strDebug);
 va_end(argList);

}


void	b3EnterProfileZoneDefault(const char* name)
{
}
void	b3LeaveProfileZoneDefault()
{
}
static b3EnterProfileZoneFunc* b3s_enterFunc = b3EnterProfileZoneDefault;
static b3LeaveProfileZoneFunc* b3s_leaveFunc = b3LeaveProfileZoneDefault;
void b3EnterProfileZone(const char* name)
{
 (b3s_enterFunc)(name);
}
void b3LeaveProfileZone()
{
 (b3s_leaveFunc)();
}

void b3SetCustomEnterProfileZoneFunc(b3EnterProfileZoneFunc* enterFunc)
{
 b3s_enterFunc = enterFunc;
}
void b3SetCustomLeaveProfileZoneFunc(b3LeaveProfileZoneFunc* leaveFunc)
{
 b3s_leaveFunc = leaveFunc;
}




#ifndef _MSC_VER
#undef vsprintf_s
#endif

/*
Copyright (c) 2011-213 Apple Inc. http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

This source version has been altered.
*/

#if defined (_WIN32) || defined (__i386__)
#define B3_USE_SSE_IN_API
#endif

#include "Bullet3Common/b3Vector3.h"

#if defined (B3_USE_SSE) || defined (B3_USE_NEON)

#ifdef __APPLE__
#include <stdint.h>
typedef  float float4 __attribute__((vector_size(16)));
#else
#define float4 __m128
#endif
//typedef  uint32_t uint4 __attribute__ ((vector_size(16)));


#if defined B3_USE_SSE || defined _WIN32

#define LOG2_ARRAY_SIZE     6
#define STACK_ARRAY_COUNT   (1UL << LOG2_ARRAY_SIZE)

#include <emmintrin.h>

#define b3CastfTo128i(a) (_mm_castps_si128(a))
#define b3CastfTo128d(a) (_mm_castps_pd(a))
#define b3CastiTo128f(a) (_mm_castsi128_ps(a))
#define b3CastdTo128f(a) (_mm_castpd_ps(a))
#define b3CastdTo128i(a) (_mm_castpd_si128(a))
#define b3Assign128(r0,r1,r2,r3) _mm_setr_ps(r0,r1,r2,r3)

long b3_maxdot_large(const float *vv, const float *vec, unsigned long count, float *dotResult);
long b3_maxdot_large(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 const float4 *vertices = (const float4*)vv;
 static const unsigned char indexTable[16] = { (unsigned char)-1, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 };
 float4 dotMax = b3Assign128(-B3_INFINITY, -B3_INFINITY, -B3_INFINITY, -B3_INFINITY);
 float4 vvec = _mm_loadu_ps(vec);
 float4 vHi = b3CastiTo128f(_mm_shuffle_epi32(b3CastfTo128i(vvec), 0xaa));          /// zzzz
 float4 vLo = _mm_movelh_ps(vvec, vvec);                               /// xyxy

 long maxIndex = -1L;

 size_t segment = 0;
 float4 stack_array[STACK_ARRAY_COUNT];

#if DEBUG
 // memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
#endif

 size_t index;
 float4 max;
 // Faster loop without cleanup code for full tiles
 for (segment = 0; segment + STACK_ARRAY_COUNT * 4 <= count; segment += STACK_ARRAY_COUNT * 4)
 {
  max = dotMax;

  for (index = 0; index < STACK_ARRAY_COUNT; index += 4)
  { // do four dot products at a time. Carefully avoid touching the w element.
   float4 v0 = vertices[0];
   float4 v1 = vertices[1];
   float4 v2 = vertices[2];
   float4 v3 = vertices[3];            vertices += 4;

   float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
   float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
   float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 1] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 2] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 3] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

                                     // It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
  }

  // If we found a new max
  if (0xf != _mm_movemask_ps((float4)_mm_cmpeq_ps(max, dotMax)))
  {
   // copy the new max across all lanes of our max accumulator
   max = _mm_max_ps(max, (float4)_mm_shuffle_ps(max, max, 0x4e));
   max = _mm_max_ps(max, (float4)_mm_shuffle_ps(max, max, 0xb1));

   dotMax = max;

   // find first occurrence of that max
   size_t test;
   for (index = 0; 0 == (test = _mm_movemask_ps(_mm_cmpeq_ps(stack_array[index], max))); index++)   // local_count must be a multiple of 4
   {
   }
   // record where it is.
   maxIndex = 4 * index + segment + indexTable[test];
  }
 }

 // account for work we've already done
 count -= segment;

 // Deal with the last < STACK_ARRAY_COUNT vectors
 max = dotMax;
 index = 0;


 if (b3Unlikely(count > 16))
 {
  for (; index + 4 <= count / 4; index += 4)
  { // do four dot products at a time. Carefully avoid touching the w element.
   float4 v0 = vertices[0];
   float4 v1 = vertices[1];
   float4 v2 = vertices[2];
   float4 v3 = vertices[3];            vertices += 4;

   float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
   float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
   float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 1] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 2] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 3] = x;
   max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan

                                     // It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
  }
 }

 size_t localCount = (count & -4L) - 4 * index;
 if (localCount)
 {
#ifdef __APPLE__
  float4 t0, t1, t2, t3, t4;
  float4 * sap = &stack_array[index + localCount / 4];
  vertices += localCount;      // counter the offset
  size_t byteIndex = -(localCount) * sizeof(float);
  //AT&T Code style assembly
  asm volatile
   (".align 4                                                                   \n\
             0: movaps  %[max], %[t2]                            // move max out of the way to avoid propagating NaNs in max \n\
          movaps  (%[vertices], %[byteIndex], 4),    %[t0]    // vertices[0]      \n\
          movaps  16(%[vertices], %[byteIndex], 4),  %[t1]    // vertices[1]      \n\
          movaps  %[t0], %[max]                               // vertices[0]      \n\
          movlhps %[t1], %[max]                               // x0y0x1y1         \n\
         movaps  32(%[vertices], %[byteIndex], 4),  %[t3]    // vertices[2]      \n\
         movaps  48(%[vertices], %[byteIndex], 4),  %[t4]    // vertices[3]      \n\
          mulps   %[vLo], %[max]                              // x0y0x1y1 * vLo   \n\
         movhlps %[t0], %[t1]                                // z0w0z1w1         \n\
         movaps  %[t3], %[t0]                                // vertices[2]      \n\
         movlhps %[t4], %[t0]                                // x2y2x3y3         \n\
         mulps   %[vLo], %[t0]                               // x2y2x3y3 * vLo   \n\
          movhlps %[t3], %[t4]                                // z2w2z3w3         \n\
          shufps  $0x88, %[t4], %[t1]                         // z0z1z2z3         \n\
          mulps   %[vHi], %[t1]                               // z0z1z2z3 * vHi   \n\
         movaps  %[max], %[t3]                               // x0y0x1y1 * vLo   \n\
         shufps  $0x88, %[t0], %[max]                        // x0x1x2x3 * vLo.x \n\
         shufps  $0xdd, %[t0], %[t3]                         // y0y1y2y3 * vLo.y \n\
         addps   %[t3], %[max]                               // x + y            \n\
         addps   %[t1], %[max]                               // x + y + z        \n\
         movaps  %[max], (%[sap], %[byteIndex])              // record result for later scrutiny \n\
         maxps   %[t2], %[max]                               // record max, restore max   \n\
         add     $16, %[byteIndex]                           // advance loop counter\n\
         jnz     0b                                          \n\
     "
    : [max] "+x" (max), [t0] "=&x" (t0), [t1] "=&x" (t1), [t2] "=&x" (t2), [t3] "=&x" (t3), [t4] "=&x" (t4), [byteIndex] "+r" (byteIndex)
    : [vLo] "x" (vLo), [vHi] "x" (vHi), [vertices] "r" (vertices), [sap] "r" (sap)
    : "memory", "cc"
    );
  index += localCount / 4;
#else
  {
   for (unsigned int i = 0; i<localCount / 4; i++, index++)
   { // do four dot products at a time. Carefully avoid touching the w element.
    float4 v0 = vertices[0];
    float4 v1 = vertices[1];
    float4 v2 = vertices[2];
    float4 v3 = vertices[3];
    vertices += 4;

    float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
    float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
    float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
    float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

    lo0 = lo0*vLo;
    lo1 = lo1*vLo;
    float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
    float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
    float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
    z = z*vHi;
    x = x + y;
    x = x + z;
    stack_array[index] = x;
    max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan
   }
  }
#endif //__APPLE__
 }

 // process the last few points
 if (count & 3)
 {
  float4 v0, v1, v2, x, y, z;
  switch (count & 3)
  {
  case 3:
  {
   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];

   // Calculate 3 dot products, transpose, duplicate v2
   float4 lo0 = _mm_movelh_ps(v0, v1);        // xyxy.lo
   float4 hi0 = _mm_movehl_ps(v1, v0);        // z?z?.lo
   lo0 = lo0*vLo;
   z = _mm_shuffle_ps(hi0, v2, 0xa8);           // z0z1z2z2
   z = z*vHi;
   float4 lo1 = _mm_movelh_ps(v2, v2);          // xyxy
   lo1 = lo1*vLo;
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
  }
  break;
  case 2:
  {
   v0 = vertices[0];
   v1 = vertices[1];
   float4 xy = _mm_movelh_ps(v0, v1);
   z = _mm_movehl_ps(v1, v0);
   xy = xy*vLo;
   z = _mm_shuffle_ps(z, z, 0xa8);
   x = _mm_shuffle_ps(xy, xy, 0xa8);
   y = _mm_shuffle_ps(xy, xy, 0xfd);
   z = z*vHi;
  }
  break;
  case 1:
  {
   float4 xy = vertices[0];
   z = _mm_shuffle_ps(xy, xy, 0xaa);
   xy = xy*vLo;
   z = z*vHi;
   x = _mm_shuffle_ps(xy, xy, 0);
   y = _mm_shuffle_ps(xy, xy, 0x55);
  }
  break;
  }
  x = x + y;
  x = x + z;
  stack_array[index] = x;
  max = _mm_max_ps(x, max);         // control the order here so that max is never NaN even if x is nan
  index++;
 }

 // if we found a new max.
 if (0 == segment || 0xf != _mm_movemask_ps((float4)_mm_cmpeq_ps(max, dotMax)))
 { // we found a new max. Search for it
   // find max across the max vector, place in all elements of max -- big latency hit here
  max = _mm_max_ps(max, (float4)_mm_shuffle_ps(max, max, 0x4e));
  max = _mm_max_ps(max, (float4)_mm_shuffle_ps(max, max, 0xb1));

  // It is slightly faster to do this part in scalar code when count < 8. However, the common case for
  // this where it actually makes a difference is handled in the early out at the top of the function,
  // so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
  // complexity, and removed it.

  dotMax = max;

  // scan for the first occurence of max in the array
  size_t test;
  for (index = 0; 0 == (test = _mm_movemask_ps(_mm_cmpeq_ps(stack_array[index], max))); index++)   // local_count must be a multiple of 4
  {
  }
  maxIndex = 4 * index + segment + indexTable[test];
 }

 _mm_store_ss(dotResult, dotMax);
 return maxIndex;
}

long b3_mindot_large(const float *vv, const float *vec, unsigned long count, float *dotResult);

long b3_mindot_large(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 const float4 *vertices = (const float4*)vv;
 static const unsigned char indexTable[16] = { (unsigned char)-1, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 };

 float4 dotmin = b3Assign128(B3_INFINITY, B3_INFINITY, B3_INFINITY, B3_INFINITY);
 float4 vvec = _mm_loadu_ps(vec);
 float4 vHi = b3CastiTo128f(_mm_shuffle_epi32(b3CastfTo128i(vvec), 0xaa));          /// zzzz
 float4 vLo = _mm_movelh_ps(vvec, vvec);                               /// xyxy

 long minIndex = -1L;

 size_t segment = 0;
 float4 stack_array[STACK_ARRAY_COUNT];

#if DEBUG
 // memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
#endif

 size_t index;
 float4 min;
 // Faster loop without cleanup code for full tiles
 for (segment = 0; segment + STACK_ARRAY_COUNT * 4 <= count; segment += STACK_ARRAY_COUNT * 4)
 {
  min = dotmin;

  for (index = 0; index < STACK_ARRAY_COUNT; index += 4)
  { // do four dot products at a time. Carefully avoid touching the w element.
   float4 v0 = vertices[0];
   float4 v1 = vertices[1];
   float4 v2 = vertices[2];
   float4 v3 = vertices[3];            vertices += 4;

   float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
   float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
   float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 1] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 2] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 3] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

                                     // It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
  }

  // If we found a new min
  if (0xf != _mm_movemask_ps((float4)_mm_cmpeq_ps(min, dotmin)))
  {
   // copy the new min across all lanes of our min accumulator
   min = _mm_min_ps(min, (float4)_mm_shuffle_ps(min, min, 0x4e));
   min = _mm_min_ps(min, (float4)_mm_shuffle_ps(min, min, 0xb1));

   dotmin = min;

   // find first occurrence of that min
   size_t test;
   for (index = 0; 0 == (test = _mm_movemask_ps(_mm_cmpeq_ps(stack_array[index], min))); index++)   // local_count must be a multiple of 4
   {
   }
   // record where it is.
   minIndex = 4 * index + segment + indexTable[test];
  }
 }

 // account for work we've already done
 count -= segment;

 // Deal with the last < STACK_ARRAY_COUNT vectors
 min = dotmin;
 index = 0;


 if (b3Unlikely(count > 16))
 {
  for (; index + 4 <= count / 4; index += 4)
  { // do four dot products at a time. Carefully avoid touching the w element.
   float4 v0 = vertices[0];
   float4 v1 = vertices[1];
   float4 v2 = vertices[2];
   float4 v3 = vertices[3];            vertices += 4;

   float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
   float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
   float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 1] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 2] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];
   v3 = vertices[3];            vertices += 4;

   lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
   hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
   lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
   hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

   lo0 = lo0*vLo;
   lo1 = lo1*vLo;
   z = _mm_shuffle_ps(hi0, hi1, 0x88);
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
   z = z*vHi;
   x = x + y;
   x = x + z;
   stack_array[index + 3] = x;
   min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan

                                     // It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
  }
 }

 size_t localCount = (count & -4L) - 4 * index;
 if (localCount)
 {


#ifdef __APPLE__
  vertices += localCount;      // counter the offset
  float4 t0, t1, t2, t3, t4;
  size_t byteIndex = -(localCount) * sizeof(float);
  float4 * sap = &stack_array[index + localCount / 4];

  asm volatile
   (".align 4                                                                   \n\
             0: movaps  %[min], %[t2]                            // move min out of the way to avoid propagating NaNs in min \n\
             movaps  (%[vertices], %[byteIndex], 4),    %[t0]    // vertices[0]      \n\
             movaps  16(%[vertices], %[byteIndex], 4),  %[t1]    // vertices[1]      \n\
             movaps  %[t0], %[min]                               // vertices[0]      \n\
             movlhps %[t1], %[min]                               // x0y0x1y1         \n\
             movaps  32(%[vertices], %[byteIndex], 4),  %[t3]    // vertices[2]      \n\
             movaps  48(%[vertices], %[byteIndex], 4),  %[t4]    // vertices[3]      \n\
             mulps   %[vLo], %[min]                              // x0y0x1y1 * vLo   \n\
             movhlps %[t0], %[t1]                                // z0w0z1w1         \n\
             movaps  %[t3], %[t0]                                // vertices[2]      \n\
             movlhps %[t4], %[t0]                                // x2y2x3y3         \n\
             movhlps %[t3], %[t4]                                // z2w2z3w3         \n\
             mulps   %[vLo], %[t0]                               // x2y2x3y3 * vLo   \n\
             shufps  $0x88, %[t4], %[t1]                         // z0z1z2z3         \n\
             mulps   %[vHi], %[t1]                               // z0z1z2z3 * vHi   \n\
             movaps  %[min], %[t3]                               // x0y0x1y1 * vLo   \n\
             shufps  $0x88, %[t0], %[min]                        // x0x1x2x3 * vLo.x \n\
             shufps  $0xdd, %[t0], %[t3]                         // y0y1y2y3 * vLo.y \n\
             addps   %[t3], %[min]                               // x + y            \n\
             addps   %[t1], %[min]                               // x + y + z        \n\
             movaps  %[min], (%[sap], %[byteIndex])              // record result for later scrutiny \n\
             minps   %[t2], %[min]                               // record min, restore min   \n\
             add     $16, %[byteIndex]                           // advance loop counter\n\
             jnz     0b                                          \n\
             "
    : [min] "+x" (min), [t0] "=&x" (t0), [t1] "=&x" (t1), [t2] "=&x" (t2), [t3] "=&x" (t3), [t4] "=&x" (t4), [byteIndex] "+r" (byteIndex)
    : [vLo] "x" (vLo), [vHi] "x" (vHi), [vertices] "r" (vertices), [sap] "r" (sap)
    : "memory", "cc"
    );
  index += localCount / 4;
#else
  {
   for (unsigned int i = 0; i<localCount / 4; i++, index++)
   { // do four dot products at a time. Carefully avoid touching the w element.
    float4 v0 = vertices[0];
    float4 v1 = vertices[1];
    float4 v2 = vertices[2];
    float4 v3 = vertices[3];
    vertices += 4;

    float4 lo0 = _mm_movelh_ps(v0, v1);    // x0y0x1y1
    float4 hi0 = _mm_movehl_ps(v1, v0);    // z0?0z1?1
    float4 lo1 = _mm_movelh_ps(v2, v3);    // x2y2x3y3
    float4 hi1 = _mm_movehl_ps(v3, v2);    // z2?2z3?3

    lo0 = lo0*vLo;
    lo1 = lo1*vLo;
    float4 z = _mm_shuffle_ps(hi0, hi1, 0x88);
    float4 x = _mm_shuffle_ps(lo0, lo1, 0x88);
    float4 y = _mm_shuffle_ps(lo0, lo1, 0xdd);
    z = z*vHi;
    x = x + y;
    x = x + z;
    stack_array[index] = x;
    min = _mm_min_ps(x, min);         // control the order here so that max is never NaN even if x is nan
   }
  }

#endif
 }

 // process the last few points
 if (count & 3)
 {
  float4 v0, v1, v2, x, y, z;
  switch (count & 3)
  {
  case 3:
  {
   v0 = vertices[0];
   v1 = vertices[1];
   v2 = vertices[2];

   // Calculate 3 dot products, transpose, duplicate v2
   float4 lo0 = _mm_movelh_ps(v0, v1);        // xyxy.lo
   float4 hi0 = _mm_movehl_ps(v1, v0);        // z?z?.lo
   lo0 = lo0*vLo;
   z = _mm_shuffle_ps(hi0, v2, 0xa8);           // z0z1z2z2
   z = z*vHi;
   float4 lo1 = _mm_movelh_ps(v2, v2);          // xyxy
   lo1 = lo1*vLo;
   x = _mm_shuffle_ps(lo0, lo1, 0x88);
   y = _mm_shuffle_ps(lo0, lo1, 0xdd);
  }
  break;
  case 2:
  {
   v0 = vertices[0];
   v1 = vertices[1];
   float4 xy = _mm_movelh_ps(v0, v1);
   z = _mm_movehl_ps(v1, v0);
   xy = xy*vLo;
   z = _mm_shuffle_ps(z, z, 0xa8);
   x = _mm_shuffle_ps(xy, xy, 0xa8);
   y = _mm_shuffle_ps(xy, xy, 0xfd);
   z = z*vHi;
  }
  break;
  case 1:
  {
   float4 xy = vertices[0];
   z = _mm_shuffle_ps(xy, xy, 0xaa);
   xy = xy*vLo;
   z = z*vHi;
   x = _mm_shuffle_ps(xy, xy, 0);
   y = _mm_shuffle_ps(xy, xy, 0x55);
  }
  break;
  }
  x = x + y;
  x = x + z;
  stack_array[index] = x;
  min = _mm_min_ps(x, min);         // control the order here so that min is never NaN even if x is nan
  index++;
 }

 // if we found a new min.
 if (0 == segment || 0xf != _mm_movemask_ps((float4)_mm_cmpeq_ps(min, dotmin)))
 { // we found a new min. Search for it
   // find min across the min vector, place in all elements of min -- big latency hit here
  min = _mm_min_ps(min, (float4)_mm_shuffle_ps(min, min, 0x4e));
  min = _mm_min_ps(min, (float4)_mm_shuffle_ps(min, min, 0xb1));

  // It is slightly faster to do this part in scalar code when count < 8. However, the common case for
  // this where it actually makes a difference is handled in the early out at the top of the function,
  // so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
  // complexity, and removed it.

  dotmin = min;

  // scan for the first occurence of min in the array
  size_t test;
  for (index = 0; 0 == (test = _mm_movemask_ps(_mm_cmpeq_ps(stack_array[index], min))); index++)   // local_count must be a multiple of 4
  {
  }
  minIndex = 4 * index + segment + indexTable[test];
 }

 _mm_store_ss(dotResult, dotmin);
 return minIndex;
}


#elif defined B3_USE_NEON
#define ARM_NEON_GCC_COMPATIBILITY  1
#include <arm_neon.h>


static long b3_maxdot_large_v0(const float *vv, const float *vec, unsigned long count, float *dotResult);
static long b3_maxdot_large_v1(const float *vv, const float *vec, unsigned long count, float *dotResult);
static long b3_maxdot_large_sel(const float *vv, const float *vec, unsigned long count, float *dotResult);
static long b3_mindot_large_v0(const float *vv, const float *vec, unsigned long count, float *dotResult);
static long b3_mindot_large_v1(const float *vv, const float *vec, unsigned long count, float *dotResult);
static long b3_mindot_large_sel(const float *vv, const float *vec, unsigned long count, float *dotResult);

long(*b3_maxdot_large)(const float *vv, const float *vec, unsigned long count, float *dotResult) = b3_maxdot_large_sel;
long(*b3_mindot_large)(const float *vv, const float *vec, unsigned long count, float *dotResult) = b3_mindot_large_sel;

extern "C" {int  _get_cpu_capabilities(void); }

static long b3_maxdot_large_sel(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 if (_get_cpu_capabilities() & 0x2000)
  b3_maxdot_large = _maxdot_large_v1;
 else
  b3_maxdot_large = _maxdot_large_v0;

 return b3_maxdot_large(vv, vec, count, dotResult);
}

static long b3_mindot_large_sel(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 if (_get_cpu_capabilities() & 0x2000)
  b3_mindot_large = _mindot_large_v1;
 else
  b3_mindot_large = _mindot_large_v0;

 return b3_mindot_large(vv, vec, count, dotResult);
}



#define vld1q_f32_aligned_postincrement( _ptr ) ({ float32x4_t _r; asm( "vld1.f32  {%0}, [%1, :128]!\n" : "=w" (_r), "+r" (_ptr) ); /*return*/ _r; })


long b3_maxdot_large_v0(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 unsigned long i = 0;
 float32x4_t vvec = vld1q_f32_aligned_postincrement(vec);
 float32x2_t vLo = vget_low_f32(vvec);
 float32x2_t vHi = vdup_lane_f32(vget_high_f32(vvec), 0);
 float32x2_t dotMaxLo = (float32x2_t) { -B3_INFINITY, -B3_INFINITY };
 float32x2_t dotMaxHi = (float32x2_t) { -B3_INFINITY, -B3_INFINITY };
 uint32x2_t indexLo = (uint32x2_t) { 0, 1 };
 uint32x2_t indexHi = (uint32x2_t) { 2, 3 };
 uint32x2_t iLo = (uint32x2_t) { -1, -1 };
 uint32x2_t iHi = (uint32x2_t) { -1, -1 };
 const uint32x2_t four = (uint32x2_t) { 4, 4 };

 for (; i + 8 <= count; i += 8)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);
  float32x2_t xy3 = vmul_f32(vget_low_f32(v3), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2x2_t z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(z1.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vcgt_f32(rLo, dotMaxLo);
  uint32x2_t maskHi = vcgt_f32(rHi, dotMaxHi);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  dotMaxHi = vbsl_f32(maskHi, rHi, dotMaxHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);

  v0 = vld1q_f32_aligned_postincrement(vv);
  v1 = vld1q_f32_aligned_postincrement(vv);
  v2 = vld1q_f32_aligned_postincrement(vv);
  v3 = vld1q_f32_aligned_postincrement(vv);

  xy0 = vmul_f32(vget_low_f32(v0), vLo);
  xy1 = vmul_f32(vget_low_f32(v1), vLo);
  xy2 = vmul_f32(vget_low_f32(v2), vLo);
  xy3 = vmul_f32(vget_low_f32(v3), vLo);

  z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  zLo = vmul_f32(z0.val[0], vHi);
  zHi = vmul_f32(z1.val[0], vHi);

  rLo = vpadd_f32(xy0, xy1);
  rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  maskLo = vcgt_f32(rLo, dotMaxLo);
  maskHi = vcgt_f32(rHi, dotMaxHi);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  dotMaxHi = vbsl_f32(maskHi, rHi, dotMaxHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);
 }

 for (; i + 4 <= count; i += 4)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);
  float32x2_t xy3 = vmul_f32(vget_low_f32(v3), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2x2_t z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(z1.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vcgt_f32(rLo, dotMaxLo);
  uint32x2_t maskHi = vcgt_f32(rHi, dotMaxHi);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  dotMaxHi = vbsl_f32(maskHi, rHi, dotMaxHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);
 }

 switch (count & 3)
 {
 case 3:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(vdup_lane_f32(vget_high_f32(v2), 0), vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy2);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vcgt_f32(rLo, dotMaxLo);
  uint32x2_t maskHi = vcgt_f32(rHi, dotMaxHi);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  dotMaxHi = vbsl_f32(maskHi, rHi, dotMaxHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
 }
 break;
 case 2:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  rLo = vadd_f32(rLo, zLo);

  uint32x2_t maskLo = vcgt_f32(rLo, dotMaxLo);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
 }
 break;
 case 1:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t z0 = vdup_lane_f32(vget_high_f32(v0), 0);
  float32x2_t zLo = vmul_f32(z0, vHi);
  float32x2_t rLo = vpadd_f32(xy0, xy0);
  rLo = vadd_f32(rLo, zLo);
  uint32x2_t maskLo = vcgt_f32(rLo, dotMaxLo);
  dotMaxLo = vbsl_f32(maskLo, rLo, dotMaxLo);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
 }
 break;

 default:
  break;
 }

 // select best answer between hi and lo results
 uint32x2_t mask = vcgt_f32(dotMaxHi, dotMaxLo);
 dotMaxLo = vbsl_f32(mask, dotMaxHi, dotMaxLo);
 iLo = vbsl_u32(mask, iHi, iLo);

 // select best answer between even and odd results
 dotMaxHi = vdup_lane_f32(dotMaxLo, 1);
 iHi = vdup_lane_u32(iLo, 1);
 mask = vcgt_f32(dotMaxHi, dotMaxLo);
 dotMaxLo = vbsl_f32(mask, dotMaxHi, dotMaxLo);
 iLo = vbsl_u32(mask, iHi, iLo);

 *dotResult = vget_lane_f32(dotMaxLo, 0);
 return vget_lane_u32(iLo, 0);
}


long b3_maxdot_large_v1(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 float32x4_t vvec = vld1q_f32_aligned_postincrement(vec);
 float32x4_t vLo = vcombine_f32(vget_low_f32(vvec), vget_low_f32(vvec));
 float32x4_t vHi = vdupq_lane_f32(vget_high_f32(vvec), 0);
 const uint32x4_t four = (uint32x4_t) { 4, 4, 4, 4 };
 uint32x4_t local_index = (uint32x4_t) { 0, 1, 2, 3 };
 uint32x4_t index = (uint32x4_t) { -1, -1, -1, -1 };
 float32x4_t maxDot = (float32x4_t) { -B3_INFINITY, -B3_INFINITY, -B3_INFINITY, -B3_INFINITY };

 unsigned long i = 0;
 for (; i + 8 <= count; i += 8)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);

  v0 = vld1q_f32_aligned_postincrement(vv);
  v1 = vld1q_f32_aligned_postincrement(vv);
  v2 = vld1q_f32_aligned_postincrement(vv);
  v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  zb = vuzpq_f32(z0, z1);
  z = vmulq_f32(zb.val[0], vHi);
  xy = vuzpq_f32(xy0, xy1);
  x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }

 for (; i + 4 <= count; i += 4)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }

 switch (count & 3) {
 case 3:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v2));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v2));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 case 2:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));

  xy0 = vmulq_f32(xy0, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z0);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy0);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 case 1:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v0));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z = vdupq_lane_f32(vget_high_f32(v0), 0);

  xy0 = vmulq_f32(xy0, vLo);

  z = vmulq_f32(z, vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy0);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcgtq_f32(x, maxDot);
  maxDot = vbslq_f32(mask, x, maxDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 default:
  break;
 }


 // select best answer between hi and lo results
 uint32x2_t mask = vcgt_f32(vget_high_f32(maxDot), vget_low_f32(maxDot));
 float32x2_t maxDot2 = vbsl_f32(mask, vget_high_f32(maxDot), vget_low_f32(maxDot));
 uint32x2_t index2 = vbsl_u32(mask, vget_high_u32(index), vget_low_u32(index));

 // select best answer between even and odd results
 float32x2_t maxDotO = vdup_lane_f32(maxDot2, 1);
 uint32x2_t indexHi = vdup_lane_u32(index2, 1);
 mask = vcgt_f32(maxDotO, maxDot2);
 maxDot2 = vbsl_f32(mask, maxDotO, maxDot2);
 index2 = vbsl_u32(mask, indexHi, index2);

 *dotResult = vget_lane_f32(maxDot2, 0);
 return vget_lane_u32(index2, 0);

}

long b3_mindot_large_v0(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 unsigned long i = 0;
 float32x4_t vvec = vld1q_f32_aligned_postincrement(vec);
 float32x2_t vLo = vget_low_f32(vvec);
 float32x2_t vHi = vdup_lane_f32(vget_high_f32(vvec), 0);
 float32x2_t dotMinLo = (float32x2_t) { B3_INFINITY, B3_INFINITY };
 float32x2_t dotMinHi = (float32x2_t) { B3_INFINITY, B3_INFINITY };
 uint32x2_t indexLo = (uint32x2_t) { 0, 1 };
 uint32x2_t indexHi = (uint32x2_t) { 2, 3 };
 uint32x2_t iLo = (uint32x2_t) { -1, -1 };
 uint32x2_t iHi = (uint32x2_t) { -1, -1 };
 const uint32x2_t four = (uint32x2_t) { 4, 4 };

 for (; i + 8 <= count; i += 8)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);
  float32x2_t xy3 = vmul_f32(vget_low_f32(v3), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2x2_t z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(z1.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vclt_f32(rLo, dotMinLo);
  uint32x2_t maskHi = vclt_f32(rHi, dotMinHi);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  dotMinHi = vbsl_f32(maskHi, rHi, dotMinHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);

  v0 = vld1q_f32_aligned_postincrement(vv);
  v1 = vld1q_f32_aligned_postincrement(vv);
  v2 = vld1q_f32_aligned_postincrement(vv);
  v3 = vld1q_f32_aligned_postincrement(vv);

  xy0 = vmul_f32(vget_low_f32(v0), vLo);
  xy1 = vmul_f32(vget_low_f32(v1), vLo);
  xy2 = vmul_f32(vget_low_f32(v2), vLo);
  xy3 = vmul_f32(vget_low_f32(v3), vLo);

  z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  zLo = vmul_f32(z0.val[0], vHi);
  zHi = vmul_f32(z1.val[0], vHi);

  rLo = vpadd_f32(xy0, xy1);
  rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  maskLo = vclt_f32(rLo, dotMinLo);
  maskHi = vclt_f32(rHi, dotMinHi);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  dotMinHi = vbsl_f32(maskHi, rHi, dotMinHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);
 }

 for (; i + 4 <= count; i += 4)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);
  float32x2_t xy3 = vmul_f32(vget_low_f32(v3), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2x2_t z1 = vtrn_f32(vget_high_f32(v2), vget_high_f32(v3));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(z1.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy3);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vclt_f32(rLo, dotMinLo);
  uint32x2_t maskHi = vclt_f32(rHi, dotMinHi);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  dotMinHi = vbsl_f32(maskHi, rHi, dotMinHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
  indexLo = vadd_u32(indexLo, four);
  indexHi = vadd_u32(indexHi, four);
 }
 switch (count & 3)
 {
 case 3:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);
  float32x2_t xy2 = vmul_f32(vget_low_f32(v2), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);
  float32x2_t zHi = vmul_f32(vdup_lane_f32(vget_high_f32(v2), 0), vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  float32x2_t rHi = vpadd_f32(xy2, xy2);
  rLo = vadd_f32(rLo, zLo);
  rHi = vadd_f32(rHi, zHi);

  uint32x2_t maskLo = vclt_f32(rLo, dotMinLo);
  uint32x2_t maskHi = vclt_f32(rHi, dotMinHi);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  dotMinHi = vbsl_f32(maskHi, rHi, dotMinHi);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
  iHi = vbsl_u32(maskHi, indexHi, iHi);
 }
 break;
 case 2:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);

  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t xy1 = vmul_f32(vget_low_f32(v1), vLo);

  float32x2x2_t z0 = vtrn_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x2_t zLo = vmul_f32(z0.val[0], vHi);

  float32x2_t rLo = vpadd_f32(xy0, xy1);
  rLo = vadd_f32(rLo, zLo);

  uint32x2_t maskLo = vclt_f32(rLo, dotMinLo);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
 }
 break;
 case 1:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x2_t xy0 = vmul_f32(vget_low_f32(v0), vLo);
  float32x2_t z0 = vdup_lane_f32(vget_high_f32(v0), 0);
  float32x2_t zLo = vmul_f32(z0, vHi);
  float32x2_t rLo = vpadd_f32(xy0, xy0);
  rLo = vadd_f32(rLo, zLo);
  uint32x2_t maskLo = vclt_f32(rLo, dotMinLo);
  dotMinLo = vbsl_f32(maskLo, rLo, dotMinLo);
  iLo = vbsl_u32(maskLo, indexLo, iLo);
 }
 break;

 default:
  break;
 }

 // select best answer between hi and lo results
 uint32x2_t mask = vclt_f32(dotMinHi, dotMinLo);
 dotMinLo = vbsl_f32(mask, dotMinHi, dotMinLo);
 iLo = vbsl_u32(mask, iHi, iLo);

 // select best answer between even and odd results
 dotMinHi = vdup_lane_f32(dotMinLo, 1);
 iHi = vdup_lane_u32(iLo, 1);
 mask = vclt_f32(dotMinHi, dotMinLo);
 dotMinLo = vbsl_f32(mask, dotMinHi, dotMinLo);
 iLo = vbsl_u32(mask, iHi, iLo);

 *dotResult = vget_lane_f32(dotMinLo, 0);
 return vget_lane_u32(iLo, 0);
}

long b3_mindot_large_v1(const float *vv, const float *vec, unsigned long count, float *dotResult)
{
 float32x4_t vvec = vld1q_f32_aligned_postincrement(vec);
 float32x4_t vLo = vcombine_f32(vget_low_f32(vvec), vget_low_f32(vvec));
 float32x4_t vHi = vdupq_lane_f32(vget_high_f32(vvec), 0);
 const uint32x4_t four = (uint32x4_t) { 4, 4, 4, 4 };
 uint32x4_t local_index = (uint32x4_t) { 0, 1, 2, 3 };
 uint32x4_t index = (uint32x4_t) { -1, -1, -1, -1 };
 float32x4_t minDot = (float32x4_t) { B3_INFINITY, B3_INFINITY, B3_INFINITY, B3_INFINITY };

 unsigned long i = 0;
 for (; i + 8 <= count; i += 8)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);

  v0 = vld1q_f32_aligned_postincrement(vv);
  v1 = vld1q_f32_aligned_postincrement(vv);
  v2 = vld1q_f32_aligned_postincrement(vv);
  v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  zb = vuzpq_f32(z0, z1);
  z = vmulq_f32(zb.val[0], vHi);
  xy = vuzpq_f32(xy0, xy1);
  x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }

 for (; i + 4 <= count; i += 4)
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v3 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v3));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v3));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }

 switch (count & 3) {
 case 3:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v2 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  float32x4_t xy1 = vcombine_f32(vget_low_f32(v2), vget_low_f32(v2));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));
  float32x4_t z1 = vcombine_f32(vget_high_f32(v2), vget_high_f32(v2));

  xy0 = vmulq_f32(xy0, vLo);
  xy1 = vmulq_f32(xy1, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z1);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy1);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 case 2:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);
  float32x4_t v1 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v1));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z0 = vcombine_f32(vget_high_f32(v0), vget_high_f32(v1));

  xy0 = vmulq_f32(xy0, vLo);

  float32x4x2_t zb = vuzpq_f32(z0, z0);
  float32x4_t z = vmulq_f32(zb.val[0], vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy0);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 case 1:
 {
  float32x4_t v0 = vld1q_f32_aligned_postincrement(vv);

  // the next two lines should resolve to a single vswp d, d
  float32x4_t xy0 = vcombine_f32(vget_low_f32(v0), vget_low_f32(v0));
  // the next two lines should resolve to a single vswp d, d
  float32x4_t z = vdupq_lane_f32(vget_high_f32(v0), 0);

  xy0 = vmulq_f32(xy0, vLo);

  z = vmulq_f32(z, vHi);
  float32x4x2_t xy = vuzpq_f32(xy0, xy0);
  float32x4_t x = vaddq_f32(xy.val[0], xy.val[1]);
  x = vaddq_f32(x, z);

  uint32x4_t mask = vcltq_f32(x, minDot);
  minDot = vbslq_f32(mask, x, minDot);
  index = vbslq_u32(mask, local_index, index);
  local_index = vaddq_u32(local_index, four);
 }
 break;

 default:
  break;
 }


 // select best answer between hi and lo results
 uint32x2_t mask = vclt_f32(vget_high_f32(minDot), vget_low_f32(minDot));
 float32x2_t minDot2 = vbsl_f32(mask, vget_high_f32(minDot), vget_low_f32(minDot));
 uint32x2_t index2 = vbsl_u32(mask, vget_high_u32(index), vget_low_u32(index));

 // select best answer between even and odd results
 float32x2_t minDotO = vdup_lane_f32(minDot2, 1);
 uint32x2_t indexHi = vdup_lane_u32(index2, 1);
 mask = vclt_f32(minDotO, minDot2);
 minDot2 = vbsl_f32(mask, minDotO, minDot2);
 index2 = vbsl_u32(mask, indexHi, index2);

 *dotResult = vget_lane_f32(minDot2, 0);
 return vget_lane_u32(index2, 0);

}

#else
#error Unhandled __APPLE__ arch
#endif

#endif  /* __APPLE__ */

#include "Bullet3Dynamics/b3CpuRigidBodyPipeline.h"

#include "Bullet3Dynamics/shared/b3IntegrateTransforms.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3RigidBodyData.h"
#include "Bullet3Collision/BroadPhaseCollision/b3DynamicBvhBroadphase.h"
#include "Bullet3Collision/NarrowPhaseCollision/b3Config.h"
#include "Bullet3Collision/NarrowPhaseCollision/b3CpuNarrowPhase.h"
#include "Bullet3Collision/BroadPhaseCollision/shared/b3Aabb.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3Collidable.h"
#include "Bullet3Common/b3Vector3.h"
#include "Bullet3Dynamics/shared/b3ContactConstraint4.h"
#include "Bullet3Dynamics/shared/b3Inertia.h"


struct b3CpuRigidBodyPipelineInternalData
{
 b3AlignedObjectArray<b3RigidBodyData> m_rigidBodies;
 b3AlignedObjectArray<b3Inertia> m_inertias;
 b3AlignedObjectArray<b3Aabb> m_aabbWorldSpace;

 b3DynamicBvhBroadphase* m_bp;
 b3CpuNarrowPhase* m_np;
 b3Config m_config;
};


b3CpuRigidBodyPipeline::b3CpuRigidBodyPipeline(class b3CpuNarrowPhase* narrowphase, struct b3DynamicBvhBroadphase* broadphaseDbvt, const b3Config& config)
{
 m_data = new b3CpuRigidBodyPipelineInternalData;
 m_data->m_np = narrowphase;
 m_data->m_bp = broadphaseDbvt;
 m_data->m_config = config;
}

b3CpuRigidBodyPipeline::~b3CpuRigidBodyPipeline()
{
 delete m_data;
}

void b3CpuRigidBodyPipeline::updateAabbWorldSpace()
{

 for (int i = 0; i<this->getNumBodies(); i++)
 {
  b3RigidBodyData* body = &m_data->m_rigidBodies[i];
  b3Float4 position = body->m_pos;
  b3Quat	orientation = body->m_quat;

  int collidableIndex = body->m_collidableIdx;
  b3Collidable& collidable = m_data->m_np->getCollidableCpu(collidableIndex);
  int shapeIndex = collidable.m_shapeIndex;

  if (shapeIndex >= 0)
  {


   b3Aabb localAabb = m_data->m_np->getLocalSpaceAabb(shapeIndex);
   b3Aabb& worldAabb = m_data->m_aabbWorldSpace[i];
   float margin = 0.f;
   b3TransformAabb2(localAabb.m_minVec, localAabb.m_maxVec, margin, position, orientation, &worldAabb.m_minVec, &worldAabb.m_maxVec);
   m_data->m_bp->setAabb(i, worldAabb.m_minVec, worldAabb.m_maxVec, 0);
  }
 }
}

void	b3CpuRigidBodyPipeline::computeOverlappingPairs()
{
 int numPairs = m_data->m_bp->getOverlappingPairCache()->getNumOverlappingPairs();
 m_data->m_bp->calculateOverlappingPairs();
 numPairs = m_data->m_bp->getOverlappingPairCache()->getNumOverlappingPairs();
 printf("numPairs=%d\n", numPairs);
}

void b3CpuRigidBodyPipeline::computeContactPoints()
{

 b3AlignedObjectArray<b3Int4>& pairs = m_data->m_bp->getOverlappingPairCache()->getOverlappingPairArray();

 m_data->m_np->computeContacts(pairs, m_data->m_aabbWorldSpace, m_data->m_rigidBodies);

}
void	b3CpuRigidBodyPipeline::stepSimulation(float deltaTime)
{

 //update world space aabb's
 updateAabbWorldSpace();

 //compute overlapping pairs
 computeOverlappingPairs();

 //compute contacts
 computeContactPoints();

 //solve contacts

 //update transforms
 integrate(deltaTime);


}


static	inline	float b3CalcRelVel(const b3Vector3& l0, const b3Vector3& l1, const b3Vector3& a0, const b3Vector3& a1,
 const b3Vector3& linVel0, const b3Vector3& angVel0, const b3Vector3& linVel1, const b3Vector3& angVel1)
{
 return b3Dot(l0, linVel0) + b3Dot(a0, angVel0) + b3Dot(l1, linVel1) + b3Dot(a1, angVel1);
}


static	inline	void b3SetLinearAndAngular(const b3Vector3& n, const b3Vector3& r0, const b3Vector3& r1,
 b3Vector3& linear, b3Vector3& angular0, b3Vector3& angular1)
{
 linear = -n;
 angular0 = -b3Cross(r0, n);
 angular1 = b3Cross(r1, n);
}



static inline void b3SolveContact(b3ContactConstraint4& cs,
 const b3Vector3& posA, b3Vector3& linVelA, b3Vector3& angVelA, float invMassA, const b3Matrix3x3& invInertiaA,
 const b3Vector3& posB, b3Vector3& linVelB, b3Vector3& angVelB, float invMassB, const b3Matrix3x3& invInertiaB,
 float maxRambdaDt[4], float minRambdaDt[4])
{

 b3Vector3 dLinVelA; dLinVelA.setZero();
 b3Vector3 dAngVelA; dAngVelA.setZero();
 b3Vector3 dLinVelB; dLinVelB.setZero();
 b3Vector3 dAngVelB; dAngVelB.setZero();

 for (int ic = 0; ic<4; ic++)
 {
  //	dont necessary because this makes change to 0
  if (cs.m_jacCoeffInv[ic] == 0.f) continue;

  {
   b3Vector3 angular0, angular1, linear;
   b3Vector3 r0 = cs.m_worldPos[ic] - (b3Vector3&)posA;
   b3Vector3 r1 = cs.m_worldPos[ic] - (b3Vector3&)posB;
   b3SetLinearAndAngular((const b3Vector3 &)-cs.m_linear, (const b3Vector3 &)r0, (const b3Vector3 &)r1, linear, angular0, angular1);

   float rambdaDt = b3CalcRelVel((const b3Vector3 &)cs.m_linear, (const b3Vector3 &)-cs.m_linear, angular0, angular1,
    linVelA, angVelA, linVelB, angVelB) + cs.m_b[ic];
   rambdaDt *= cs.m_jacCoeffInv[ic];

   {
    float prevSum = cs.m_appliedRambdaDt[ic];
    float updated = prevSum;
    updated += rambdaDt;
    updated = b3Max(updated, minRambdaDt[ic]);
    updated = b3Min(updated, maxRambdaDt[ic]);
    rambdaDt = updated - prevSum;
    cs.m_appliedRambdaDt[ic] = updated;
   }

   b3Vector3 linImp0 = invMassA*linear*rambdaDt;
   b3Vector3 linImp1 = invMassB*(-linear)*rambdaDt;
   b3Vector3 angImp0 = (invInertiaA* angular0)*rambdaDt;
   b3Vector3 angImp1 = (invInertiaB* angular1)*rambdaDt;
#ifdef _WIN32
   b3Assert(_finite(linImp0.getX()));
   b3Assert(_finite(linImp1.getX()));
#endif
   {
    linVelA += linImp0;
    angVelA += angImp0;
    linVelB += linImp1;
    angVelB += angImp1;
   }
  }
 }


}





static inline void b3SolveFriction(b3ContactConstraint4& cs,
 const b3Vector3& posA, b3Vector3& linVelA, b3Vector3& angVelA, float invMassA, const b3Matrix3x3& invInertiaA,
 const b3Vector3& posB, b3Vector3& linVelB, b3Vector3& angVelB, float invMassB, const b3Matrix3x3& invInertiaB,
 float maxRambdaDt[4], float minRambdaDt[4])
{

 if (cs.m_fJacCoeffInv[0] == 0 && cs.m_fJacCoeffInv[0] == 0) return;
 const b3Vector3& center = (const b3Vector3&)cs.m_center;

 b3Vector3 n = -(const b3Vector3&)cs.m_linear;

 b3Vector3 tangent[2];

 b3PlaneSpace1(n, tangent[0], tangent[1]);

 b3Vector3 angular0, angular1, linear;
 b3Vector3 r0 = center - posA;
 b3Vector3 r1 = center - posB;
 for (int i = 0; i<2; i++)
 {
  b3SetLinearAndAngular(tangent[i], r0, r1, linear, angular0, angular1);
  float rambdaDt = b3CalcRelVel(linear, -linear, angular0, angular1,
   linVelA, angVelA, linVelB, angVelB);
  rambdaDt *= cs.m_fJacCoeffInv[i];

  {
   float prevSum = cs.m_fAppliedRambdaDt[i];
   float updated = prevSum;
   updated += rambdaDt;
   updated = b3Max(updated, minRambdaDt[i]);
   updated = b3Min(updated, maxRambdaDt[i]);
   rambdaDt = updated - prevSum;
   cs.m_fAppliedRambdaDt[i] = updated;
  }

  b3Vector3 linImp0 = invMassA*linear*rambdaDt;
  b3Vector3 linImp1 = invMassB*(-linear)*rambdaDt;
  b3Vector3 angImp0 = (invInertiaA* angular0)*rambdaDt;
  b3Vector3 angImp1 = (invInertiaB* angular1)*rambdaDt;
#ifdef _WIN32
  b3Assert(_finite(linImp0.getX()));
  b3Assert(_finite(linImp1.getX()));
#endif
  linVelA += linImp0;
  angVelA += angImp0;
  linVelB += linImp1;
  angVelB += angImp1;
 }

 {	//	angular damping for point constraint
  b3Vector3 ab = (posB - posA).normalized();
  b3Vector3 ac = (center - posA).normalized();
  if (b3Dot(ab, ac) > 0.95f || (invMassA == 0.f || invMassB == 0.f))
  {
   float angNA = b3Dot(n, angVelA);
   float angNB = b3Dot(n, angVelB);

   angVelA -= (angNA*0.1f)*n;
   angVelB -= (angNB*0.1f)*n;
  }
 }

}





struct b3SolveTask// : public ThreadPool::Task
{
 b3SolveTask(b3AlignedObjectArray<b3RigidBodyData>& bodies,
  b3AlignedObjectArray<b3Inertia>& shapes,
  b3AlignedObjectArray<b3ContactConstraint4>& constraints,
  int start, int nConstraints,
  int maxNumBatches,
  b3AlignedObjectArray<int>* wgUsedBodies, int curWgidx
 )
  : m_bodies(bodies), m_shapes(shapes), m_constraints(constraints),
  m_wgUsedBodies(wgUsedBodies), m_curWgidx(curWgidx),
  m_start(start),
  m_nConstraints(nConstraints),
  m_solveFriction(true),
  m_maxNumBatches(maxNumBatches)
 {}

 unsigned short int getType() { return 0; }

 void run(int tIdx)
 {
  b3AlignedObjectArray<int> usedBodies;
  //printf("run..............\n");


  for (int bb = 0; bb<m_maxNumBatches; bb++)
  {
   usedBodies.resize(0);
   for (int ic = m_nConstraints - 1; ic >= 0; ic--)
    //for(int ic=0; ic<m_nConstraints; ic++)
   {

    int i = m_start + ic;
    if (m_constraints[i].m_batchIdx != bb)
     continue;

    float frictionCoeff = b3GetFrictionCoeff(&m_constraints[i]);
    int aIdx = (int)m_constraints[i].m_bodyA;
    int bIdx = (int)m_constraints[i].m_bodyB;
    //int localBatch = m_constraints[i].m_batchIdx;
    b3RigidBodyData& bodyA = m_bodies[aIdx];
    b3RigidBodyData& bodyB = m_bodies[bIdx];

#if 0
    if ((bodyA.m_invMass) && (bodyB.m_invMass))
    {
     //	printf("aIdx=%d, bIdx=%d\n", aIdx,bIdx);
    }
    if (bIdx == 10)
    {
     //printf("ic(b)=%d, localBatch=%d\n",ic,localBatch);
    }
#endif
    if (aIdx == 10)
    {
     //printf("ic(a)=%d, localBatch=%d\n",ic,localBatch);
    }
    if (usedBodies.size()<(aIdx + 1))
    {
     usedBodies.resize(aIdx + 1, 0);
    }

    if (usedBodies.size()<(bIdx + 1))
    {
     usedBodies.resize(bIdx + 1, 0);
    }

    if (bodyA.m_invMass)
    {
     b3Assert(usedBodies[aIdx] == 0);
     usedBodies[aIdx]++;
    }

    if (bodyB.m_invMass)
    {
     b3Assert(usedBodies[bIdx] == 0);
     usedBodies[bIdx]++;
    }


    if (!m_solveFriction)
    {
     float maxRambdaDt[4] = { FLT_MAX,FLT_MAX,FLT_MAX,FLT_MAX };
     float minRambdaDt[4] = { 0.f,0.f,0.f,0.f };

     b3SolveContact(m_constraints[i], (b3Vector3&)bodyA.m_pos, (b3Vector3&)bodyA.m_linVel, (b3Vector3&)bodyA.m_angVel, bodyA.m_invMass, (const b3Matrix3x3 &)m_shapes[aIdx].m_invInertiaWorld,
      (b3Vector3&)bodyB.m_pos, (b3Vector3&)bodyB.m_linVel, (b3Vector3&)bodyB.m_angVel, bodyB.m_invMass, (const b3Matrix3x3 &)m_shapes[bIdx].m_invInertiaWorld,
      maxRambdaDt, minRambdaDt);

    }
    else
    {
     float maxRambdaDt[4] = { FLT_MAX,FLT_MAX,FLT_MAX,FLT_MAX };
     float minRambdaDt[4] = { 0.f,0.f,0.f,0.f };

     float sum = 0;
     for (int j = 0; j<4; j++)
     {
      sum += m_constraints[i].m_appliedRambdaDt[j];
     }
     frictionCoeff = 0.7f;
     for (int j = 0; j<4; j++)
     {
      maxRambdaDt[j] = frictionCoeff*sum;
      minRambdaDt[j] = -maxRambdaDt[j];
     }

     b3SolveFriction(m_constraints[i], (b3Vector3&)bodyA.m_pos, (b3Vector3&)bodyA.m_linVel, (b3Vector3&)bodyA.m_angVel, bodyA.m_invMass, (const b3Matrix3x3 &)m_shapes[aIdx].m_invInertiaWorld,
      (b3Vector3&)bodyB.m_pos, (b3Vector3&)bodyB.m_linVel, (b3Vector3&)bodyB.m_angVel, bodyB.m_invMass, (const b3Matrix3x3 &)m_shapes[bIdx].m_invInertiaWorld,
      maxRambdaDt, minRambdaDt);

    }
   }

   if (m_wgUsedBodies)
   {
    if (m_wgUsedBodies[m_curWgidx].size()<usedBodies.size())
    {
     m_wgUsedBodies[m_curWgidx].resize(usedBodies.size());
    }
    for (int i = 0; i<usedBodies.size(); i++)
    {
     if (usedBodies[i])
     {
      //printf("cell %d uses body %d\n", m_curWgidx,i);
      m_wgUsedBodies[m_curWgidx][i] = 1;
     }
    }
   }

  }



 }

 b3AlignedObjectArray<b3RigidBodyData>& m_bodies;
 b3AlignedObjectArray<b3Inertia>& m_shapes;
 b3AlignedObjectArray<b3ContactConstraint4>& m_constraints;
 b3AlignedObjectArray<int>* m_wgUsedBodies;
 int m_curWgidx;
 int m_start;
 int m_nConstraints;
 bool m_solveFriction;
 int m_maxNumBatches;
};

void b3CpuRigidBodyPipeline::solveContactConstraints()
{
 int m_nIterations = 4;

 b3AlignedObjectArray<b3ContactConstraint4> contactConstraints;
 //	const b3AlignedObjectArray<b3Contact4Data>& contacts = m_data->m_np->getContacts();
 int n = contactConstraints.size();
 //convert contacts...



 int maxNumBatches = 250;

 for (int iter = 0; iter<m_nIterations; iter++)
 {
  b3SolveTask task(m_data->m_rigidBodies, m_data->m_inertias, contactConstraints, 0, n, maxNumBatches, 0, 0);
  task.m_solveFriction = false;
  task.run(0);
 }

 for (int iter = 0; iter<m_nIterations; iter++)
 {
  b3SolveTask task(m_data->m_rigidBodies, m_data->m_inertias, contactConstraints, 0, n, maxNumBatches, 0, 0);
  task.m_solveFriction = true;
  task.run(0);
 }
}

void b3CpuRigidBodyPipeline::integrate(float deltaTime)
{
 float angDamping = 0.f;
 b3Vector3 gravityAcceleration = b3MakeVector3(0, -9, 0);

 //integrate transforms (external forces/gravity should be moved into constraint solver)
 for (int i = 0; i<m_data->m_rigidBodies.size(); i++)
 {
  b3IntegrateTransform(&m_data->m_rigidBodies[i], deltaTime, angDamping, gravityAcceleration);
 }

}

int		b3CpuRigidBodyPipeline::registerPhysicsInstance(float mass, const float* position, const float* orientation, int collidableIndex, int userData)
{
 b3RigidBodyData body;
 int bodyIndex = m_data->m_rigidBodies.size();
 body.m_invMass = mass ? 1.f / mass : 0.f;
 body.m_angVel.setValue(0, 0, 0);
 body.m_collidableIdx = collidableIndex;
 body.m_frictionCoeff = 0.3f;
 body.m_linVel.setValue(0, 0, 0);
 body.m_pos.setValue(position[0], position[1], position[2]);
 body.m_quat.setValue(orientation[0], orientation[1], orientation[2], orientation[3]);
 body.m_restituitionCoeff = 0.f;

 m_data->m_rigidBodies.push_back(body);


 if (collidableIndex >= 0)
 {
  b3Aabb& worldAabb = m_data->m_aabbWorldSpace.expand();

  b3Aabb localAabb = m_data->m_np->getLocalSpaceAabb(collidableIndex);
  b3Vector3 localAabbMin = b3MakeVector3(localAabb.m_min[0], localAabb.m_min[1], localAabb.m_min[2]);
  b3Vector3 localAabbMax = b3MakeVector3(localAabb.m_max[0], localAabb.m_max[1], localAabb.m_max[2]);

  b3Scalar margin = 0.01f;
  b3Transform t;
  t.setIdentity();
  t.setOrigin(b3MakeVector3(position[0], position[1], position[2]));
  t.setRotation(b3Quaternion(orientation[0], orientation[1], orientation[2], orientation[3]));
  b3TransformAabb(localAabbMin, localAabbMax, margin, t, worldAabb.m_minVec, worldAabb.m_maxVec);

  m_data->m_bp->createProxy(worldAabb.m_minVec, worldAabb.m_maxVec, bodyIndex, 0, 1, 1);
  //		b3Vector3 aabbMin,aabbMax;
  //	m_data->m_bp->getAabb(bodyIndex,aabbMin,aabbMax);

 }
 else
 {
  b3Error("registerPhysicsInstance using invalid collidableIndex\n");
 }

 return bodyIndex;
}


const struct b3RigidBodyData* b3CpuRigidBodyPipeline::getBodyBuffer() const
{
 return m_data->m_rigidBodies.size() ? &m_data->m_rigidBodies[0] : 0;
}

int	b3CpuRigidBodyPipeline::getNumBodies() const
{
 return m_data->m_rigidBodies.size();
}

#include "Bullet3Dynamics/ConstraintSolver/b3FixedConstraint.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3RigidBodyData.h"
#include "Bullet3Common/b3TransformUtil.h"
#include <new>


b3FixedConstraint::b3FixedConstraint(int rbA, int rbB, const b3Transform& frameInA, const b3Transform& frameInB)
 :b3TypedConstraint(B3_FIXED_CONSTRAINT_TYPE, rbA, rbB)
{
 m_pivotInA = frameInA.getOrigin();
 m_pivotInB = frameInB.getOrigin();
 m_relTargetAB = frameInA.getRotation()*frameInB.getRotation().inverse();

}

b3FixedConstraint::~b3FixedConstraint()
{
}


void b3FixedConstraint::getInfo1(b3ConstraintInfo1* info, const b3RigidBodyData* bodies)
{
 info->m_numConstraintRows = 6;
 info->nub = 6;
}

void b3FixedConstraint::getInfo2(b3ConstraintInfo2* info, const b3RigidBodyData* bodies)
{
 //fix the 3 linear degrees of freedom

 const b3Vector3& worldPosA = bodies[m_rbA].m_pos;
 const b3Quaternion& worldOrnA = bodies[m_rbA].m_quat;
 const b3Vector3& worldPosB = bodies[m_rbB].m_pos;
 const b3Quaternion& worldOrnB = bodies[m_rbB].m_quat;

 info->m_J1linearAxis[0] = 1;
 info->m_J1linearAxis[info->rowskip + 1] = 1;
 info->m_J1linearAxis[2 * info->rowskip + 2] = 1;

 b3Vector3 a1 = b3QuatRotate(worldOrnA, m_pivotInA);
 {
  b3Vector3* angular0 = (b3Vector3*)(info->m_J1angularAxis);
  b3Vector3* angular1 = (b3Vector3*)(info->m_J1angularAxis + info->rowskip);
  b3Vector3* angular2 = (b3Vector3*)(info->m_J1angularAxis + 2 * info->rowskip);
  b3Vector3 a1neg = -a1;
  a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }

 if (info->m_J2linearAxis)
 {
  info->m_J2linearAxis[0] = -1;
  info->m_J2linearAxis[info->rowskip + 1] = -1;
  info->m_J2linearAxis[2 * info->rowskip + 2] = -1;
 }

 b3Vector3 a2 = b3QuatRotate(worldOrnB, m_pivotInB);

 {
  //	b3Vector3 a2n = -a2;
  b3Vector3* angular0 = (b3Vector3*)(info->m_J2angularAxis);
  b3Vector3* angular1 = (b3Vector3*)(info->m_J2angularAxis + info->rowskip);
  b3Vector3* angular2 = (b3Vector3*)(info->m_J2angularAxis + 2 * info->rowskip);
  a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }

 // set right hand side for the linear dofs
 b3Scalar k = info->fps * info->erp;
 b3Vector3 linearError = k*(a2 + worldPosB - a1 - worldPosA);
 int j;
 for (j = 0; j<3; j++)
 {
  info->m_constraintError[j*info->rowskip] = linearError[j];
  //printf("info->m_constraintError[%d]=%f\n",j,info->m_constraintError[j]);
 }

 //fix the 3 angular degrees of freedom

 int start_row = 3;
 int s = info->rowskip;
 int start_index = start_row * s;

 // 3 rows to make body rotations equal
 info->m_J1angularAxis[start_index] = 1;
 info->m_J1angularAxis[start_index + s + 1] = 1;
 info->m_J1angularAxis[start_index + s * 2 + 2] = 1;
 if (info->m_J2angularAxis)
 {
  info->m_J2angularAxis[start_index] = -1;
  info->m_J2angularAxis[start_index + s + 1] = -1;
  info->m_J2angularAxis[start_index + s * 2 + 2] = -1;
 }


 // set right hand side for the angular dofs

 b3Vector3 diff;
 b3Scalar angle;
 b3Quaternion qrelCur = worldOrnA *worldOrnB.inverse();

 b3TransformUtil::calculateDiffAxisAngleQuaternion(m_relTargetAB, qrelCur, diff, angle);
 diff *= -angle;
 for (j = 0; j<3; j++)
 {
  info->m_constraintError[(3 + j)*info->rowskip] = k * diff[j];
 }

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
/*
2007-09-09
Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#include "Bullet3Dynamics/ConstraintSolver/b3Generic6DofConstraint.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3RigidBodyData.h"

#include "Bullet3Common/b3TransformUtil.h"
#include "Bullet3Common/b3TransformUtil.h"
#include <new>



#define D6_USE_OBSOLETE_METHOD false
#define D6_USE_FRAME_OFFSET true






b3Generic6DofConstraint::b3Generic6DofConstraint(int rbA, int  rbB, const b3Transform& frameInA, const b3Transform& frameInB, bool useLinearReferenceFrameA, const b3RigidBodyData* bodies)
 : b3TypedConstraint(B3_D6_CONSTRAINT_TYPE, rbA, rbB)
 , m_frameInA(frameInA)
 , m_frameInB(frameInB),
 m_useLinearReferenceFrameA(useLinearReferenceFrameA),
 m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET),
 m_flags(0)
{
 calculateTransforms(bodies);
}






#define GENERIC_D6_DISABLE_WARMSTARTING 1



b3Scalar btGetMatrixElem(const b3Matrix3x3& mat, int index);
b3Scalar btGetMatrixElem(const b3Matrix3x3& mat, int index)
{
 int i = index % 3;
 int j = index / 3;
 return mat[i][j];
}



///MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
bool	matrixToEulerXYZ(const b3Matrix3x3& mat, b3Vector3& xyz);
bool	matrixToEulerXYZ(const b3Matrix3x3& mat, b3Vector3& xyz)
{
 //	// rot =  cy*cz          -cy*sz           sy
 //	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
 //	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
 //

 b3Scalar fi = btGetMatrixElem(mat, 2);
 if (fi < b3Scalar(1.0f))
 {
  if (fi > b3Scalar(-1.0f))
  {
   xyz[0] = b3Atan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 8));
   xyz[1] = b3Asin(btGetMatrixElem(mat, 2));
   xyz[2] = b3Atan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
   return true;
  }
  else
  {
   // WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
   xyz[0] = -b3Atan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
   xyz[1] = -B3_HALF_PI;
   xyz[2] = b3Scalar(0.0);
   return false;
  }
 }
 else
 {
  // WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
  xyz[0] = b3Atan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
  xyz[1] = B3_HALF_PI;
  xyz[2] = 0.0;
 }
 return false;
}

//////////////////////////// b3RotationalLimitMotor ////////////////////////////////////

int b3RotationalLimitMotor::testLimitValue(b3Scalar test_value)
{
 if (m_loLimit>m_hiLimit)
 {
  m_currentLimit = 0;//Free from violation
  return 0;
 }
 if (test_value < m_loLimit)
 {
  m_currentLimit = 1;//low limit violation
  m_currentLimitError = test_value - m_loLimit;
  if (m_currentLimitError>B3_PI)
   m_currentLimitError -= B3_2_PI;
  else if (m_currentLimitError<-B3_PI)
   m_currentLimitError += B3_2_PI;
  return 1;
 }
 else if (test_value> m_hiLimit)
 {
  m_currentLimit = 2;//High limit violation
  m_currentLimitError = test_value - m_hiLimit;
  if (m_currentLimitError>B3_PI)
   m_currentLimitError -= B3_2_PI;
  else if (m_currentLimitError<-B3_PI)
   m_currentLimitError += B3_2_PI;
  return 2;
 };

 m_currentLimit = 0;//Free from violation
 return 0;

}




//////////////////////////// End b3RotationalLimitMotor ////////////////////////////////////




//////////////////////////// b3TranslationalLimitMotor ////////////////////////////////////


int b3TranslationalLimitMotor::testLimitValue(int limitIndex, b3Scalar test_value)
{
 b3Scalar loLimit = m_lowerLimit[limitIndex];
 b3Scalar hiLimit = m_upperLimit[limitIndex];
 if (loLimit > hiLimit)
 {
  m_currentLimit[limitIndex] = 0;//Free from violation
  m_currentLimitError[limitIndex] = b3Scalar(0.f);
  return 0;
 }

 if (test_value < loLimit)
 {
  m_currentLimit[limitIndex] = 2;//low limit violation
  m_currentLimitError[limitIndex] = test_value - loLimit;
  return 2;
 }
 else if (test_value> hiLimit)
 {
  m_currentLimit[limitIndex] = 1;//High limit violation
  m_currentLimitError[limitIndex] = test_value - hiLimit;
  return 1;
 };

 m_currentLimit[limitIndex] = 0;//Free from violation
 m_currentLimitError[limitIndex] = b3Scalar(0.f);
 return 0;
}



//////////////////////////// b3TranslationalLimitMotor ////////////////////////////////////

void b3Generic6DofConstraint::calculateAngleInfo()
{
 b3Matrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse()*m_calculatedTransformB.getBasis();
 matrixToEulerXYZ(relative_frame, m_calculatedAxisAngleDiff);
 // in euler angle mode we do not actually constrain the angular velocity
 // along the axes axis[0] and axis[2] (although we do use axis[1]) :
 //
 //    to get			constrain w2-w1 along		...not
 //    ------			---------------------		------
 //    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
 //    d(angle[1])/dt = 0	ax[1]
 //    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
 //
 // constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
 // to prove the result for angle[0], write the expression for angle[0] from
 // GetInfo1 then take the derivative. to prove this for angle[2] it is
 // easier to take the euler rate expression for d(angle[2])/dt with respect
 // to the components of w and set that to 0.
 b3Vector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
 b3Vector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);

 m_calculatedAxis[1] = axis2.cross(axis0);
 m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
 m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);

 m_calculatedAxis[0].normalize();
 m_calculatedAxis[1].normalize();
 m_calculatedAxis[2].normalize();

}

static b3Transform getCenterOfMassTransform(const b3RigidBodyData& body)
{
 b3Transform tr(body.m_quat, body.m_pos);
 return tr;
}

void b3Generic6DofConstraint::calculateTransforms(const b3RigidBodyData* bodies)
{
 b3Transform transA;
 b3Transform transB;
 transA = getCenterOfMassTransform(bodies[m_rbA]);
 transB = getCenterOfMassTransform(bodies[m_rbB]);
 calculateTransforms(transA, transB, bodies);
}

void b3Generic6DofConstraint::calculateTransforms(const b3Transform& transA, const b3Transform& transB, const b3RigidBodyData* bodies)
{
 m_calculatedTransformA = transA * m_frameInA;
 m_calculatedTransformB = transB * m_frameInB;
 calculateLinearInfo();
 calculateAngleInfo();
 if (m_useOffsetForConstraintFrame)
 {	//  get weight factors depending on masses
  b3Scalar miA = bodies[m_rbA].m_invMass;
  b3Scalar miB = bodies[m_rbB].m_invMass;
  m_hasStaticBody = (miA < B3_EPSILON) || (miB < B3_EPSILON);
  b3Scalar miS = miA + miB;
  if (miS > b3Scalar(0.f))
  {
   m_factA = miB / miS;
  }
  else
  {
   m_factA = b3Scalar(0.5f);
  }
  m_factB = b3Scalar(1.0f) - m_factA;
 }
}







bool b3Generic6DofConstraint::testAngularLimitMotor(int axis_index)
{
 b3Scalar angle = m_calculatedAxisAngleDiff[axis_index];
 angle = b3AdjustAngleToLimits(angle, m_angularLimits[axis_index].m_loLimit, m_angularLimits[axis_index].m_hiLimit);
 m_angularLimits[axis_index].m_currentPosition = angle;
 //test limits
 m_angularLimits[axis_index].testLimitValue(angle);
 return m_angularLimits[axis_index].needApplyTorques();
}




void b3Generic6DofConstraint::getInfo1(b3ConstraintInfo1* info, const b3RigidBodyData* bodies)
{
 //prepare constraint
 calculateTransforms(getCenterOfMassTransform(bodies[m_rbA]), getCenterOfMassTransform(bodies[m_rbB]), bodies);
 info->m_numConstraintRows = 0;
 info->nub = 6;
 int i;
 //test linear limits
 for (i = 0; i < 3; i++)
 {
  if (m_linearLimits.needApplyForce(i))
  {
   info->m_numConstraintRows++;
   info->nub--;
  }
 }
 //test angular limits
 for (i = 0; i<3; i++)
 {
  if (testAngularLimitMotor(i))
  {
   info->m_numConstraintRows++;
   info->nub--;
  }
 }
 //	printf("info->m_numConstraintRows=%d\n",info->m_numConstraintRows);
}

void b3Generic6DofConstraint::getInfo1NonVirtual(b3ConstraintInfo1* info, const b3RigidBodyData* bodies)
{
 //pre-allocate all 6
 info->m_numConstraintRows = 6;
 info->nub = 0;
}


void b3Generic6DofConstraint::getInfo2(b3ConstraintInfo2* info, const b3RigidBodyData* bodies)
{

 b3Transform transA = getCenterOfMassTransform(bodies[m_rbA]);
 b3Transform transB = getCenterOfMassTransform(bodies[m_rbB]);
 const b3Vector3& linVelA = bodies[m_rbA].m_linVel;
 const b3Vector3& linVelB = bodies[m_rbB].m_linVel;
 const b3Vector3& angVelA = bodies[m_rbA].m_angVel;
 const b3Vector3& angVelB = bodies[m_rbB].m_angVel;

 if (m_useOffsetForConstraintFrame)
 { // for stability better to solve angular limits first
  int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
 else
 { // leave old version for compatibility
  int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }

}


void b3Generic6DofConstraint::getInfo2NonVirtual(b3ConstraintInfo2* info, const b3Transform& transA, const b3Transform& transB, const b3Vector3& linVelA, const b3Vector3& linVelB, const b3Vector3& angVelA, const b3Vector3& angVelB, const b3RigidBodyData* bodies)
{

 //prepare constraint
 calculateTransforms(transA, transB, bodies);

 int i;
 for (i = 0; i<3; i++)
 {
  testAngularLimitMotor(i);
 }

 if (m_useOffsetForConstraintFrame)
 { // for stability better to solve angular limits first
  int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
 else
 { // leave old version for compatibility
  int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
}



int b3Generic6DofConstraint::setLinearLimits(b3ConstraintInfo2* info, int row, const b3Transform& transA, const b3Transform& transB, const b3Vector3& linVelA, const b3Vector3& linVelB, const b3Vector3& angVelA, const b3Vector3& angVelB)
{
 //	int row = 0;
 //solve linear limits
 b3RotationalLimitMotor limot;
 for (int i = 0; i<3; i++)
 {
  if (m_linearLimits.needApplyForce(i))
  { // re-use rotational motor code
   limot.m_bounce = b3Scalar(0.f);
   limot.m_currentLimit = m_linearLimits.m_currentLimit[i];
   limot.m_currentPosition = m_linearLimits.m_currentLinearDiff[i];
   limot.m_currentLimitError = m_linearLimits.m_currentLimitError[i];
   limot.m_damping = m_linearLimits.m_damping;
   limot.m_enableMotor = m_linearLimits.m_enableMotor[i];
   limot.m_hiLimit = m_linearLimits.m_upperLimit[i];
   limot.m_limitSoftness = m_linearLimits.m_limitSoftness;
   limot.m_loLimit = m_linearLimits.m_lowerLimit[i];
   limot.m_maxLimitForce = b3Scalar(0.f);
   limot.m_maxMotorForce = m_linearLimits.m_maxMotorForce[i];
   limot.m_targetVelocity = m_linearLimits.m_targetVelocity[i];
   b3Vector3 axis = m_calculatedTransformA.getBasis().getColumn(i);
   int flags = m_flags >> (i * B3_6DOF_FLAGS_AXIS_SHIFT);
   limot.m_normalCFM = (flags & B3_6DOF_FLAGS_CFM_NORM) ? m_linearLimits.m_normalCFM[i] : info->cfm[0];
   limot.m_stopCFM = (flags & B3_6DOF_FLAGS_CFM_STOP) ? m_linearLimits.m_stopCFM[i] : info->cfm[0];
   limot.m_stopERP = (flags & B3_6DOF_FLAGS_ERP_STOP) ? m_linearLimits.m_stopERP[i] : info->erp;
   if (m_useOffsetForConstraintFrame)
   {
    int indx1 = (i + 1) % 3;
    int indx2 = (i + 2) % 3;
    int rotAllowed = 1; // rotations around orthos to current axis
    if (m_angularLimits[indx1].m_currentLimit && m_angularLimits[indx2].m_currentLimit)
    {
     rotAllowed = 0;
    }
    row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0, rotAllowed);
   }
   else
   {
    row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0);
   }
  }
 }
 return row;
}



int b3Generic6DofConstraint::setAngularLimits(b3ConstraintInfo2 *info, int row_offset, const b3Transform& transA, const b3Transform& transB, const b3Vector3& linVelA, const b3Vector3& linVelB, const b3Vector3& angVelA, const b3Vector3& angVelB)
{
 b3Generic6DofConstraint * d6constraint = this;
 int row = row_offset;
 //solve angular limits
 for (int i = 0; i<3; i++)
 {
  if (d6constraint->getRotationalLimitMotor(i)->needApplyTorques())
  {
   b3Vector3 axis = d6constraint->getAxis(i);
   int flags = m_flags >> ((i + 3) * B3_6DOF_FLAGS_AXIS_SHIFT);
   if (!(flags & B3_6DOF_FLAGS_CFM_NORM))
   {
    m_angularLimits[i].m_normalCFM = info->cfm[0];
   }
   if (!(flags & B3_6DOF_FLAGS_CFM_STOP))
   {
    m_angularLimits[i].m_stopCFM = info->cfm[0];
   }
   if (!(flags & B3_6DOF_FLAGS_ERP_STOP))
   {
    m_angularLimits[i].m_stopERP = info->erp;
   }
   row += get_limit_motor_info2(d6constraint->getRotationalLimitMotor(i),
    transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 1);
  }
 }

 return row;
}




void	b3Generic6DofConstraint::updateRHS(b3Scalar	timeStep)
{
 (void)timeStep;

}


void b3Generic6DofConstraint::setFrames(const b3Transform& frameA, const b3Transform& frameB, const b3RigidBodyData* bodies)
{
 m_frameInA = frameA;
 m_frameInB = frameB;

 calculateTransforms(bodies);
}



b3Vector3 b3Generic6DofConstraint::getAxis(int axis_index) const
{
 return m_calculatedAxis[axis_index];
}


b3Scalar	b3Generic6DofConstraint::getRelativePivotPosition(int axisIndex) const
{
 return m_calculatedLinearDiff[axisIndex];
}


b3Scalar b3Generic6DofConstraint::getAngle(int axisIndex) const
{
 return m_calculatedAxisAngleDiff[axisIndex];
}



void b3Generic6DofConstraint::calcAnchorPos(const b3RigidBodyData* bodies)
{
 b3Scalar imA = bodies[m_rbA].m_invMass;
 b3Scalar imB = bodies[m_rbB].m_invMass;
 b3Scalar weight;
 if (imB == b3Scalar(0.0))
 {
  weight = b3Scalar(1.0);
 }
 else
 {
  weight = imA / (imA + imB);
 }
 const b3Vector3& pA = m_calculatedTransformA.getOrigin();
 const b3Vector3& pB = m_calculatedTransformB.getOrigin();
 m_AnchorPos = pA * weight + pB * (b3Scalar(1.0) - weight);
 return;
}



void b3Generic6DofConstraint::calculateLinearInfo()
{
 m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
 m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
 for (int i = 0; i < 3; i++)
 {
  m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
  m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
 }
}



int b3Generic6DofConstraint::get_limit_motor_info2(
 b3RotationalLimitMotor * limot,
 const b3Transform& transA, const b3Transform& transB, const b3Vector3& linVelA, const b3Vector3& linVelB, const b3Vector3& angVelA, const b3Vector3& angVelB,
 b3ConstraintInfo2 *info, int row, b3Vector3& ax1, int rotational, int rotAllowed)
{
 int srow = row * info->rowskip;
 bool powered = limot->m_enableMotor;
 int limit = limot->m_currentLimit;
 if (powered || limit)
 {   // if the joint is powered, or has joint limits, add in the extra row
  b3Scalar *J1 = rotational ? info->m_J1angularAxis : info->m_J1linearAxis;
  b3Scalar *J2 = rotational ? info->m_J2angularAxis : info->m_J2linearAxis;
  if (J1)
  {
   J1[srow + 0] = ax1[0];
   J1[srow + 1] = ax1[1];
   J1[srow + 2] = ax1[2];
  }
  if (J2)
  {
   J2[srow + 0] = -ax1[0];
   J2[srow + 1] = -ax1[1];
   J2[srow + 2] = -ax1[2];
  }
  if ((!rotational))
  {
   if (m_useOffsetForConstraintFrame)
   {
    b3Vector3 tmpA, tmpB, relA, relB;
    // get vector from bodyB to frameB in WCS
    relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
    // get its projection to constraint axis
    b3Vector3 projB = ax1 * relB.dot(ax1);
    // get vector directed from bodyB to constraint axis (and orthogonal to it)
    b3Vector3 orthoB = relB - projB;
    // same for bodyA
    relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
    b3Vector3 projA = ax1 * relA.dot(ax1);
    b3Vector3 orthoA = relA - projA;
    // get desired offset between frames A and B along constraint axis
    b3Scalar desiredOffs = limot->m_currentPosition - limot->m_currentLimitError;
    // desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis
    b3Vector3 totalDist = projA + ax1 * desiredOffs - projB;
    // get offset vectors relA and relB
    relA = orthoA + totalDist * m_factA;
    relB = orthoB - totalDist * m_factB;
    tmpA = relA.cross(ax1);
    tmpB = relB.cross(ax1);
    if (m_hasStaticBody && (!rotAllowed))
    {
     tmpA *= m_factA;
     tmpB *= m_factB;
    }
    int i;
    for (i = 0; i<3; i++) info->m_J1angularAxis[srow + i] = tmpA[i];
    for (i = 0; i<3; i++) info->m_J2angularAxis[srow + i] = -tmpB[i];
   }
   else
   {
    b3Vector3 ltd;	// Linear Torque Decoupling vector
    b3Vector3 c = m_calculatedTransformB.getOrigin() - transA.getOrigin();
    ltd = c.cross(ax1);
    info->m_J1angularAxis[srow + 0] = ltd[0];
    info->m_J1angularAxis[srow + 1] = ltd[1];
    info->m_J1angularAxis[srow + 2] = ltd[2];

    c = m_calculatedTransformB.getOrigin() - transB.getOrigin();
    ltd = -c.cross(ax1);
    info->m_J2angularAxis[srow + 0] = ltd[0];
    info->m_J2angularAxis[srow + 1] = ltd[1];
    info->m_J2angularAxis[srow + 2] = ltd[2];
   }
  }
  // if we're limited low and high simultaneously, the joint motor is
  // ineffective
  if (limit && (limot->m_loLimit == limot->m_hiLimit)) powered = false;
  info->m_constraintError[srow] = b3Scalar(0.f);
  if (powered)
  {
   info->cfm[srow] = limot->m_normalCFM;
   if (!limit)
   {
    b3Scalar tag_vel = rotational ? limot->m_targetVelocity : -limot->m_targetVelocity;

    b3Scalar mot_fact = getMotorFactor(limot->m_currentPosition,
     limot->m_loLimit,
     limot->m_hiLimit,
     tag_vel,
     info->fps * limot->m_stopERP);
    info->m_constraintError[srow] += mot_fact * limot->m_targetVelocity;
    info->m_lowerLimit[srow] = -limot->m_maxMotorForce;
    info->m_upperLimit[srow] = limot->m_maxMotorForce;
   }
  }
  if (limit)
  {
   b3Scalar k = info->fps * limot->m_stopERP;
   if (!rotational)
   {
    info->m_constraintError[srow] += k * limot->m_currentLimitError;
   }
   else
   {
    info->m_constraintError[srow] += -k * limot->m_currentLimitError;
   }
   info->cfm[srow] = limot->m_stopCFM;
   if (limot->m_loLimit == limot->m_hiLimit)
   {   // limited low and high simultaneously
    info->m_lowerLimit[srow] = -B3_INFINITY;
    info->m_upperLimit[srow] = B3_INFINITY;
   }
   else
   {
    if (limit == 1)
    {
     info->m_lowerLimit[srow] = 0;
     info->m_upperLimit[srow] = B3_INFINITY;
    }
    else
    {
     info->m_lowerLimit[srow] = -B3_INFINITY;
     info->m_upperLimit[srow] = 0;
    }
    // deal with bounce
    if (limot->m_bounce > 0)
    {
     // calculate joint velocity
     b3Scalar vel;
     if (rotational)
     {
      vel = angVelA.dot(ax1);
      //make sure that if no body -> angVelB == zero vec
      //                        if (body1)
      vel -= angVelB.dot(ax1);
     }
     else
     {
      vel = linVelA.dot(ax1);
      //make sure that if no body -> angVelB == zero vec
      //                        if (body1)
      vel -= linVelB.dot(ax1);
     }
     // only apply bounce if the velocity is incoming, and if the
     // resulting c[] exceeds what we already have.
     if (limit == 1)
     {
      if (vel < 0)
      {
       b3Scalar newc = -limot->m_bounce* vel;
       if (newc > info->m_constraintError[srow])
        info->m_constraintError[srow] = newc;
      }
     }
     else
     {
      if (vel > 0)
      {
       b3Scalar newc = -limot->m_bounce * vel;
       if (newc < info->m_constraintError[srow])
        info->m_constraintError[srow] = newc;
      }
     }
    }
   }
  }
  return 1;
 }
 else return 0;
}






///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void b3Generic6DofConstraint::setParam(int num, b3Scalar value, int axis)
{
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case B3_CONSTRAINT_STOP_ERP:
   m_linearLimits.m_stopERP[axis] = value;
   m_flags |= B3_6DOF_FLAGS_ERP_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case B3_CONSTRAINT_STOP_CFM:
   m_linearLimits.m_stopCFM[axis] = value;
   m_flags |= B3_6DOF_FLAGS_CFM_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case B3_CONSTRAINT_CFM:
   m_linearLimits.m_normalCFM[axis] = value;
   m_flags |= B3_6DOF_FLAGS_CFM_NORM << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case B3_CONSTRAINT_STOP_ERP:
   m_angularLimits[axis - 3].m_stopERP = value;
   m_flags |= B3_6DOF_FLAGS_ERP_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case B3_CONSTRAINT_STOP_CFM:
   m_angularLimits[axis - 3].m_stopCFM = value;
   m_flags |= B3_6DOF_FLAGS_CFM_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case B3_CONSTRAINT_CFM:
   m_angularLimits[axis - 3].m_normalCFM = value;
   m_flags |= B3_6DOF_FLAGS_CFM_NORM << (axis * B3_6DOF_FLAGS_AXIS_SHIFT);
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
 else
 {
  b3AssertConstrParams(0);
 }
}

///return the local value of parameter
b3Scalar b3Generic6DofConstraint::getParam(int num, int axis) const
{
 b3Scalar retVal = 0;
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case B3_CONSTRAINT_STOP_ERP:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_ERP_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_stopERP[axis];
   break;
  case B3_CONSTRAINT_STOP_CFM:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_CFM_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_stopCFM[axis];
   break;
  case B3_CONSTRAINT_CFM:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_CFM_NORM << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_normalCFM[axis];
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case B3_CONSTRAINT_STOP_ERP:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_ERP_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_stopERP;
   break;
  case B3_CONSTRAINT_STOP_CFM:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_CFM_STOP << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_stopCFM;
   break;
  case B3_CONSTRAINT_CFM:
   b3AssertConstrParams(m_flags & (B3_6DOF_FLAGS_CFM_NORM << (axis * B3_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_normalCFM;
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
 else
 {
  b3AssertConstrParams(0);
 }
 return retVal;
}



void b3Generic6DofConstraint::setAxis(const b3Vector3& axis1, const b3Vector3& axis2, const b3RigidBodyData* bodies)
{
 b3Vector3 zAxis = axis1.normalized();
 b3Vector3 yAxis = axis2.normalized();
 b3Vector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system

 b3Transform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);

 // now get constraint frame in local coordinate systems
 m_frameInA = getCenterOfMassTransform(bodies[m_rbA]).inverse() * frameInW;
 m_frameInB = getCenterOfMassTransform(bodies[m_rbB]).inverse() * frameInW;

 calculateTransforms(bodies);
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2012 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//enable B3_SOLVER_DEBUG if you experience solver crashes
//#define B3_SOLVER_DEBUG
//#define COMPUTE_IMPULSE_DENOM 1
//It is not necessary (redundant) to refresh contact manifolds, this refresh has been moved to the collision algorithms.

//#define DISABLE_JOINTS

#include "Bullet3Dynamics/ConstraintSolver/b3PgsJacobiSolver.h"
#include "Bullet3Common/b3MinMax.h"
#include "Bullet3Dynamics/ConstraintSolver/b3TypedConstraint.h"
#include <new>
#include "Bullet3Common/b3StackAlloc.h"

//#include "b3SolverBody.h"
//#include "b3SolverConstraint.h"
#include "Bullet3Common/b3AlignedObjectArray.h"
#include <string.h> //for memset
//#include "../../dynamics/basic_demo/Stubs/AdlContact4.h"
#include "Bullet3Collision/NarrowPhaseCollision/b3Contact4.h"


#include "Bullet3Collision/NarrowPhaseCollision/shared/b3RigidBodyData.h"

static b3Transform	getWorldTransform(b3RigidBodyData* rb)
{
 b3Transform newTrans;
 newTrans.setOrigin(rb->m_pos);
 newTrans.setRotation(rb->m_quat);
 return newTrans;
}

static const b3Matrix3x3&	getInvInertiaTensorWorld(b3InertiaData* inertia)
{
 return inertia->m_invInertiaWorld;
}



static const b3Vector3&	getLinearVelocity(b3RigidBodyData* rb)
{
 return rb->m_linVel;
}

static const b3Vector3&	getAngularVelocity(b3RigidBodyData* rb)
{
 return rb->m_angVel;
}

static b3Vector3 getVelocityInLocalPoint(b3RigidBodyData* rb, const b3Vector3& rel_pos)
{
 //we also calculate lin/ang velocity for kinematic objects
 return getLinearVelocity(rb) + getAngularVelocity(rb).cross(rel_pos);

}

struct	b3ContactPoint
{
 b3Vector3	m_positionWorldOnA;
 b3Vector3	m_positionWorldOnB;
 b3Vector3	m_normalWorldOnB;
 b3Scalar	m_appliedImpulse;
 b3Scalar	m_distance;
 b3Scalar	m_combinedRestitution;

 ///information related to friction
 b3Scalar	m_combinedFriction;
 b3Vector3	m_lateralFrictionDir1;
 b3Vector3	m_lateralFrictionDir2;
 b3Scalar	m_appliedImpulseLateral1;
 b3Scalar	m_appliedImpulseLateral2;
 b3Scalar	m_combinedRollingFriction;
 b3Scalar	m_contactMotion1;
 b3Scalar	m_contactMotion2;
 b3Scalar	m_contactCFM1;
 b3Scalar	m_contactCFM2;

 bool		m_lateralFrictionInitialized;

 b3Vector3	getPositionWorldOnA()
 {
  return m_positionWorldOnA;
 }
 b3Vector3	getPositionWorldOnB()
 {
  return m_positionWorldOnB;
 }
 b3Scalar	getDistance()
 {
  return m_distance;
 }
};

void	getContactPoint(b3Contact4* contact, int contactIndex, b3ContactPoint& pointOut)
{
 pointOut.m_appliedImpulse = 0.f;
 pointOut.m_appliedImpulseLateral1 = 0.f;
 pointOut.m_appliedImpulseLateral2 = 0.f;
 pointOut.m_combinedFriction = contact->getFrictionCoeff();
 pointOut.m_combinedRestitution = contact->getRestituitionCoeff();
 pointOut.m_combinedRollingFriction = 0.f;
 pointOut.m_contactCFM1 = 0.f;
 pointOut.m_contactCFM2 = 0.f;
 pointOut.m_contactMotion1 = 0.f;
 pointOut.m_contactMotion2 = 0.f;
 pointOut.m_distance = contact->getPenetration(contactIndex);//??0.01f
 b3Vector3 normalOnB = contact->m_worldNormalOnB;
 normalOnB.normalize();//is this needed?

 b3Vector3 l1, l2;
 b3PlaneSpace1(normalOnB, l1, l2);

 pointOut.m_normalWorldOnB = normalOnB;
 //printf("normalOnB = %f,%f,%f\n",normalOnB.getX(),normalOnB.getY(),normalOnB.getZ());
 pointOut.m_lateralFrictionDir1 = l1;
 pointOut.m_lateralFrictionDir2 = l2;
 pointOut.m_lateralFrictionInitialized = true;


 b3Vector3 worldPosB = contact->m_worldPosB[contactIndex];
 pointOut.m_positionWorldOnB = worldPosB;
 pointOut.m_positionWorldOnA = worldPosB + normalOnB*pointOut.m_distance;
}

int	getNumContacts(b3Contact4* contact)
{
 return contact->getNPoints();
}

b3PgsJacobiSolver::b3PgsJacobiSolver(bool usePgs)
 :m_usePgs(usePgs),
 m_numSplitImpulseRecoveries(0),
 m_btSeed2(0)
{

}

b3PgsJacobiSolver::~b3PgsJacobiSolver()
{
}

void	b3PgsJacobiSolver::solveContacts(int numBodies, b3RigidBodyData* bodies, b3InertiaData* inertias, int numContacts, b3Contact4* contacts, int numConstraints, b3TypedConstraint** constraints)
{
 b3ContactSolverInfo infoGlobal;
 infoGlobal.m_splitImpulse = false;
 infoGlobal.m_timeStep = 1.f / 60.f;
 infoGlobal.m_numIterations = 4;//4;
                                //	infoGlobal.m_solverMode|=B3_SOLVER_USE_2_FRICTION_DIRECTIONS|B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS|B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
                                //infoGlobal.m_solverMode|=B3_SOLVER_USE_2_FRICTION_DIRECTIONS|B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
 infoGlobal.m_solverMode |= B3_SOLVER_USE_2_FRICTION_DIRECTIONS;

 //if (infoGlobal.m_solverMode & B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
 //if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS) && (infoGlobal.m_solverMode & B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION))


 solveGroup(bodies, inertias, numBodies, contacts, numContacts, constraints, numConstraints, infoGlobal);

 if (!numContacts)
  return;
}




/// b3PgsJacobiSolver Sequentially applies impulses
b3Scalar b3PgsJacobiSolver::solveGroup(b3RigidBodyData* bodies,
 b3InertiaData* inertias,
 int numBodies,
 b3Contact4* manifoldPtr,
 int numManifolds,
 b3TypedConstraint** constraints,
 int numConstraints,
 const b3ContactSolverInfo& infoGlobal)
{

 B3_PROFILE("solveGroup");
 //you need to provide at least some bodies

 solveGroupCacheFriendlySetup(bodies, inertias, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal);

 solveGroupCacheFriendlyIterations(constraints, numConstraints, infoGlobal);

 solveGroupCacheFriendlyFinish(bodies, inertias, numBodies, infoGlobal);

 return 0.f;
}









#ifdef USE_SIMD
#include <emmintrin.h>
#define b3VecSplat(x, e) _mm_shuffle_ps(x, x, _MM_SHUFFLE(e,e,e,e))
static inline __m128 b3SimdDot3(__m128 vec0, __m128 vec1)
{
 __m128 result = _mm_mul_ps(vec0, vec1);
 return _mm_add_ps(b3VecSplat(result, 0), _mm_add_ps(b3VecSplat(result, 1), b3VecSplat(result, 2)));
}
#endif//USE_SIMD

// Project Gauss Seidel or the equivalent Sequential Impulse
void b3PgsJacobiSolver::resolveSingleConstraintRowGenericSIMD(b3SolverBody& body1, b3SolverBody& body2, const b3SolverConstraint& c)
{
#ifdef USE_SIMD
 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 __m128 deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(b3SimdDot3(c.m_contactNormal.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), b3SimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_sub_ps(b3SimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128), b3SimdDot3((c.m_contactNormal).mVec128, body2.internalGetDeltaLinearVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 b3SimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 b3SimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128 upperMinApplied = _mm_sub_ps(upperLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, deltaImpulse), _mm_andnot_ps(resultUpperLess, upperMinApplied));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, c.m_appliedImpulse), _mm_andnot_ps(resultUpperLess, upperLimit1));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps((c.m_contactNormal).mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetDeltaLinearVelocity().mVec128 = _mm_sub_ps(body2.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
#else
 resolveSingleConstraintRowGeneric(body1, body2, c);
#endif
}

// Project Gauss Seidel or the equivalent Sequential Impulse
void b3PgsJacobiSolver::resolveSingleConstraintRowGeneric(b3SolverBody& body1, b3SolverBody& body2, const b3SolverConstraint& c)
{
 b3Scalar deltaImpulse = c.m_rhs - b3Scalar(c.m_appliedImpulse)*c.m_cfm;
 const b3Scalar deltaVel1Dotn = c.m_contactNormal.dot(body1.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetDeltaAngularVelocity());
 const b3Scalar deltaVel2Dotn = -c.m_contactNormal.dot(body2.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetDeltaAngularVelocity());

 //	const b3Scalar delta_rel_vel	=	deltaVel1Dotn-deltaVel2Dotn;
 deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
 deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;

 const b3Scalar sum = b3Scalar(c.m_appliedImpulse) + deltaImpulse;
 if (sum < c.m_lowerLimit)
 {
  deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_lowerLimit;
 }
 else if (sum > c.m_upperLimit)
 {
  deltaImpulse = c.m_upperLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_upperLimit;
 }
 else
 {
  c.m_appliedImpulse = sum;
 }

 body1.internalApplyImpulse(c.m_contactNormal*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
 body2.internalApplyImpulse(-c.m_contactNormal*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
}

void b3PgsJacobiSolver::resolveSingleConstraintRowLowerLimitSIMD(b3SolverBody& body1, b3SolverBody& body2, const b3SolverConstraint& c)
{
#ifdef USE_SIMD
 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 __m128 deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(b3SimdDot3(c.m_contactNormal.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), b3SimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_sub_ps(b3SimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128), b3SimdDot3((c.m_contactNormal).mVec128, body2.internalGetDeltaLinearVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 b3SimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 b3SimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps((c.m_contactNormal).mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetDeltaLinearVelocity().mVec128 = _mm_sub_ps(body2.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
#else
 resolveSingleConstraintRowLowerLimit(body1, body2, c);
#endif
}

// Project Gauss Seidel or the equivalent Sequential Impulse
void b3PgsJacobiSolver::resolveSingleConstraintRowLowerLimit(b3SolverBody& body1, b3SolverBody& body2, const b3SolverConstraint& c)
{
 b3Scalar deltaImpulse = c.m_rhs - b3Scalar(c.m_appliedImpulse)*c.m_cfm;
 const b3Scalar deltaVel1Dotn = c.m_contactNormal.dot(body1.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetDeltaAngularVelocity());
 const b3Scalar deltaVel2Dotn = -c.m_contactNormal.dot(body2.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetDeltaAngularVelocity());

 deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
 deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;
 const b3Scalar sum = b3Scalar(c.m_appliedImpulse) + deltaImpulse;
 if (sum < c.m_lowerLimit)
 {
  deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_lowerLimit;
 }
 else
 {
  c.m_appliedImpulse = sum;
 }
 body1.internalApplyImpulse(c.m_contactNormal*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
 body2.internalApplyImpulse(-c.m_contactNormal*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
}


void	b3PgsJacobiSolver::resolveSplitPenetrationImpulseCacheFriendly(
 b3SolverBody& body1,
 b3SolverBody& body2,
 const b3SolverConstraint& c)
{
 if (c.m_rhsPenetration)
 {
  m_numSplitImpulseRecoveries++;
  b3Scalar deltaImpulse = c.m_rhsPenetration - b3Scalar(c.m_appliedPushImpulse)*c.m_cfm;
  const b3Scalar deltaVel1Dotn = c.m_contactNormal.dot(body1.internalGetPushVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetTurnVelocity());
  const b3Scalar deltaVel2Dotn = -c.m_contactNormal.dot(body2.internalGetPushVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetTurnVelocity());

  deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
  deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;
  const b3Scalar sum = b3Scalar(c.m_appliedPushImpulse) + deltaImpulse;
  if (sum < c.m_lowerLimit)
  {
   deltaImpulse = c.m_lowerLimit - c.m_appliedPushImpulse;
   c.m_appliedPushImpulse = c.m_lowerLimit;
  }
  else
  {
   c.m_appliedPushImpulse = sum;
  }
  body1.internalApplyPushImpulse(c.m_contactNormal*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
  body2.internalApplyPushImpulse(-c.m_contactNormal*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
 }
}

void b3PgsJacobiSolver::resolveSplitPenetrationSIMD(b3SolverBody& body1, b3SolverBody& body2, const b3SolverConstraint& c)
{
#ifdef USE_SIMD
 if (!c.m_rhsPenetration)
  return;

 m_numSplitImpulseRecoveries++;

 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedPushImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 __m128 deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhsPenetration), _mm_mul_ps(_mm_set1_ps(c.m_appliedPushImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(b3SimdDot3(c.m_contactNormal.mVec128, body1.internalGetPushVelocity().mVec128), b3SimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetTurnVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_sub_ps(b3SimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetTurnVelocity().mVec128), b3SimdDot3((c.m_contactNormal).mVec128, body2.internalGetPushVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 b3SimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 b3SimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedPushImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps((c.m_contactNormal).mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetPushVelocity().mVec128 = _mm_add_ps(body1.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetTurnVelocity().mVec128 = _mm_add_ps(body1.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetPushVelocity().mVec128 = _mm_sub_ps(body2.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetTurnVelocity().mVec128 = _mm_add_ps(body2.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
#else
 resolveSplitPenetrationImpulseCacheFriendly(body1, body2, c);
#endif
}



unsigned long b3PgsJacobiSolver::b3Rand2()
{
 m_btSeed2 = (1664525L * m_btSeed2 + 1013904223L) & 0xffffffff;
 return m_btSeed2;
}



//See ODE: adam's all-int straightforward(?) dRandInt (0..n-1)
int b3PgsJacobiSolver::b3RandInt2(int n)
{
 // seems good; xor-fold and modulus
 const unsigned long un = static_cast<unsigned long>(n);
 unsigned long r = b3Rand2();

 // note: probably more aggressive than it needs to be -- might be
 //       able to get away without one or two of the innermost branches.
 if (un <= 0x00010000UL) {
  r ^= (r >> 16);
  if (un <= 0x00000100UL) {
   r ^= (r >> 8);
   if (un <= 0x00000010UL) {
    r ^= (r >> 4);
    if (un <= 0x00000004UL) {
     r ^= (r >> 2);
     if (un <= 0x00000002UL) {
      r ^= (r >> 1);
     }
    }
   }
  }
 }

 return (int)(r % un);
}



void	b3PgsJacobiSolver::initSolverBody(int bodyIndex, b3SolverBody* solverBody, b3RigidBodyData* rb)
{

 solverBody->m_deltaLinearVelocity.setValue(0.f, 0.f, 0.f);
 solverBody->m_deltaAngularVelocity.setValue(0.f, 0.f, 0.f);
 solverBody->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
 solverBody->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);

 if (rb)
 {
  solverBody->m_worldTransform = getWorldTransform(rb);
  solverBody->internalSetInvMass(b3MakeVector3(rb->m_invMass, rb->m_invMass, rb->m_invMass));
  solverBody->m_originalBodyIndex = bodyIndex;
  solverBody->m_angularFactor = b3MakeVector3(1, 1, 1);
  solverBody->m_linearFactor = b3MakeVector3(1, 1, 1);
  solverBody->m_linearVelocity = getLinearVelocity(rb);
  solverBody->m_angularVelocity = getAngularVelocity(rb);
 }
 else
 {
  solverBody->m_worldTransform.setIdentity();
  solverBody->internalSetInvMass(b3MakeVector3(0, 0, 0));
  solverBody->m_originalBodyIndex = bodyIndex;
  solverBody->m_angularFactor.setValue(1, 1, 1);
  solverBody->m_linearFactor.setValue(1, 1, 1);
  solverBody->m_linearVelocity.setValue(0, 0, 0);
  solverBody->m_angularVelocity.setValue(0, 0, 0);
 }


}






b3Scalar b3PgsJacobiSolver::restitutionCurve(b3Scalar rel_vel, b3Scalar restitution)
{
 b3Scalar rest = restitution * -rel_vel;
 return rest;
}






void b3PgsJacobiSolver::setupFrictionConstraint(b3RigidBodyData* bodies, b3InertiaData* inertias, b3SolverConstraint& solverConstraint, const b3Vector3& normalAxis, int  solverBodyIdA, int solverBodyIdB, b3ContactPoint& cp, const b3Vector3& rel_pos1, const b3Vector3& rel_pos2, b3RigidBodyData* colObj0, b3RigidBodyData* colObj1, b3Scalar relaxation, b3Scalar desiredVelocity, b3Scalar cfmSlip)
{


 solverConstraint.m_contactNormal = normalAxis;
 b3SolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
 b3SolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

 b3RigidBodyData* body0 = &bodies[solverBodyA.m_originalBodyIndex];
 b3RigidBodyData* body1 = &bodies[solverBodyB.m_originalBodyIndex];


 solverConstraint.m_solverBodyIdA = solverBodyIdA;
 solverConstraint.m_solverBodyIdB = solverBodyIdB;

 solverConstraint.m_friction = cp.m_combinedFriction;
 solverConstraint.m_originalContactPoint = 0;

 solverConstraint.m_appliedImpulse = 0.f;
 solverConstraint.m_appliedPushImpulse = 0.f;

 {
  b3Vector3 ftorqueAxis1 = rel_pos1.cross(solverConstraint.m_contactNormal);
  solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentA = body0 ? getInvInertiaTensorWorld(&inertias[solverBodyA.m_originalBodyIndex])*ftorqueAxis1 : b3MakeVector3(0, 0, 0);
 }
 {
  b3Vector3 ftorqueAxis1 = rel_pos2.cross(-solverConstraint.m_contactNormal);
  solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentB = body1 ? getInvInertiaTensorWorld(&inertias[solverBodyB.m_originalBodyIndex])*ftorqueAxis1 : b3MakeVector3(0, 0, 0);
 }

 b3Scalar scaledDenom;

 {
  b3Vector3 vec;
  b3Scalar denom0 = 0.f;
  b3Scalar denom1 = 0.f;
  if (body0)
  {
   vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
   denom0 = body0->m_invMass + normalAxis.dot(vec);
  }
  if (body1)
  {
   vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
   denom1 = body1->m_invMass + normalAxis.dot(vec);
  }

  b3Scalar denom;
  if (m_usePgs)
  {
   scaledDenom = denom = relaxation / (denom0 + denom1);
  }
  else
  {
   denom = relaxation / (denom0 + denom1);
   b3Scalar countA = body0->m_invMass ? b3Scalar(m_bodyCount[solverBodyA.m_originalBodyIndex]) : 1.f;
   b3Scalar countB = body1->m_invMass ? b3Scalar(m_bodyCount[solverBodyB.m_originalBodyIndex]) : 1.f;

   scaledDenom = relaxation / (denom0*countA + denom1*countB);
  }

  solverConstraint.m_jacDiagABInv = denom;
 }

 {


  b3Scalar rel_vel;
  b3Scalar vel1Dotn = solverConstraint.m_contactNormal.dot(body0 ? solverBodyA.m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : b3MakeVector3(0, 0, 0));
  b3Scalar vel2Dotn = -solverConstraint.m_contactNormal.dot(body1 ? solverBodyB.m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos2CrossNormal.dot(body1 ? solverBodyB.m_angularVelocity : b3MakeVector3(0, 0, 0));

  rel_vel = vel1Dotn + vel2Dotn;

  //		b3Scalar positionalError = 0.f;

  b3SimdScalar velocityError = desiredVelocity - rel_vel;
  b3SimdScalar	velocityImpulse = velocityError * b3SimdScalar(scaledDenom);//solverConstraint.m_jacDiagABInv);
  solverConstraint.m_rhs = velocityImpulse;
  solverConstraint.m_cfm = cfmSlip;
  solverConstraint.m_lowerLimit = 0;
  solverConstraint.m_upperLimit = 1e10f;

 }
}

b3SolverConstraint&	b3PgsJacobiSolver::addFrictionConstraint(b3RigidBodyData* bodies, b3InertiaData* inertias, const b3Vector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, b3ContactPoint& cp, const b3Vector3& rel_pos1, const b3Vector3& rel_pos2, b3RigidBodyData* colObj0, b3RigidBodyData* colObj1, b3Scalar relaxation, b3Scalar desiredVelocity, b3Scalar cfmSlip)
{
 b3SolverConstraint& solverConstraint = m_tmpSolverContactFrictionConstraintPool.expandNonInitializing();
 solverConstraint.m_frictionIndex = frictionIndex;
 setupFrictionConstraint(bodies, inertias, solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, rel_pos1, rel_pos2,
  colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
 return solverConstraint;
}


void b3PgsJacobiSolver::setupRollingFrictionConstraint(b3RigidBodyData* bodies, b3InertiaData* inertias, b3SolverConstraint& solverConstraint, const b3Vector3& normalAxis1, int solverBodyIdA, int  solverBodyIdB,
 b3ContactPoint& cp, const b3Vector3& rel_pos1, const b3Vector3& rel_pos2,
 b3RigidBodyData* colObj0, b3RigidBodyData* colObj1, b3Scalar relaxation,
 b3Scalar desiredVelocity, b3Scalar cfmSlip)

{
 b3Vector3 normalAxis = b3MakeVector3(0, 0, 0);


 solverConstraint.m_contactNormal = normalAxis;
 b3SolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
 b3SolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

 b3RigidBodyData* body0 = &bodies[m_tmpSolverBodyPool[solverBodyIdA].m_originalBodyIndex];
 b3RigidBodyData* body1 = &bodies[m_tmpSolverBodyPool[solverBodyIdB].m_originalBodyIndex];

 solverConstraint.m_solverBodyIdA = solverBodyIdA;
 solverConstraint.m_solverBodyIdB = solverBodyIdB;

 solverConstraint.m_friction = cp.m_combinedRollingFriction;
 solverConstraint.m_originalContactPoint = 0;

 solverConstraint.m_appliedImpulse = 0.f;
 solverConstraint.m_appliedPushImpulse = 0.f;

 {
  b3Vector3 ftorqueAxis1 = -normalAxis1;
  solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentA = body0 ? getInvInertiaTensorWorld(&inertias[solverBodyA.m_originalBodyIndex])*ftorqueAxis1 : b3MakeVector3(0, 0, 0);
 }
 {
  b3Vector3 ftorqueAxis1 = normalAxis1;
  solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentB = body1 ? getInvInertiaTensorWorld(&inertias[solverBodyB.m_originalBodyIndex])*ftorqueAxis1 : b3MakeVector3(0, 0, 0);
 }


 {
  b3Vector3 iMJaA = body0 ? getInvInertiaTensorWorld(&inertias[solverBodyA.m_originalBodyIndex])*solverConstraint.m_relpos1CrossNormal : b3MakeVector3(0, 0, 0);
  b3Vector3 iMJaB = body1 ? getInvInertiaTensorWorld(&inertias[solverBodyB.m_originalBodyIndex])*solverConstraint.m_relpos2CrossNormal : b3MakeVector3(0, 0, 0);
  b3Scalar sum = 0;
  sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
  sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
  solverConstraint.m_jacDiagABInv = b3Scalar(1.) / sum;
 }

 {


  b3Scalar rel_vel;
  b3Scalar vel1Dotn = solverConstraint.m_contactNormal.dot(body0 ? solverBodyA.m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : b3MakeVector3(0, 0, 0));
  b3Scalar vel2Dotn = -solverConstraint.m_contactNormal.dot(body1 ? solverBodyB.m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos2CrossNormal.dot(body1 ? solverBodyB.m_angularVelocity : b3MakeVector3(0, 0, 0));

  rel_vel = vel1Dotn + vel2Dotn;

  //		b3Scalar positionalError = 0.f;

  b3SimdScalar velocityError = desiredVelocity - rel_vel;
  b3SimdScalar	velocityImpulse = velocityError * b3SimdScalar(solverConstraint.m_jacDiagABInv);
  solverConstraint.m_rhs = velocityImpulse;
  solverConstraint.m_cfm = cfmSlip;
  solverConstraint.m_lowerLimit = 0;
  solverConstraint.m_upperLimit = 1e10f;

 }
}








b3SolverConstraint&	b3PgsJacobiSolver::addRollingFrictionConstraint(b3RigidBodyData* bodies, b3InertiaData* inertias, const b3Vector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, b3ContactPoint& cp, const b3Vector3& rel_pos1, const b3Vector3& rel_pos2, b3RigidBodyData* colObj0, b3RigidBodyData* colObj1, b3Scalar relaxation, b3Scalar desiredVelocity, b3Scalar cfmSlip)
{
 b3SolverConstraint& solverConstraint = m_tmpSolverContactRollingFrictionConstraintPool.expandNonInitializing();
 solverConstraint.m_frictionIndex = frictionIndex;
 setupRollingFrictionConstraint(bodies, inertias, solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, rel_pos1, rel_pos2,
  colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
 return solverConstraint;
}


int	b3PgsJacobiSolver::getOrInitSolverBody(int bodyIndex, b3RigidBodyData* bodies, b3InertiaData* inertias)
{
 //b3Assert(bodyIndex< m_tmpSolverBodyPool.size());

 b3RigidBodyData& body = bodies[bodyIndex];
 int curIndex = -1;
 if (m_usePgs || body.m_invMass == 0.f)
 {
  if (m_bodyCount[bodyIndex]<0)
  {
   curIndex = m_tmpSolverBodyPool.size();
   b3SolverBody& solverBody = m_tmpSolverBodyPool.expand();
   initSolverBody(bodyIndex, &solverBody, &body);
   solverBody.m_originalBodyIndex = bodyIndex;
   m_bodyCount[bodyIndex] = curIndex;
  }
  else
  {
   curIndex = m_bodyCount[bodyIndex];
  }
 }
 else
 {
  b3Assert(m_bodyCount[bodyIndex]>0);
  m_bodyCountCheck[bodyIndex]++;
  curIndex = m_tmpSolverBodyPool.size();
  b3SolverBody& solverBody = m_tmpSolverBodyPool.expand();
  initSolverBody(bodyIndex, &solverBody, &body);
  solverBody.m_originalBodyIndex = bodyIndex;
 }

 b3Assert(curIndex >= 0);
 return curIndex;

}
#include <stdio.h>


void b3PgsJacobiSolver::setupContactConstraint(b3RigidBodyData* bodies, b3InertiaData* inertias, b3SolverConstraint& solverConstraint,
 int solverBodyIdA, int solverBodyIdB,
 b3ContactPoint& cp, const b3ContactSolverInfo& infoGlobal,
 b3Vector3& vel, b3Scalar& rel_vel, b3Scalar& relaxation,
 b3Vector3& rel_pos1, b3Vector3& rel_pos2)
{

 const b3Vector3& pos1 = cp.getPositionWorldOnA();
 const b3Vector3& pos2 = cp.getPositionWorldOnB();

 b3SolverBody* bodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 b3SolverBody* bodyB = &m_tmpSolverBodyPool[solverBodyIdB];

 b3RigidBodyData* rb0 = &bodies[bodyA->m_originalBodyIndex];
 b3RigidBodyData* rb1 = &bodies[bodyB->m_originalBodyIndex];

 //			b3Vector3 rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin(); 
 //			b3Vector3 rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();
 rel_pos1 = pos1 - bodyA->getWorldTransform().getOrigin();
 rel_pos2 = pos2 - bodyB->getWorldTransform().getOrigin();

 relaxation = 1.f;

 b3Vector3 torqueAxis0 = rel_pos1.cross(cp.m_normalWorldOnB);
 solverConstraint.m_angularComponentA = rb0 ? getInvInertiaTensorWorld(&inertias[bodyA->m_originalBodyIndex])*torqueAxis0 : b3MakeVector3(0, 0, 0);
 b3Vector3 torqueAxis1 = rel_pos2.cross(cp.m_normalWorldOnB);
 solverConstraint.m_angularComponentB = rb1 ? getInvInertiaTensorWorld(&inertias[bodyB->m_originalBodyIndex])*-torqueAxis1 : b3MakeVector3(0, 0, 0);

 b3Scalar scaledDenom;
 {
#ifdef COMPUTE_IMPULSE_DENOM
  b3Scalar denom0 = rb0->computeImpulseDenominator(pos1, cp.m_normalWorldOnB);
  b3Scalar denom1 = rb1->computeImpulseDenominator(pos2, cp.m_normalWorldOnB);
#else							
  b3Vector3 vec;
  b3Scalar denom0 = 0.f;
  b3Scalar denom1 = 0.f;
  if (rb0)
  {
   vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
   denom0 = rb0->m_invMass + cp.m_normalWorldOnB.dot(vec);
  }
  if (rb1)
  {
   vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
   denom1 = rb1->m_invMass + cp.m_normalWorldOnB.dot(vec);
  }
#endif //COMPUTE_IMPULSE_DENOM		


  b3Scalar denom;
  if (m_usePgs)
  {
   scaledDenom = denom = relaxation / (denom0 + denom1);
  }
  else
  {
   denom = relaxation / (denom0 + denom1);

   b3Scalar countA = rb0->m_invMass ? b3Scalar(m_bodyCount[bodyA->m_originalBodyIndex]) : 1.f;
   b3Scalar countB = rb1->m_invMass ? b3Scalar(m_bodyCount[bodyB->m_originalBodyIndex]) : 1.f;
   scaledDenom = relaxation / (denom0*countA + denom1*countB);
  }
  solverConstraint.m_jacDiagABInv = denom;
 }

 solverConstraint.m_contactNormal = cp.m_normalWorldOnB;
 solverConstraint.m_relpos1CrossNormal = torqueAxis0;
 solverConstraint.m_relpos2CrossNormal = -torqueAxis1;

 b3Scalar restitution = 0.f;
 b3Scalar penetration = cp.getDistance() + infoGlobal.m_linearSlop;

 {
  b3Vector3 vel1, vel2;

  vel1 = rb0 ? getVelocityInLocalPoint(rb0, rel_pos1) : b3MakeVector3(0, 0, 0);
  vel2 = rb1 ? getVelocityInLocalPoint(rb1, rel_pos2) : b3MakeVector3(0, 0, 0);

  //			b3Vector3 vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : b3Vector3(0,0,0);
  vel = vel1 - vel2;
  rel_vel = cp.m_normalWorldOnB.dot(vel);



  solverConstraint.m_friction = cp.m_combinedFriction;


  restitution = restitutionCurve(rel_vel, cp.m_combinedRestitution);
  if (restitution <= b3Scalar(0.))
  {
   restitution = 0.f;
  };
 }


 ///warm starting (or zero if disabled)
 if (infoGlobal.m_solverMode & B3_SOLVER_USE_WARMSTARTING)
 {
  solverConstraint.m_appliedImpulse = cp.m_appliedImpulse * infoGlobal.m_warmstartingFactor;
  if (rb0)
   bodyA->internalApplyImpulse(solverConstraint.m_contactNormal*bodyA->internalGetInvMass(), solverConstraint.m_angularComponentA, solverConstraint.m_appliedImpulse);
  if (rb1)
   bodyB->internalApplyImpulse(solverConstraint.m_contactNormal*bodyB->internalGetInvMass(), -solverConstraint.m_angularComponentB, -(b3Scalar)solverConstraint.m_appliedImpulse);
 }
 else
 {
  solverConstraint.m_appliedImpulse = 0.f;
 }

 solverConstraint.m_appliedPushImpulse = 0.f;

 {
  b3Scalar vel1Dotn = solverConstraint.m_contactNormal.dot(rb0 ? bodyA->m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos1CrossNormal.dot(rb0 ? bodyA->m_angularVelocity : b3MakeVector3(0, 0, 0));
  b3Scalar vel2Dotn = -solverConstraint.m_contactNormal.dot(rb1 ? bodyB->m_linearVelocity : b3MakeVector3(0, 0, 0))
   + solverConstraint.m_relpos2CrossNormal.dot(rb1 ? bodyB->m_angularVelocity : b3MakeVector3(0, 0, 0));
  b3Scalar rel_vel = vel1Dotn + vel2Dotn;

  b3Scalar positionalError = 0.f;
  b3Scalar	velocityError = restitution - rel_vel;// * damping;


  b3Scalar erp = infoGlobal.m_erp2;
  if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
  {
   erp = infoGlobal.m_erp;
  }

  if (penetration>0)
  {
   positionalError = 0;

   velocityError -= penetration / infoGlobal.m_timeStep;
  }
  else
  {
   positionalError = -penetration * erp / infoGlobal.m_timeStep;
  }

  b3Scalar  penetrationImpulse = positionalError*scaledDenom;//solverConstraint.m_jacDiagABInv;
  b3Scalar velocityImpulse = velocityError *scaledDenom;//solverConstraint.m_jacDiagABInv;

  if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
  {
   //combine position and velocity into rhs
   solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
   solverConstraint.m_rhsPenetration = 0.f;

  }
  else
  {
   //split position and velocity into rhs and m_rhsPenetration
   solverConstraint.m_rhs = velocityImpulse;
   solverConstraint.m_rhsPenetration = penetrationImpulse;
  }
  solverConstraint.m_cfm = 0.f;
  solverConstraint.m_lowerLimit = 0;
  solverConstraint.m_upperLimit = 1e10f;
 }




}



void b3PgsJacobiSolver::setFrictionConstraintImpulse(b3RigidBodyData* bodies, b3InertiaData* inertias, b3SolverConstraint& solverConstraint,
 int solverBodyIdA, int solverBodyIdB,
 b3ContactPoint& cp, const b3ContactSolverInfo& infoGlobal)
{

 b3SolverBody* bodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 b3SolverBody* bodyB = &m_tmpSolverBodyPool[solverBodyIdB];


 {
  b3SolverConstraint& frictionConstraint1 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex];
  if (infoGlobal.m_solverMode & B3_SOLVER_USE_WARMSTARTING)
  {
   frictionConstraint1.m_appliedImpulse = cp.m_appliedImpulseLateral1 * infoGlobal.m_warmstartingFactor;
   if (bodies[bodyA->m_originalBodyIndex].m_invMass)
    bodyA->internalApplyImpulse(frictionConstraint1.m_contactNormal*bodies[bodyA->m_originalBodyIndex].m_invMass, frictionConstraint1.m_angularComponentA, frictionConstraint1.m_appliedImpulse);
   if (bodies[bodyB->m_originalBodyIndex].m_invMass)
    bodyB->internalApplyImpulse(frictionConstraint1.m_contactNormal*bodies[bodyB->m_originalBodyIndex].m_invMass, -frictionConstraint1.m_angularComponentB, -(b3Scalar)frictionConstraint1.m_appliedImpulse);
  }
  else
  {
   frictionConstraint1.m_appliedImpulse = 0.f;
  }
 }

 if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
 {
  b3SolverConstraint& frictionConstraint2 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex + 1];
  if (infoGlobal.m_solverMode & B3_SOLVER_USE_WARMSTARTING)
  {
   frictionConstraint2.m_appliedImpulse = cp.m_appliedImpulseLateral2  * infoGlobal.m_warmstartingFactor;
   if (bodies[bodyA->m_originalBodyIndex].m_invMass)
    bodyA->internalApplyImpulse(frictionConstraint2.m_contactNormal*bodies[bodyA->m_originalBodyIndex].m_invMass, frictionConstraint2.m_angularComponentA, frictionConstraint2.m_appliedImpulse);
   if (bodies[bodyB->m_originalBodyIndex].m_invMass)
    bodyB->internalApplyImpulse(frictionConstraint2.m_contactNormal*bodies[bodyB->m_originalBodyIndex].m_invMass, -frictionConstraint2.m_angularComponentB, -(b3Scalar)frictionConstraint2.m_appliedImpulse);
  }
  else
  {
   frictionConstraint2.m_appliedImpulse = 0.f;
  }
 }
}




void	b3PgsJacobiSolver::convertContact(b3RigidBodyData* bodies, b3InertiaData* inertias, b3Contact4* manifold, const b3ContactSolverInfo& infoGlobal)
{
 b3RigidBodyData* colObj0 = 0, *colObj1 = 0;


 int solverBodyIdA = getOrInitSolverBody(manifold->getBodyA(), bodies, inertias);
 int solverBodyIdB = getOrInitSolverBody(manifold->getBodyB(), bodies, inertias);

 //	b3RigidBody* bodyA = b3RigidBody::upcast(colObj0);
 //	b3RigidBody* bodyB = b3RigidBody::upcast(colObj1);

 b3SolverBody* solverBodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 b3SolverBody* solverBodyB = &m_tmpSolverBodyPool[solverBodyIdB];



 ///avoid collision response between two static objects
 if (solverBodyA->m_invMass.isZero() && solverBodyB->m_invMass.isZero())
  return;

 int rollingFriction = 1;
 int numContacts = getNumContacts(manifold);
 for (int j = 0; j<numContacts; j++)
 {

  b3ContactPoint cp;
  getContactPoint(manifold, j, cp);

  if (cp.getDistance() <= getContactProcessingThreshold(manifold))
  {
   b3Vector3 rel_pos1;
   b3Vector3 rel_pos2;
   b3Scalar relaxation;
   b3Scalar rel_vel;
   b3Vector3 vel;

   int frictionIndex = m_tmpSolverContactConstraintPool.size();
   b3SolverConstraint& solverConstraint = m_tmpSolverContactConstraintPool.expandNonInitializing();
   //			b3RigidBody* rb0 = b3RigidBody::upcast(colObj0);
   //			b3RigidBody* rb1 = b3RigidBody::upcast(colObj1);
   solverConstraint.m_solverBodyIdA = solverBodyIdA;
   solverConstraint.m_solverBodyIdB = solverBodyIdB;

   solverConstraint.m_originalContactPoint = &cp;

   setupContactConstraint(bodies, inertias, solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal, vel, rel_vel, relaxation, rel_pos1, rel_pos2);

   //			const b3Vector3& pos1 = cp.getPositionWorldOnA();
   //			const b3Vector3& pos2 = cp.getPositionWorldOnB();

   /////setup the friction constraints

   solverConstraint.m_frictionIndex = m_tmpSolverContactFrictionConstraintPool.size();

   b3Vector3 angVelA, angVelB;
   solverBodyA->getAngularVelocity(angVelA);
   solverBodyB->getAngularVelocity(angVelB);
   b3Vector3 relAngVel = angVelB - angVelA;

   if ((cp.m_combinedRollingFriction>0.f) && (rollingFriction>0))
   {
    //only a single rollingFriction per manifold
    rollingFriction--;
    if (relAngVel.length()>infoGlobal.m_singleAxisRollingFrictionThreshold)
    {
     relAngVel.normalize();
     if (relAngVel.length()>0.001)
      addRollingFrictionConstraint(bodies, inertias, relAngVel, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

    }
    else
    {
     addRollingFrictionConstraint(bodies, inertias, cp.m_normalWorldOnB, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
     b3Vector3 axis0, axis1;
     b3PlaneSpace1(cp.m_normalWorldOnB, axis0, axis1);
     if (axis0.length()>0.001)
      addRollingFrictionConstraint(bodies, inertias, axis0, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
     if (axis1.length()>0.001)
      addRollingFrictionConstraint(bodies, inertias, axis1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

    }
   }

   ///Bullet has several options to set the friction directions
   ///By default, each contact has only a single friction direction that is recomputed automatically very frame 
   ///based on the relative linear velocity.
   ///If the relative velocity it zero, it will automatically compute a friction direction.

   ///You can also enable two friction directions, using the B3_SOLVER_USE_2_FRICTION_DIRECTIONS.
   ///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
   ///
   ///If you choose B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
   ///
   ///The user can manually override the friction directions for certain contacts using a contact callback, 
   ///and set the cp.m_lateralFrictionInitialized to true
   ///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
   ///this will give a conveyor belt effect
   ///
   if (!(infoGlobal.m_solverMode & B3_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING) || !cp.m_lateralFrictionInitialized)
   {
    cp.m_lateralFrictionDir1 = vel - cp.m_normalWorldOnB * rel_vel;
    b3Scalar lat_rel_vel = cp.m_lateralFrictionDir1.length2();
    if (!(infoGlobal.m_solverMode & B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION) && lat_rel_vel > B3_EPSILON)
    {
     cp.m_lateralFrictionDir1 *= 1.f / b3Sqrt(lat_rel_vel);
     if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
     {
      cp.m_lateralFrictionDir2 = cp.m_lateralFrictionDir1.cross(cp.m_normalWorldOnB);
      cp.m_lateralFrictionDir2.normalize();//??
      addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

     }

     addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

    }
    else
    {
     b3PlaneSpace1(cp.m_normalWorldOnB, cp.m_lateralFrictionDir1, cp.m_lateralFrictionDir2);

     if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
     {
      addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
     }

     addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

     if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS) && (infoGlobal.m_solverMode & B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION))
     {
      cp.m_lateralFrictionInitialized = true;
     }
    }

   }
   else
   {
    addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, cp.m_contactMotion1, cp.m_contactCFM1);

    if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
     addFrictionConstraint(bodies, inertias, cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, cp.m_contactMotion2, cp.m_contactCFM2);

    setFrictionConstraintImpulse(bodies, inertias, solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal);
   }




  }
 }
}

b3Scalar b3PgsJacobiSolver::solveGroupCacheFriendlySetup(b3RigidBodyData* bodies, b3InertiaData* inertias, int numBodies, b3Contact4* manifoldPtr, int numManifolds, b3TypedConstraint** constraints, int numConstraints, const b3ContactSolverInfo& infoGlobal)
{
 B3_PROFILE("solveGroupCacheFriendlySetup");


 m_maxOverrideNumSolverIterations = 0;



 m_tmpSolverBodyPool.resize(0);


 m_bodyCount.resize(0);
 m_bodyCount.resize(numBodies, 0);
 m_bodyCountCheck.resize(0);
 m_bodyCountCheck.resize(numBodies, 0);

 m_deltaLinearVelocities.resize(0);
 m_deltaLinearVelocities.resize(numBodies, b3MakeVector3(0, 0, 0));
 m_deltaAngularVelocities.resize(0);
 m_deltaAngularVelocities.resize(numBodies, b3MakeVector3(0, 0, 0));

 //int totalBodies = 0;

 for (int i = 0; i<numConstraints; i++)
 {
  int bodyIndexA = constraints[i]->getRigidBodyA();
  int bodyIndexB = constraints[i]->getRigidBodyB();
  if (m_usePgs)
  {
   m_bodyCount[bodyIndexA] = -1;
   m_bodyCount[bodyIndexB] = -1;
  }
  else
  {
   //didn't implement joints with Jacobi version yet
   b3Assert(0);
  }

 }
 for (int i = 0; i<numManifolds; i++)
 {
  int bodyIndexA = manifoldPtr[i].getBodyA();
  int bodyIndexB = manifoldPtr[i].getBodyB();
  if (m_usePgs)
  {
   m_bodyCount[bodyIndexA] = -1;
   m_bodyCount[bodyIndexB] = -1;
  }
  else
  {
   if (bodies[bodyIndexA].m_invMass)
   {
    //m_bodyCount[bodyIndexA]+=manifoldPtr[i].getNPoints();
    m_bodyCount[bodyIndexA]++;
   }
   else
    m_bodyCount[bodyIndexA] = -1;

   if (bodies[bodyIndexB].m_invMass)
    //	m_bodyCount[bodyIndexB]+=manifoldPtr[i].getNPoints();
    m_bodyCount[bodyIndexB]++;
   else
    m_bodyCount[bodyIndexB] = -1;
  }

 }



 if (1)
 {
  int j;
  for (j = 0; j<numConstraints; j++)
  {
   b3TypedConstraint* constraint = constraints[j];

   constraint->internalSetAppliedImpulse(0.0f);
  }
 }

 //b3RigidBody* rb0=0,*rb1=0;
 //if (1)
 {
  {

   int totalNumRows = 0;
   int i;

   m_tmpConstraintSizesPool.resizeNoInitialize(numConstraints);
   //calculate the total number of contraint rows
   for (i = 0; i<numConstraints; i++)
   {
    b3TypedConstraint::b3ConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];
    b3JointFeedback* fb = constraints[i]->getJointFeedback();
    if (fb)
    {
     fb->m_appliedForceBodyA.setZero();
     fb->m_appliedTorqueBodyA.setZero();
     fb->m_appliedForceBodyB.setZero();
     fb->m_appliedTorqueBodyB.setZero();
    }

    if (constraints[i]->isEnabled())
    {
    }
    if (constraints[i]->isEnabled())
    {
     constraints[i]->getInfo1(&info1, bodies);
    }
    else
    {
     info1.m_numConstraintRows = 0;
     info1.nub = 0;
    }
    totalNumRows += info1.m_numConstraintRows;
   }
   m_tmpSolverNonContactConstraintPool.resizeNoInitialize(totalNumRows);


#ifndef DISABLE_JOINTS
   ///setup the b3SolverConstraints
   int currentRow = 0;

   for (i = 0; i<numConstraints; i++)
   {
    const b3TypedConstraint::b3ConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];

    if (info1.m_numConstraintRows)
    {
     b3Assert(currentRow<totalNumRows);

     b3SolverConstraint* currentConstraintRow = &m_tmpSolverNonContactConstraintPool[currentRow];
     b3TypedConstraint* constraint = constraints[i];

     b3RigidBodyData& rbA = bodies[constraint->getRigidBodyA()];
     //b3RigidBody& rbA = constraint->getRigidBodyA();
     //				b3RigidBody& rbB = constraint->getRigidBodyB();
     b3RigidBodyData& rbB = bodies[constraint->getRigidBodyB()];

     int solverBodyIdA = getOrInitSolverBody(constraint->getRigidBodyA(), bodies, inertias);
     int solverBodyIdB = getOrInitSolverBody(constraint->getRigidBodyB(), bodies, inertias);

     b3SolverBody* bodyAPtr = &m_tmpSolverBodyPool[solverBodyIdA];
     b3SolverBody* bodyBPtr = &m_tmpSolverBodyPool[solverBodyIdB];




     int overrideNumSolverIterations = constraint->getOverrideNumSolverIterations() > 0 ? constraint->getOverrideNumSolverIterations() : infoGlobal.m_numIterations;
     if (overrideNumSolverIterations>m_maxOverrideNumSolverIterations)
      m_maxOverrideNumSolverIterations = overrideNumSolverIterations;


     int j;
     for (j = 0; j<info1.m_numConstraintRows; j++)
     {
      memset(&currentConstraintRow[j], 0, sizeof(b3SolverConstraint));
      currentConstraintRow[j].m_lowerLimit = -B3_INFINITY;
      currentConstraintRow[j].m_upperLimit = B3_INFINITY;
      currentConstraintRow[j].m_appliedImpulse = 0.f;
      currentConstraintRow[j].m_appliedPushImpulse = 0.f;
      currentConstraintRow[j].m_solverBodyIdA = solverBodyIdA;
      currentConstraintRow[j].m_solverBodyIdB = solverBodyIdB;
      currentConstraintRow[j].m_overrideNumSolverIterations = overrideNumSolverIterations;
     }

     bodyAPtr->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);


     b3TypedConstraint::b3ConstraintInfo2 info2;
     info2.fps = 1.f / infoGlobal.m_timeStep;
     info2.erp = infoGlobal.m_erp;
     info2.m_J1linearAxis = currentConstraintRow->m_contactNormal;
     info2.m_J1angularAxis = currentConstraintRow->m_relpos1CrossNormal;
     info2.m_J2linearAxis = 0;
     info2.m_J2angularAxis = currentConstraintRow->m_relpos2CrossNormal;
     info2.rowskip = sizeof(b3SolverConstraint) / sizeof(b3Scalar);//check this
                                                                   ///the size of b3SolverConstraint needs be a multiple of b3Scalar
     b3Assert(info2.rowskip * sizeof(b3Scalar) == sizeof(b3SolverConstraint));
     info2.m_constraintError = &currentConstraintRow->m_rhs;
     currentConstraintRow->m_cfm = infoGlobal.m_globalCfm;
     info2.m_damping = infoGlobal.m_damping;
     info2.cfm = &currentConstraintRow->m_cfm;
     info2.m_lowerLimit = &currentConstraintRow->m_lowerLimit;
     info2.m_upperLimit = &currentConstraintRow->m_upperLimit;
     info2.m_numIterations = infoGlobal.m_numIterations;
     constraints[i]->getInfo2(&info2, bodies);

     ///finalize the constraint setup
     for (j = 0; j<info1.m_numConstraintRows; j++)
     {
      b3SolverConstraint& solverConstraint = currentConstraintRow[j];

      if (solverConstraint.m_upperLimit >= constraints[i]->getBreakingImpulseThreshold())
      {
       solverConstraint.m_upperLimit = constraints[i]->getBreakingImpulseThreshold();
      }

      if (solverConstraint.m_lowerLimit <= -constraints[i]->getBreakingImpulseThreshold())
      {
       solverConstraint.m_lowerLimit = -constraints[i]->getBreakingImpulseThreshold();
      }

      solverConstraint.m_originalContactPoint = constraint;

      b3Matrix3x3& invInertiaWorldA = inertias[constraint->getRigidBodyA()].m_invInertiaWorld;
      {

       //b3Vector3 angularFactorA(1,1,1);
       const b3Vector3& ftorqueAxis1 = solverConstraint.m_relpos1CrossNormal;
       solverConstraint.m_angularComponentA = invInertiaWorldA*ftorqueAxis1;//*angularFactorA;
      }

      b3Matrix3x3& invInertiaWorldB = inertias[constraint->getRigidBodyB()].m_invInertiaWorld;
      {

       const b3Vector3& ftorqueAxis2 = solverConstraint.m_relpos2CrossNormal;
       solverConstraint.m_angularComponentB = invInertiaWorldB*ftorqueAxis2;//*constraint->getRigidBodyB().getAngularFactor();
      }

      {
       //it is ok to use solverConstraint.m_contactNormal instead of -solverConstraint.m_contactNormal
       //because it gets multiplied iMJlB
       b3Vector3 iMJlA = solverConstraint.m_contactNormal*rbA.m_invMass;
       b3Vector3 iMJaA = invInertiaWorldA*solverConstraint.m_relpos1CrossNormal;
       b3Vector3 iMJlB = solverConstraint.m_contactNormal*rbB.m_invMass;//sign of normal?
       b3Vector3 iMJaB = invInertiaWorldB*solverConstraint.m_relpos2CrossNormal;

       b3Scalar sum = iMJlA.dot(solverConstraint.m_contactNormal);
       sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
       sum += iMJlB.dot(solverConstraint.m_contactNormal);
       sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
       b3Scalar fsum = b3Fabs(sum);
       b3Assert(fsum > B3_EPSILON);
       solverConstraint.m_jacDiagABInv = fsum>B3_EPSILON ? b3Scalar(1.) / sum : 0.f;
      }


      ///fix rhs
      ///todo: add force/torque accelerators
      {
       b3Scalar rel_vel;
       b3Scalar vel1Dotn = solverConstraint.m_contactNormal.dot(rbA.m_linVel) + solverConstraint.m_relpos1CrossNormal.dot(rbA.m_angVel);
       b3Scalar vel2Dotn = -solverConstraint.m_contactNormal.dot(rbB.m_linVel) + solverConstraint.m_relpos2CrossNormal.dot(rbB.m_angVel);

       rel_vel = vel1Dotn + vel2Dotn;

       b3Scalar restitution = 0.f;
       b3Scalar positionalError = solverConstraint.m_rhs;//already filled in by getConstraintInfo2
       b3Scalar	velocityError = restitution - rel_vel * info2.m_damping;
       b3Scalar	penetrationImpulse = positionalError*solverConstraint.m_jacDiagABInv;
       b3Scalar	velocityImpulse = velocityError *solverConstraint.m_jacDiagABInv;
       solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
       solverConstraint.m_appliedImpulse = 0.f;

      }
     }
    }
    currentRow += m_tmpConstraintSizesPool[i].m_numConstraintRows;
   }
#endif //DISABLE_JOINTS
  }


  {
   int i;

   for (i = 0; i<numManifolds; i++)
   {
    b3Contact4& manifold = manifoldPtr[i];
    convertContact(bodies, inertias, &manifold, infoGlobal);
   }
  }
 }

 //	b3ContactSolverInfo info = infoGlobal;


 int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
 int numConstraintPool = m_tmpSolverContactConstraintPool.size();
 int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

 ///@todo: use stack allocator for such temporarily memory, same for solver bodies/constraints
 m_orderNonContactConstraintPool.resizeNoInitialize(numNonContactPool);
 if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
  m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool * 2);
 else
  m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool);

 m_orderFrictionConstraintPool.resizeNoInitialize(numFrictionPool);
 {
  int i;
  for (i = 0; i<numNonContactPool; i++)
  {
   m_orderNonContactConstraintPool[i] = i;
  }
  for (i = 0; i<numConstraintPool; i++)
  {
   m_orderTmpConstraintPool[i] = i;
  }
  for (i = 0; i<numFrictionPool; i++)
  {
   m_orderFrictionConstraintPool[i] = i;
  }
 }

 return 0.f;

}


b3Scalar b3PgsJacobiSolver::solveSingleIteration(int iteration, b3TypedConstraint** constraints, int numConstraints, const b3ContactSolverInfo& infoGlobal)
{

 int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
 int numConstraintPool = m_tmpSolverContactConstraintPool.size();
 int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

 if (infoGlobal.m_solverMode & B3_SOLVER_RANDMIZE_ORDER)
 {
  if (1)			// uncomment this for a bit less random ((iteration & 7) == 0)
  {

   for (int j = 0; j<numNonContactPool; ++j) {
    int tmp = m_orderNonContactConstraintPool[j];
    int swapi = b3RandInt2(j + 1);
    m_orderNonContactConstraintPool[j] = m_orderNonContactConstraintPool[swapi];
    m_orderNonContactConstraintPool[swapi] = tmp;
   }

   //contact/friction constraints are not solved more than 
   if (iteration< infoGlobal.m_numIterations)
   {
    for (int j = 0; j<numConstraintPool; ++j) {
     int tmp = m_orderTmpConstraintPool[j];
     int swapi = b3RandInt2(j + 1);
     m_orderTmpConstraintPool[j] = m_orderTmpConstraintPool[swapi];
     m_orderTmpConstraintPool[swapi] = tmp;
    }

    for (int j = 0; j<numFrictionPool; ++j) {
     int tmp = m_orderFrictionConstraintPool[j];
     int swapi = b3RandInt2(j + 1);
     m_orderFrictionConstraintPool[j] = m_orderFrictionConstraintPool[swapi];
     m_orderFrictionConstraintPool[swapi] = tmp;
    }
   }
  }
 }

 if (infoGlobal.m_solverMode & B3_SOLVER_SIMD)
 {
  ///solve all joint constraints, using SIMD, if available
  for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
  {
   b3SolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
   if (iteration < constraint.m_overrideNumSolverIterations)
    resolveSingleConstraintRowGenericSIMD(m_tmpSolverBodyPool[constraint.m_solverBodyIdA], m_tmpSolverBodyPool[constraint.m_solverBodyIdB], constraint);
  }

  if (iteration< infoGlobal.m_numIterations)
  {

   ///solve all contact constraints using SIMD, if available
   if (infoGlobal.m_solverMode & B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
   {
    int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
    int multiplier = (infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS) ? 2 : 1;

    for (int c = 0; c<numPoolConstraints; c++)
    {
     b3Scalar totalImpulse = 0;

     {
      const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[c]];
      resolveSingleConstraintRowLowerLimitSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
      totalImpulse = solveManifold.m_appliedImpulse;
     }
     bool applyFriction = true;
     if (applyFriction)
     {
      {

       b3SolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier]];

       if (totalImpulse>b3Scalar(0))
       {
        solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
        solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

        resolveSingleConstraintRowGenericSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
       }
      }

      if (infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS)
      {

       b3SolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier + 1]];

       if (totalImpulse>b3Scalar(0))
       {
        solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
        solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

        resolveSingleConstraintRowGenericSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
       }
      }
     }
    }

   }
   else//B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
   {
    //solve the friction constraints after all contact constraints, don't interleave them
    int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
    int j;

    for (j = 0; j<numPoolConstraints; j++)
    {
     const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
     resolveSingleConstraintRowLowerLimitSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);

    }

    if (!m_usePgs)
     averageVelocities();


    ///solve all friction constraints, using SIMD, if available

    int numFrictionPoolConstraints = m_tmpSolverContactFrictionConstraintPool.size();
    for (j = 0; j<numFrictionPoolConstraints; j++)
    {
     b3SolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
     b3Scalar totalImpulse = m_tmpSolverContactConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;

     if (totalImpulse>b3Scalar(0))
     {
      solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
      solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

      resolveSingleConstraintRowGenericSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     }
    }


    int numRollingFrictionPoolConstraints = m_tmpSolverContactRollingFrictionConstraintPool.size();
    for (j = 0; j<numRollingFrictionPoolConstraints; j++)
    {

     b3SolverConstraint& rollingFrictionConstraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
     b3Scalar totalImpulse = m_tmpSolverContactConstraintPool[rollingFrictionConstraint.m_frictionIndex].m_appliedImpulse;
     if (totalImpulse>b3Scalar(0))
     {
      b3Scalar rollingFrictionMagnitude = rollingFrictionConstraint.m_friction*totalImpulse;
      if (rollingFrictionMagnitude>rollingFrictionConstraint.m_friction)
       rollingFrictionMagnitude = rollingFrictionConstraint.m_friction;

      rollingFrictionConstraint.m_lowerLimit = -rollingFrictionMagnitude;
      rollingFrictionConstraint.m_upperLimit = rollingFrictionMagnitude;

      resolveSingleConstraintRowGenericSIMD(m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdA], m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdB], rollingFrictionConstraint);
     }
    }


   }
  }
 }
 else
 {
  //non-SIMD version
  ///solve all joint constraints
  for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
  {
   b3SolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
   if (iteration < constraint.m_overrideNumSolverIterations)
    resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[constraint.m_solverBodyIdA], m_tmpSolverBodyPool[constraint.m_solverBodyIdB], constraint);
  }

  if (iteration< infoGlobal.m_numIterations)
  {

   ///solve all contact constraints
   int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
   for (int j = 0; j<numPoolConstraints; j++)
   {
    const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
    resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
   }
   ///solve all friction constraints
   int numFrictionPoolConstraints = m_tmpSolverContactFrictionConstraintPool.size();
   for (int j = 0; j<numFrictionPoolConstraints; j++)
   {
    b3SolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
    b3Scalar totalImpulse = m_tmpSolverContactConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;

    if (totalImpulse>b3Scalar(0))
    {
     solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
     solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

     resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
    }
   }

   int numRollingFrictionPoolConstraints = m_tmpSolverContactRollingFrictionConstraintPool.size();
   for (int j = 0; j<numRollingFrictionPoolConstraints; j++)
   {
    b3SolverConstraint& rollingFrictionConstraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
    b3Scalar totalImpulse = m_tmpSolverContactConstraintPool[rollingFrictionConstraint.m_frictionIndex].m_appliedImpulse;
    if (totalImpulse>b3Scalar(0))
    {
     b3Scalar rollingFrictionMagnitude = rollingFrictionConstraint.m_friction*totalImpulse;
     if (rollingFrictionMagnitude>rollingFrictionConstraint.m_friction)
      rollingFrictionMagnitude = rollingFrictionConstraint.m_friction;

     rollingFrictionConstraint.m_lowerLimit = -rollingFrictionMagnitude;
     rollingFrictionConstraint.m_upperLimit = rollingFrictionMagnitude;

     resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdA], m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdB], rollingFrictionConstraint);
    }
   }
  }
 }
 return 0.f;
}


void b3PgsJacobiSolver::solveGroupCacheFriendlySplitImpulseIterations(b3TypedConstraint** constraints, int numConstraints, const b3ContactSolverInfo& infoGlobal)
{
 int iteration;
 if (infoGlobal.m_splitImpulse)
 {
  if (infoGlobal.m_solverMode & B3_SOLVER_SIMD)
  {
   for (iteration = 0; iteration<infoGlobal.m_numIterations; iteration++)
   {
    {
     int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
     int j;
     for (j = 0; j<numPoolConstraints; j++)
     {
      const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];

      resolveSplitPenetrationSIMD(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     }
    }
   }
  }
  else
  {
   for (iteration = 0; iteration<infoGlobal.m_numIterations; iteration++)
   {
    {
     int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
     int j;
     for (j = 0; j<numPoolConstraints; j++)
     {
      const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];

      resolveSplitPenetrationImpulseCacheFriendly(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     }
    }
   }
  }
 }
}

b3Scalar b3PgsJacobiSolver::solveGroupCacheFriendlyIterations(b3TypedConstraint** constraints, int numConstraints, const b3ContactSolverInfo& infoGlobal)
{
 B3_PROFILE("solveGroupCacheFriendlyIterations");

 {
  ///this is a special step to resolve penetrations (just for contacts)
  solveGroupCacheFriendlySplitImpulseIterations(constraints, numConstraints, infoGlobal);

  int maxIterations = m_maxOverrideNumSolverIterations > infoGlobal.m_numIterations ? m_maxOverrideNumSolverIterations : infoGlobal.m_numIterations;

  for (int iteration = 0; iteration< maxIterations; iteration++)
   //for ( int iteration = maxIterations-1  ; iteration >= 0;iteration--)
  {

   solveSingleIteration(iteration, constraints, numConstraints, infoGlobal);


   if (!m_usePgs)
   {
    averageVelocities();
   }
  }

 }
 return 0.f;
}

void	b3PgsJacobiSolver::averageVelocities()
{
 B3_PROFILE("averaging");
 //average the velocities
 int numBodies = m_bodyCount.size();

 m_deltaLinearVelocities.resize(0);
 m_deltaLinearVelocities.resize(numBodies, b3MakeVector3(0, 0, 0));
 m_deltaAngularVelocities.resize(0);
 m_deltaAngularVelocities.resize(numBodies, b3MakeVector3(0, 0, 0));

 for (int i = 0; i<m_tmpSolverBodyPool.size(); i++)
 {
  if (!m_tmpSolverBodyPool[i].m_invMass.isZero())
  {
   int orgBodyIndex = m_tmpSolverBodyPool[i].m_originalBodyIndex;
   m_deltaLinearVelocities[orgBodyIndex] += m_tmpSolverBodyPool[i].getDeltaLinearVelocity();
   m_deltaAngularVelocities[orgBodyIndex] += m_tmpSolverBodyPool[i].getDeltaAngularVelocity();
  }
 }

 for (int i = 0; i<m_tmpSolverBodyPool.size(); i++)
 {
  int orgBodyIndex = m_tmpSolverBodyPool[i].m_originalBodyIndex;

  if (!m_tmpSolverBodyPool[i].m_invMass.isZero())
  {

   b3Assert(m_bodyCount[orgBodyIndex] == m_bodyCountCheck[orgBodyIndex]);

   b3Scalar factor = 1.f / b3Scalar(m_bodyCount[orgBodyIndex]);


   m_tmpSolverBodyPool[i].m_deltaLinearVelocity = m_deltaLinearVelocities[orgBodyIndex] * factor;
   m_tmpSolverBodyPool[i].m_deltaAngularVelocity = m_deltaAngularVelocities[orgBodyIndex] * factor;
  }
 }
}

b3Scalar b3PgsJacobiSolver::solveGroupCacheFriendlyFinish(b3RigidBodyData* bodies, b3InertiaData* inertias, int numBodies, const b3ContactSolverInfo& infoGlobal)
{
 B3_PROFILE("solveGroupCacheFriendlyFinish");
 int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
 int i, j;

 if (infoGlobal.m_solverMode & B3_SOLVER_USE_WARMSTARTING)
 {
  for (j = 0; j<numPoolConstraints; j++)
  {
   const b3SolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[j];
   b3ContactPoint* pt = (b3ContactPoint*)solveManifold.m_originalContactPoint;
   b3Assert(pt);
   pt->m_appliedImpulse = solveManifold.m_appliedImpulse;
   //	float f = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
   //	printf("pt->m_appliedImpulseLateral1 = %f\n", f);
   pt->m_appliedImpulseLateral1 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
   //printf("pt->m_appliedImpulseLateral1 = %f\n", pt->m_appliedImpulseLateral1);
   if ((infoGlobal.m_solverMode & B3_SOLVER_USE_2_FRICTION_DIRECTIONS))
   {
    pt->m_appliedImpulseLateral2 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex + 1].m_appliedImpulse;
   }
   //do a callback here?
  }
 }

 numPoolConstraints = m_tmpSolverNonContactConstraintPool.size();
 for (j = 0; j<numPoolConstraints; j++)
 {
  const b3SolverConstraint& solverConstr = m_tmpSolverNonContactConstraintPool[j];
  b3TypedConstraint* constr = (b3TypedConstraint*)solverConstr.m_originalContactPoint;
  b3JointFeedback* fb = constr->getJointFeedback();
  if (fb)
  {
   b3SolverBody* bodyA = &m_tmpSolverBodyPool[solverConstr.m_solverBodyIdA];
   b3SolverBody* bodyB = &m_tmpSolverBodyPool[solverConstr.m_solverBodyIdB];

   fb->m_appliedForceBodyA += solverConstr.m_contactNormal*solverConstr.m_appliedImpulse*bodyA->m_linearFactor / infoGlobal.m_timeStep;
   fb->m_appliedForceBodyB += -solverConstr.m_contactNormal*solverConstr.m_appliedImpulse*bodyB->m_linearFactor / infoGlobal.m_timeStep;
   fb->m_appliedTorqueBodyA += solverConstr.m_relpos1CrossNormal* bodyA->m_angularFactor*solverConstr.m_appliedImpulse / infoGlobal.m_timeStep;
   fb->m_appliedTorqueBodyB += -solverConstr.m_relpos1CrossNormal* bodyB->m_angularFactor*solverConstr.m_appliedImpulse / infoGlobal.m_timeStep;

  }

  constr->internalSetAppliedImpulse(solverConstr.m_appliedImpulse);
  if (b3Fabs(solverConstr.m_appliedImpulse) >= constr->getBreakingImpulseThreshold())
  {
   constr->setEnabled(false);
  }
 }

 {
  B3_PROFILE("write back velocities and transforms");
  for (i = 0; i<m_tmpSolverBodyPool.size(); i++)
  {
   int bodyIndex = m_tmpSolverBodyPool[i].m_originalBodyIndex;
   //b3Assert(i==bodyIndex);

   b3RigidBodyData* body = &bodies[bodyIndex];
   if (body->m_invMass)
   {
    if (infoGlobal.m_splitImpulse)
     m_tmpSolverBodyPool[i].writebackVelocityAndTransform(infoGlobal.m_timeStep, infoGlobal.m_splitImpulseTurnErp);
    else
     m_tmpSolverBodyPool[i].writebackVelocity();

    if (m_usePgs)
    {
     body->m_linVel = m_tmpSolverBodyPool[i].m_linearVelocity;
     body->m_angVel = m_tmpSolverBodyPool[i].m_angularVelocity;
    }
    else
    {
     b3Scalar factor = 1.f / b3Scalar(m_bodyCount[bodyIndex]);

     b3Vector3 deltaLinVel = m_deltaLinearVelocities[bodyIndex] * factor;
     b3Vector3 deltaAngVel = m_deltaAngularVelocities[bodyIndex] * factor;
     //printf("body %d\n",bodyIndex);
     //printf("deltaLinVel = %f,%f,%f\n",deltaLinVel.getX(),deltaLinVel.getY(),deltaLinVel.getZ());
     //printf("deltaAngVel = %f,%f,%f\n",deltaAngVel.getX(),deltaAngVel.getY(),deltaAngVel.getZ());

     body->m_linVel += deltaLinVel;
     body->m_angVel += deltaAngVel;
    }

    if (infoGlobal.m_splitImpulse)
    {
     body->m_pos = m_tmpSolverBodyPool[i].m_worldTransform.getOrigin();
     b3Quaternion orn;
     orn = m_tmpSolverBodyPool[i].m_worldTransform.getRotation();
     body->m_quat = orn;
    }
   }
  }
 }


 m_tmpSolverContactConstraintPool.resizeNoInitialize(0);
 m_tmpSolverNonContactConstraintPool.resizeNoInitialize(0);
 m_tmpSolverContactFrictionConstraintPool.resizeNoInitialize(0);
 m_tmpSolverContactRollingFrictionConstraintPool.resizeNoInitialize(0);

 m_tmpSolverBodyPool.resizeNoInitialize(0);
 return 0.f;
}



void	b3PgsJacobiSolver::reset()
{
 m_btSeed2 = 0;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "Bullet3Dynamics/ConstraintSolver/b3Point2PointConstraint.h"
#include "Bullet3Collision/NarrowPhaseCollision/shared/b3RigidBodyData.h"

#include <new>





b3Point2PointConstraint::b3Point2PointConstraint(int rbA, int rbB, const b3Vector3& pivotInA, const b3Vector3& pivotInB)
 :b3TypedConstraint(B3_POINT2POINT_CONSTRAINT_TYPE, rbA, rbB), m_pivotInA(pivotInA), m_pivotInB(pivotInB),
 m_flags(0)
{

}

/*
b3Point2PointConstraint::b3Point2PointConstraint(int  rbA,const b3Vector3& pivotInA)
:b3TypedConstraint(B3_POINT2POINT_CONSTRAINT_TYPE,rbA),m_pivotInA(pivotInA),m_pivotInB(rbA.getCenterOfMassTransform()(pivotInA)),
m_flags(0),
m_useSolveConstraintObsolete(false)
{

}
*/


void b3Point2PointConstraint::getInfo1(b3ConstraintInfo1* info, const b3RigidBodyData* bodies)
{
 getInfo1NonVirtual(info, bodies);
}

void b3Point2PointConstraint::getInfo1NonVirtual(b3ConstraintInfo1* info, const b3RigidBodyData* bodies)
{
 info->m_numConstraintRows = 3;
 info->nub = 3;
}




void b3Point2PointConstraint::getInfo2(b3ConstraintInfo2* info, const b3RigidBodyData* bodies)
{
 b3Transform trA;
 trA.setIdentity();
 trA.setOrigin(bodies[m_rbA].m_pos);
 trA.setRotation(bodies[m_rbA].m_quat);

 b3Transform trB;
 trB.setIdentity();
 trB.setOrigin(bodies[m_rbB].m_pos);
 trB.setRotation(bodies[m_rbB].m_quat);

 getInfo2NonVirtual(info, trA, trB);
}

void b3Point2PointConstraint::getInfo2NonVirtual(b3ConstraintInfo2* info, const b3Transform& body0_trans, const b3Transform& body1_trans)
{

 //retrieve matrices

 // anchor points in global coordinates with respect to body PORs.

 // set jacobian
 info->m_J1linearAxis[0] = 1;
 info->m_J1linearAxis[info->rowskip + 1] = 1;
 info->m_J1linearAxis[2 * info->rowskip + 2] = 1;

 b3Vector3 a1 = body0_trans.getBasis()*getPivotInA();
 //b3Vector3 a1a = b3QuatRotate(body0_trans.getRotation(),getPivotInA());

 {
  b3Vector3* angular0 = (b3Vector3*)(info->m_J1angularAxis);
  b3Vector3* angular1 = (b3Vector3*)(info->m_J1angularAxis + info->rowskip);
  b3Vector3* angular2 = (b3Vector3*)(info->m_J1angularAxis + 2 * info->rowskip);
  b3Vector3 a1neg = -a1;
  a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }

 if (info->m_J2linearAxis)
 {
  info->m_J2linearAxis[0] = -1;
  info->m_J2linearAxis[info->rowskip + 1] = -1;
  info->m_J2linearAxis[2 * info->rowskip + 2] = -1;
 }

 b3Vector3 a2 = body1_trans.getBasis()*getPivotInB();

 {
  //	b3Vector3 a2n = -a2;
  b3Vector3* angular0 = (b3Vector3*)(info->m_J2angularAxis);
  b3Vector3* angular1 = (b3Vector3*)(info->m_J2angularAxis + info->rowskip);
  b3Vector3* angular2 = (b3Vector3*)(info->m_J2angularAxis + 2 * info->rowskip);
  a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }



 // set right hand side
 b3Scalar currERP = (m_flags & B3_P2P_FLAGS_ERP) ? m_erp : info->erp;
 b3Scalar k = info->fps * currERP;
 int j;
 for (j = 0; j<3; j++)
 {
  info->m_constraintError[j*info->rowskip] = k * (a2[j] + body1_trans.getOrigin()[j] - a1[j] - body0_trans.getOrigin()[j]);
  //printf("info->m_constraintError[%d]=%f\n",j,info->m_constraintError[j]);
 }
 if (m_flags & B3_P2P_FLAGS_CFM)
 {
  for (j = 0; j<3; j++)
  {
   info->cfm[j*info->rowskip] = m_cfm;
  }
 }

 b3Scalar impulseClamp = m_setting.m_impulseClamp;//
 for (j = 0; j<3; j++)
 {
  if (m_setting.m_impulseClamp > 0)
  {
   info->m_lowerLimit[j*info->rowskip] = -impulseClamp;
   info->m_upperLimit[j*info->rowskip] = impulseClamp;
  }
 }
 info->m_damping = m_setting.m_damping;

}



void	b3Point2PointConstraint::updateRHS(b3Scalar	timeStep)
{
 (void)timeStep;

}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void b3Point2PointConstraint::setParam(int num, b3Scalar value, int axis)
{
 if (axis != -1)
 {
  b3AssertConstrParams(0);
 }
 else
 {
  switch (num)
  {
  case B3_CONSTRAINT_ERP:
  case B3_CONSTRAINT_STOP_ERP:
   m_erp = value;
   m_flags |= B3_P2P_FLAGS_ERP;
   break;
  case B3_CONSTRAINT_CFM:
  case B3_CONSTRAINT_STOP_CFM:
   m_cfm = value;
   m_flags |= B3_P2P_FLAGS_CFM;
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
}

///return the local value of parameter
b3Scalar b3Point2PointConstraint::getParam(int num, int axis) const
{
 b3Scalar retVal(B3_INFINITY);
 if (axis != -1)
 {
  b3AssertConstrParams(0);
 }
 else
 {
  switch (num)
  {
  case B3_CONSTRAINT_ERP:
  case B3_CONSTRAINT_STOP_ERP:
   b3AssertConstrParams(m_flags & B3_P2P_FLAGS_ERP);
   retVal = m_erp;
   break;
  case B3_CONSTRAINT_CFM:
  case B3_CONSTRAINT_STOP_CFM:
   b3AssertConstrParams(m_flags & B3_P2P_FLAGS_CFM);
   retVal = m_cfm;
   break;
  default:
   b3AssertConstrParams(0);
  }
 }
 return retVal;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "Bullet3Dynamics/ConstraintSolver/b3TypedConstraint.h"
//#include "Bullet3Common/b3Serializer.h"


#define B3_DEFAULT_DEBUGDRAW_SIZE b3Scalar(0.3f)



b3TypedConstraint::b3TypedConstraint(b3TypedConstraintType type, int rbA, int rbB)
 :b3TypedObject(type),
 m_userConstraintType(-1),
 m_userConstraintPtr((void*)-1),
 m_breakingImpulseThreshold(B3_INFINITY),
 m_isEnabled(true),
 m_needsFeedback(false),
 m_overrideNumSolverIterations(-1),
 m_rbA(rbA),
 m_rbB(rbB),
 m_appliedImpulse(b3Scalar(0.)),
 m_dbgDrawSize(B3_DEFAULT_DEBUGDRAW_SIZE),
 m_jointFeedback(0)
{
}




b3Scalar b3TypedConstraint::getMotorFactor(b3Scalar pos, b3Scalar lowLim, b3Scalar uppLim, b3Scalar vel, b3Scalar timeFact)
{
 if (lowLim > uppLim)
 {
  return b3Scalar(1.0f);
 }
 else if (lowLim == uppLim)
 {
  return b3Scalar(0.0f);
 }
 b3Scalar lim_fact = b3Scalar(1.0f);
 b3Scalar delta_max = vel / timeFact;
 if (delta_max < b3Scalar(0.0f))
 {
  if ((pos >= lowLim) && (pos < (lowLim - delta_max)))
  {
   lim_fact = (lowLim - pos) / delta_max;
  }
  else if (pos  < lowLim)
  {
   lim_fact = b3Scalar(0.0f);
  }
  else
  {
   lim_fact = b3Scalar(1.0f);
  }
 }
 else if (delta_max > b3Scalar(0.0f))
 {
  if ((pos <= uppLim) && (pos > (uppLim - delta_max)))
  {
   lim_fact = (uppLim - pos) / delta_max;
  }
  else if (pos  > uppLim)
  {
   lim_fact = b3Scalar(0.0f);
  }
  else
  {
   lim_fact = b3Scalar(1.0f);
  }
 }
 else
 {
  lim_fact = b3Scalar(0.0f);
 }
 return lim_fact;
}



void b3AngularLimit::set(b3Scalar low, b3Scalar high, b3Scalar _softness, b3Scalar _biasFactor, b3Scalar _relaxationFactor)
{
 m_halfRange = (high - low) / 2.0f;
 m_center = b3NormalizeAngle(low + m_halfRange);
 m_softness = _softness;
 m_biasFactor = _biasFactor;
 m_relaxationFactor = _relaxationFactor;
}

void b3AngularLimit::test(const b3Scalar angle)
{
 m_correction = 0.0f;
 m_sign = 0.0f;
 m_solveLimit = false;

 if (m_halfRange >= 0.0f)
 {
  b3Scalar deviation = b3NormalizeAngle(angle - m_center);
  if (deviation < -m_halfRange)
  {
   m_solveLimit = true;
   m_correction = -(deviation + m_halfRange);
   m_sign = +1.0f;
  }
  else if (deviation > m_halfRange)
  {
   m_solveLimit = true;
   m_correction = m_halfRange - deviation;
   m_sign = -1.0f;
  }
 }
}


b3Scalar b3AngularLimit::getError() const
{
 return m_correction * m_sign;
}

void b3AngularLimit::fit(b3Scalar& angle) const
{
 if (m_halfRange > 0.0f)
 {
  b3Scalar relativeAngle = b3NormalizeAngle(angle - m_center);
  if (!b3Equal(relativeAngle, m_halfRange))
  {
   if (relativeAngle > 0.0f)
   {
    angle = getHigh();
   }
   else
   {
    angle = getLow();
   }
  }
 }
}

b3Scalar b3AngularLimit::getLow() const
{
 return b3NormalizeAngle(m_center - m_halfRange);
}

b3Scalar b3AngularLimit::getHigh() const
{
 return b3NormalizeAngle(m_center + m_halfRange);
}

/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include <string.h>

#include "Bullet3Geometry/b3ConvexHullComputer.h"
#include "Bullet3Common/b3AlignedObjectArray.h"
#include "Bullet3Common/b3MinMax.h"
#include "Bullet3Common/b3Vector3.h"

#ifdef __GNUC__
#include <stdint.h>
typedef int32_t btInt32_t;
typedef int64_t btInt64_t;
typedef uint32_t btUint32_t;
typedef uint64_t btUint64_t;
#elif defined(_MSC_VER)
typedef __int32 btInt32_t;
typedef __int64 btInt64_t;
typedef unsigned __int32 btUint32_t;
typedef unsigned __int64 btUint64_t;
#else
typedef int btInt32_t;
typedef long long int btInt64_t;
typedef unsigned int btUint32_t;
typedef unsigned long long int btUint64_t;
#endif


//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif


//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS

#if defined(DEBUG_CONVEX_HULL) || defined(SHOW_ITERATIONS)
#include <stdio.h>
#endif

// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
class b3ConvexHullInternal
{
public:

 class Point64
 {
 public:
  btInt64_t x;
  btInt64_t y;
  btInt64_t z;

  Point64(btInt64_t x, btInt64_t y, btInt64_t z) : x(x), y(y), z(z)
  {
  }

  bool isZero()
  {
   return (x == 0) && (y == 0) && (z == 0);
  }

  btInt64_t dot(const Point64& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }
 };

 class Point32
 {
 public:
  btInt32_t x;
  btInt32_t y;
  btInt32_t z;
  int index;

  Point32()
  {
  }

  Point32(btInt32_t x, btInt32_t y, btInt32_t z) : x(x), y(y), z(z), index(-1)
  {
  }

  bool operator==(const Point32& b) const
  {
   return (x == b.x) && (y == b.y) && (z == b.z);
  }

  bool operator!=(const Point32& b) const
  {
   return (x != b.x) || (y != b.y) || (z != b.z);
  }

  bool isZero()
  {
   return (x == 0) && (y == 0) && (z == 0);
  }

  Point64 cross(const Point32& b) const
  {
   return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
  }

  Point64 cross(const Point64& b) const
  {
   return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
  }

  btInt64_t dot(const Point32& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }

  btInt64_t dot(const Point64& b) const
  {
   return x * b.x + y * b.y + z * b.z;
  }

  Point32 operator+(const Point32& b) const
  {
   return Point32(x + b.x, y + b.y, z + b.z);
  }

  Point32 operator-(const Point32& b) const
  {
   return Point32(x - b.x, y - b.y, z - b.z);
  }
 };

 class Int128
 {
 public:
  btUint64_t low;
  btUint64_t high;

  Int128()
  {
  }

  Int128(btUint64_t low, btUint64_t high) : low(low), high(high)
  {
  }

  Int128(btUint64_t low) : low(low), high(0)
  {
  }

  Int128(btInt64_t value) : low(value), high((value >= 0) ? 0 : (btUint64_t)-1LL)
  {
  }

  static Int128 mul(btInt64_t a, btInt64_t b);

  static Int128 mul(btUint64_t a, btUint64_t b);

  Int128 operator-() const
  {
   return Int128((btUint64_t)-(btInt64_t)low, ~high + (low == 0));
  }

  Int128 operator+(const Int128& b) const
  {
#ifdef USE_X86_64_ASM
   Int128 result;
   __asm__("addq %[bl], %[rl]\n\t"
    "adcq %[bh], %[rh]\n\t"
    : [rl] "=r" (result.low), [rh] "=r" (result.high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
   return result;
#else
   btUint64_t lo = low + b.low;
   return Int128(lo, high + b.high + (lo < low));
#endif
  }

  Int128 operator-(const Int128& b) const
  {
#ifdef USE_X86_64_ASM
   Int128 result;
   __asm__("subq %[bl], %[rl]\n\t"
    "sbbq %[bh], %[rh]\n\t"
    : [rl] "=r" (result.low), [rh] "=r" (result.high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
   return result;
#else
   return *this + -b;
#endif
  }

  Int128& operator+=(const Int128& b)
  {
#ifdef USE_X86_64_ASM
   __asm__("addq %[bl], %[rl]\n\t"
    "adcq %[bh], %[rh]\n\t"
    : [rl] "=r" (low), [rh] "=r" (high)
    : "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
    : "cc");
#else
   btUint64_t lo = low + b.low;
   if (lo < low)
   {
    ++high;
   }
   low = lo;
   high += b.high;
#endif
   return *this;
  }

  Int128& operator++()
  {
   if (++low == 0)
   {
    ++high;
   }
   return *this;
  }

  Int128 operator*(btInt64_t b) const;

  b3Scalar toScalar() const
  {
   return ((btInt64_t)high >= 0) ? b3Scalar(high) * (b3Scalar(0x100000000LL) * b3Scalar(0x100000000LL)) + b3Scalar(low)
    : -(-*this).toScalar();
  }

  int getSign() const
  {
   return ((btInt64_t)high < 0) ? -1 : (high || low) ? 1 : 0;
  }

  bool operator<(const Int128& b) const
  {
   return (high < b.high) || ((high == b.high) && (low < b.low));
  }

  int ucmp(const Int128&b) const
  {
   if (high < b.high)
   {
    return -1;
   }
   if (high > b.high)
   {
    return 1;
   }
   if (low < b.low)
   {
    return -1;
   }
   if (low > b.low)
   {
    return 1;
   }
   return 0;
  }
 };


 class Rational64
 {
 private:
  btUint64_t m_numerator;
  btUint64_t m_denominator;
  int sign;

 public:
  Rational64(btInt64_t numerator, btInt64_t denominator)
  {
   if (numerator > 0)
   {
    sign = 1;
    m_numerator = (btUint64_t)numerator;
   }
   else if (numerator < 0)
   {
    sign = -1;
    m_numerator = (btUint64_t)-numerator;
   }
   else
   {
    sign = 0;
    m_numerator = 0;
   }
   if (denominator > 0)
   {
    m_denominator = (btUint64_t)denominator;
   }
   else if (denominator < 0)
   {
    sign = -sign;
    m_denominator = (btUint64_t)-denominator;
   }
   else
   {
    m_denominator = 0;
   }
  }

  bool isNegativeInfinity() const
  {
   return (sign < 0) && (m_denominator == 0);
  }

  bool isNaN() const
  {
   return (sign == 0) && (m_denominator == 0);
  }

  int compare(const Rational64& b) const;

  b3Scalar toScalar() const
  {
   return sign * ((m_denominator == 0) ? B3_INFINITY : (b3Scalar)m_numerator / m_denominator);
  }
 };


 class Rational128
 {
 private:
  Int128 numerator;
  Int128 denominator;
  int sign;
  bool isInt64;

 public:
  Rational128(btInt64_t value)
  {
   if (value > 0)
   {
    sign = 1;
    this->numerator = value;
   }
   else if (value < 0)
   {
    sign = -1;
    this->numerator = -value;
   }
   else
   {
    sign = 0;
    this->numerator = (btUint64_t)0;
   }
   this->denominator = (btUint64_t)1;
   isInt64 = true;
  }

  Rational128(const Int128& numerator, const Int128& denominator)
  {
   sign = numerator.getSign();
   if (sign >= 0)
   {
    this->numerator = numerator;
   }
   else
   {
    this->numerator = -numerator;
   }
   int dsign = denominator.getSign();
   if (dsign >= 0)
   {
    this->denominator = denominator;
   }
   else
   {
    sign = -sign;
    this->denominator = -denominator;
   }
   isInt64 = false;
  }

  int compare(const Rational128& b) const;

  int compare(btInt64_t b) const;

  b3Scalar toScalar() const
  {
   return sign * ((denominator.getSign() == 0) ? B3_INFINITY : numerator.toScalar() / denominator.toScalar());
  }
 };

 class PointR128
 {
 public:
  Int128 x;
  Int128 y;
  Int128 z;
  Int128 denominator;

  PointR128()
  {
  }

  PointR128(Int128 x, Int128 y, Int128 z, Int128 denominator) : x(x), y(y), z(z), denominator(denominator)
  {
  }

  b3Scalar xvalue() const
  {
   return x.toScalar() / denominator.toScalar();
  }

  b3Scalar yvalue() const
  {
   return y.toScalar() / denominator.toScalar();
  }

  b3Scalar zvalue() const
  {
   return z.toScalar() / denominator.toScalar();
  }
 };


 class Edge;
 class Face;

 class Vertex
 {
 public:
  Vertex* next;
  Vertex* prev;
  Edge* edges;
  Face* firstNearbyFace;
  Face* lastNearbyFace;
  PointR128 point128;
  Point32 point;
  int copy;

  Vertex() : next(NULL), prev(NULL), edges(NULL), firstNearbyFace(NULL), lastNearbyFace(NULL), copy(-1)
  {
  }

#ifdef DEBUG_CONVEX_HULL
  void print()
  {
   b3Printf("V%d (%d, %d, %d)", point.index, point.x, point.y, point.z);
  }

  void printGraph();
#endif

  Point32 operator-(const Vertex& b) const
  {
   return point - b.point;
  }

  Rational128 dot(const Point64& b) const
  {
   return (point.index >= 0) ? Rational128(point.dot(b))
    : Rational128(point128.x * b.x + point128.y * b.y + point128.z * b.z, point128.denominator);
  }

  b3Scalar xvalue() const
  {
   return (point.index >= 0) ? b3Scalar(point.x) : point128.xvalue();
  }

  b3Scalar yvalue() const
  {
   return (point.index >= 0) ? b3Scalar(point.y) : point128.yvalue();
  }

  b3Scalar zvalue() const
  {
   return (point.index >= 0) ? b3Scalar(point.z) : point128.zvalue();
  }

  void receiveNearbyFaces(Vertex* src)
  {
   if (lastNearbyFace)
   {
    lastNearbyFace->nextWithSameNearbyVertex = src->firstNearbyFace;
   }
   else
   {
    firstNearbyFace = src->firstNearbyFace;
   }
   if (src->lastNearbyFace)
   {
    lastNearbyFace = src->lastNearbyFace;
   }
   for (Face* f = src->firstNearbyFace; f; f = f->nextWithSameNearbyVertex)
   {
    b3Assert(f->nearbyVertex == src);
    f->nearbyVertex = this;
   }
   src->firstNearbyFace = NULL;
   src->lastNearbyFace = NULL;
  }
 };


 class Edge
 {
 public:
  Edge* next;
  Edge* prev;
  Edge* reverse;
  Vertex* target;
  Face* face;
  int copy;

  ~Edge()
  {
   next = NULL;
   prev = NULL;
   reverse = NULL;
   target = NULL;
   face = NULL;
  }

  void link(Edge* n)
  {
   b3Assert(reverse->target == n->reverse->target);
   next = n;
   n->prev = this;
  }

#ifdef DEBUG_CONVEX_HULL
  void print()
  {
   b3Printf("E%p : %d -> %d,  n=%p p=%p   (0 %d\t%d\t%d) -> (%d %d %d)", this, reverse->target->point.index, target->point.index, next, prev,
    reverse->target->point.x, reverse->target->point.y, reverse->target->point.z, target->point.x, target->point.y, target->point.z);
  }
#endif
 };

 class Face
 {
 public:
  Face* next;
  Vertex* nearbyVertex;
  Face* nextWithSameNearbyVertex;
  Point32 origin;
  Point32 dir0;
  Point32 dir1;

  Face() : next(NULL), nearbyVertex(NULL), nextWithSameNearbyVertex(NULL)
  {
  }

  void init(Vertex* a, Vertex* b, Vertex* c)
  {
   nearbyVertex = a;
   origin = a->point;
   dir0 = *b - *a;
   dir1 = *c - *a;
   if (a->lastNearbyFace)
   {
    a->lastNearbyFace->nextWithSameNearbyVertex = this;
   }
   else
   {
    a->firstNearbyFace = this;
   }
   a->lastNearbyFace = this;
  }

  Point64 getNormal()
  {
   return dir0.cross(dir1);
  }
 };

 template<typename UWord, typename UHWord> class DMul
 {
 private:
  static btUint32_t high(btUint64_t value)
  {
   return (btUint32_t)(value >> 32);
  }

  static btUint32_t low(btUint64_t value)
  {
   return (btUint32_t)value;
  }

  static btUint64_t mul(btUint32_t a, btUint32_t b)
  {
   return (btUint64_t)a * (btUint64_t)b;
  }

  static void shlHalf(btUint64_t& value)
  {
   value <<= 32;
  }

  static btUint64_t high(Int128 value)
  {
   return value.high;
  }

  static btUint64_t low(Int128 value)
  {
   return value.low;
  }

  static Int128 mul(btUint64_t a, btUint64_t b)
  {
   return Int128::mul(a, b);
  }

  static void shlHalf(Int128& value)
  {
   value.high = value.low;
   value.low = 0;
  }

 public:

  static void mul(UWord a, UWord b, UWord& resLow, UWord& resHigh)
  {
   UWord p00 = mul(low(a), low(b));
   UWord p01 = mul(low(a), high(b));
   UWord p10 = mul(high(a), low(b));
   UWord p11 = mul(high(a), high(b));
   UWord p0110 = UWord(low(p01)) + UWord(low(p10));
   p11 += high(p01);
   p11 += high(p10);
   p11 += high(p0110);
   shlHalf(p0110);
   p00 += p0110;
   if (p00 < p0110)
   {
    ++p11;
   }
   resLow = p00;
   resHigh = p11;
  }
 };

private:

 class IntermediateHull
 {
 public:
  Vertex* minXy;
  Vertex* maxXy;
  Vertex* minYx;
  Vertex* maxYx;

  IntermediateHull() : minXy(NULL), maxXy(NULL), minYx(NULL), maxYx(NULL)
  {
  }

  void print();
 };

 enum Orientation { NONE, CLOCKWISE, COUNTER_CLOCKWISE };

 template <typename T> class PoolArray
 {
 private:
  T* array;
  int size;

 public:
  PoolArray<T>* next;

  PoolArray(int size) : size(size), next(NULL)
  {
   array = (T*)b3AlignedAlloc(sizeof(T) * size, 16);
  }

  ~PoolArray()
  {
   b3AlignedFree(array);
  }

  T* init()
  {
   T* o = array;
   for (int i = 0; i < size; i++, o++)
   {
    o->next = (i + 1 < size) ? o + 1 : NULL;
   }
   return array;
  }
 };

 template <typename T> class Pool
 {
 private:
  PoolArray<T>* arrays;
  PoolArray<T>* nextArray;
  T* freeObjects;
  int arraySize;

 public:
  Pool() : arrays(NULL), nextArray(NULL), freeObjects(NULL), arraySize(256)
  {
  }

  ~Pool()
  {
   while (arrays)
   {
    PoolArray<T>* p = arrays;
    arrays = p->next;
    p->~PoolArray<T>();
    b3AlignedFree(p);
   }
  }

  void reset()
  {
   nextArray = arrays;
   freeObjects = NULL;
  }

  void setArraySize(int arraySize)
  {
   this->arraySize = arraySize;
  }

  T* newObject()
  {
   T* o = freeObjects;
   if (!o)
   {
    PoolArray<T>* p = nextArray;
    if (p)
    {
     nextArray = p->next;
    }
    else
    {
     p = new(b3AlignedAlloc(sizeof(PoolArray<T>), 16)) PoolArray<T>(arraySize);
     p->next = arrays;
     arrays = p;
    }
    o = p->init();
   }
   freeObjects = o->next;
   return new(o) T();
  };

  void freeObject(T* object)
  {
   object->~T();
   object->next = freeObjects;
   freeObjects = object;
  }
 };

 b3Vector3 scaling;
 b3Vector3 center;
 Pool<Vertex> vertexPool;
 Pool<Edge> edgePool;
 Pool<Face> facePool;
 b3AlignedObjectArray<Vertex*> originalVertices;
 int mergeStamp;
 int minAxis;
 int medAxis;
 int maxAxis;
 int usedEdgePairs;
 int maxUsedEdgePairs;

 static Orientation getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t);
 Edge* findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot);
 void findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1);

 Edge* newEdgePair(Vertex* from, Vertex* to);

 void removeEdgePair(Edge* edge)
 {
  Edge* n = edge->next;
  Edge* r = edge->reverse;

  b3Assert(edge->target && r->target);

  if (n != edge)
  {
   n->prev = edge->prev;
   edge->prev->next = n;
   r->target->edges = n;
  }
  else
  {
   r->target->edges = NULL;
  }

  n = r->next;

  if (n != r)
  {
   n->prev = r->prev;
   r->prev->next = n;
   edge->target->edges = n;
  }
  else
  {
   edge->target->edges = NULL;
  }

  edgePool.freeObject(edge);
  edgePool.freeObject(r);
  usedEdgePairs--;
 }

 void computeInternal(int start, int end, IntermediateHull& result);

 bool mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1);

 void merge(IntermediateHull& h0, IntermediateHull& h1);

 b3Vector3 toBtVector(const Point32& v);

 b3Vector3 getBtNormal(Face* face);

 bool shiftFace(Face* face, b3Scalar amount, b3AlignedObjectArray<Vertex*> stack);

public:
 Vertex* vertexList;

 void compute(const void* coords, bool doubleCoords, int stride, int count);

 b3Vector3 getCoordinates(const Vertex* v);

 b3Scalar shrink(b3Scalar amount, b3Scalar clampAmount);
};


b3ConvexHullInternal::Int128 b3ConvexHullInternal::Int128::operator*(btInt64_t b) const
{
 bool negative = (btInt64_t)high < 0;
 Int128 a = negative ? -*this : *this;
 if (b < 0)
 {
  negative = !negative;
  b = -b;
 }
 Int128 result = mul(a.low, (btUint64_t)b);
 result.high += a.high * (btUint64_t)b;
 return negative ? -result : result;
}

b3ConvexHullInternal::Int128 b3ConvexHullInternal::Int128::mul(btInt64_t a, btInt64_t b)
{
 Int128 result;

#ifdef USE_X86_64_ASM
 __asm__("imulq %[b]"
  : "=a" (result.low), "=d" (result.high)
  : "0"(a), [b] "r"(b)
  : "cc");
 return result;

#else
 bool negative = a < 0;
 if (negative)
 {
  a = -a;
 }
 if (b < 0)
 {
  negative = !negative;
  b = -b;
 }
 DMul<btUint64_t, btUint32_t>::mul((btUint64_t)a, (btUint64_t)b, result.low, result.high);
 return negative ? -result : result;
#endif
}

b3ConvexHullInternal::Int128 b3ConvexHullInternal::Int128::mul(btUint64_t a, btUint64_t b)
{
 Int128 result;

#ifdef USE_X86_64_ASM
 __asm__("mulq %[b]"
  : "=a" (result.low), "=d" (result.high)
  : "0"(a), [b] "r"(b)
  : "cc");

#else
 DMul<btUint64_t, btUint32_t>::mul(a, b, result.low, result.high);
#endif

 return result;
}

int b3ConvexHullInternal::Rational64::compare(const Rational64& b) const
{
 if (sign != b.sign)
 {
  return sign - b.sign;
 }
 else if (sign == 0)
 {
  return 0;
 }

 //	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;

#ifdef USE_X86_64_ASM

 int result;
 btInt64_t tmp;
 btInt64_t dummy;
 __asm__("mulq %[bn]\n\t"
  "movq %%rax, %[tmp]\n\t"
  "movq %%rdx, %%rbx\n\t"
  "movq %[tn], %%rax\n\t"
  "mulq %[bd]\n\t"
  "subq %[tmp], %%rax\n\t"
  "sbbq %%rbx, %%rdx\n\t" // rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
  "setnsb %%bh\n\t" // bh=1 if difference is non-negative, bh=0 otherwise
  "orq %%rdx, %%rax\n\t"
  "setnzb %%bl\n\t" // bl=1 if difference if non-zero, bl=0 if it is zero
  "decb %%bh\n\t" // now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
  "shll $16, %%ebx\n\t" // ebx has same sign as difference
  : "=&b"(result), [tmp] "=&r"(tmp), "=a"(dummy)
  : "a"(denominator), [bn] "g"(b.numerator), [tn] "g"(numerator), [bd] "g"(b.denominator)
  : "%rdx", "cc");
 return result ? result ^ sign // if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
                               // if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
  : 0;

#else

 return sign * Int128::mul(m_numerator, b.m_denominator).ucmp(Int128::mul(m_denominator, b.m_numerator));

#endif
}

int b3ConvexHullInternal::Rational128::compare(const Rational128& b) const
{
 if (sign != b.sign)
 {
  return sign - b.sign;
 }
 else if (sign == 0)
 {
  return 0;
 }
 if (isInt64)
 {
  return -b.compare(sign * (btInt64_t)numerator.low);
 }

 Int128 nbdLow, nbdHigh, dbnLow, dbnHigh;
 DMul<Int128, btUint64_t>::mul(numerator, b.denominator, nbdLow, nbdHigh);
 DMul<Int128, btUint64_t>::mul(denominator, b.numerator, dbnLow, dbnHigh);

 int cmp = nbdHigh.ucmp(dbnHigh);
 if (cmp)
 {
  return cmp * sign;
 }
 return nbdLow.ucmp(dbnLow) * sign;
}

int b3ConvexHullInternal::Rational128::compare(btInt64_t b) const
{
 if (isInt64)
 {
  btInt64_t a = sign * (btInt64_t)numerator.low;
  return (a > b) ? 1 : (a < b) ? -1 : 0;
 }
 if (b > 0)
 {
  if (sign <= 0)
  {
   return -1;
  }
 }
 else if (b < 0)
 {
  if (sign >= 0)
  {
   return 1;
  }
  b = -b;
 }
 else
 {
  return sign;
 }

 return numerator.ucmp(denominator * b) * sign;
}


b3ConvexHullInternal::Edge* b3ConvexHullInternal::newEdgePair(Vertex* from, Vertex* to)
{
 b3Assert(from && to);
 Edge* e = edgePool.newObject();
 Edge* r = edgePool.newObject();
 e->reverse = r;
 r->reverse = e;
 e->copy = mergeStamp;
 r->copy = mergeStamp;
 e->target = to;
 r->target = from;
 e->face = NULL;
 r->face = NULL;
 usedEdgePairs++;
 if (usedEdgePairs > maxUsedEdgePairs)
 {
  maxUsedEdgePairs = usedEdgePairs;
 }
 return e;
}

bool b3ConvexHullInternal::mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1)
{
 Vertex* v0 = h0.maxYx;
 Vertex* v1 = h1.minYx;
 if ((v0->point.x == v1->point.x) && (v0->point.y == v1->point.y))
 {
  b3Assert(v0->point.z < v1->point.z);
  Vertex* v1p = v1->prev;
  if (v1p == v1)
  {
   c0 = v0;
   if (v1->edges)
   {
    b3Assert(v1->edges->next == v1->edges);
    v1 = v1->edges->target;
    b3Assert(v1->edges->next == v1->edges);
   }
   c1 = v1;
   return false;
  }
  Vertex* v1n = v1->next;
  v1p->next = v1n;
  v1n->prev = v1p;
  if (v1 == h1.minXy)
  {
   if ((v1n->point.x < v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y < v1p->point.y)))
   {
    h1.minXy = v1n;
   }
   else
   {
    h1.minXy = v1p;
   }
  }
  if (v1 == h1.maxXy)
  {
   if ((v1n->point.x > v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y > v1p->point.y)))
   {
    h1.maxXy = v1n;
   }
   else
   {
    h1.maxXy = v1p;
   }
  }
 }

 v0 = h0.maxXy;
 v1 = h1.maxXy;
 Vertex* v00 = NULL;
 Vertex* v10 = NULL;
 btInt32_t sign = 1;

 for (int side = 0; side <= 1; side++)
 {
  btInt32_t dx = (v1->point.x - v0->point.x) * sign;
  if (dx > 0)
  {
   while (true)
   {
    btInt32_t dy = v1->point.y - v0->point.y;

    Vertex* w0 = side ? v0->next : v0->prev;
    if (w0 != v0)
    {
     btInt32_t dx0 = (w0->point.x - v0->point.x) * sign;
     btInt32_t dy0 = w0->point.y - v0->point.y;
     if ((dy0 <= 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx <= dy * dx0))))
     {
      v0 = w0;
      dx = (v1->point.x - v0->point.x) * sign;
      continue;
     }
    }

    Vertex* w1 = side ? v1->next : v1->prev;
    if (w1 != v1)
    {
     btInt32_t dx1 = (w1->point.x - v1->point.x) * sign;
     btInt32_t dy1 = w1->point.y - v1->point.y;
     btInt32_t dxn = (w1->point.x - v0->point.x) * sign;
     if ((dxn > 0) && (dy1 < 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx < dy * dx1))))
     {
      v1 = w1;
      dx = dxn;
      continue;
     }
    }

    break;
   }
  }
  else if (dx < 0)
  {
   while (true)
   {
    btInt32_t dy = v1->point.y - v0->point.y;

    Vertex* w1 = side ? v1->prev : v1->next;
    if (w1 != v1)
    {
     btInt32_t dx1 = (w1->point.x - v1->point.x) * sign;
     btInt32_t dy1 = w1->point.y - v1->point.y;
     if ((dy1 >= 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx <= dy * dx1))))
     {
      v1 = w1;
      dx = (v1->point.x - v0->point.x) * sign;
      continue;
     }
    }

    Vertex* w0 = side ? v0->prev : v0->next;
    if (w0 != v0)
    {
     btInt32_t dx0 = (w0->point.x - v0->point.x) * sign;
     btInt32_t dy0 = w0->point.y - v0->point.y;
     btInt32_t dxn = (v1->point.x - w0->point.x) * sign;
     if ((dxn < 0) && (dy0 > 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx < dy * dx0))))
     {
      v0 = w0;
      dx = dxn;
      continue;
     }
    }

    break;
   }
  }
  else
  {
   btInt32_t x = v0->point.x;
   btInt32_t y0 = v0->point.y;
   Vertex* w0 = v0;
   Vertex* t;
   while (((t = side ? w0->next : w0->prev) != v0) && (t->point.x == x) && (t->point.y <= y0))
   {
    w0 = t;
    y0 = t->point.y;
   }
   v0 = w0;

   btInt32_t y1 = v1->point.y;
   Vertex* w1 = v1;
   while (((t = side ? w1->prev : w1->next) != v1) && (t->point.x == x) && (t->point.y >= y1))
   {
    w1 = t;
    y1 = t->point.y;
   }
   v1 = w1;
  }

  if (side == 0)
  {
   v00 = v0;
   v10 = v1;

   v0 = h0.minXy;
   v1 = h1.minXy;
   sign = -1;
  }
 }

 v0->prev = v1;
 v1->next = v0;

 v00->next = v10;
 v10->prev = v00;

 if (h1.minXy->point.x < h0.minXy->point.x)
 {
  h0.minXy = h1.minXy;
 }
 if (h1.maxXy->point.x >= h0.maxXy->point.x)
 {
  h0.maxXy = h1.maxXy;
 }

 h0.maxYx = h1.maxYx;

 c0 = v00;
 c1 = v10;

 return true;
}

void b3ConvexHullInternal::computeInternal(int start, int end, IntermediateHull& result)
{
 int n = end - start;
 switch (n)
 {
 case 0:
  result.minXy = NULL;
  result.maxXy = NULL;
  result.minYx = NULL;
  result.maxYx = NULL;
  return;
 case 2:
 {
  Vertex* v = originalVertices[start];
  Vertex* w = v + 1;
  if (v->point != w->point)
  {
   btInt32_t dx = v->point.x - w->point.x;
   btInt32_t dy = v->point.y - w->point.y;

   if ((dx == 0) && (dy == 0))
   {
    if (v->point.z > w->point.z)
    {
     Vertex* t = w;
     w = v;
     v = t;
    }
    b3Assert(v->point.z < w->point.z);
    v->next = v;
    v->prev = v;
    result.minXy = v;
    result.maxXy = v;
    result.minYx = v;
    result.maxYx = v;
   }
   else
   {
    v->next = w;
    v->prev = w;
    w->next = v;
    w->prev = v;

    if ((dx < 0) || ((dx == 0) && (dy < 0)))
    {
     result.minXy = v;
     result.maxXy = w;
    }
    else
    {
     result.minXy = w;
     result.maxXy = v;
    }

    if ((dy < 0) || ((dy == 0) && (dx < 0)))
    {
     result.minYx = v;
     result.maxYx = w;
    }
    else
    {
     result.minYx = w;
     result.maxYx = v;
    }
   }

   Edge* e = newEdgePair(v, w);
   e->link(e);
   v->edges = e;

   e = e->reverse;
   e->link(e);
   w->edges = e;

   return;
  }
 }
 // lint -fallthrough
 case 1:
 {
  Vertex* v = originalVertices[start];
  v->edges = NULL;
  v->next = v;
  v->prev = v;

  result.minXy = v;
  result.maxXy = v;
  result.minYx = v;
  result.maxYx = v;

  return;
 }
 }

 int split0 = start + n / 2;
 Point32 p = originalVertices[split0 - 1]->point;
 int split1 = split0;
 while ((split1 < end) && (originalVertices[split1]->point == p))
 {
  split1++;
 }
 computeInternal(start, split0, result);
 IntermediateHull hull1;
 computeInternal(split1, end, hull1);
#ifdef DEBUG_CONVEX_HULL
 b3Printf("\n\nMerge\n");
 result.print();
 hull1.print();
#endif
 merge(result, hull1);
#ifdef DEBUG_CONVEX_HULL
 b3Printf("\n  Result\n");
 result.print();
#endif
}

#ifdef DEBUG_CONVEX_HULL
void b3ConvexHullInternal::IntermediateHull::print()
{
 b3Printf("    Hull\n");
 for (Vertex* v = minXy; v; )
 {
  b3Printf("      ");
  v->print();
  if (v == maxXy)
  {
   b3Printf(" maxXy");
  }
  if (v == minYx)
  {
   b3Printf(" minYx");
  }
  if (v == maxYx)
  {
   b3Printf(" maxYx");
  }
  if (v->next->prev != v)
  {
   b3Printf(" Inconsistency");
  }
  b3Printf("\n");
  v = v->next;
  if (v == minXy)
  {
   break;
  }
 }
 if (minXy)
 {
  minXy->copy = (minXy->copy == -1) ? -2 : -1;
  minXy->printGraph();
 }
}

void b3ConvexHullInternal::Vertex::printGraph()
{
 print();
 b3Printf("\nEdges\n");
 Edge* e = edges;
 if (e)
 {
  do
  {
   e->print();
   b3Printf("\n");
   e = e->next;
  } while (e != edges);
  do
  {
   Vertex* v = e->target;
   if (v->copy != copy)
   {
    v->copy = copy;
    v->printGraph();
   }
   e = e->next;
  } while (e != edges);
 }
}
#endif

b3ConvexHullInternal::Orientation b3ConvexHullInternal::getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t)
{
 b3Assert(prev->reverse->target == next->reverse->target);
 if (prev->next == next)
 {
  if (prev->prev == next)
  {
   Point64 n = t.cross(s);
   Point64 m = (*prev->target - *next->reverse->target).cross(*next->target - *next->reverse->target);
   b3Assert(!m.isZero());
   btInt64_t dot = n.dot(m);
   b3Assert(dot != 0);
   return (dot > 0) ? COUNTER_CLOCKWISE : CLOCKWISE;
  }
  return COUNTER_CLOCKWISE;
 }
 else if (prev->prev == next)
 {
  return CLOCKWISE;
 }
 else
 {
  return NONE;
 }
}

b3ConvexHullInternal::Edge* b3ConvexHullInternal::findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot)
{
 Edge* minEdge = NULL;

#ifdef DEBUG_CONVEX_HULL
 b3Printf("find max edge for %d\n", start->point.index);
#endif
 Edge* e = start->edges;
 if (e)
 {
  do
  {
   if (e->copy > mergeStamp)
   {
    Point32 t = *e->target - *start;
    Rational64 cot(t.dot(sxrxs), t.dot(rxs));
#ifdef DEBUG_CONVEX_HULL
    b3Printf("      Angle is %f (%d) for ", (float)b3Atan(cot.toScalar()), (int)cot.isNaN());
    e->print();
#endif
    if (cot.isNaN())
    {
     b3Assert(ccw ? (t.dot(s) < 0) : (t.dot(s) > 0));
    }
    else
    {
     int cmp;
     if (minEdge == NULL)
     {
      minCot = cot;
      minEdge = e;
     }
     else if ((cmp = cot.compare(minCot)) < 0)
     {
      minCot = cot;
      minEdge = e;
     }
     else if ((cmp == 0) && (ccw == (getOrientation(minEdge, e, s, t) == COUNTER_CLOCKWISE)))
     {
      minEdge = e;
     }
    }
#ifdef DEBUG_CONVEX_HULL
    b3Printf("\n");
#endif
   }
   e = e->next;
  } while (e != start->edges);
 }
 return minEdge;
}

void b3ConvexHullInternal::findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1)
{
 Edge* start0 = e0;
 Edge* start1 = e1;
 Point32 et0 = start0 ? start0->target->point : c0->point;
 Point32 et1 = start1 ? start1->target->point : c1->point;
 Point32 s = c1->point - c0->point;
 Point64 normal = ((start0 ? start0 : start1)->target->point - c0->point).cross(s);
 btInt64_t dist = c0->point.dot(normal);
 b3Assert(!start1 || (start1->target->point.dot(normal) == dist));
 Point64 perp = s.cross(normal);
 b3Assert(!perp.isZero());

#ifdef DEBUG_CONVEX_HULL
 b3Printf("   Advancing %d %d  (%p %p, %d %d)\n", c0->point.index, c1->point.index, start0, start1, start0 ? start0->target->point.index : -1, start1 ? start1->target->point.index : -1);
#endif

 btInt64_t maxDot0 = et0.dot(perp);
 if (e0)
 {
  while (e0->target != stop0)
  {
   Edge* e = e0->reverse->prev;
   if (e->target->point.dot(normal) < dist)
   {
    break;
   }
   b3Assert(e->target->point.dot(normal) == dist);
   if (e->copy == mergeStamp)
   {
    break;
   }
   btInt64_t dot = e->target->point.dot(perp);
   if (dot <= maxDot0)
   {
    break;
   }
   maxDot0 = dot;
   e0 = e;
   et0 = e->target->point;
  }
 }

 btInt64_t maxDot1 = et1.dot(perp);
 if (e1)
 {
  while (e1->target != stop1)
  {
   Edge* e = e1->reverse->next;
   if (e->target->point.dot(normal) < dist)
   {
    break;
   }
   b3Assert(e->target->point.dot(normal) == dist);
   if (e->copy == mergeStamp)
   {
    break;
   }
   btInt64_t dot = e->target->point.dot(perp);
   if (dot <= maxDot1)
   {
    break;
   }
   maxDot1 = dot;
   e1 = e;
   et1 = e->target->point;
  }
 }

#ifdef DEBUG_CONVEX_HULL
 b3Printf("   Starting at %d %d\n", et0.index, et1.index);
#endif

 btInt64_t dx = maxDot1 - maxDot0;
 if (dx > 0)
 {
  while (true)
  {
   btInt64_t dy = (et1 - et0).dot(s);

   if (e0 && (e0->target != stop0))
   {
    Edge* f0 = e0->next->reverse;
    if (f0->copy > mergeStamp)
    {
     btInt64_t dx0 = (f0->target->point - et0).dot(perp);
     btInt64_t dy0 = (f0->target->point - et0).dot(s);
     if ((dx0 == 0) ? (dy0 < 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) >= 0)))
     {
      et0 = f0->target->point;
      dx = (et1 - et0).dot(perp);
      e0 = (e0 == start0) ? NULL : f0;
      continue;
     }
    }
   }

   if (e1 && (e1->target != stop1))
   {
    Edge* f1 = e1->reverse->next;
    if (f1->copy > mergeStamp)
    {
     Point32 d1 = f1->target->point - et1;
     if (d1.dot(normal) == 0)
     {
      btInt64_t dx1 = d1.dot(perp);
      btInt64_t dy1 = d1.dot(s);
      btInt64_t dxn = (f1->target->point - et0).dot(perp);
      if ((dxn > 0) && ((dx1 == 0) ? (dy1 < 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) > 0))))
      {
       e1 = f1;
       et1 = e1->target->point;
       dx = dxn;
       continue;
      }
     }
     else
     {
      b3Assert((e1 == start1) && (d1.dot(normal) < 0));
     }
    }
   }

   break;
  }
 }
 else if (dx < 0)
 {
  while (true)
  {
   btInt64_t dy = (et1 - et0).dot(s);

   if (e1 && (e1->target != stop1))
   {
    Edge* f1 = e1->prev->reverse;
    if (f1->copy > mergeStamp)
    {
     btInt64_t dx1 = (f1->target->point - et1).dot(perp);
     btInt64_t dy1 = (f1->target->point - et1).dot(s);
     if ((dx1 == 0) ? (dy1 > 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) <= 0)))
     {
      et1 = f1->target->point;
      dx = (et1 - et0).dot(perp);
      e1 = (e1 == start1) ? NULL : f1;
      continue;
     }
    }
   }

   if (e0 && (e0->target != stop0))
   {
    Edge* f0 = e0->reverse->prev;
    if (f0->copy > mergeStamp)
    {
     Point32 d0 = f0->target->point - et0;
     if (d0.dot(normal) == 0)
     {
      btInt64_t dx0 = d0.dot(perp);
      btInt64_t dy0 = d0.dot(s);
      btInt64_t dxn = (et1 - f0->target->point).dot(perp);
      if ((dxn < 0) && ((dx0 == 0) ? (dy0 > 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) < 0))))
      {
       e0 = f0;
       et0 = e0->target->point;
       dx = dxn;
       continue;
      }
     }
     else
     {
      b3Assert((e0 == start0) && (d0.dot(normal) < 0));
     }
    }
   }

   break;
  }
 }
#ifdef DEBUG_CONVEX_HULL
 b3Printf("   Advanced edges to %d %d\n", et0.index, et1.index);
#endif
}


void b3ConvexHullInternal::merge(IntermediateHull& h0, IntermediateHull& h1)
{
 if (!h1.maxXy)
 {
  return;
 }
 if (!h0.maxXy)
 {
  h0 = h1;
  return;
 }

 mergeStamp--;

 Vertex* c0 = NULL;
 Edge* toPrev0 = NULL;
 Edge* firstNew0 = NULL;
 Edge* pendingHead0 = NULL;
 Edge* pendingTail0 = NULL;
 Vertex* c1 = NULL;
 Edge* toPrev1 = NULL;
 Edge* firstNew1 = NULL;
 Edge* pendingHead1 = NULL;
 Edge* pendingTail1 = NULL;
 Point32 prevPoint;

 if (mergeProjection(h0, h1, c0, c1))
 {
  Point32 s = *c1 - *c0;
  Point64 normal = Point32(0, 0, -1).cross(s);
  Point64 t = s.cross(normal);
  b3Assert(!t.isZero());

  Edge* e = c0->edges;
  Edge* start0 = NULL;
  if (e)
  {
   do
   {
    btInt64_t dot = (*e->target - *c0).dot(normal);
    b3Assert(dot <= 0);
    if ((dot == 0) && ((*e->target - *c0).dot(t) > 0))
    {
     if (!start0 || (getOrientation(start0, e, s, Point32(0, 0, -1)) == CLOCKWISE))
     {
      start0 = e;
     }
    }
    e = e->next;
   } while (e != c0->edges);
  }

  e = c1->edges;
  Edge* start1 = NULL;
  if (e)
  {
   do
   {
    btInt64_t dot = (*e->target - *c1).dot(normal);
    b3Assert(dot <= 0);
    if ((dot == 0) && ((*e->target - *c1).dot(t) > 0))
    {
     if (!start1 || (getOrientation(start1, e, s, Point32(0, 0, -1)) == COUNTER_CLOCKWISE))
     {
      start1 = e;
     }
    }
    e = e->next;
   } while (e != c1->edges);
  }

  if (start0 || start1)
  {
   findEdgeForCoplanarFaces(c0, c1, start0, start1, NULL, NULL);
   if (start0)
   {
    c0 = start0->target;
   }
   if (start1)
   {
    c1 = start1->target;
   }
  }

  prevPoint = c1->point;
  prevPoint.z++;
 }
 else
 {
  prevPoint = c1->point;
  prevPoint.x++;
 }

 Vertex* first0 = c0;
 Vertex* first1 = c1;
 bool firstRun = true;

 while (true)
 {
  Point32 s = *c1 - *c0;
  Point32 r = prevPoint - c0->point;
  Point64 rxs = r.cross(s);
  Point64 sxrxs = s.cross(rxs);

#ifdef DEBUG_CONVEX_HULL
  b3Printf("\n  Checking %d %d\n", c0->point.index, c1->point.index);
#endif
  Rational64 minCot0(0, 0);
  Edge* min0 = findMaxAngle(false, c0, s, rxs, sxrxs, minCot0);
  Rational64 minCot1(0, 0);
  Edge* min1 = findMaxAngle(true, c1, s, rxs, sxrxs, minCot1);
  if (!min0 && !min1)
  {
   Edge* e = newEdgePair(c0, c1);
   e->link(e);
   c0->edges = e;

   e = e->reverse;
   e->link(e);
   c1->edges = e;
   return;
  }
  else
  {
   int cmp = !min0 ? 1 : !min1 ? -1 : minCot0.compare(minCot1);
#ifdef DEBUG_CONVEX_HULL
   b3Printf("    -> Result %d\n", cmp);
#endif
   if (firstRun || ((cmp >= 0) ? !minCot1.isNegativeInfinity() : !minCot0.isNegativeInfinity()))
   {
    Edge* e = newEdgePair(c0, c1);
    if (pendingTail0)
    {
     pendingTail0->prev = e;
    }
    else
    {
     pendingHead0 = e;
    }
    e->next = pendingTail0;
    pendingTail0 = e;

    e = e->reverse;
    if (pendingTail1)
    {
     pendingTail1->next = e;
    }
    else
    {
     pendingHead1 = e;
    }
    e->prev = pendingTail1;
    pendingTail1 = e;
   }

   Edge* e0 = min0;
   Edge* e1 = min1;

#ifdef DEBUG_CONVEX_HULL
   b3Printf("   Found min edges to %d %d\n", e0 ? e0->target->point.index : -1, e1 ? e1->target->point.index : -1);
#endif

   if (cmp == 0)
   {
    findEdgeForCoplanarFaces(c0, c1, e0, e1, NULL, NULL);
   }

   if ((cmp >= 0) && e1)
   {
    if (toPrev1)
    {
     for (Edge* e = toPrev1->next, *n = NULL; e != min1; e = n)
     {
      n = e->next;
      removeEdgePair(e);
     }
    }

    if (pendingTail1)
    {
     if (toPrev1)
     {
      toPrev1->link(pendingHead1);
     }
     else
     {
      min1->prev->link(pendingHead1);
      firstNew1 = pendingHead1;
     }
     pendingTail1->link(min1);
     pendingHead1 = NULL;
     pendingTail1 = NULL;
    }
    else if (!toPrev1)
    {
     firstNew1 = min1;
    }

    prevPoint = c1->point;
    c1 = e1->target;
    toPrev1 = e1->reverse;
   }

   if ((cmp <= 0) && e0)
   {
    if (toPrev0)
    {
     for (Edge* e = toPrev0->prev, *n = NULL; e != min0; e = n)
     {
      n = e->prev;
      removeEdgePair(e);
     }
    }

    if (pendingTail0)
    {
     if (toPrev0)
     {
      pendingHead0->link(toPrev0);
     }
     else
     {
      pendingHead0->link(min0->next);
      firstNew0 = pendingHead0;
     }
     min0->link(pendingTail0);
     pendingHead0 = NULL;
     pendingTail0 = NULL;
    }
    else if (!toPrev0)
    {
     firstNew0 = min0;
    }

    prevPoint = c0->point;
    c0 = e0->target;
    toPrev0 = e0->reverse;
   }
  }

  if ((c0 == first0) && (c1 == first1))
  {
   if (toPrev0 == NULL)
   {
    pendingHead0->link(pendingTail0);
    c0->edges = pendingTail0;
   }
   else
   {
    for (Edge* e = toPrev0->prev, *n = NULL; e != firstNew0; e = n)
    {
     n = e->prev;
     removeEdgePair(e);
    }
    if (pendingTail0)
    {
     pendingHead0->link(toPrev0);
     firstNew0->link(pendingTail0);
    }
   }

   if (toPrev1 == NULL)
   {
    pendingTail1->link(pendingHead1);
    c1->edges = pendingTail1;
   }
   else
   {
    for (Edge* e = toPrev1->next, *n = NULL; e != firstNew1; e = n)
    {
     n = e->next;
     removeEdgePair(e);
    }
    if (pendingTail1)
    {
     toPrev1->link(pendingHead1);
     pendingTail1->link(firstNew1);
    }
   }

   return;
  }

  firstRun = false;
 }
}


static bool b3PointCmp(const b3ConvexHullInternal::Point32& p, const b3ConvexHullInternal::Point32& q)
{
 return (p.y < q.y) || ((p.y == q.y) && ((p.x < q.x) || ((p.x == q.x) && (p.z < q.z))));
}

void b3ConvexHullInternal::compute(const void* coords, bool doubleCoords, int stride, int count)
{
 b3Vector3 min = b3MakeVector3(b3Scalar(1e30), b3Scalar(1e30), b3Scalar(1e30)), max = b3MakeVector3(b3Scalar(-1e30), b3Scalar(-1e30), b3Scalar(-1e30));
 const char* ptr = (const char*)coords;
 if (doubleCoords)
 {
  for (int i = 0; i < count; i++)
  {
   const double* v = (const double*)ptr;
   b3Vector3 p = b3MakeVector3((b3Scalar)v[0], (b3Scalar)v[1], (b3Scalar)v[2]);
   ptr += stride;
   min.setMin(p);
   max.setMax(p);
  }
 }
 else
 {
  for (int i = 0; i < count; i++)
  {
   const float* v = (const float*)ptr;
   b3Vector3 p = b3MakeVector3(v[0], v[1], v[2]);
   ptr += stride;
   min.setMin(p);
   max.setMax(p);
  }
 }

 b3Vector3 s = max - min;
 maxAxis = s.maxAxis();
 minAxis = s.minAxis();
 if (minAxis == maxAxis)
 {
  minAxis = (maxAxis + 1) % 3;
 }
 medAxis = 3 - maxAxis - minAxis;

 s /= b3Scalar(10216);
 if (((medAxis + 1) % 3) != maxAxis)
 {
  s *= -1;
 }
 scaling = s;

 if (s[0] != 0)
 {
  s[0] = b3Scalar(1) / s[0];
 }
 if (s[1] != 0)
 {
  s[1] = b3Scalar(1) / s[1];
 }
 if (s[2] != 0)
 {
  s[2] = b3Scalar(1) / s[2];
 }

 center = (min + max) * b3Scalar(0.5);

 b3AlignedObjectArray<Point32> points;
 points.resize(count);
 ptr = (const char*)coords;
 if (doubleCoords)
 {
  for (int i = 0; i < count; i++)
  {
   const double* v = (const double*)ptr;
   b3Vector3 p = b3MakeVector3((b3Scalar)v[0], (b3Scalar)v[1], (b3Scalar)v[2]);
   ptr += stride;
   p = (p - center) * s;
   points[i].x = (btInt32_t)p[medAxis];
   points[i].y = (btInt32_t)p[maxAxis];
   points[i].z = (btInt32_t)p[minAxis];
   points[i].index = i;
  }
 }
 else
 {
  for (int i = 0; i < count; i++)
  {
   const float* v = (const float*)ptr;
   b3Vector3 p = b3MakeVector3(v[0], v[1], v[2]);
   ptr += stride;
   p = (p - center) * s;
   points[i].x = (btInt32_t)p[medAxis];
   points[i].y = (btInt32_t)p[maxAxis];
   points[i].z = (btInt32_t)p[minAxis];
   points[i].index = i;
  }
 }
 points.quickSort(b3PointCmp);

 vertexPool.reset();
 vertexPool.setArraySize(count);
 originalVertices.resize(count);
 for (int i = 0; i < count; i++)
 {
  Vertex* v = vertexPool.newObject();
  v->edges = NULL;
  v->point = points[i];
  v->copy = -1;
  originalVertices[i] = v;
 }

 points.clear();

 edgePool.reset();
 edgePool.setArraySize(6 * count);

 usedEdgePairs = 0;
 maxUsedEdgePairs = 0;

 mergeStamp = -3;

 IntermediateHull hull;
 computeInternal(0, count, hull);
 vertexList = hull.minXy;
#ifdef DEBUG_CONVEX_HULL
 b3Printf("max. edges %d (3v = %d)", maxUsedEdgePairs, 3 * count);
#endif
}

b3Vector3 b3ConvexHullInternal::toBtVector(const Point32& v)
{
 b3Vector3 p;
 p[medAxis] = b3Scalar(v.x);
 p[maxAxis] = b3Scalar(v.y);
 p[minAxis] = b3Scalar(v.z);
 return p * scaling;
}

b3Vector3 b3ConvexHullInternal::getBtNormal(Face* face)
{
 return toBtVector(face->dir0).cross(toBtVector(face->dir1)).normalized();
}

b3Vector3 b3ConvexHullInternal::getCoordinates(const Vertex* v)
{
 b3Vector3 p;
 p[medAxis] = v->xvalue();
 p[maxAxis] = v->yvalue();
 p[minAxis] = v->zvalue();
 return p * scaling + center;
}

b3Scalar b3ConvexHullInternal::shrink(b3Scalar amount, b3Scalar clampAmount)
{
 if (!vertexList)
 {
  return 0;
 }
 int stamp = --mergeStamp;
 b3AlignedObjectArray<Vertex*> stack;
 vertexList->copy = stamp;
 stack.push_back(vertexList);
 b3AlignedObjectArray<Face*> faces;

 Point32 ref = vertexList->point;
 Int128 hullCenterX(0, 0);
 Int128 hullCenterY(0, 0);
 Int128 hullCenterZ(0, 0);
 Int128 volume(0, 0);

 while (stack.size() > 0)
 {
  Vertex* v = stack[stack.size() - 1];
  stack.pop_back();
  Edge* e = v->edges;
  if (e)
  {
   do
   {
    if (e->target->copy != stamp)
    {
     e->target->copy = stamp;
     stack.push_back(e->target);
    }
    if (e->copy != stamp)
    {
     Face* face = facePool.newObject();
     face->init(e->target, e->reverse->prev->target, v);
     faces.push_back(face);
     Edge* f = e;

     Vertex* a = NULL;
     Vertex* b = NULL;
     do
     {
      if (a && b)
      {
       btInt64_t vol = (v->point - ref).dot((a->point - ref).cross(b->point - ref));
       b3Assert(vol >= 0);
       Point32 c = v->point + a->point + b->point + ref;
       hullCenterX += vol * c.x;
       hullCenterY += vol * c.y;
       hullCenterZ += vol * c.z;
       volume += vol;
      }

      b3Assert(f->copy != stamp);
      f->copy = stamp;
      f->face = face;

      a = b;
      b = f->target;

      f = f->reverse->prev;
     } while (f != e);
    }
    e = e->next;
   } while (e != v->edges);
  }
 }

 if (volume.getSign() <= 0)
 {
  return 0;
 }

 b3Vector3 hullCenter;
 hullCenter[medAxis] = hullCenterX.toScalar();
 hullCenter[maxAxis] = hullCenterY.toScalar();
 hullCenter[minAxis] = hullCenterZ.toScalar();
 hullCenter /= 4 * volume.toScalar();
 hullCenter *= scaling;

 int faceCount = faces.size();

 if (clampAmount > 0)
 {
  b3Scalar minDist = B3_INFINITY;
  for (int i = 0; i < faceCount; i++)
  {
   b3Vector3 normal = getBtNormal(faces[i]);
   b3Scalar dist = normal.dot(toBtVector(faces[i]->origin) - hullCenter);
   if (dist < minDist)
   {
    minDist = dist;
   }
  }

  if (minDist <= 0)
  {
   return 0;
  }

  amount = b3Min(amount, minDist * clampAmount);
 }

 unsigned int seed = 243703;
 for (int i = 0; i < faceCount; i++, seed = 1664525 * seed + 1013904223)
 {
  b3Swap(faces[i], faces[seed % faceCount]);
 }

 for (int i = 0; i < faceCount; i++)
 {
  if (!shiftFace(faces[i], amount, stack))
  {
   return -amount;
  }
 }

 return amount;
}

bool b3ConvexHullInternal::shiftFace(Face* face, b3Scalar amount, b3AlignedObjectArray<Vertex*> stack)
{
 b3Vector3 origShift = getBtNormal(face) * -amount;
 if (scaling[0] != 0)
 {
  origShift[0] /= scaling[0];
 }
 if (scaling[1] != 0)
 {
  origShift[1] /= scaling[1];
 }
 if (scaling[2] != 0)
 {
  origShift[2] /= scaling[2];
 }
 Point32 shift((btInt32_t)origShift[medAxis], (btInt32_t)origShift[maxAxis], (btInt32_t)origShift[minAxis]);
 if (shift.isZero())
 {
  return true;
 }
 Point64 normal = face->getNormal();
#ifdef DEBUG_CONVEX_HULL
 b3Printf("\nShrinking face (%d %d %d) (%d %d %d) (%d %d %d) by (%d %d %d)\n",
  face->origin.x, face->origin.y, face->origin.z, face->dir0.x, face->dir0.y, face->dir0.z, face->dir1.x, face->dir1.y, face->dir1.z, shift.x, shift.y, shift.z);
#endif
 btInt64_t origDot = face->origin.dot(normal);
 Point32 shiftedOrigin = face->origin + shift;
 btInt64_t shiftedDot = shiftedOrigin.dot(normal);
 b3Assert(shiftedDot <= origDot);
 if (shiftedDot >= origDot)
 {
  return false;
 }

 Edge* intersection = NULL;

 Edge* startEdge = face->nearbyVertex->edges;
#ifdef DEBUG_CONVEX_HULL
 b3Printf("Start edge is ");
 startEdge->print();
 b3Printf(", normal is (%lld %lld %lld), shifted dot is %lld\n", normal.x, normal.y, normal.z, shiftedDot);
#endif
 Rational128 optDot = face->nearbyVertex->dot(normal);
 int cmp = optDot.compare(shiftedDot);
#ifdef SHOW_ITERATIONS
 int n = 0;
#endif
 if (cmp >= 0)
 {
  Edge* e = startEdge;
  do
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   Rational128 dot = e->target->dot(normal);
   b3Assert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
   b3Printf("Moving downwards, edge is ");
   e->print();
   b3Printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
   if (dot.compare(optDot) < 0)
   {
    int c = dot.compare(shiftedDot);
    optDot = dot;
    e = e->reverse;
    startEdge = e;
    if (c < 0)
    {
     intersection = e;
     break;
    }
    cmp = c;
   }
   e = e->prev;
  } while (e != startEdge);

  if (!intersection)
  {
   return false;
  }
 }
 else
 {
  Edge* e = startEdge;
  do
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   Rational128 dot = e->target->dot(normal);
   b3Assert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
   b3Printf("Moving upwards, edge is ");
   e->print();
   b3Printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
   if (dot.compare(optDot) > 0)
   {
    cmp = dot.compare(shiftedDot);
    if (cmp >= 0)
    {
     intersection = e;
     break;
    }
    optDot = dot;
    e = e->reverse;
    startEdge = e;
   }
   e = e->prev;
  } while (e != startEdge);

  if (!intersection)
  {
   return true;
  }
 }

#ifdef SHOW_ITERATIONS
 b3Printf("Needed %d iterations to find initial intersection\n", n);
#endif

 if (cmp == 0)
 {
  Edge* e = intersection->reverse->next;
#ifdef SHOW_ITERATIONS
  n = 0;
#endif
  while (e->target->dot(normal).compare(shiftedDot) <= 0)
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   e = e->next;
   if (e == intersection->reverse)
   {
    return true;
   }
#ifdef DEBUG_CONVEX_HULL
   b3Printf("Checking for outwards edge, current edge is ");
   e->print();
   b3Printf("\n");
#endif
  }
#ifdef SHOW_ITERATIONS
  b3Printf("Needed %d iterations to check for complete containment\n", n);
#endif
 }

 Edge* firstIntersection = NULL;
 Edge* faceEdge = NULL;
 Edge* firstFaceEdge = NULL;

#ifdef SHOW_ITERATIONS
 int m = 0;
#endif
 while (true)
 {
#ifdef SHOW_ITERATIONS
  m++;
#endif
#ifdef DEBUG_CONVEX_HULL
  b3Printf("Intersecting edge is ");
  intersection->print();
  b3Printf("\n");
#endif
  if (cmp == 0)
  {
   Edge* e = intersection->reverse->next;
   startEdge = e;
#ifdef SHOW_ITERATIONS
   n = 0;
#endif
   while (true)
   {
#ifdef SHOW_ITERATIONS
    n++;
#endif
    if (e->target->dot(normal).compare(shiftedDot) >= 0)
    {
     break;
    }
    intersection = e->reverse;
    e = e->next;
    if (e == startEdge)
    {
     return true;
    }
   }
#ifdef SHOW_ITERATIONS
   b3Printf("Needed %d iterations to advance intersection\n", n);
#endif
  }

#ifdef DEBUG_CONVEX_HULL
  b3Printf("Advanced intersecting edge to ");
  intersection->print();
  b3Printf(", cmp = %d\n", cmp);
#endif

  if (!firstIntersection)
  {
   firstIntersection = intersection;
  }
  else if (intersection == firstIntersection)
  {
   break;
  }

  int prevCmp = cmp;
  Edge* prevIntersection = intersection;
  Edge* prevFaceEdge = faceEdge;

  Edge* e = intersection->reverse;
#ifdef SHOW_ITERATIONS
  n = 0;
#endif
  while (true)
  {
#ifdef SHOW_ITERATIONS
   n++;
#endif
   e = e->reverse->prev;
   b3Assert(e != intersection->reverse);
   cmp = e->target->dot(normal).compare(shiftedDot);
#ifdef DEBUG_CONVEX_HULL
   b3Printf("Testing edge ");
   e->print();
   b3Printf(" -> cmp = %d\n", cmp);
#endif
   if (cmp >= 0)
   {
    intersection = e;
    break;
   }
  }
#ifdef SHOW_ITERATIONS
  b3Printf("Needed %d iterations to find other intersection of face\n", n);
#endif

  if (cmp > 0)
  {
   Vertex* removed = intersection->target;
   e = intersection->reverse;
   if (e->prev == e)
   {
    removed->edges = NULL;
   }
   else
   {
    removed->edges = e->prev;
    e->prev->link(e->next);
    e->link(e);
   }
#ifdef DEBUG_CONVEX_HULL
   b3Printf("1: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif

   Point64 n0 = intersection->face->getNormal();
   Point64 n1 = intersection->reverse->face->getNormal();
   btInt64_t m00 = face->dir0.dot(n0);
   btInt64_t m01 = face->dir1.dot(n0);
   btInt64_t m10 = face->dir0.dot(n1);
   btInt64_t m11 = face->dir1.dot(n1);
   btInt64_t r0 = (intersection->face->origin - shiftedOrigin).dot(n0);
   btInt64_t r1 = (intersection->reverse->face->origin - shiftedOrigin).dot(n1);
   Int128 det = Int128::mul(m00, m11) - Int128::mul(m01, m10);
   b3Assert(det.getSign() != 0);
   Vertex* v = vertexPool.newObject();
   v->point.index = -1;
   v->copy = -1;
   v->point128 = PointR128(Int128::mul(face->dir0.x * r0, m11) - Int128::mul(face->dir0.x * r1, m01)
    + Int128::mul(face->dir1.x * r1, m00) - Int128::mul(face->dir1.x * r0, m10) + det * shiftedOrigin.x,
    Int128::mul(face->dir0.y * r0, m11) - Int128::mul(face->dir0.y * r1, m01)
    + Int128::mul(face->dir1.y * r1, m00) - Int128::mul(face->dir1.y * r0, m10) + det * shiftedOrigin.y,
    Int128::mul(face->dir0.z * r0, m11) - Int128::mul(face->dir0.z * r1, m01)
    + Int128::mul(face->dir1.z * r1, m00) - Int128::mul(face->dir1.z * r0, m10) + det * shiftedOrigin.z,
    det);
   v->point.x = (btInt32_t)v->point128.xvalue();
   v->point.y = (btInt32_t)v->point128.yvalue();
   v->point.z = (btInt32_t)v->point128.zvalue();
   intersection->target = v;
   v->edges = e;

   stack.push_back(v);
   stack.push_back(removed);
   stack.push_back(NULL);
  }

  if (cmp || prevCmp || (prevIntersection->reverse->next->target != intersection->target))
  {
   faceEdge = newEdgePair(prevIntersection->target, intersection->target);
   if (prevCmp == 0)
   {
    faceEdge->link(prevIntersection->reverse->next);
   }
   if ((prevCmp == 0) || prevFaceEdge)
   {
    prevIntersection->reverse->link(faceEdge);
   }
   if (cmp == 0)
   {
    intersection->reverse->prev->link(faceEdge->reverse);
   }
   faceEdge->reverse->link(intersection->reverse);
  }
  else
  {
   faceEdge = prevIntersection->reverse->next;
  }

  if (prevFaceEdge)
  {
   if (prevCmp > 0)
   {
    faceEdge->link(prevFaceEdge->reverse);
   }
   else if (faceEdge != prevFaceEdge->reverse)
   {
    stack.push_back(prevFaceEdge->target);
    while (faceEdge->next != prevFaceEdge->reverse)
    {
     Vertex* removed = faceEdge->next->target;
     removeEdgePair(faceEdge->next);
     stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
     b3Printf("2: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
    }
    stack.push_back(NULL);
   }
  }
  faceEdge->face = face;
  faceEdge->reverse->face = intersection->face;

  if (!firstFaceEdge)
  {
   firstFaceEdge = faceEdge;
  }
 }
#ifdef SHOW_ITERATIONS
 b3Printf("Needed %d iterations to process all intersections\n", m);
#endif

 if (cmp > 0)
 {
  firstFaceEdge->reverse->target = faceEdge->target;
  firstIntersection->reverse->link(firstFaceEdge);
  firstFaceEdge->link(faceEdge->reverse);
 }
 else if (firstFaceEdge != faceEdge->reverse)
 {
  stack.push_back(faceEdge->target);
  while (firstFaceEdge->next != faceEdge->reverse)
  {
   Vertex* removed = firstFaceEdge->next->target;
   removeEdgePair(firstFaceEdge->next);
   stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
   b3Printf("3: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
  }
  stack.push_back(NULL);
 }

 b3Assert(stack.size() > 0);
 vertexList = stack[0];

#ifdef DEBUG_CONVEX_HULL
 b3Printf("Removing part\n");
#endif
#ifdef SHOW_ITERATIONS
 n = 0;
#endif
 int pos = 0;
 while (pos < stack.size())
 {
  int end = stack.size();
  while (pos < end)
  {
   Vertex* kept = stack[pos++];
#ifdef DEBUG_CONVEX_HULL
   kept->print();
#endif
   bool deeper = false;
   Vertex* removed;
   while ((removed = stack[pos++]) != NULL)
   {
#ifdef SHOW_ITERATIONS
    n++;
#endif
    kept->receiveNearbyFaces(removed);
    while (removed->edges)
    {
     if (!deeper)
     {
      deeper = true;
      stack.push_back(kept);
     }
     stack.push_back(removed->edges->target);
     removeEdgePair(removed->edges);
    }
   }
   if (deeper)
   {
    stack.push_back(NULL);
   }
  }
 }
#ifdef SHOW_ITERATIONS
 b3Printf("Needed %d iterations to remove part\n", n);
#endif

 stack.resize(0);
 face->origin = shiftedOrigin;

 return true;
}


static int getVertexCopy(b3ConvexHullInternal::Vertex* vertex, b3AlignedObjectArray<b3ConvexHullInternal::Vertex*>& vertices)
{
 int index = vertex->copy;
 if (index < 0)
 {
  index = vertices.size();
  vertex->copy = index;
  vertices.push_back(vertex);
#ifdef DEBUG_CONVEX_HULL
  b3Printf("Vertex %d gets index *%d\n", vertex->point.index, index);
#endif
 }
 return index;
}

b3Scalar b3ConvexHullComputer::compute(const void* coords, bool doubleCoords, int stride, int count, b3Scalar shrink, b3Scalar shrinkClamp)
{
 if (count <= 0)
 {
  vertices.clear();
  edges.clear();
  faces.clear();
  return 0;
 }

 b3ConvexHullInternal hull;
 hull.compute(coords, doubleCoords, stride, count);

 b3Scalar shift = 0;
 if ((shrink > 0) && ((shift = hull.shrink(shrink, shrinkClamp)) < 0))
 {
  vertices.clear();
  edges.clear();
  faces.clear();
  return shift;
 }

 vertices.resize(0);
 edges.resize(0);
 faces.resize(0);

 b3AlignedObjectArray<b3ConvexHullInternal::Vertex*> oldVertices;
 getVertexCopy(hull.vertexList, oldVertices);
 int copied = 0;
 while (copied < oldVertices.size())
 {
  b3ConvexHullInternal::Vertex* v = oldVertices[copied];
  vertices.push_back(hull.getCoordinates(v));
  b3ConvexHullInternal::Edge* firstEdge = v->edges;
  if (firstEdge)
  {
   int firstCopy = -1;
   int prevCopy = -1;
   b3ConvexHullInternal::Edge* e = firstEdge;
   do
   {
    if (e->copy < 0)
    {
     int s = edges.size();
     edges.push_back(Edge());
     edges.push_back(Edge());
     Edge* c = &edges[s];
     Edge* r = &edges[s + 1];
     e->copy = s;
     e->reverse->copy = s + 1;
     c->reverse = 1;
     r->reverse = -1;
     c->targetVertex = getVertexCopy(e->target, oldVertices);
     r->targetVertex = copied;
#ifdef DEBUG_CONVEX_HULL
     b3Printf("      CREATE: Vertex *%d has edge to *%d\n", copied, c->getTargetVertex());
#endif
    }
    if (prevCopy >= 0)
    {
     edges[e->copy].next = prevCopy - e->copy;
    }
    else
    {
     firstCopy = e->copy;
    }
    prevCopy = e->copy;
    e = e->next;
   } while (e != firstEdge);
   edges[firstCopy].next = prevCopy - firstCopy;
  }
  copied++;
 }

 for (int i = 0; i < copied; i++)
 {
  b3ConvexHullInternal::Vertex* v = oldVertices[i];
  b3ConvexHullInternal::Edge* firstEdge = v->edges;
  if (firstEdge)
  {
   b3ConvexHullInternal::Edge* e = firstEdge;
   do
   {
    if (e->copy >= 0)
    {
#ifdef DEBUG_CONVEX_HULL
     b3Printf("Vertex *%d has edge to *%d\n", i, edges[e->copy].getTargetVertex());
#endif
     faces.push_back(e->copy);
     b3ConvexHullInternal::Edge* f = e;
     do
     {
#ifdef DEBUG_CONVEX_HULL
      b3Printf("   Face *%d\n", edges[f->copy].getTargetVertex());
#endif
      f->copy = -1;
      f = f->reverse->prev;
     } while (f != e);
    }
    e = e->next;
   } while (e != firstEdge);
  }
 }

 return shift;
}

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "Bullet3Geometry/b3GeometryUtil.h"


/*
Make sure this dummy function never changes so that it
can be used by probes that are checking whether the
library is actually installed.
*/
extern "C"
{
 void b3BulletMathProbe();

 void b3BulletMathProbe() {}
}


bool	b3GeometryUtil::isPointInsidePlanes(const b3AlignedObjectArray<b3Vector3>& planeEquations, const b3Vector3& point, b3Scalar	margin)
{
 int numbrushes = planeEquations.size();
 for (int i = 0; i<numbrushes; i++)
 {
  const b3Vector3& N1 = planeEquations[i];
  b3Scalar dist = b3Scalar(N1.dot(point)) + b3Scalar(N1[3]) - margin;
  if (dist>b3Scalar(0.))
  {
   return false;
  }
 }
 return true;

}


bool	b3GeometryUtil::areVerticesBehindPlane(const b3Vector3& planeNormal, const b3AlignedObjectArray<b3Vector3>& vertices, b3Scalar	margin)
{
 int numvertices = vertices.size();
 for (int i = 0; i<numvertices; i++)
 {
  const b3Vector3& N1 = vertices[i];
  b3Scalar dist = b3Scalar(planeNormal.dot(N1)) + b3Scalar(planeNormal[3]) - margin;
  if (dist>b3Scalar(0.))
  {
   return false;
  }
 }
 return true;
}

bool notExist(const b3Vector3& planeEquation, const b3AlignedObjectArray<b3Vector3>& planeEquations);

bool notExist(const b3Vector3& planeEquation, const b3AlignedObjectArray<b3Vector3>& planeEquations)
{
 int numbrushes = planeEquations.size();
 for (int i = 0; i<numbrushes; i++)
 {
  const b3Vector3& N1 = planeEquations[i];
  if (planeEquation.dot(N1) > b3Scalar(0.999))
  {
   return false;
  }
 }
 return true;
}

void	b3GeometryUtil::getPlaneEquationsFromVertices(b3AlignedObjectArray<b3Vector3>& vertices, b3AlignedObjectArray<b3Vector3>& planeEquationsOut)
{
 const int numvertices = vertices.size();
 // brute force:
 for (int i = 0; i<numvertices; i++)
 {
  const b3Vector3& N1 = vertices[i];


  for (int j = i + 1; j<numvertices; j++)
  {
   const b3Vector3& N2 = vertices[j];

   for (int k = j + 1; k<numvertices; k++)
   {

    const b3Vector3& N3 = vertices[k];

    b3Vector3 planeEquation, edge0, edge1;
    edge0 = N2 - N1;
    edge1 = N3 - N1;
    b3Scalar normalSign = b3Scalar(1.);
    for (int ww = 0; ww<2; ww++)
    {
     planeEquation = normalSign * edge0.cross(edge1);
     if (planeEquation.length2() > b3Scalar(0.0001))
     {
      planeEquation.normalize();
      if (notExist(planeEquation, planeEquationsOut))
      {
       planeEquation[3] = -planeEquation.dot(N1);

       //check if inside, and replace supportingVertexOut if needed
       if (areVerticesBehindPlane(planeEquation, vertices, b3Scalar(0.01)))
       {
        planeEquationsOut.push_back(planeEquation);
       }
      }
     }
     normalSign = b3Scalar(-1.);
    }

   }
  }
 }

}

void	b3GeometryUtil::getVerticesFromPlaneEquations(const b3AlignedObjectArray<b3Vector3>& planeEquations, b3AlignedObjectArray<b3Vector3>& verticesOut)
{
 const int numbrushes = planeEquations.size();
 // brute force:
 for (int i = 0; i<numbrushes; i++)
 {
  const b3Vector3& N1 = planeEquations[i];


  for (int j = i + 1; j<numbrushes; j++)
  {
   const b3Vector3& N2 = planeEquations[j];

   for (int k = j + 1; k<numbrushes; k++)
   {

    const b3Vector3& N3 = planeEquations[k];

    b3Vector3 n2n3; n2n3 = N2.cross(N3);
    b3Vector3 n3n1; n3n1 = N3.cross(N1);
    b3Vector3 n1n2; n1n2 = N1.cross(N2);

    if ((n2n3.length2() > b3Scalar(0.0001)) &&
     (n3n1.length2() > b3Scalar(0.0001)) &&
     (n1n2.length2() > b3Scalar(0.0001)))
    {
     //point P out of 3 plane equations:

     //	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )  
     //P =  -------------------------------------------------------------------------  
     //   N1 . ( N2 * N3 )  


     b3Scalar quotient = (N1.dot(n2n3));
     if (b3Fabs(quotient) > b3Scalar(0.000001))
     {
      quotient = b3Scalar(-1.) / quotient;
      n2n3 *= N1[3];
      n3n1 *= N2[3];
      n1n2 *= N3[3];
      b3Vector3 potentialVertex = n2n3;
      potentialVertex += n3n1;
      potentialVertex += n1n2;
      potentialVertex *= quotient;

      //check if inside, and replace supportingVertexOut if needed
      if (isPointInsidePlanes(planeEquations, potentialVertex, b3Scalar(0.01)))
      {
       verticesOut.push_back(potentialVertex);
      }
     }
    }
   }
  }
 }
}

//Bullet Continuous Collision Detection and Physics Library
//Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/


//
// btAxisSweep3
//
// Copyright (c) 2006 Simon Hobbs
//
// This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
#include "BulletCollision/BroadphaseCollision/btAxisSweep3.h"


btAxisSweep3::btAxisSweep3(const btVector3& worldAabbMin, const btVector3& worldAabbMax, unsigned short int maxHandles, btOverlappingPairCache* pairCache, bool disableRaycastAccelerator)
 :btAxisSweep3Internal<unsigned short int>(worldAabbMin, worldAabbMax, 0xfffe, 0xffff, maxHandles, pairCache, disableRaycastAccelerator)
{
 // 1 handle is reserved as sentinel
 btAssert(maxHandles > 1 && maxHandles < 32767);

}


bt32BitAxisSweep3::bt32BitAxisSweep3(const btVector3& worldAabbMin, const btVector3& worldAabbMax, unsigned int maxHandles, btOverlappingPairCache* pairCache, bool disableRaycastAccelerator)
 :btAxisSweep3Internal<unsigned int>(worldAabbMin, worldAabbMax, 0xfffffffe, 0x7fffffff, maxHandles, pairCache, disableRaycastAccelerator)
{
 // 1 handle is reserved as sentinel
 btAssert(maxHandles > 1 && maxHandles < 2147483647);
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

BT_NOT_EMPTY_FILE // fix warning LNK4221: This object file does not define any previously undefined public symbols, so it will not be used by any link operation that consumes this library 

                  /*
                  Bullet Continuous Collision Detection and Physics Library
                  Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

                  This software is provided 'as-is', without any express or implied warranty.
                  In no event will the authors be held liable for any damages arising from the use of this software.
                  Permission is granted to anyone to use this software for any purpose,
                  including commercial applications, and to alter it and redistribute it freely,
                  subject to the following restrictions:

                  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
                  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
                  3. This notice may not be removed or altered from any source distribution.
                  */

#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"

 btCollisionAlgorithm::btCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci)
{
 m_dispatcher = ci.m_dispatcher1;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
///btDbvt implementation by Nathanael Presson

#include "BulletCollision/BroadphaseCollision/btDbvt.h"

//
typedef btAlignedObjectArray<btDbvtNode*>			tNodeArray;
typedef btAlignedObjectArray<const btDbvtNode*>	tConstNodeArray;

//
struct btDbvtNodeEnumerator : btDbvt::ICollide
{
 tConstNodeArray	nodes;
 void Process(const btDbvtNode* n) { nodes.push_back(n); }
};

//
static DBVT_INLINE int			indexof(const btDbvtNode* node)
{
 return(node->parent->childs[1] == node);
}

//
static DBVT_INLINE btDbvtVolume	merge(const btDbvtVolume& a,
 const btDbvtVolume& b)
{
#if (DBVT_MERGE_IMPL==DBVT_IMPL_SSE)
 ATTRIBUTE_ALIGNED16(char locals[sizeof(btDbvtAabbMm)]);
 btDbvtVolume* ptr = (btDbvtVolume*)locals;
 btDbvtVolume&	res = *ptr;
#else
 btDbvtVolume	res;
#endif
 Merge(a, b, res);
 return(res);
}

// volume+edge lengths
static DBVT_INLINE btScalar		size(const btDbvtVolume& a)
{
 const btVector3	edges = a.Lengths();
 return(edges.x()*edges.y()*edges.z() +
  edges.x() + edges.y() + edges.z());
}

//
static void						getmaxdepth(const btDbvtNode* node, int depth, int& maxdepth)
{
 if (node->isinternal())
 {
  getmaxdepth(node->childs[0], depth + 1, maxdepth);
  getmaxdepth(node->childs[1], depth + 1, maxdepth);
 }
 else maxdepth = btMax(maxdepth, depth);
}

//
static DBVT_INLINE void			deletenode(btDbvt* pdbvt,
 btDbvtNode* node)
{
 btAlignedFree(pdbvt->m_free);
 pdbvt->m_free = node;
}

//
static void						recursedeletenode(btDbvt* pdbvt,
 btDbvtNode* node)
{
 if (!node->isleaf())
 {
  recursedeletenode(pdbvt, node->childs[0]);
  recursedeletenode(pdbvt, node->childs[1]);
 }
 if (node == pdbvt->m_root) pdbvt->m_root = 0;
 deletenode(pdbvt, node);
}

//
static DBVT_INLINE btDbvtNode*	createnode(btDbvt* pdbvt,
 btDbvtNode* parent,
 void* data)
{
 btDbvtNode*	node;
 if (pdbvt->m_free)
 {
  node = pdbvt->m_free; pdbvt->m_free = 0;
 }
 else
 {
  node = new(btAlignedAlloc(sizeof(btDbvtNode), 16)) btDbvtNode();
 }
 node->parent = parent;
 node->data = data;
 node->childs[1] = 0;
 return(node);
}

//
static DBVT_INLINE btDbvtNode*	createnode(btDbvt* pdbvt,
 btDbvtNode* parent,
 const btDbvtVolume& volume,
 void* data)
{
 btDbvtNode*	node = createnode(pdbvt, parent, data);
 node->volume = volume;
 return(node);
}

//
static DBVT_INLINE btDbvtNode*	createnode(btDbvt* pdbvt,
 btDbvtNode* parent,
 const btDbvtVolume& volume0,
 const btDbvtVolume& volume1,
 void* data)
{
 btDbvtNode*	node = createnode(pdbvt, parent, data);
 Merge(volume0, volume1, node->volume);
 return(node);
}

//
static void						insertleaf(btDbvt* pdbvt,
 btDbvtNode* root,
 btDbvtNode* leaf)
{
 if (!pdbvt->m_root)
 {
  pdbvt->m_root = leaf;
  leaf->parent = 0;
 }
 else
 {
  if (!root->isleaf())
  {
   do {
    root = root->childs[Select(leaf->volume,
     root->childs[0]->volume,
     root->childs[1]->volume)];
   } while (!root->isleaf());
  }
  btDbvtNode*	prev = root->parent;
  btDbvtNode*	node = createnode(pdbvt, prev, leaf->volume, root->volume, 0);
  if (prev)
  {
   prev->childs[indexof(root)] = node;
   node->childs[0] = root; root->parent = node;
   node->childs[1] = leaf; leaf->parent = node;
   do {
    if (!prev->volume.Contain(node->volume))
     Merge(prev->childs[0]->volume, prev->childs[1]->volume, prev->volume);
    else
     break;
    node = prev;
   } while (0 != (prev = node->parent));
  }
  else
  {
   node->childs[0] = root; root->parent = node;
   node->childs[1] = leaf; leaf->parent = node;
   pdbvt->m_root = node;
  }
 }
}

//
static btDbvtNode*				removeleaf(btDbvt* pdbvt,
 btDbvtNode* leaf)
{
 if (leaf == pdbvt->m_root)
 {
  pdbvt->m_root = 0;
  return(0);
 }
 else
 {
  btDbvtNode*	parent = leaf->parent;
  btDbvtNode*	prev = parent->parent;
  btDbvtNode*	sibling = parent->childs[1 - indexof(leaf)];
  if (prev)
  {
   prev->childs[indexof(parent)] = sibling;
   sibling->parent = prev;
   deletenode(pdbvt, parent);
   while (prev)
   {
    const btDbvtVolume	pb = prev->volume;
    Merge(prev->childs[0]->volume, prev->childs[1]->volume, prev->volume);
    if (NotEqual(pb, prev->volume))
    {
     prev = prev->parent;
    }
    else break;
   }
   return(prev ? prev : pdbvt->m_root);
  }
  else
  {
   pdbvt->m_root = sibling;
   sibling->parent = 0;
   deletenode(pdbvt, parent);
   return(pdbvt->m_root);
  }
 }
}

//
static void						fetchleaves(btDbvt* pdbvt,
 btDbvtNode* root,
 tNodeArray& leaves,
 int depth = -1)
{
 if (root->isinternal() && depth)
 {
  fetchleaves(pdbvt, root->childs[0], leaves, depth - 1);
  fetchleaves(pdbvt, root->childs[1], leaves, depth - 1);
  deletenode(pdbvt, root);
 }
 else
 {
  leaves.push_back(root);
 }
}

//
static bool						leftOfAxis(const btDbvtNode* node,
 const btVector3& org,
 const btVector3& axis)
{
 return btDot(axis, node->volume.Center() - org) <= 0;
}


// Partitions leaves such that leaves[0, n) are on the
// left of axis, and leaves[n, count) are on the right
// of axis. returns N.
static int						split(btDbvtNode** leaves,
 int count,
 const btVector3& org,
 const btVector3& axis)
{
 int begin = 0;
 int end = count;
 for (;;)
 {
  while (begin != end && leftOfAxis(leaves[begin], org, axis))
  {
   ++begin;
  }

  if (begin == end)
  {
   break;
  }

  while (begin != end && !leftOfAxis(leaves[end - 1], org, axis))
  {
   --end;
  }

  if (begin == end)
  {
   break;
  }

  // swap out of place nodes
  --end;
  btDbvtNode* temp = leaves[begin];
  leaves[begin] = leaves[end];
  leaves[end] = temp;
  ++begin;
 }

 return begin;
}

//
static btDbvtVolume				bounds(btDbvtNode** leaves,
 int count)
{
#if DBVT_MERGE_IMPL==DBVT_IMPL_SSE
 ATTRIBUTE_ALIGNED16(char	locals[sizeof(btDbvtVolume)]);
 btDbvtVolume* ptr = (btDbvtVolume*)locals;
 btDbvtVolume&	volume = *ptr;
 volume = leaves[0]->volume;
#else
 btDbvtVolume volume = leaves[0]->volume;
#endif
 for (int i = 1, ni = count; i<ni; ++i)
 {
  Merge(volume, leaves[i]->volume, volume);
 }
 return(volume);
}

//
static void						bottomup(btDbvt* pdbvt,
 btDbvtNode** leaves,
 int count)
{
 while (count>1)
 {
  btScalar	minsize = SIMD_INFINITY;
  int			minidx[2] = { -1,-1 };
  for (int i = 0; i<count; ++i)
  {
   for (int j = i + 1; j<count; ++j)
   {
    const btScalar	sz = size(merge(leaves[i]->volume, leaves[j]->volume));
    if (sz<minsize)
    {
     minsize = sz;
     minidx[0] = i;
     minidx[1] = j;
    }
   }
  }
  btDbvtNode*	n[] = { leaves[minidx[0]],leaves[minidx[1]] };
  btDbvtNode*	p = createnode(pdbvt, 0, n[0]->volume, n[1]->volume, 0);
  p->childs[0] = n[0];
  p->childs[1] = n[1];
  n[0]->parent = p;
  n[1]->parent = p;
  leaves[minidx[0]] = p;
  leaves[minidx[1]] = leaves[count - 1];
  --count;
 }
}

//
static btDbvtNode*			topdown(btDbvt* pdbvt,
 btDbvtNode** leaves,
 int count,
 int bu_treshold)
{
 static const btVector3	axis[] = { btVector3(1,0,0),
  btVector3(0,1,0),
  btVector3(0,0,1) };
 btAssert(bu_treshold>2);
 if (count>1)
 {
  if (count>bu_treshold)
  {
   const btDbvtVolume	vol = bounds(leaves, count);
   const btVector3			org = vol.Center();
   int						partition;
   int						bestaxis = -1;
   int						bestmidp = count;
   int						splitcount[3][2] = { { 0,0 },{ 0,0 },{ 0,0 } };
   int i;
   for (i = 0; i<count; ++i)
   {
    const btVector3	x = leaves[i]->volume.Center() - org;
    for (int j = 0; j<3; ++j)
    {
     ++splitcount[j][btDot(x, axis[j])>0 ? 1 : 0];
    }
   }
   for (i = 0; i<3; ++i)
   {
    if ((splitcount[i][0]>0) && (splitcount[i][1]>0))
    {
     const int	midp = (int)btFabs(btScalar(splitcount[i][0] - splitcount[i][1]));
     if (midp<bestmidp)
     {
      bestaxis = i;
      bestmidp = midp;
     }
    }
   }
   if (bestaxis >= 0)
   {
    partition = split(leaves, count, org, axis[bestaxis]);
    btAssert(partition != 0 && partition != count);
   }
   else
   {
    partition = count / 2 + 1;
   }
   btDbvtNode*	node = createnode(pdbvt, 0, vol, 0);
   node->childs[0] = topdown(pdbvt, &leaves[0], partition, bu_treshold);
   node->childs[1] = topdown(pdbvt, &leaves[partition], count - partition, bu_treshold);
   node->childs[0]->parent = node;
   node->childs[1]->parent = node;
   return(node);
  }
  else
  {
   bottomup(pdbvt, leaves, count);
   return(leaves[0]);
  }
 }
 return(leaves[0]);
}

//
static DBVT_INLINE btDbvtNode*	sort(btDbvtNode* n, btDbvtNode*& r)
{
 btDbvtNode*	p = n->parent;
 btAssert(n->isinternal());
 if (p>n)
 {
  const int		i = indexof(n);
  const int		j = 1 - i;
  btDbvtNode*	s = p->childs[j];
  btDbvtNode*	q = p->parent;
  btAssert(n == p->childs[i]);
  if (q) q->childs[indexof(p)] = n; else r = n;
  s->parent = n;
  p->parent = n;
  n->parent = q;
  p->childs[0] = n->childs[0];
  p->childs[1] = n->childs[1];
  n->childs[0]->parent = p;
  n->childs[1]->parent = p;
  n->childs[i] = p;
  n->childs[j] = s;
  btSwap(p->volume, n->volume);
  return(p);
 }
 return(n);
}

#if 0
static DBVT_INLINE btDbvtNode*	walkup(btDbvtNode* n, int count)
{
 while (n && (count--)) n = n->parent;
 return(n);
}
#endif

//
// Api
//

//
btDbvt::btDbvt()
{
 m_root = 0;
 m_free = 0;
 m_lkhd = -1;
 m_leaves = 0;
 m_opath = 0;
}

//
btDbvt::~btDbvt()
{
 clear();
}

//
void			btDbvt::clear()
{
 if (m_root)
  recursedeletenode(this, m_root);
 btAlignedFree(m_free);
 m_free = 0;
 m_lkhd = -1;
 m_stkStack.clear();
 m_opath = 0;

}

//
void			btDbvt::optimizeBottomUp()
{
 if (m_root)
 {
  tNodeArray leaves;
  leaves.reserve(m_leaves);
  fetchleaves(this, m_root, leaves);
  bottomup(this, &leaves[0], leaves.size());
  m_root = leaves[0];
 }
}

//
void			btDbvt::optimizeTopDown(int bu_treshold)
{
 if (m_root)
 {
  tNodeArray	leaves;
  leaves.reserve(m_leaves);
  fetchleaves(this, m_root, leaves);
  m_root = topdown(this, &leaves[0], leaves.size(), bu_treshold);
 }
}

//
void			btDbvt::optimizeIncremental(int passes)
{
 if (passes<0) passes = m_leaves;
 if (m_root && (passes>0))
 {
  do {
   btDbvtNode*		node = m_root;
   unsigned	bit = 0;
   while (node->isinternal())
   {
    node = sort(node, m_root)->childs[(m_opath >> bit) & 1];
    bit = (bit + 1)&(sizeof(unsigned) * 8 - 1);
   }
   update(node);
   ++m_opath;
  } while (--passes);
 }
}

//
btDbvtNode*	btDbvt::insert(const btDbvtVolume& volume, void* data)
{
 btDbvtNode*	leaf = createnode(this, 0, volume, data);
 insertleaf(this, m_root, leaf);
 ++m_leaves;
 return(leaf);
}

//
void			btDbvt::update(btDbvtNode* leaf, int lookahead)
{
 btDbvtNode*	root = removeleaf(this, leaf);
 if (root)
 {
  if (lookahead >= 0)
  {
   for (int i = 0; (i<lookahead) && root->parent; ++i)
   {
    root = root->parent;
   }
  }
  else root = m_root;
 }
 insertleaf(this, root, leaf);
}

//
void			btDbvt::update(btDbvtNode* leaf, btDbvtVolume& volume)
{
 btDbvtNode*	root = removeleaf(this, leaf);
 if (root)
 {
  if (m_lkhd >= 0)
  {
   for (int i = 0; (i<m_lkhd) && root->parent; ++i)
   {
    root = root->parent;
   }
  }
  else root = m_root;
 }
 leaf->volume = volume;
 insertleaf(this, root, leaf);
}

//
bool			btDbvt::update(btDbvtNode* leaf, btDbvtVolume& volume, const btVector3& velocity, btScalar margin)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.Expand(btVector3(margin, margin, margin));
 volume.SignedExpand(velocity);
 update(leaf, volume);
 return(true);
}

//
bool			btDbvt::update(btDbvtNode* leaf, btDbvtVolume& volume, const btVector3& velocity)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.SignedExpand(velocity);
 update(leaf, volume);
 return(true);
}

//
bool			btDbvt::update(btDbvtNode* leaf, btDbvtVolume& volume, btScalar margin)
{
 if (leaf->volume.Contain(volume)) return(false);
 volume.Expand(btVector3(margin, margin, margin));
 update(leaf, volume);
 return(true);
}

//
void			btDbvt::remove(btDbvtNode* leaf)
{
 removeleaf(this, leaf);
 deletenode(this, leaf);
 --m_leaves;
}

//
void			btDbvt::write(IWriter* iwriter) const
{
 btDbvtNodeEnumerator	nodes;
 nodes.nodes.reserve(m_leaves * 2);
 enumNodes(m_root, nodes);
 iwriter->Prepare(m_root, nodes.nodes.size());
 for (int i = 0; i<nodes.nodes.size(); ++i)
 {
  const btDbvtNode* n = nodes.nodes[i];
  int			p = -1;
  if (n->parent) p = nodes.nodes.findLinearSearch(n->parent);
  if (n->isinternal())
  {
   const int	c0 = nodes.nodes.findLinearSearch(n->childs[0]);
   const int	c1 = nodes.nodes.findLinearSearch(n->childs[1]);
   iwriter->WriteNode(n, i, p, c0, c1);
  }
  else
  {
   iwriter->WriteLeaf(n, i, p);
  }
 }
}

//
void			btDbvt::clone(btDbvt& dest, IClone* iclone) const
{
 dest.clear();
 if (m_root != 0)
 {
  btAlignedObjectArray<sStkCLN>	stack;
  stack.reserve(m_leaves);
  stack.push_back(sStkCLN(m_root, 0));
  do {
   const int		i = stack.size() - 1;
   const sStkCLN	e = stack[i];
   btDbvtNode*			n = createnode(&dest, e.parent, e.node->volume, e.node->data);
   stack.pop_back();
   if (e.parent != 0)
    e.parent->childs[i & 1] = n;
   else
    dest.m_root = n;
   if (e.node->isinternal())
   {
    stack.push_back(sStkCLN(e.node->childs[0], n));
    stack.push_back(sStkCLN(e.node->childs[1], n));
   }
   else
   {
    iclone->CloneLeaf(n);
   }
  } while (stack.size()>0);
 }
}

//
int				btDbvt::maxdepth(const btDbvtNode* node)
{
 int	depth = 0;
 if (node) getmaxdepth(node, 1, depth);
 return(depth);
}

//
int				btDbvt::countLeaves(const btDbvtNode* node)
{
 if (node->isinternal())
  return(countLeaves(node->childs[0]) + countLeaves(node->childs[1]));
 else
  return(1);
}

//
void			btDbvt::extractLeaves(const btDbvtNode* node, btAlignedObjectArray<const btDbvtNode*>& leaves)
{
 if (node->isinternal())
 {
  extractLeaves(node->childs[0], leaves);
  extractLeaves(node->childs[1], leaves);
 }
 else
 {
  leaves.push_back(node);
 }
}

//
#if DBVT_ENABLE_BENCHMARK

#include <stdio.h>
#include <stdlib.h>
#include "LinearMath/btQuickProf.h"

/*
q6600,2.4ghz

/Ox /Ob2 /Oi /Ot /I "." /I "..\.." /I "..\..\src" /D "NDEBUG" /D "_LIB" /D "_WINDOWS" /D "_CRT_SECURE_NO_DEPRECATE" /D "_CRT_NONSTDC_NO_DEPRECATE" /D "WIN32"
/GF /FD /MT /GS- /Gy /arch:SSE2 /Zc:wchar_t- /Fp"..\..\out\release8\build\libbulletcollision\libbulletcollision.pch"
/Fo"..\..\out\release8\build\libbulletcollision\\"
/Fd"..\..\out\release8\build\libbulletcollision\bulletcollision.pdb"
/W3 /nologo /c /Wp64 /Zi /errorReport:prompt

Benchmarking dbvt...
World scale: 100.000000
Extents base: 1.000000
Extents range: 4.000000
Leaves: 8192
sizeof(btDbvtVolume): 32 bytes
sizeof(btDbvtNode):   44 bytes
[1] btDbvtVolume intersections: 3499 ms (-1%)
[2] btDbvtVolume merges: 1934 ms (0%)
[3] btDbvt::collideTT: 5485 ms (-21%)
[4] btDbvt::collideTT self: 2814 ms (-20%)
[5] btDbvt::collideTT xform: 7379 ms (-1%)
[6] btDbvt::collideTT xform,self: 7270 ms (-2%)
[7] btDbvt::rayTest: 6314 ms (0%),(332143 r/s)
[8] insert/remove: 2093 ms (0%),(1001983 ir/s)
[9] updates (teleport): 1879 ms (-3%),(1116100 u/s)
[10] updates (jitter): 1244 ms (-4%),(1685813 u/s)
[11] optimize (incremental): 2514 ms (0%),(1668000 o/s)
[12] btDbvtVolume notequal: 3659 ms (0%)
[13] culling(OCL+fullsort): 2218 ms (0%),(461 t/s)
[14] culling(OCL+qsort): 3688 ms (5%),(2221 t/s)
[15] culling(KDOP+qsort): 1139 ms (-1%),(7192 t/s)
[16] insert/remove batch(256): 5092 ms (0%),(823704 bir/s)
[17] btDbvtVolume select: 3419 ms (0%)
*/

struct btDbvtBenchmark
{
 struct NilPolicy : btDbvt::ICollide
 {
  NilPolicy() : m_pcount(0), m_depth(-SIMD_INFINITY), m_checksort(true) {}
  void	Process(const btDbvtNode*, const btDbvtNode*) { ++m_pcount; }
  void	Process(const btDbvtNode*) { ++m_pcount; }
  void	Process(const btDbvtNode*, btScalar depth)
  {
   ++m_pcount;
   if (m_checksort)
   {
    if (depth >= m_depth) m_depth = depth; else printf("wrong depth: %f (should be >= %f)\r\n", depth, m_depth);
   }
  }
  int			m_pcount;
  btScalar	m_depth;
  bool		m_checksort;
 };
 struct P14 : btDbvt::ICollide
 {
  struct Node
  {
   const btDbvtNode*	leaf;
   btScalar			depth;
  };
  void Process(const btDbvtNode* leaf, btScalar depth)
  {
   Node	n;
   n.leaf = leaf;
   n.depth = depth;
  }
  static int sortfnc(const Node& a, const Node& b)
  {
   if (a.depth<b.depth) return(+1);
   if (a.depth>b.depth) return(-1);
   return(0);
  }
  btAlignedObjectArray<Node>		m_nodes;
 };
 struct P15 : btDbvt::ICollide
 {
  struct Node
  {
   const btDbvtNode*	leaf;
   btScalar			depth;
  };
  void Process(const btDbvtNode* leaf)
  {
   Node	n;
   n.leaf = leaf;
   n.depth = dot(leaf->volume.Center(), m_axis);
  }
  static int sortfnc(const Node& a, const Node& b)
  {
   if (a.depth<b.depth) return(+1);
   if (a.depth>b.depth) return(-1);
   return(0);
  }
  btAlignedObjectArray<Node>		m_nodes;
  btVector3						m_axis;
 };
 static btScalar			RandUnit()
 {
  return(rand() / (btScalar)RAND_MAX);
 }
 static btVector3		RandVector3()
 {
  return(btVector3(RandUnit(), RandUnit(), RandUnit()));
 }
 static btVector3		RandVector3(btScalar cs)
 {
  return(RandVector3()*cs - btVector3(cs, cs, cs) / 2);
 }
 static btDbvtVolume	RandVolume(btScalar cs, btScalar eb, btScalar es)
 {
  return(btDbvtVolume::FromCE(RandVector3(cs), btVector3(eb, eb, eb) + RandVector3()*es));
 }
 static btTransform		RandTransform(btScalar cs)
 {
  btTransform	t;
  t.setOrigin(RandVector3(cs));
  t.setRotation(btQuaternion(RandUnit()*SIMD_PI * 2, RandUnit()*SIMD_PI * 2, RandUnit()*SIMD_PI * 2).normalized());
  return(t);
 }
 static void				RandTree(btScalar cs, btScalar eb, btScalar es, int leaves, btDbvt& dbvt)
 {
  dbvt.clear();
  for (int i = 0; i<leaves; ++i)
  {
   dbvt.insert(RandVolume(cs, eb, es), 0);
  }
 }
};

void			btDbvt::benchmark()
{
 static const btScalar	cfgVolumeCenterScale = 100;
 static const btScalar	cfgVolumeExentsBase = 1;
 static const btScalar	cfgVolumeExentsScale = 4;
 static const int		cfgLeaves = 8192;
 static const bool		cfgEnable = true;

 //[1] btDbvtVolume intersections
 bool					cfgBenchmark1_Enable = cfgEnable;
 static const int		cfgBenchmark1_Iterations = 8;
 static const int		cfgBenchmark1_Reference = 3499;
 //[2] btDbvtVolume merges
 bool					cfgBenchmark2_Enable = cfgEnable;
 static const int		cfgBenchmark2_Iterations = 4;
 static const int		cfgBenchmark2_Reference = 1945;
 //[3] btDbvt::collideTT
 bool					cfgBenchmark3_Enable = cfgEnable;
 static const int		cfgBenchmark3_Iterations = 512;
 static const int		cfgBenchmark3_Reference = 5485;
 //[4] btDbvt::collideTT self
 bool					cfgBenchmark4_Enable = cfgEnable;
 static const int		cfgBenchmark4_Iterations = 512;
 static const int		cfgBenchmark4_Reference = 2814;
 //[5] btDbvt::collideTT xform
 bool					cfgBenchmark5_Enable = cfgEnable;
 static const int		cfgBenchmark5_Iterations = 512;
 static const btScalar	cfgBenchmark5_OffsetScale = 2;
 static const int		cfgBenchmark5_Reference = 7379;
 //[6] btDbvt::collideTT xform,self
 bool					cfgBenchmark6_Enable = cfgEnable;
 static const int		cfgBenchmark6_Iterations = 512;
 static const btScalar	cfgBenchmark6_OffsetScale = 2;
 static const int		cfgBenchmark6_Reference = 7270;
 //[7] btDbvt::rayTest
 bool					cfgBenchmark7_Enable = cfgEnable;
 static const int		cfgBenchmark7_Passes = 32;
 static const int		cfgBenchmark7_Iterations = 65536;
 static const int		cfgBenchmark7_Reference = 6307;
 //[8] insert/remove
 bool					cfgBenchmark8_Enable = cfgEnable;
 static const int		cfgBenchmark8_Passes = 32;
 static const int		cfgBenchmark8_Iterations = 65536;
 static const int		cfgBenchmark8_Reference = 2105;
 //[9] updates (teleport)
 bool					cfgBenchmark9_Enable = cfgEnable;
 static const int		cfgBenchmark9_Passes = 32;
 static const int		cfgBenchmark9_Iterations = 65536;
 static const int		cfgBenchmark9_Reference = 1879;
 //[10] updates (jitter)
 bool					cfgBenchmark10_Enable = cfgEnable;
 static const btScalar	cfgBenchmark10_Scale = cfgVolumeCenterScale / 10000;
 static const int		cfgBenchmark10_Passes = 32;
 static const int		cfgBenchmark10_Iterations = 65536;
 static const int		cfgBenchmark10_Reference = 1244;
 //[11] optimize (incremental)
 bool					cfgBenchmark11_Enable = cfgEnable;
 static const int		cfgBenchmark11_Passes = 64;
 static const int		cfgBenchmark11_Iterations = 65536;
 static const int		cfgBenchmark11_Reference = 2510;
 //[12] btDbvtVolume notequal
 bool					cfgBenchmark12_Enable = cfgEnable;
 static const int		cfgBenchmark12_Iterations = 32;
 static const int		cfgBenchmark12_Reference = 3677;
 //[13] culling(OCL+fullsort)
 bool					cfgBenchmark13_Enable = cfgEnable;
 static const int		cfgBenchmark13_Iterations = 1024;
 static const int		cfgBenchmark13_Reference = 2231;
 //[14] culling(OCL+qsort)
 bool					cfgBenchmark14_Enable = cfgEnable;
 static const int		cfgBenchmark14_Iterations = 8192;
 static const int		cfgBenchmark14_Reference = 3500;
 //[15] culling(KDOP+qsort)
 bool					cfgBenchmark15_Enable = cfgEnable;
 static const int		cfgBenchmark15_Iterations = 8192;
 static const int		cfgBenchmark15_Reference = 1151;
 //[16] insert/remove batch
 bool					cfgBenchmark16_Enable = cfgEnable;
 static const int		cfgBenchmark16_BatchCount = 256;
 static const int		cfgBenchmark16_Passes = 16384;
 static const int		cfgBenchmark16_Reference = 5138;
 //[17] select
 bool					cfgBenchmark17_Enable = cfgEnable;
 static const int		cfgBenchmark17_Iterations = 4;
 static const int		cfgBenchmark17_Reference = 3390;

 btClock					wallclock;
 printf("Benchmarking dbvt...\r\n");
 printf("\tWorld scale: %f\r\n", cfgVolumeCenterScale);
 printf("\tExtents base: %f\r\n", cfgVolumeExentsBase);
 printf("\tExtents range: %f\r\n", cfgVolumeExentsScale);
 printf("\tLeaves: %u\r\n", cfgLeaves);
 printf("\tsizeof(btDbvtVolume): %u bytes\r\n", sizeof(btDbvtVolume));
 printf("\tsizeof(btDbvtNode):   %u bytes\r\n", sizeof(btDbvtNode));
 if (cfgBenchmark1_Enable)
 {// Benchmark 1	
  srand(380843);
  btAlignedObjectArray<btDbvtVolume>	volumes;
  btAlignedObjectArray<bool>			results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[1] btDbvtVolume intersections: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark1_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     results[k] = Intersect(volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark1_Reference) * 100 / time);
 }
 if (cfgBenchmark2_Enable)
 {// Benchmark 2	
  srand(380843);
  btAlignedObjectArray<btDbvtVolume>	volumes;
  btAlignedObjectArray<btDbvtVolume>	results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[2] btDbvtVolume merges: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark2_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     Merge(volumes[j], volumes[k], results[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark2_Reference) * 100 / time);
 }
 if (cfgBenchmark3_Enable)
 {// Benchmark 3	
  srand(380843);
  btDbvt						dbvt[2];
  btDbvtBenchmark::NilPolicy	policy;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[0]);
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[1]);
  dbvt[0].optimizeTopDown();
  dbvt[1].optimizeTopDown();
  printf("[3] btDbvt::collideTT: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark3_Iterations; ++i)
  {
   btDbvt::collideTT(dbvt[0].m_root, dbvt[1].m_root, policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark3_Reference) * 100 / time);
 }
 if (cfgBenchmark4_Enable)
 {// Benchmark 4
  srand(380843);
  btDbvt						dbvt;
  btDbvtBenchmark::NilPolicy	policy;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[4] btDbvt::collideTT self: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark4_Iterations; ++i)
  {
   btDbvt::collideTT(dbvt.m_root, dbvt.m_root, policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark4_Reference) * 100 / time);
 }
 if (cfgBenchmark5_Enable)
 {// Benchmark 5	
  srand(380843);
  btDbvt								dbvt[2];
  btAlignedObjectArray<btTransform>	transforms;
  btDbvtBenchmark::NilPolicy			policy;
  transforms.resize(cfgBenchmark5_Iterations);
  for (int i = 0; i<transforms.size(); ++i)
  {
   transforms[i] = btDbvtBenchmark::RandTransform(cfgVolumeCenterScale*cfgBenchmark5_OffsetScale);
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[0]);
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt[1]);
  dbvt[0].optimizeTopDown();
  dbvt[1].optimizeTopDown();
  printf("[5] btDbvt::collideTT xform: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark5_Iterations; ++i)
  {
   btDbvt::collideTT(dbvt[0].m_root, dbvt[1].m_root, transforms[i], policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark5_Reference) * 100 / time);
 }
 if (cfgBenchmark6_Enable)
 {// Benchmark 6	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btTransform>	transforms;
  btDbvtBenchmark::NilPolicy			policy;
  transforms.resize(cfgBenchmark6_Iterations);
  for (int i = 0; i<transforms.size(); ++i)
  {
   transforms[i] = btDbvtBenchmark::RandTransform(cfgVolumeCenterScale*cfgBenchmark6_OffsetScale);
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[6] btDbvt::collideTT xform,self: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark6_Iterations; ++i)
  {
   btDbvt::collideTT(dbvt.m_root, dbvt.m_root, transforms[i], policy);
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark6_Reference) * 100 / time);
 }
 if (cfgBenchmark7_Enable)
 {// Benchmark 7	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btVector3>		rayorg;
  btAlignedObjectArray<btVector3>		raydir;
  btDbvtBenchmark::NilPolicy			policy;
  rayorg.resize(cfgBenchmark7_Iterations);
  raydir.resize(cfgBenchmark7_Iterations);
  for (int i = 0; i<rayorg.size(); ++i)
  {
   rayorg[i] = btDbvtBenchmark::RandVector3(cfgVolumeCenterScale * 2);
   raydir[i] = btDbvtBenchmark::RandVector3(cfgVolumeCenterScale * 2);
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[7] btDbvt::rayTest: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark7_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark7_Iterations; ++j)
   {
    btDbvt::rayTest(dbvt.m_root, rayorg[j], rayorg[j] + raydir[j], policy);
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  unsigned	rays = cfgBenchmark7_Passes*cfgBenchmark7_Iterations;
  printf("%u ms (%i%%),(%u r/s)\r\n", time, (time - cfgBenchmark7_Reference) * 100 / time, (rays * 1000) / time);
 }
 if (cfgBenchmark8_Enable)
 {// Benchmark 8	
  srand(380843);
  btDbvt								dbvt;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[8] insert/remove: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark8_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark8_Iterations; ++j)
   {
    dbvt.remove(dbvt.insert(btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale), 0));
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	ir = cfgBenchmark8_Passes*cfgBenchmark8_Iterations;
  printf("%u ms (%i%%),(%u ir/s)\r\n", time, (time - cfgBenchmark8_Reference) * 100 / time, ir * 1000 / time);
 }
 if (cfgBenchmark9_Enable)
 {// Benchmark 9	
  srand(380843);
  btDbvt										dbvt;
  btAlignedObjectArray<const btDbvtNode*>	leaves;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  dbvt.extractLeaves(dbvt.m_root, leaves);
  printf("[9] updates (teleport): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark9_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark9_Iterations; ++j)
   {
    dbvt.update(const_cast<btDbvtNode*>(leaves[rand() % cfgLeaves]),
     btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale));
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	up = cfgBenchmark9_Passes*cfgBenchmark9_Iterations;
  printf("%u ms (%i%%),(%u u/s)\r\n", time, (time - cfgBenchmark9_Reference) * 100 / time, up * 1000 / time);
 }
 if (cfgBenchmark10_Enable)
 {// Benchmark 10	
  srand(380843);
  btDbvt										dbvt;
  btAlignedObjectArray<const btDbvtNode*>	leaves;
  btAlignedObjectArray<btVector3>				vectors;
  vectors.resize(cfgBenchmark10_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (btDbvtBenchmark::RandVector3() * 2 - btVector3(1, 1, 1))*cfgBenchmark10_Scale;
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  dbvt.extractLeaves(dbvt.m_root, leaves);
  printf("[10] updates (jitter): ");
  wallclock.reset();

  for (int i = 0; i<cfgBenchmark10_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark10_Iterations; ++j)
   {
    const btVector3&	d = vectors[j];
    btDbvtNode*		l = const_cast<btDbvtNode*>(leaves[rand() % cfgLeaves]);
    btDbvtVolume		v = btDbvtVolume::FromMM(l->volume.Mins() + d, l->volume.Maxs() + d);
    dbvt.update(l, v);
   }
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	up = cfgBenchmark10_Passes*cfgBenchmark10_Iterations;
  printf("%u ms (%i%%),(%u u/s)\r\n", time, (time - cfgBenchmark10_Reference) * 100 / time, up * 1000 / time);
 }
 if (cfgBenchmark11_Enable)
 {// Benchmark 11	
  srand(380843);
  btDbvt										dbvt;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[11] optimize (incremental): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark11_Passes; ++i)
  {
   dbvt.optimizeIncremental(cfgBenchmark11_Iterations);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	op = cfgBenchmark11_Passes*cfgBenchmark11_Iterations;
  printf("%u ms (%i%%),(%u o/s)\r\n", time, (time - cfgBenchmark11_Reference) * 100 / time, op / time * 1000);
 }
 if (cfgBenchmark12_Enable)
 {// Benchmark 12	
  srand(380843);
  btAlignedObjectArray<btDbvtVolume>	volumes;
  btAlignedObjectArray<bool>				results;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   volumes[i] = btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  printf("[12] btDbvtVolume notequal: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark12_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     results[k] = NotEqual(volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark12_Reference) * 100 / time);
 }
 if (cfgBenchmark13_Enable)
 {// Benchmark 13	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btVector3>		vectors;
  btDbvtBenchmark::NilPolicy			policy;
  vectors.resize(cfgBenchmark13_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (btDbvtBenchmark::RandVector3() * 2 - btVector3(1, 1, 1)).normalized();
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  printf("[13] culling(OCL+fullsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark13_Iterations; ++i)
  {
   static const btScalar	offset = 0;
   policy.m_depth = -SIMD_INFINITY;
   dbvt.collideOCL(dbvt.m_root, &vectors[i], &offset, vectors[i], 1, policy);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark13_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark13_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark14_Enable)
 {// Benchmark 14	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btVector3>		vectors;
  btDbvtBenchmark::P14				policy;
  vectors.resize(cfgBenchmark14_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (btDbvtBenchmark::RandVector3() * 2 - btVector3(1, 1, 1)).normalized();
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  policy.m_nodes.reserve(cfgLeaves);
  printf("[14] culling(OCL+qsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark14_Iterations; ++i)
  {
   static const btScalar	offset = 0;
   policy.m_nodes.resize(0);
   dbvt.collideOCL(dbvt.m_root, &vectors[i], &offset, vectors[i], 1, policy, false);
   policy.m_nodes.quickSort(btDbvtBenchmark::P14::sortfnc);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark14_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark14_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark15_Enable)
 {// Benchmark 15	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btVector3>		vectors;
  btDbvtBenchmark::P15				policy;
  vectors.resize(cfgBenchmark15_Iterations);
  for (int i = 0; i<vectors.size(); ++i)
  {
   vectors[i] = (btDbvtBenchmark::RandVector3() * 2 - btVector3(1, 1, 1)).normalized();
  }
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  policy.m_nodes.reserve(cfgLeaves);
  printf("[15] culling(KDOP+qsort): ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark15_Iterations; ++i)
  {
   static const btScalar	offset = 0;
   policy.m_nodes.resize(0);
   policy.m_axis = vectors[i];
   dbvt.collideKDOP(dbvt.m_root, &vectors[i], &offset, 1, policy);
   policy.m_nodes.quickSort(btDbvtBenchmark::P15::sortfnc);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	t = cfgBenchmark15_Iterations;
  printf("%u ms (%i%%),(%u t/s)\r\n", time, (time - cfgBenchmark15_Reference) * 100 / time, (t * 1000) / time);
 }
 if (cfgBenchmark16_Enable)
 {// Benchmark 16	
  srand(380843);
  btDbvt								dbvt;
  btAlignedObjectArray<btDbvtNode*>	batch;
  btDbvtBenchmark::RandTree(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale, cfgLeaves, dbvt);
  dbvt.optimizeTopDown();
  batch.reserve(cfgBenchmark16_BatchCount);
  printf("[16] insert/remove batch(%u): ", cfgBenchmark16_BatchCount);
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark16_Passes; ++i)
  {
   for (int j = 0; j<cfgBenchmark16_BatchCount; ++j)
   {
    batch.push_back(dbvt.insert(btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale), 0));
   }
   for (int j = 0; j<cfgBenchmark16_BatchCount; ++j)
   {
    dbvt.remove(batch[j]);
   }
   batch.resize(0);
  }
  const int	time = (int)wallclock.getTimeMilliseconds();
  const int	ir = cfgBenchmark16_Passes*cfgBenchmark16_BatchCount;
  printf("%u ms (%i%%),(%u bir/s)\r\n", time, (time - cfgBenchmark16_Reference) * 100 / time, int(ir*1000.0 / time));
 }
 if (cfgBenchmark17_Enable)
 {// Benchmark 17
  srand(380843);
  btAlignedObjectArray<btDbvtVolume>	volumes;
  btAlignedObjectArray<int>			results;
  btAlignedObjectArray<int>			indices;
  volumes.resize(cfgLeaves);
  results.resize(cfgLeaves);
  indices.resize(cfgLeaves);
  for (int i = 0; i<cfgLeaves; ++i)
  {
   indices[i] = i;
   volumes[i] = btDbvtBenchmark::RandVolume(cfgVolumeCenterScale, cfgVolumeExentsBase, cfgVolumeExentsScale);
  }
  for (int i = 0; i<cfgLeaves; ++i)
  {
   btSwap(indices[i], indices[rand() % cfgLeaves]);
  }
  printf("[17] btDbvtVolume select: ");
  wallclock.reset();
  for (int i = 0; i<cfgBenchmark17_Iterations; ++i)
  {
   for (int j = 0; j<cfgLeaves; ++j)
   {
    for (int k = 0; k<cfgLeaves; ++k)
    {
     const int idx = indices[k];
     results[idx] = Select(volumes[idx], volumes[j], volumes[k]);
    }
   }
  }
  const int time = (int)wallclock.getTimeMilliseconds();
  printf("%u ms (%i%%)\r\n", time, (time - cfgBenchmark17_Reference) * 100 / time);
 }
 printf("\r\n\r\n");
}
#endif 

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btDispatcher.h"

btDispatcher::~btDispatcher()
{

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"

#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "LinearMath/btAabbUtil2.h"

#include <stdio.h>

int	gOverlappingPairs = 0;

int gRemovePairs = 0;
int gAddedPairs = 0;
int gFindPairs = 0;




btHashedOverlappingPairCache::btHashedOverlappingPairCache() :
 m_overlapFilterCallback(0),
 m_ghostPairCallback(0)
{
 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
 growTables();
}




btHashedOverlappingPairCache::~btHashedOverlappingPairCache()
{
}



void	btHashedOverlappingPairCache::cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher)
{
 if (pair.m_algorithm && dispatcher)
 {
  {
   pair.m_algorithm->~btCollisionAlgorithm();
   dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
   pair.m_algorithm = 0;
  }
 }
}




void	btHashedOverlappingPairCache::cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{

 class	CleanPairCallback : public btOverlapCallback
 {
  btBroadphaseProxy* m_cleanProxy;
  btOverlappingPairCache*	m_pairCache;
  btDispatcher* m_dispatcher;

 public:
  CleanPairCallback(btBroadphaseProxy* cleanProxy, btOverlappingPairCache* pairCache, btDispatcher* dispatcher)
   :m_cleanProxy(cleanProxy),
   m_pairCache(pairCache),
   m_dispatcher(dispatcher)
  {
  }
  virtual	bool	processOverlap(btBroadphasePair& pair)
  {
   if ((pair.m_pProxy0 == m_cleanProxy) ||
    (pair.m_pProxy1 == m_cleanProxy))
   {
    m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
   }
   return false;
  }

 };

 CleanPairCallback cleanPairs(proxy, this, dispatcher);

 processAllOverlappingPairs(&cleanPairs, dispatcher);

}




void	btHashedOverlappingPairCache::removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{

 class	RemovePairCallback : public btOverlapCallback
 {
  btBroadphaseProxy* m_obsoleteProxy;

 public:
  RemovePairCallback(btBroadphaseProxy* obsoleteProxy)
   :m_obsoleteProxy(obsoleteProxy)
  {
  }
  virtual	bool	processOverlap(btBroadphasePair& pair)
  {
   return ((pair.m_pProxy0 == m_obsoleteProxy) ||
    (pair.m_pProxy1 == m_obsoleteProxy));
  }

 };


 RemovePairCallback removeCallback(proxy);

 processAllOverlappingPairs(&removeCallback, dispatcher);
}





btBroadphasePair* btHashedOverlappingPairCache::findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
 gFindPairs++;
 if (proxy0->m_uniqueId>proxy1->m_uniqueId)
  btSwap(proxy0, proxy1);
 int proxyId1 = proxy0->getUid();
 int proxyId2 = proxy1->getUid();

 /*if (proxyId1 > proxyId2)
 btSwap(proxyId1, proxyId2);*/

 int hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

 if (hash >= m_hashTable.size())
 {
  return NULL;
 }

 int index = m_hashTable[hash];
 while (index != BT_NULL_PAIR && equalsPair(m_overlappingPairArray[index], proxyId1, proxyId2) == false)
 {
  index = m_next[index];
 }

 if (index == BT_NULL_PAIR)
 {
  return NULL;
 }

 btAssert(index < m_overlappingPairArray.size());

 return &m_overlappingPairArray[index];
}

//#include <stdio.h>

void	btHashedOverlappingPairCache::growTables()
{

 int newCapacity = m_overlappingPairArray.capacity();

 if (m_hashTable.size() < newCapacity)
 {
  //grow hashtable and next table
  int curHashtableSize = m_hashTable.size();

  m_hashTable.resize(newCapacity);
  m_next.resize(newCapacity);


  int i;

  for (i = 0; i < newCapacity; ++i)
  {
   m_hashTable[i] = BT_NULL_PAIR;
  }
  for (i = 0; i < newCapacity; ++i)
  {
   m_next[i] = BT_NULL_PAIR;
  }

  for (i = 0; i<curHashtableSize; i++)
  {

   const btBroadphasePair& pair = m_overlappingPairArray[i];
   int proxyId1 = pair.m_pProxy0->getUid();
   int proxyId2 = pair.m_pProxy1->getUid();
   /*if (proxyId1 > proxyId2)
   btSwap(proxyId1, proxyId2);*/
   int	hashValue = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask
   m_next[i] = m_hashTable[hashValue];
   m_hashTable[hashValue] = i;
  }


 }
}

btBroadphasePair* btHashedOverlappingPairCache::internalAddPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
 if (proxy0->m_uniqueId>proxy1->m_uniqueId)
  btSwap(proxy0, proxy1);
 int proxyId1 = proxy0->getUid();
 int proxyId2 = proxy1->getUid();

 /*if (proxyId1 > proxyId2)
 btSwap(proxyId1, proxyId2);*/

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask


 btBroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
 if (pair != NULL)
 {
  return pair;
 }
 /*for(int i=0;i<m_overlappingPairArray.size();++i)
 {
 if(	(m_overlappingPairArray[i].m_pProxy0==proxy0)&&
 (m_overlappingPairArray[i].m_pProxy1==proxy1))
 {
 printf("Adding duplicated %u<>%u\r\n",proxyId1,proxyId2);
 internalFindPair(proxy0, proxy1, hash);
 }
 }*/
 int count = m_overlappingPairArray.size();
 int oldCapacity = m_overlappingPairArray.capacity();
 void* mem = &m_overlappingPairArray.expandNonInitializing();

 //this is where we add an actual pair, so also call the 'ghost'
 if (m_ghostPairCallback)
  m_ghostPairCallback->addOverlappingPair(proxy0, proxy1);

 int newCapacity = m_overlappingPairArray.capacity();

 if (oldCapacity < newCapacity)
 {
  growTables();
  //hash with new capacity
  hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));
 }

 pair = new (mem) btBroadphasePair(*proxy0, *proxy1);
 //	pair->m_pProxy0 = proxy0;
 //	pair->m_pProxy1 = proxy1;
 pair->m_algorithm = 0;
 pair->m_internalTmpValue = 0;


 m_next[count] = m_hashTable[hash];
 m_hashTable[hash] = count;

 return pair;
}



void* btHashedOverlappingPairCache::removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher)
{
 gRemovePairs++;
 if (proxy0->m_uniqueId>proxy1->m_uniqueId)
  btSwap(proxy0, proxy1);
 int proxyId1 = proxy0->getUid();
 int proxyId2 = proxy1->getUid();

 /*if (proxyId1 > proxyId2)
 btSwap(proxyId1, proxyId2);*/

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

 btBroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
 if (pair == NULL)
 {
  return 0;
 }

 cleanOverlappingPair(*pair, dispatcher);

 void* userData = pair->m_internalInfo1;

 btAssert(pair->m_pProxy0->getUid() == proxyId1);
 btAssert(pair->m_pProxy1->getUid() == proxyId2);

 int pairIndex = int(pair - &m_overlappingPairArray[0]);
 btAssert(pairIndex < m_overlappingPairArray.size());

 // Remove the pair from the hash table.
 int index = m_hashTable[hash];
 btAssert(index != BT_NULL_PAIR);

 int previous = BT_NULL_PAIR;
 while (index != pairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != BT_NULL_PAIR)
 {
  btAssert(m_next[previous] == pairIndex);
  m_next[previous] = m_next[pairIndex];
 }
 else
 {
  m_hashTable[hash] = m_next[pairIndex];
 }

 // We now move the last pair into spot of the
 // pair being removed. We need to fix the hash
 // table indices to support the move.

 int lastPairIndex = m_overlappingPairArray.size() - 1;

 if (m_ghostPairCallback)
  m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1, dispatcher);

 // If the removed pair is the last pair, we are done.
 if (lastPairIndex == pairIndex)
 {
  m_overlappingPairArray.pop_back();
  return userData;
 }

 // Remove the last pair from the hash table.
 const btBroadphasePair* last = &m_overlappingPairArray[lastPairIndex];
 /* missing swap here too, Nat. */
 int lastHash = static_cast<int>(getHash(static_cast<unsigned int>(last->m_pProxy0->getUid()), static_cast<unsigned int>(last->m_pProxy1->getUid())) & (m_overlappingPairArray.capacity() - 1));

 index = m_hashTable[lastHash];
 btAssert(index != BT_NULL_PAIR);

 previous = BT_NULL_PAIR;
 while (index != lastPairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != BT_NULL_PAIR)
 {
  btAssert(m_next[previous] == lastPairIndex);
  m_next[previous] = m_next[lastPairIndex];
 }
 else
 {
  m_hashTable[lastHash] = m_next[lastPairIndex];
 }

 // Copy the last pair into the remove pair's spot.
 m_overlappingPairArray[pairIndex] = m_overlappingPairArray[lastPairIndex];

 // Insert the last pair into the hash table
 m_next[pairIndex] = m_hashTable[lastHash];
 m_hashTable[lastHash] = pairIndex;

 m_overlappingPairArray.pop_back();

 return userData;
}
//#include <stdio.h>
#include "LinearMath/btQuickprof.h"
void	btHashedOverlappingPairCache::processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher)
{
 BT_PROFILE("btHashedOverlappingPairCache::processAllOverlappingPairs");
 int i;

 //	printf("m_overlappingPairArray.size()=%d\n",m_overlappingPairArray.size());
 for (i = 0; i<m_overlappingPairArray.size();)
 {

  btBroadphasePair* pair = &m_overlappingPairArray[i];
  if (callback->processOverlap(*pair))
  {
   removeOverlappingPair(pair->m_pProxy0, pair->m_pProxy1, dispatcher);

   gOverlappingPairs--;
  }
  else
  {
   i++;
  }
 }
}

void	btHashedOverlappingPairCache::sortOverlappingPairs(btDispatcher* dispatcher)
{
 ///need to keep hashmap in sync with pair address, so rebuild all
 btBroadphasePairArray tmpPairs;
 int i;
 for (i = 0; i<m_overlappingPairArray.size(); i++)
 {
  tmpPairs.push_back(m_overlappingPairArray[i]);
 }

 for (i = 0; i<tmpPairs.size(); i++)
 {
  removeOverlappingPair(tmpPairs[i].m_pProxy0, tmpPairs[i].m_pProxy1, dispatcher);
 }

 for (i = 0; i < m_next.size(); i++)
 {
  m_next[i] = BT_NULL_PAIR;
 }

 tmpPairs.quickSort(btBroadphasePairSortPredicate());

 for (i = 0; i<tmpPairs.size(); i++)
 {
  addOverlappingPair(tmpPairs[i].m_pProxy0, tmpPairs[i].m_pProxy1);
 }


}


void*	btSortedOverlappingPairCache::removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher)
{
 if (!hasDeferredRemoval())
 {
  btBroadphasePair findPair(*proxy0, *proxy1);

  int findIndex = m_overlappingPairArray.findLinearSearch(findPair);
  if (findIndex < m_overlappingPairArray.size())
  {
   gOverlappingPairs--;
   btBroadphasePair& pair = m_overlappingPairArray[findIndex];
   void* userData = pair.m_internalInfo1;
   cleanOverlappingPair(pair, dispatcher);
   if (m_ghostPairCallback)
    m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1, dispatcher);

   m_overlappingPairArray.swap(findIndex, m_overlappingPairArray.capacity() - 1);
   m_overlappingPairArray.pop_back();
   return userData;
  }
 }

 return 0;
}








btBroadphasePair*	btSortedOverlappingPairCache::addOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
 //don't add overlap with own
 btAssert(proxy0 != proxy1);

 if (!needsBroadphaseCollision(proxy0, proxy1))
  return 0;

 void* mem = &m_overlappingPairArray.expandNonInitializing();
 btBroadphasePair* pair = new (mem) btBroadphasePair(*proxy0, *proxy1);

 gOverlappingPairs++;
 gAddedPairs++;

 if (m_ghostPairCallback)
  m_ghostPairCallback->addOverlappingPair(proxy0, proxy1);
 return pair;

}

///this findPair becomes really slow. Either sort the list to speedup the query, or
///use a different solution. It is mainly used for Removing overlapping pairs. Removal could be delayed.
///we could keep a linked list in each proxy, and store pair in one of the proxies (with lowest memory address)
///Also we can use a 2D bitmap, which can be useful for a future GPU implementation
btBroadphasePair*	btSortedOverlappingPairCache::findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
 if (!needsBroadphaseCollision(proxy0, proxy1))
  return 0;

 btBroadphasePair tmpPair(*proxy0, *proxy1);
 int findIndex = m_overlappingPairArray.findLinearSearch(tmpPair);

 if (findIndex < m_overlappingPairArray.size())
 {
  //btAssert(it != m_overlappingPairSet.end());
  btBroadphasePair* pair = &m_overlappingPairArray[findIndex];
  return pair;
 }
 return 0;
}










//#include <stdio.h>

void	btSortedOverlappingPairCache::processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher)
{

 int i;

 for (i = 0; i<m_overlappingPairArray.size();)
 {

  btBroadphasePair* pair = &m_overlappingPairArray[i];
  if (callback->processOverlap(*pair))
  {
   cleanOverlappingPair(*pair, dispatcher);
   pair->m_pProxy0 = 0;
   pair->m_pProxy1 = 0;
   m_overlappingPairArray.swap(i, m_overlappingPairArray.size() - 1);
   m_overlappingPairArray.pop_back();
   gOverlappingPairs--;
  }
  else
  {
   i++;
  }
 }
}




btSortedOverlappingPairCache::btSortedOverlappingPairCache() :
 m_blockedForChanges(false),
 m_hasDeferredRemoval(true),
 m_overlapFilterCallback(0),
 m_ghostPairCallback(0)
{
 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
}

btSortedOverlappingPairCache::~btSortedOverlappingPairCache()
{
}

void	btSortedOverlappingPairCache::cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher)
{
 if (pair.m_algorithm)
 {
  {
   pair.m_algorithm->~btCollisionAlgorithm();
   dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
   pair.m_algorithm = 0;
   gRemovePairs--;
  }
 }
}


void	btSortedOverlappingPairCache::cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{

 class	CleanPairCallback : public btOverlapCallback
 {
  btBroadphaseProxy* m_cleanProxy;
  btOverlappingPairCache*	m_pairCache;
  btDispatcher* m_dispatcher;

 public:
  CleanPairCallback(btBroadphaseProxy* cleanProxy, btOverlappingPairCache* pairCache, btDispatcher* dispatcher)
   :m_cleanProxy(cleanProxy),
   m_pairCache(pairCache),
   m_dispatcher(dispatcher)
  {
  }
  virtual	bool	processOverlap(btBroadphasePair& pair)
  {
   if ((pair.m_pProxy0 == m_cleanProxy) ||
    (pair.m_pProxy1 == m_cleanProxy))
   {
    m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
   }
   return false;
  }

 };

 CleanPairCallback cleanPairs(proxy, this, dispatcher);

 processAllOverlappingPairs(&cleanPairs, dispatcher);

}


void	btSortedOverlappingPairCache::removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{

 class	RemovePairCallback : public btOverlapCallback
 {
  btBroadphaseProxy* m_obsoleteProxy;

 public:
  RemovePairCallback(btBroadphaseProxy* obsoleteProxy)
   :m_obsoleteProxy(obsoleteProxy)
  {
  }
  virtual	bool	processOverlap(btBroadphasePair& pair)
  {
   return ((pair.m_pProxy0 == m_obsoleteProxy) ||
    (pair.m_pProxy1 == m_obsoleteProxy));
  }

 };

 RemovePairCallback removeCallback(proxy);

 processAllOverlappingPairs(&removeCallback, dispatcher);
}

void	btSortedOverlappingPairCache::sortOverlappingPairs(btDispatcher* dispatcher)
{
 //should already be sorted
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btQuantizedBvh.h"

#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btSerializer.h"

#define RAYAABB2

btQuantizedBvh::btQuantizedBvh() :
 m_bulletVersion(BT_BULLET_VERSION),
 m_useQuantization(false),
 //m_traversalMode(TRAVERSAL_STACKLESS_CACHE_FRIENDLY)
 m_traversalMode(TRAVERSAL_STACKLESS)
 //m_traversalMode(TRAVERSAL_RECURSIVE)
 , m_subtreeHeaderCount(0) //PCK: add this line
{
 m_bvhAabbMin.setValue(-SIMD_INFINITY, -SIMD_INFINITY, -SIMD_INFINITY);
 m_bvhAabbMax.setValue(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
}





void btQuantizedBvh::buildInternal()
{
 ///assumes that caller filled in the m_quantizedLeafNodes
 m_useQuantization = true;
 int numLeafNodes = 0;

 if (m_useQuantization)
 {
  //now we have an array of leafnodes in m_leafNodes
  numLeafNodes = m_quantizedLeafNodes.size();

  m_quantizedContiguousNodes.resize(2 * numLeafNodes);

 }

 m_curNodeIndex = 0;

 buildTree(0, numLeafNodes);

 ///if the entire tree is small then subtree size, we need to create a header info for the tree
 if (m_useQuantization && !m_SubtreeHeaders.size())
 {
  btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
  subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[0]);
  subtree.m_rootNodeIndex = 0;
  subtree.m_subtreeSize = m_quantizedContiguousNodes[0].isLeafNode() ? 1 : m_quantizedContiguousNodes[0].getEscapeIndex();
 }

 //PCK: update the copy of the size
 m_subtreeHeaderCount = m_SubtreeHeaders.size();

 //PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
 m_quantizedLeafNodes.clear();
 m_leafNodes.clear();
}



///just for debugging, to visualize the individual patches/subtrees
#ifdef DEBUG_PATCH_COLORS
btVector3 color[4] =
{
 btVector3(1,0,0),
 btVector3(0,1,0),
 btVector3(0,0,1),
 btVector3(0,1,1)
};
#endif //DEBUG_PATCH_COLORS



void	btQuantizedBvh::setQuantizationValues(const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, btScalar quantizationMargin)
{
 //enlarge the AABB to avoid division by zero when initializing the quantization values
 btVector3 clampValue(quantizationMargin, quantizationMargin, quantizationMargin);
 m_bvhAabbMin = bvhAabbMin - clampValue;
 m_bvhAabbMax = bvhAabbMax + clampValue;
 btVector3 aabbSize = m_bvhAabbMax - m_bvhAabbMin;
 m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;

 m_useQuantization = true;

 {
  unsigned short vecIn[3];
  btVector3 v;
  {
   quantize(vecIn, m_bvhAabbMin, false);
   v = unQuantize(vecIn);
   m_bvhAabbMin.setMin(v - clampValue);
  }
  aabbSize = m_bvhAabbMax - m_bvhAabbMin;
  m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;
  {
   quantize(vecIn, m_bvhAabbMax, true);
   v = unQuantize(vecIn);
   m_bvhAabbMax.setMax(v + clampValue);
  }
  aabbSize = m_bvhAabbMax - m_bvhAabbMin;
  m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;
 }
}




btQuantizedBvh::~btQuantizedBvh()
{
}

#ifdef DEBUG_TREE_BUILDING
int gStackDepth = 0;
int gMaxStackDepth = 0;
#endif //DEBUG_TREE_BUILDING

void	btQuantizedBvh::buildTree(int startIndex, int endIndex)
{
#ifdef DEBUG_TREE_BUILDING
 gStackDepth++;
 if (gStackDepth > gMaxStackDepth)
  gMaxStackDepth = gStackDepth;
#endif //DEBUG_TREE_BUILDING


 int splitAxis, splitIndex, i;
 int numIndices = endIndex - startIndex;
 int curIndex = m_curNodeIndex;

 btAssert(numIndices>0);

 if (numIndices == 1)
 {
#ifdef DEBUG_TREE_BUILDING
  gStackDepth--;
#endif //DEBUG_TREE_BUILDING

  assignInternalNodeFromLeafNode(m_curNodeIndex, startIndex);

  m_curNodeIndex++;
  return;
 }
 //calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.

 splitAxis = calcSplittingAxis(startIndex, endIndex);

 splitIndex = sortAndCalcSplittingIndex(startIndex, endIndex, splitAxis);

 int internalNodeIndex = m_curNodeIndex;

 //set the min aabb to 'inf' or a max value, and set the max aabb to a -inf/minimum value.
 //the aabb will be expanded during buildTree/mergeInternalNodeAabb with actual node values
 setInternalNodeAabbMin(m_curNodeIndex, m_bvhAabbMax);//can't use btVector3(SIMD_INFINITY,SIMD_INFINITY,SIMD_INFINITY)) because of quantization
 setInternalNodeAabbMax(m_curNodeIndex, m_bvhAabbMin);//can't use btVector3(-SIMD_INFINITY,-SIMD_INFINITY,-SIMD_INFINITY)) because of quantization


 for (i = startIndex; i<endIndex; i++)
 {
  mergeInternalNodeAabb(m_curNodeIndex, getAabbMin(i), getAabbMax(i));
 }

 m_curNodeIndex++;


 //internalNode->m_escapeIndex;

 int leftChildNodexIndex = m_curNodeIndex;

 //build left child tree
 buildTree(startIndex, splitIndex);

 int rightChildNodexIndex = m_curNodeIndex;
 //build right child tree
 buildTree(splitIndex, endIndex);

#ifdef DEBUG_TREE_BUILDING
 gStackDepth--;
#endif //DEBUG_TREE_BUILDING

 int escapeIndex = m_curNodeIndex - curIndex;

 if (m_useQuantization)
 {
  //escapeIndex is the number of nodes of this subtree
  const int sizeQuantizedNode = sizeof(btQuantizedBvhNode);
  const int treeSizeInBytes = escapeIndex * sizeQuantizedNode;
  if (treeSizeInBytes > MAX_SUBTREE_SIZE_IN_BYTES)
  {
   updateSubtreeHeaders(leftChildNodexIndex, rightChildNodexIndex);
  }
 }
 else
 {

 }

 setInternalNodeEscapeIndex(internalNodeIndex, escapeIndex);

}

void	btQuantizedBvh::updateSubtreeHeaders(int leftChildNodexIndex, int rightChildNodexIndex)
{
 btAssert(m_useQuantization);

 btQuantizedBvhNode& leftChildNode = m_quantizedContiguousNodes[leftChildNodexIndex];
 int leftSubTreeSize = leftChildNode.isLeafNode() ? 1 : leftChildNode.getEscapeIndex();
 int leftSubTreeSizeInBytes = leftSubTreeSize * static_cast<int>(sizeof(btQuantizedBvhNode));

 btQuantizedBvhNode& rightChildNode = m_quantizedContiguousNodes[rightChildNodexIndex];
 int rightSubTreeSize = rightChildNode.isLeafNode() ? 1 : rightChildNode.getEscapeIndex();
 int rightSubTreeSizeInBytes = rightSubTreeSize *  static_cast<int>(sizeof(btQuantizedBvhNode));

 if (leftSubTreeSizeInBytes <= MAX_SUBTREE_SIZE_IN_BYTES)
 {
  btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
  subtree.setAabbFromQuantizeNode(leftChildNode);
  subtree.m_rootNodeIndex = leftChildNodexIndex;
  subtree.m_subtreeSize = leftSubTreeSize;
 }

 if (rightSubTreeSizeInBytes <= MAX_SUBTREE_SIZE_IN_BYTES)
 {
  btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
  subtree.setAabbFromQuantizeNode(rightChildNode);
  subtree.m_rootNodeIndex = rightChildNodexIndex;
  subtree.m_subtreeSize = rightSubTreeSize;
 }

 //PCK: update the copy of the size
 m_subtreeHeaderCount = m_SubtreeHeaders.size();
}


int	btQuantizedBvh::sortAndCalcSplittingIndex(int startIndex, int endIndex, int splitAxis)
{
 int i;
 int splitIndex = startIndex;
 int numIndices = endIndex - startIndex;
 btScalar splitValue;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(getAabbMax(i) + getAabbMin(i));
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 splitValue = means[splitAxis];

 //sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(getAabbMax(i) + getAabbMin(i));
  if (center[splitAxis] > splitValue)
  {
   //swap
   swapLeafNodes(i, splitIndex);
   splitIndex++;
  }
 }

 //if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
 //otherwise the tree-building might fail due to stack-overflows in certain cases.
 //unbalanced1 is unsafe: it can cause stack overflows
 //bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));

 //unbalanced2 should work too: always use center (perfect balanced trees)	
 //bool unbalanced2 = true;

 //this should be safe too:
 int rangeBalancedIndices = numIndices / 3;
 bool unbalanced = ((splitIndex <= (startIndex + rangeBalancedIndices)) || (splitIndex >= (endIndex - 1 - rangeBalancedIndices)));

 if (unbalanced)
 {
  splitIndex = startIndex + (numIndices >> 1);
 }

 bool unbal = (splitIndex == startIndex) || (splitIndex == (endIndex));
 (void)unbal;
 btAssert(!unbal);

 return splitIndex;
}


int	btQuantizedBvh::calcSplittingAxis(int startIndex, int endIndex)
{
 int i;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 btVector3 variance(btScalar(0.), btScalar(0.), btScalar(0.));
 int numIndices = endIndex - startIndex;

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(getAabbMax(i) + getAabbMin(i));
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(getAabbMax(i) + getAabbMin(i));
  btVector3 diff2 = center - means;
  diff2 = diff2 * diff2;
  variance += diff2;
 }
 variance *= (btScalar(1.) / ((btScalar)numIndices - 1));

 return variance.maxAxis();
}



void	btQuantizedBvh::reportAabbOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 //either choose recursive traversal (walkTree) or stackless (walkStacklessTree)

 if (m_useQuantization)
 {
  ///quantize query AABB
  unsigned short int quantizedQueryAabbMin[3];
  unsigned short int quantizedQueryAabbMax[3];
  quantizeWithClamp(quantizedQueryAabbMin, aabbMin, 0);
  quantizeWithClamp(quantizedQueryAabbMax, aabbMax, 1);

  switch (m_traversalMode)
  {
  case TRAVERSAL_STACKLESS:
   walkStacklessQuantizedTree(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax, 0, m_curNodeIndex);
   break;
  case TRAVERSAL_STACKLESS_CACHE_FRIENDLY:
   walkStacklessQuantizedTreeCacheFriendly(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
   break;
  case TRAVERSAL_RECURSIVE:
  {
   const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[0];
   walkRecursiveQuantizedTreeAgainstQueryAabb(rootNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
  }
  break;
  default:
   //unsupported
   btAssert(0);
  }
 }
 else
 {
  walkStacklessTree(nodeCallback, aabbMin, aabbMax);
 }
}


int maxIterations = 0;


void	btQuantizedBvh::walkStacklessTree(btNodeOverlapCallback* nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 btAssert(!m_useQuantization);

 const btOptimizedBvhNode* rootNode = &m_contiguousNodes[0];
 int escapeIndex, curIndex = 0;
 int walkIterations = 0;
 bool isLeafNode;
 //PCK: unsigned instead of bool
 unsigned aabbOverlap;

 while (curIndex < m_curNodeIndex)
 {
  //catch bugs in tree data
  btAssert(walkIterations < m_curNodeIndex);

  walkIterations++;
  aabbOverlap = TestAabbAgainstAabb2(aabbMin, aabbMax, rootNode->m_aabbMinOrg, rootNode->m_aabbMaxOrg);
  isLeafNode = rootNode->m_escapeIndex == -1;

  //PCK: unsigned instead of bool
  if (isLeafNode && (aabbOverlap != 0))
  {
   nodeCallback->processNode(rootNode->m_subPart, rootNode->m_triangleIndex);
  }

  //PCK: unsigned instead of bool
  if ((aabbOverlap != 0) || isLeafNode)
  {
   rootNode++;
   curIndex++;
  }
  else
  {
   escapeIndex = rootNode->m_escapeIndex;
   rootNode += escapeIndex;
   curIndex += escapeIndex;
  }
 }
 if (maxIterations < walkIterations)
  maxIterations = walkIterations;

}

/*
///this was the original recursive traversal, before we optimized towards stackless traversal
void	btQuantizedBvh::walkTree(btOptimizedBvhNode* rootNode,btNodeOverlapCallback* nodeCallback,const btVector3& aabbMin,const btVector3& aabbMax) const
{
bool isLeafNode, aabbOverlap = TestAabbAgainstAabb2(aabbMin,aabbMax,rootNode->m_aabbMin,rootNode->m_aabbMax);
if (aabbOverlap)
{
isLeafNode = (!rootNode->m_leftChild && !rootNode->m_rightChild);
if (isLeafNode)
{
nodeCallback->processNode(rootNode);
} else
{
walkTree(rootNode->m_leftChild,nodeCallback,aabbMin,aabbMax);
walkTree(rootNode->m_rightChild,nodeCallback,aabbMin,aabbMax);
}
}

}
*/

void btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQueryAabb(const btQuantizedBvhNode* currentNode, btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const
{
 btAssert(m_useQuantization);

 bool isLeafNode;
 //PCK: unsigned instead of bool
 unsigned aabbOverlap;

 //PCK: unsigned instead of bool
 aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, currentNode->m_quantizedAabbMin, currentNode->m_quantizedAabbMax);
 isLeafNode = currentNode->isLeafNode();

 //PCK: unsigned instead of bool
 if (aabbOverlap != 0)
 {
  if (isLeafNode)
  {
   nodeCallback->processNode(currentNode->getPartId(), currentNode->getTriangleIndex());
  }
  else
  {
   //process left and right children
   const btQuantizedBvhNode* leftChildNode = currentNode + 1;
   walkRecursiveQuantizedTreeAgainstQueryAabb(leftChildNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);

   const btQuantizedBvhNode* rightChildNode = leftChildNode->isLeafNode() ? leftChildNode + 1 : leftChildNode + leftChildNode->getEscapeIndex();
   walkRecursiveQuantizedTreeAgainstQueryAabb(rightChildNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
  }
 }
}



void	btQuantizedBvh::walkStacklessTreeAgainstRay(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const
{
 btAssert(!m_useQuantization);

 const btOptimizedBvhNode* rootNode = &m_contiguousNodes[0];
 int escapeIndex, curIndex = 0;
 int walkIterations = 0;
 bool isLeafNode;
 //PCK: unsigned instead of bool
 unsigned aabbOverlap = 0;
 unsigned rayBoxOverlap = 0;
 btScalar lambda_max = 1.0;

 /* Quick pruning by quantized box */
 btVector3 rayAabbMin = raySource;
 btVector3 rayAabbMax = raySource;
 rayAabbMin.setMin(rayTarget);
 rayAabbMax.setMax(rayTarget);

 /* Add box cast extents to bounding box */
 rayAabbMin += aabbMin;
 rayAabbMax += aabbMax;

#ifdef RAYAABB2
 btVector3 rayDir = (rayTarget - raySource);
 rayDir.normalize();
 lambda_max = rayDir.dot(rayTarget - raySource);
 ///what about division by zero? --> just set rayDirection[i] to 1.0
 btVector3 rayDirectionInverse;
 rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
 rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
 rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
 unsigned int sign[3] = { rayDirectionInverse[0] < 0.0, rayDirectionInverse[1] < 0.0, rayDirectionInverse[2] < 0.0 };
#endif

 btVector3 bounds[2];

 while (curIndex < m_curNodeIndex)
 {
  btScalar param = 1.0;
  //catch bugs in tree data
  btAssert(walkIterations < m_curNodeIndex);

  walkIterations++;

  bounds[0] = rootNode->m_aabbMinOrg;
  bounds[1] = rootNode->m_aabbMaxOrg;
  /* Add box cast extents */
  bounds[0] -= aabbMax;
  bounds[1] -= aabbMin;

  aabbOverlap = TestAabbAgainstAabb2(rayAabbMin, rayAabbMax, rootNode->m_aabbMinOrg, rootNode->m_aabbMaxOrg);
  //perhaps profile if it is worth doing the aabbOverlap test first

#ifdef RAYAABB2
  ///careful with this check: need to check division by zero (above) and fix the unQuantize method
  ///thanks Joerg/hiker for the reproduction case!
  ///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858
  rayBoxOverlap = aabbOverlap ? btRayAabb2(raySource, rayDirectionInverse, sign, bounds, param, 0.0f, lambda_max) : false;

#else
  btVector3 normal;
  rayBoxOverlap = btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
#endif

  isLeafNode = rootNode->m_escapeIndex == -1;

  //PCK: unsigned instead of bool
  if (isLeafNode && (rayBoxOverlap != 0))
  {
   nodeCallback->processNode(rootNode->m_subPart, rootNode->m_triangleIndex);
  }

  //PCK: unsigned instead of bool
  if ((rayBoxOverlap != 0) || isLeafNode)
  {
   rootNode++;
   curIndex++;
  }
  else
  {
   escapeIndex = rootNode->m_escapeIndex;
   rootNode += escapeIndex;
   curIndex += escapeIndex;
  }
 }
 if (maxIterations < walkIterations)
  maxIterations = walkIterations;

}



void	btQuantizedBvh::walkStacklessQuantizedTreeAgainstRay(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const
{
 btAssert(m_useQuantization);

 int curIndex = startNodeIndex;
 int walkIterations = 0;
 int subTreeSize = endNodeIndex - startNodeIndex;
 (void)subTreeSize;

 const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[startNodeIndex];
 int escapeIndex;

 bool isLeafNode;
 //PCK: unsigned instead of bool
 unsigned boxBoxOverlap = 0;
 unsigned rayBoxOverlap = 0;

 btScalar lambda_max = 1.0;

#ifdef RAYAABB2
 btVector3 rayDirection = (rayTarget - raySource);
 rayDirection.normalize();
 lambda_max = rayDirection.dot(rayTarget - raySource);
 ///what about division by zero? --> just set rayDirection[i] to 1.0
 rayDirection[0] = rayDirection[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[0];
 rayDirection[1] = rayDirection[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[1];
 rayDirection[2] = rayDirection[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[2];
 unsigned int sign[3] = { rayDirection[0] < 0.0, rayDirection[1] < 0.0, rayDirection[2] < 0.0 };
#endif

 /* Quick pruning by quantized box */
 btVector3 rayAabbMin = raySource;
 btVector3 rayAabbMax = raySource;
 rayAabbMin.setMin(rayTarget);
 rayAabbMax.setMax(rayTarget);

 /* Add box cast extents to bounding box */
 rayAabbMin += aabbMin;
 rayAabbMax += aabbMax;

 unsigned short int quantizedQueryAabbMin[3];
 unsigned short int quantizedQueryAabbMax[3];
 quantizeWithClamp(quantizedQueryAabbMin, rayAabbMin, 0);
 quantizeWithClamp(quantizedQueryAabbMax, rayAabbMax, 1);

 while (curIndex < endNodeIndex)
 {

  //#define VISUALLY_ANALYZE_BVH 1
#ifdef VISUALLY_ANALYZE_BVH
  //some code snippet to debugDraw aabb, to visually analyze bvh structure
  static int drawPatch = 0;
  //need some global access to a debugDrawer
  extern btIDebugDraw* debugDrawerPtr;
  if (curIndex == drawPatch)
  {
   btVector3 aabbMin, aabbMax;
   aabbMin = unQuantize(rootNode->m_quantizedAabbMin);
   aabbMax = unQuantize(rootNode->m_quantizedAabbMax);
   btVector3	color(1, 0, 0);
   debugDrawerPtr->drawAabb(aabbMin, aabbMax, color);
  }
#endif//VISUALLY_ANALYZE_BVH

  //catch bugs in tree data
  btAssert(walkIterations < subTreeSize);

  walkIterations++;
  //PCK: unsigned instead of bool
  // only interested if this is closer than any previous hit
  btScalar param = 1.0;
  rayBoxOverlap = 0;
  boxBoxOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, rootNode->m_quantizedAabbMin, rootNode->m_quantizedAabbMax);
  isLeafNode = rootNode->isLeafNode();
  if (boxBoxOverlap)
  {
   btVector3 bounds[2];
   bounds[0] = unQuantize(rootNode->m_quantizedAabbMin);
   bounds[1] = unQuantize(rootNode->m_quantizedAabbMax);
   /* Add box cast extents */
   bounds[0] -= aabbMax;
   bounds[1] -= aabbMin;
   btVector3 normal;
#if 0
   bool ra2 = btRayAabb2(raySource, rayDirection, sign, bounds, param, 0.0, lambda_max);
   bool ra = btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
   if (ra2 != ra)
   {
    printf("functions don't match\n");
   }
#endif
#ifdef RAYAABB2
   ///careful with this check: need to check division by zero (above) and fix the unQuantize method
   ///thanks Joerg/hiker for the reproduction case!
   ///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858

   //BT_PROFILE("btRayAabb2");
   rayBoxOverlap = btRayAabb2(raySource, rayDirection, sign, bounds, param, 0.0f, lambda_max);

#else
   rayBoxOverlap = true;//btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
#endif
  }

  if (isLeafNode && rayBoxOverlap)
  {
   nodeCallback->processNode(rootNode->getPartId(), rootNode->getTriangleIndex());
  }

  //PCK: unsigned instead of bool
  if ((rayBoxOverlap != 0) || isLeafNode)
  {
   rootNode++;
   curIndex++;
  }
  else
  {
   escapeIndex = rootNode->getEscapeIndex();
   rootNode += escapeIndex;
   curIndex += escapeIndex;
  }
 }
 if (maxIterations < walkIterations)
  maxIterations = walkIterations;

}

void	btQuantizedBvh::walkStacklessQuantizedTree(btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax, int startNodeIndex, int endNodeIndex) const
{
 btAssert(m_useQuantization);

 int curIndex = startNodeIndex;
 int walkIterations = 0;
 int subTreeSize = endNodeIndex - startNodeIndex;
 (void)subTreeSize;

 const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[startNodeIndex];
 int escapeIndex;

 bool isLeafNode;
 //PCK: unsigned instead of bool
 unsigned aabbOverlap;

 while (curIndex < endNodeIndex)
 {

  //#define VISUALLY_ANALYZE_BVH 1
#ifdef VISUALLY_ANALYZE_BVH
  //some code snippet to debugDraw aabb, to visually analyze bvh structure
  static int drawPatch = 0;
  //need some global access to a debugDrawer
  extern btIDebugDraw* debugDrawerPtr;
  if (curIndex == drawPatch)
  {
   btVector3 aabbMin, aabbMax;
   aabbMin = unQuantize(rootNode->m_quantizedAabbMin);
   aabbMax = unQuantize(rootNode->m_quantizedAabbMax);
   btVector3	color(1, 0, 0);
   debugDrawerPtr->drawAabb(aabbMin, aabbMax, color);
  }
#endif//VISUALLY_ANALYZE_BVH

  //catch bugs in tree data
  btAssert(walkIterations < subTreeSize);

  walkIterations++;
  //PCK: unsigned instead of bool
  aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, rootNode->m_quantizedAabbMin, rootNode->m_quantizedAabbMax);
  isLeafNode = rootNode->isLeafNode();

  if (isLeafNode && aabbOverlap)
  {
   nodeCallback->processNode(rootNode->getPartId(), rootNode->getTriangleIndex());
  }

  //PCK: unsigned instead of bool
  if ((aabbOverlap != 0) || isLeafNode)
  {
   rootNode++;
   curIndex++;
  }
  else
  {
   escapeIndex = rootNode->getEscapeIndex();
   rootNode += escapeIndex;
   curIndex += escapeIndex;
  }
 }
 if (maxIterations < walkIterations)
  maxIterations = walkIterations;

}

//This traversal can be called from Playstation 3 SPU
void	btQuantizedBvh::walkStacklessQuantizedTreeCacheFriendly(btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const
{
 btAssert(m_useQuantization);

 int i;


 for (i = 0; i<this->m_SubtreeHeaders.size(); i++)
 {
  const btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];

  //PCK: unsigned instead of bool
  unsigned overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, subtree.m_quantizedAabbMin, subtree.m_quantizedAabbMax);
  if (overlap != 0)
  {
   walkStacklessQuantizedTree(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax,
    subtree.m_rootNodeIndex,
    subtree.m_rootNodeIndex + subtree.m_subtreeSize);
  }
 }
}


void	btQuantizedBvh::reportRayOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget) const
{
 reportBoxCastOverlappingNodex(nodeCallback, raySource, rayTarget, btVector3(0, 0, 0), btVector3(0, 0, 0));
}


void	btQuantizedBvh::reportBoxCastOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 //always use stackless

 if (m_useQuantization)
 {
  walkStacklessQuantizedTreeAgainstRay(nodeCallback, raySource, rayTarget, aabbMin, aabbMax, 0, m_curNodeIndex);
 }
 else
 {
  walkStacklessTreeAgainstRay(nodeCallback, raySource, rayTarget, aabbMin, aabbMax, 0, m_curNodeIndex);
 }
 /*
 {
 //recursive traversal
 btVector3 qaabbMin = raySource;
 btVector3 qaabbMax = raySource;
 qaabbMin.setMin(rayTarget);
 qaabbMax.setMax(rayTarget);
 qaabbMin += aabbMin;
 qaabbMax += aabbMax;
 reportAabbOverlappingNodex(nodeCallback,qaabbMin,qaabbMax);
 }
 */

}


void	btQuantizedBvh::swapLeafNodes(int i, int splitIndex)
{
 if (m_useQuantization)
 {
  btQuantizedBvhNode tmp = m_quantizedLeafNodes[i];
  m_quantizedLeafNodes[i] = m_quantizedLeafNodes[splitIndex];
  m_quantizedLeafNodes[splitIndex] = tmp;
 }
 else
 {
  btOptimizedBvhNode tmp = m_leafNodes[i];
  m_leafNodes[i] = m_leafNodes[splitIndex];
  m_leafNodes[splitIndex] = tmp;
 }
}

void	btQuantizedBvh::assignInternalNodeFromLeafNode(int internalNode, int leafNodeIndex)
{
 if (m_useQuantization)
 {
  m_quantizedContiguousNodes[internalNode] = m_quantizedLeafNodes[leafNodeIndex];
 }
 else
 {
  m_contiguousNodes[internalNode] = m_leafNodes[leafNodeIndex];
 }
}

//PCK: include
#include <new>

#if 0
//PCK: consts
static const unsigned BVH_ALIGNMENT = 16;
static const unsigned BVH_ALIGNMENT_MASK = BVH_ALIGNMENT - 1;

static const unsigned BVH_ALIGNMENT_BLOCKS = 2;
#endif


unsigned int btQuantizedBvh::getAlignmentSerializationPadding()
{
 // I changed this to 0 since the extra padding is not needed or used.
 return 0;//BVH_ALIGNMENT_BLOCKS * BVH_ALIGNMENT;
}

unsigned btQuantizedBvh::calculateSerializeBufferSize() const
{
 unsigned baseSize = sizeof(btQuantizedBvh) + getAlignmentSerializationPadding();
 baseSize += sizeof(btBvhSubtreeInfo) * m_subtreeHeaderCount;
 if (m_useQuantization)
 {
  return baseSize + m_curNodeIndex * sizeof(btQuantizedBvhNode);
 }
 return baseSize + m_curNodeIndex * sizeof(btOptimizedBvhNode);
}

bool btQuantizedBvh::serialize(void *o_alignedDataBuffer, unsigned /*i_dataBufferSize */, bool i_swapEndian) const
{
 btAssert(m_subtreeHeaderCount == m_SubtreeHeaders.size());
 m_subtreeHeaderCount = m_SubtreeHeaders.size();

 /*	if (i_dataBufferSize < calculateSerializeBufferSize() || o_alignedDataBuffer == NULL || (((unsigned)o_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
 {
 ///check alignedment for buffer?
 btAssert(0);
 return false;
 }
 */

 btQuantizedBvh *targetBvh = (btQuantizedBvh *)o_alignedDataBuffer;

 // construct the class so the virtual function table, etc will be set up
 // Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
 new (targetBvh) btQuantizedBvh;

 if (i_swapEndian)
 {
  targetBvh->m_curNodeIndex = static_cast<int>(btSwapEndian(m_curNodeIndex));


  btSwapVector3Endian(m_bvhAabbMin, targetBvh->m_bvhAabbMin);
  btSwapVector3Endian(m_bvhAabbMax, targetBvh->m_bvhAabbMax);
  btSwapVector3Endian(m_bvhQuantization, targetBvh->m_bvhQuantization);

  targetBvh->m_traversalMode = (btTraversalMode)btSwapEndian(m_traversalMode);
  targetBvh->m_subtreeHeaderCount = static_cast<int>(btSwapEndian(m_subtreeHeaderCount));
 }
 else
 {
  targetBvh->m_curNodeIndex = m_curNodeIndex;
  targetBvh->m_bvhAabbMin = m_bvhAabbMin;
  targetBvh->m_bvhAabbMax = m_bvhAabbMax;
  targetBvh->m_bvhQuantization = m_bvhQuantization;
  targetBvh->m_traversalMode = m_traversalMode;
  targetBvh->m_subtreeHeaderCount = m_subtreeHeaderCount;
 }

 targetBvh->m_useQuantization = m_useQuantization;

 unsigned char *nodeData = (unsigned char *)targetBvh;
 nodeData += sizeof(btQuantizedBvh);

 unsigned sizeToAdd = 0;//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
 nodeData += sizeToAdd;

 int nodeCount = m_curNodeIndex;

 if (m_useQuantization)
 {
  targetBvh->m_quantizedContiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

  if (i_swapEndian)
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0]);
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1]);
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2]);

    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0]);
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1]);
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2]);

    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = static_cast<int>(btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex));
   }
  }
  else
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {

    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0];
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1];
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2];

    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0];
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1];
    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2];

    targetBvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex;


   }
  }
  nodeData += sizeof(btQuantizedBvhNode) * nodeCount;

  // this clears the pointer in the member variable it doesn't really do anything to the data
  // it does call the destructor on the contained objects, but they are all classes with no destructor defined
  // so the memory (which is not freed) is left alone
  targetBvh->m_quantizedContiguousNodes.initializeFromBuffer(NULL, 0, 0);
 }
 else
 {
  targetBvh->m_contiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

  if (i_swapEndian)
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {
    btSwapVector3Endian(m_contiguousNodes[nodeIndex].m_aabbMinOrg, targetBvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg);
    btSwapVector3Endian(m_contiguousNodes[nodeIndex].m_aabbMaxOrg, targetBvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg);

    targetBvh->m_contiguousNodes[nodeIndex].m_escapeIndex = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_escapeIndex));
    targetBvh->m_contiguousNodes[nodeIndex].m_subPart = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_subPart));
    targetBvh->m_contiguousNodes[nodeIndex].m_triangleIndex = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_triangleIndex));
   }
  }
  else
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {
    targetBvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg = m_contiguousNodes[nodeIndex].m_aabbMinOrg;
    targetBvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg = m_contiguousNodes[nodeIndex].m_aabbMaxOrg;

    targetBvh->m_contiguousNodes[nodeIndex].m_escapeIndex = m_contiguousNodes[nodeIndex].m_escapeIndex;
    targetBvh->m_contiguousNodes[nodeIndex].m_subPart = m_contiguousNodes[nodeIndex].m_subPart;
    targetBvh->m_contiguousNodes[nodeIndex].m_triangleIndex = m_contiguousNodes[nodeIndex].m_triangleIndex;
   }
  }
  nodeData += sizeof(btOptimizedBvhNode) * nodeCount;

  // this clears the pointer in the member variable it doesn't really do anything to the data
  // it does call the destructor on the contained objects, but they are all classes with no destructor defined
  // so the memory (which is not freed) is left alone
  targetBvh->m_contiguousNodes.initializeFromBuffer(NULL, 0, 0);
 }

 sizeToAdd = 0;//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
 nodeData += sizeToAdd;

 // Now serialize the subtree headers
 targetBvh->m_SubtreeHeaders.initializeFromBuffer(nodeData, m_subtreeHeaderCount, m_subtreeHeaderCount);
 if (i_swapEndian)
 {
  for (int i = 0; i < m_subtreeHeaderCount; i++)
  {
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

   targetBvh->m_SubtreeHeaders[i].m_rootNodeIndex = static_cast<int>(btSwapEndian(m_SubtreeHeaders[i].m_rootNodeIndex));
   targetBvh->m_SubtreeHeaders[i].m_subtreeSize = static_cast<int>(btSwapEndian(m_SubtreeHeaders[i].m_subtreeSize));
  }
 }
 else
 {
  for (int i = 0; i < m_subtreeHeaderCount; i++)
  {
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = (m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = (m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = (m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = (m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = (m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
   targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = (m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

   targetBvh->m_SubtreeHeaders[i].m_rootNodeIndex = (m_SubtreeHeaders[i].m_rootNodeIndex);
   targetBvh->m_SubtreeHeaders[i].m_subtreeSize = (m_SubtreeHeaders[i].m_subtreeSize);

   // need to clear padding in destination buffer
   targetBvh->m_SubtreeHeaders[i].m_padding[0] = 0;
   targetBvh->m_SubtreeHeaders[i].m_padding[1] = 0;
   targetBvh->m_SubtreeHeaders[i].m_padding[2] = 0;
  }
 }
 nodeData += sizeof(btBvhSubtreeInfo) * m_subtreeHeaderCount;

 // this clears the pointer in the member variable it doesn't really do anything to the data
 // it does call the destructor on the contained objects, but they are all classes with no destructor defined
 // so the memory (which is not freed) is left alone
 targetBvh->m_SubtreeHeaders.initializeFromBuffer(NULL, 0, 0);

 // this wipes the virtual function table pointer at the start of the buffer for the class
 *((void**)o_alignedDataBuffer) = NULL;

 return true;
}

btQuantizedBvh *btQuantizedBvh::deSerializeInPlace(void *i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian)
{

 if (i_alignedDataBuffer == NULL)// || (((unsigned)i_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
 {
  return NULL;
 }
 btQuantizedBvh *bvh = (btQuantizedBvh *)i_alignedDataBuffer;

 if (i_swapEndian)
 {
  bvh->m_curNodeIndex = static_cast<int>(btSwapEndian(bvh->m_curNodeIndex));

  btUnSwapVector3Endian(bvh->m_bvhAabbMin);
  btUnSwapVector3Endian(bvh->m_bvhAabbMax);
  btUnSwapVector3Endian(bvh->m_bvhQuantization);

  bvh->m_traversalMode = (btTraversalMode)btSwapEndian(bvh->m_traversalMode);
  bvh->m_subtreeHeaderCount = static_cast<int>(btSwapEndian(bvh->m_subtreeHeaderCount));
 }

 unsigned int calculatedBufSize = bvh->calculateSerializeBufferSize();
 btAssert(calculatedBufSize <= i_dataBufferSize);

 if (calculatedBufSize > i_dataBufferSize)
 {
  return NULL;
 }

 unsigned char *nodeData = (unsigned char *)bvh;
 nodeData += sizeof(btQuantizedBvh);

 unsigned sizeToAdd = 0;//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
 nodeData += sizeToAdd;

 int nodeCount = bvh->m_curNodeIndex;

 // Must call placement new to fill in virtual function table, etc, but we don't want to overwrite most data, so call a special version of the constructor
 // Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
 new (bvh) btQuantizedBvh(*bvh, false);

 if (bvh->m_useQuantization)
 {
  bvh->m_quantizedContiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

  if (i_swapEndian)
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {
    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0]);
    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1]);
    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2]);

    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0]);
    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1]);
    bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2]);

    bvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = static_cast<int>(btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex));
   }
  }
  nodeData += sizeof(btQuantizedBvhNode) * nodeCount;
 }
 else
 {
  bvh->m_contiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

  if (i_swapEndian)
  {
   for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
   {
    btUnSwapVector3Endian(bvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg);
    btUnSwapVector3Endian(bvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg);

    bvh->m_contiguousNodes[nodeIndex].m_escapeIndex = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_escapeIndex));
    bvh->m_contiguousNodes[nodeIndex].m_subPart = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_subPart));
    bvh->m_contiguousNodes[nodeIndex].m_triangleIndex = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_triangleIndex));
   }
  }
  nodeData += sizeof(btOptimizedBvhNode) * nodeCount;
 }

 sizeToAdd = 0;//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
 nodeData += sizeToAdd;

 // Now serialize the subtree headers
 bvh->m_SubtreeHeaders.initializeFromBuffer(nodeData, bvh->m_subtreeHeaderCount, bvh->m_subtreeHeaderCount);
 if (i_swapEndian)
 {
  for (int i = 0; i < bvh->m_subtreeHeaderCount; i++)
  {
   bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
   bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
   bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

   bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
   bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
   bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

   bvh->m_SubtreeHeaders[i].m_rootNodeIndex = static_cast<int>(btSwapEndian(bvh->m_SubtreeHeaders[i].m_rootNodeIndex));
   bvh->m_SubtreeHeaders[i].m_subtreeSize = static_cast<int>(btSwapEndian(bvh->m_SubtreeHeaders[i].m_subtreeSize));
  }
 }

 return bvh;
}

// Constructor that prevents btVector3's default constructor from being called
btQuantizedBvh::btQuantizedBvh(btQuantizedBvh &self, bool /* ownsMemory */) :
 m_bvhAabbMin(self.m_bvhAabbMin),
 m_bvhAabbMax(self.m_bvhAabbMax),
 m_bvhQuantization(self.m_bvhQuantization),
 m_bulletVersion(BT_BULLET_VERSION)
{

}

void btQuantizedBvh::deSerializeFloat(struct btQuantizedBvhFloatData& quantizedBvhFloatData)
{
 m_bvhAabbMax.deSerializeFloat(quantizedBvhFloatData.m_bvhAabbMax);
 m_bvhAabbMin.deSerializeFloat(quantizedBvhFloatData.m_bvhAabbMin);
 m_bvhQuantization.deSerializeFloat(quantizedBvhFloatData.m_bvhQuantization);

 m_curNodeIndex = quantizedBvhFloatData.m_curNodeIndex;
 m_useQuantization = quantizedBvhFloatData.m_useQuantization != 0;

 {
  int numElem = quantizedBvhFloatData.m_numContiguousLeafNodes;
  m_contiguousNodes.resize(numElem);

  if (numElem)
  {
   btOptimizedBvhNodeFloatData* memPtr = quantizedBvhFloatData.m_contiguousNodesPtr;

   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_contiguousNodes[i].m_aabbMaxOrg.deSerializeFloat(memPtr->m_aabbMaxOrg);
    m_contiguousNodes[i].m_aabbMinOrg.deSerializeFloat(memPtr->m_aabbMinOrg);
    m_contiguousNodes[i].m_escapeIndex = memPtr->m_escapeIndex;
    m_contiguousNodes[i].m_subPart = memPtr->m_subPart;
    m_contiguousNodes[i].m_triangleIndex = memPtr->m_triangleIndex;
   }
  }
 }

 {
  int numElem = quantizedBvhFloatData.m_numQuantizedContiguousNodes;
  m_quantizedContiguousNodes.resize(numElem);

  if (numElem)
  {
   btQuantizedBvhNodeData* memPtr = quantizedBvhFloatData.m_quantizedContiguousNodesPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex = memPtr->m_escapeIndexOrTriangleIndex;
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
   }
  }
 }

 m_traversalMode = btTraversalMode(quantizedBvhFloatData.m_traversalMode);

 {
  int numElem = quantizedBvhFloatData.m_numSubtreeHeaders;
  m_SubtreeHeaders.resize(numElem);
  if (numElem)
  {
   btBvhSubtreeInfoData* memPtr = quantizedBvhFloatData.m_subTreeInfoPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_SubtreeHeaders[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
    m_SubtreeHeaders[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
    m_SubtreeHeaders[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
    m_SubtreeHeaders[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
    m_SubtreeHeaders[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
    m_SubtreeHeaders[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
    m_SubtreeHeaders[i].m_rootNodeIndex = memPtr->m_rootNodeIndex;
    m_SubtreeHeaders[i].m_subtreeSize = memPtr->m_subtreeSize;
   }
  }
 }
}

void btQuantizedBvh::deSerializeDouble(struct btQuantizedBvhDoubleData& quantizedBvhDoubleData)
{
 m_bvhAabbMax.deSerializeDouble(quantizedBvhDoubleData.m_bvhAabbMax);
 m_bvhAabbMin.deSerializeDouble(quantizedBvhDoubleData.m_bvhAabbMin);
 m_bvhQuantization.deSerializeDouble(quantizedBvhDoubleData.m_bvhQuantization);

 m_curNodeIndex = quantizedBvhDoubleData.m_curNodeIndex;
 m_useQuantization = quantizedBvhDoubleData.m_useQuantization != 0;

 {
  int numElem = quantizedBvhDoubleData.m_numContiguousLeafNodes;
  m_contiguousNodes.resize(numElem);

  if (numElem)
  {
   btOptimizedBvhNodeDoubleData* memPtr = quantizedBvhDoubleData.m_contiguousNodesPtr;

   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_contiguousNodes[i].m_aabbMaxOrg.deSerializeDouble(memPtr->m_aabbMaxOrg);
    m_contiguousNodes[i].m_aabbMinOrg.deSerializeDouble(memPtr->m_aabbMinOrg);
    m_contiguousNodes[i].m_escapeIndex = memPtr->m_escapeIndex;
    m_contiguousNodes[i].m_subPart = memPtr->m_subPart;
    m_contiguousNodes[i].m_triangleIndex = memPtr->m_triangleIndex;
   }
  }
 }

 {
  int numElem = quantizedBvhDoubleData.m_numQuantizedContiguousNodes;
  m_quantizedContiguousNodes.resize(numElem);

  if (numElem)
  {
   btQuantizedBvhNodeData* memPtr = quantizedBvhDoubleData.m_quantizedContiguousNodesPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex = memPtr->m_escapeIndexOrTriangleIndex;
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
    m_quantizedContiguousNodes[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
    m_quantizedContiguousNodes[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
   }
  }
 }

 m_traversalMode = btTraversalMode(quantizedBvhDoubleData.m_traversalMode);

 {
  int numElem = quantizedBvhDoubleData.m_numSubtreeHeaders;
  m_SubtreeHeaders.resize(numElem);
  if (numElem)
  {
   btBvhSubtreeInfoData* memPtr = quantizedBvhDoubleData.m_subTreeInfoPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_SubtreeHeaders[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
    m_SubtreeHeaders[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
    m_SubtreeHeaders[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
    m_SubtreeHeaders[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
    m_SubtreeHeaders[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
    m_SubtreeHeaders[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
    m_SubtreeHeaders[i].m_rootNodeIndex = memPtr->m_rootNodeIndex;
    m_SubtreeHeaders[i].m_subtreeSize = memPtr->m_subtreeSize;
   }
  }
 }

}



///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btQuantizedBvh::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btQuantizedBvhData* quantizedData = (btQuantizedBvhData*)dataBuffer;

 m_bvhAabbMax.serialize(quantizedData->m_bvhAabbMax);
 m_bvhAabbMin.serialize(quantizedData->m_bvhAabbMin);
 m_bvhQuantization.serialize(quantizedData->m_bvhQuantization);

 quantizedData->m_curNodeIndex = m_curNodeIndex;
 quantizedData->m_useQuantization = m_useQuantization;

 quantizedData->m_numContiguousLeafNodes = m_contiguousNodes.size();
 quantizedData->m_contiguousNodesPtr = (btOptimizedBvhNodeData*)(m_contiguousNodes.size() ? serializer->getUniquePointer((void*)&m_contiguousNodes[0]) : 0);
 if (quantizedData->m_contiguousNodesPtr)
 {
  int sz = sizeof(btOptimizedBvhNodeData);
  int numElem = m_contiguousNodes.size();
  btChunk* chunk = serializer->allocate(sz, numElem);
  btOptimizedBvhNodeData* memPtr = (btOptimizedBvhNodeData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   m_contiguousNodes[i].m_aabbMaxOrg.serialize(memPtr->m_aabbMaxOrg);
   m_contiguousNodes[i].m_aabbMinOrg.serialize(memPtr->m_aabbMinOrg);
   memPtr->m_escapeIndex = m_contiguousNodes[i].m_escapeIndex;
   memPtr->m_subPart = m_contiguousNodes[i].m_subPart;
   memPtr->m_triangleIndex = m_contiguousNodes[i].m_triangleIndex;
   // Fill padding with zeros to appease msan.
   memset(memPtr->m_pad, 0, sizeof(memPtr->m_pad));
  }
  serializer->finalizeChunk(chunk, "btOptimizedBvhNodeData", BT_ARRAY_CODE, (void*)&m_contiguousNodes[0]);
 }

 quantizedData->m_numQuantizedContiguousNodes = m_quantizedContiguousNodes.size();
 //	printf("quantizedData->m_numQuantizedContiguousNodes=%d\n",quantizedData->m_numQuantizedContiguousNodes);
 quantizedData->m_quantizedContiguousNodesPtr = (btQuantizedBvhNodeData*)(m_quantizedContiguousNodes.size() ? serializer->getUniquePointer((void*)&m_quantizedContiguousNodes[0]) : 0);
 if (quantizedData->m_quantizedContiguousNodesPtr)
 {
  int sz = sizeof(btQuantizedBvhNodeData);
  int numElem = m_quantizedContiguousNodes.size();
  btChunk* chunk = serializer->allocate(sz, numElem);
  btQuantizedBvhNodeData* memPtr = (btQuantizedBvhNodeData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_escapeIndexOrTriangleIndex = m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex;
   memPtr->m_quantizedAabbMax[0] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[0];
   memPtr->m_quantizedAabbMax[1] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[1];
   memPtr->m_quantizedAabbMax[2] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[2];
   memPtr->m_quantizedAabbMin[0] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[0];
   memPtr->m_quantizedAabbMin[1] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[1];
   memPtr->m_quantizedAabbMin[2] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[2];
  }
  serializer->finalizeChunk(chunk, "btQuantizedBvhNodeData", BT_ARRAY_CODE, (void*)&m_quantizedContiguousNodes[0]);
 }

 quantizedData->m_traversalMode = int(m_traversalMode);
 quantizedData->m_numSubtreeHeaders = m_SubtreeHeaders.size();

 quantizedData->m_subTreeInfoPtr = (btBvhSubtreeInfoData*)(m_SubtreeHeaders.size() ? serializer->getUniquePointer((void*)&m_SubtreeHeaders[0]) : 0);
 if (quantizedData->m_subTreeInfoPtr)
 {
  int sz = sizeof(btBvhSubtreeInfoData);
  int numElem = m_SubtreeHeaders.size();
  btChunk* chunk = serializer->allocate(sz, numElem);
  btBvhSubtreeInfoData* memPtr = (btBvhSubtreeInfoData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_quantizedAabbMax[0] = m_SubtreeHeaders[i].m_quantizedAabbMax[0];
   memPtr->m_quantizedAabbMax[1] = m_SubtreeHeaders[i].m_quantizedAabbMax[1];
   memPtr->m_quantizedAabbMax[2] = m_SubtreeHeaders[i].m_quantizedAabbMax[2];
   memPtr->m_quantizedAabbMin[0] = m_SubtreeHeaders[i].m_quantizedAabbMin[0];
   memPtr->m_quantizedAabbMin[1] = m_SubtreeHeaders[i].m_quantizedAabbMin[1];
   memPtr->m_quantizedAabbMin[2] = m_SubtreeHeaders[i].m_quantizedAabbMin[2];

   memPtr->m_rootNodeIndex = m_SubtreeHeaders[i].m_rootNodeIndex;
   memPtr->m_subtreeSize = m_SubtreeHeaders[i].m_subtreeSize;
  }
  serializer->finalizeChunk(chunk, "btBvhSubtreeInfoData", BT_ARRAY_CODE, (void*)&m_SubtreeHeaders[0]);
 }
 return btQuantizedBvhDataName;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btMatrix3x3.h"
#include "LinearMath/btAabbUtil2.h"

#include <new>

extern int gOverlappingPairs;

void	btSimpleBroadphase::validate()
{
 for (int i = 0; i<m_numHandles; i++)
 {
  for (int j = i + 1; j<m_numHandles; j++)
  {
   btAssert(&m_pHandles[i] != &m_pHandles[j]);
  }
 }

}

btSimpleBroadphase::btSimpleBroadphase(int maxProxies, btOverlappingPairCache* overlappingPairCache)
 :m_pairCache(overlappingPairCache),
 m_ownsPairCache(false),
 m_invalidPair(0)
{

 if (!overlappingPairCache)
 {
  void* mem = btAlignedAlloc(sizeof(btHashedOverlappingPairCache), 16);
  m_pairCache = new (mem)btHashedOverlappingPairCache();
  m_ownsPairCache = true;
 }

 // allocate handles buffer and put all handles on free list
 m_pHandlesRawPtr = btAlignedAlloc(sizeof(btSimpleBroadphaseProxy)*maxProxies, 16);
 m_pHandles = new(m_pHandlesRawPtr) btSimpleBroadphaseProxy[maxProxies];
 m_maxHandles = maxProxies;
 m_numHandles = 0;
 m_firstFreeHandle = 0;
 m_LastHandleIndex = -1;


 {
  for (int i = m_firstFreeHandle; i < maxProxies; i++)
  {
   m_pHandles[i].SetNextFree(i + 1);
   m_pHandles[i].m_uniqueId = i + 2;//any UID will do, we just avoid too trivial values (0,1) for debugging purposes
  }
  m_pHandles[maxProxies - 1].SetNextFree(0);

 }

}

btSimpleBroadphase::~btSimpleBroadphase()
{
 btAlignedFree(m_pHandlesRawPtr);

 if (m_ownsPairCache)
 {
  m_pairCache->~btOverlappingPairCache();
  btAlignedFree(m_pairCache);
 }
}


btBroadphaseProxy*	btSimpleBroadphase::createProxy(const btVector3& aabbMin, const btVector3& aabbMax, int shapeType, void* userPtr, int collisionFilterGroup, int collisionFilterMask, btDispatcher* /*dispatcher*/)
{
 if (m_numHandles >= m_maxHandles)
 {
  btAssert(0);
  return 0; //should never happen, but don't let the game crash ;-)
 }
 btAssert(aabbMin[0] <= aabbMax[0] && aabbMin[1] <= aabbMax[1] && aabbMin[2] <= aabbMax[2]);

 int newHandleIndex = allocHandle();
 btSimpleBroadphaseProxy* proxy = new (&m_pHandles[newHandleIndex])btSimpleBroadphaseProxy(aabbMin, aabbMax, shapeType, userPtr, collisionFilterGroup, collisionFilterMask);

 return proxy;
}

class	RemovingOverlapCallback : public btOverlapCallback
{
protected:
 virtual bool	processOverlap(btBroadphasePair& pair)
 {
  (void)pair;
  btAssert(0);
  return false;
 }
};

class RemovePairContainingProxy
{

 btBroadphaseProxy*	m_targetProxy;
public:
 virtual ~RemovePairContainingProxy()
 {
 }
protected:
 virtual bool processOverlap(btBroadphasePair& pair)
 {
  btSimpleBroadphaseProxy* proxy0 = static_cast<btSimpleBroadphaseProxy*>(pair.m_pProxy0);
  btSimpleBroadphaseProxy* proxy1 = static_cast<btSimpleBroadphaseProxy*>(pair.m_pProxy1);

  return ((m_targetProxy == proxy0 || m_targetProxy == proxy1));
 };
};

void	btSimpleBroadphase::destroyProxy(btBroadphaseProxy* proxyOrg, btDispatcher* dispatcher)
{

 btSimpleBroadphaseProxy* proxy0 = static_cast<btSimpleBroadphaseProxy*>(proxyOrg);
 freeHandle(proxy0);

 m_pairCache->removeOverlappingPairsContainingProxy(proxyOrg, dispatcher);

 //validate();

}

void	btSimpleBroadphase::getAabb(btBroadphaseProxy* proxy, btVector3& aabbMin, btVector3& aabbMax) const
{
 const btSimpleBroadphaseProxy* sbp = getSimpleProxyFromProxy(proxy);
 aabbMin = sbp->m_aabbMin;
 aabbMax = sbp->m_aabbMax;
}

void	btSimpleBroadphase::setAabb(btBroadphaseProxy* proxy, const btVector3& aabbMin, const btVector3& aabbMax, btDispatcher* /*dispatcher*/)
{
 btSimpleBroadphaseProxy* sbp = getSimpleProxyFromProxy(proxy);
 sbp->m_aabbMin = aabbMin;
 sbp->m_aabbMax = aabbMax;
}

void	btSimpleBroadphase::rayTest(const btVector3& rayFrom, const btVector3& rayTo, btBroadphaseRayCallback& rayCallback, const btVector3& aabbMin, const btVector3& aabbMax)
{
 for (int i = 0; i <= m_LastHandleIndex; i++)
 {
  btSimpleBroadphaseProxy* proxy = &m_pHandles[i];
  if (!proxy->m_clientObject)
  {
   continue;
  }
  rayCallback.process(proxy);
 }
}


void	btSimpleBroadphase::aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback)
{
 for (int i = 0; i <= m_LastHandleIndex; i++)
 {
  btSimpleBroadphaseProxy* proxy = &m_pHandles[i];
  if (!proxy->m_clientObject)
  {
   continue;
  }
  if (TestAabbAgainstAabb2(aabbMin, aabbMax, proxy->m_aabbMin, proxy->m_aabbMax))
  {
   callback.process(proxy);
  }
 }
}







bool	btSimpleBroadphase::aabbOverlap(btSimpleBroadphaseProxy* proxy0, btSimpleBroadphaseProxy* proxy1)
{
 return proxy0->m_aabbMin[0] <= proxy1->m_aabbMax[0] && proxy1->m_aabbMin[0] <= proxy0->m_aabbMax[0] &&
  proxy0->m_aabbMin[1] <= proxy1->m_aabbMax[1] && proxy1->m_aabbMin[1] <= proxy0->m_aabbMax[1] &&
  proxy0->m_aabbMin[2] <= proxy1->m_aabbMax[2] && proxy1->m_aabbMin[2] <= proxy0->m_aabbMax[2];

}



//then remove non-overlapping ones
class CheckOverlapCallback : public btOverlapCallback
{
public:
 virtual bool processOverlap(btBroadphasePair& pair)
 {
  return (!btSimpleBroadphase::aabbOverlap(static_cast<btSimpleBroadphaseProxy*>(pair.m_pProxy0), static_cast<btSimpleBroadphaseProxy*>(pair.m_pProxy1)));
 }
};

void	btSimpleBroadphase::calculateOverlappingPairs(btDispatcher* dispatcher)
{
 //first check for new overlapping pairs
 int i, j;
 if (m_numHandles >= 0)
 {
  int new_largest_index = -1;
  for (i = 0; i <= m_LastHandleIndex; i++)
  {
   btSimpleBroadphaseProxy* proxy0 = &m_pHandles[i];
   if (!proxy0->m_clientObject)
   {
    continue;
   }
   new_largest_index = i;
   for (j = i + 1; j <= m_LastHandleIndex; j++)
   {
    btSimpleBroadphaseProxy* proxy1 = &m_pHandles[j];
    btAssert(proxy0 != proxy1);
    if (!proxy1->m_clientObject)
    {
     continue;
    }

    btSimpleBroadphaseProxy* p0 = getSimpleProxyFromProxy(proxy0);
    btSimpleBroadphaseProxy* p1 = getSimpleProxyFromProxy(proxy1);

    if (aabbOverlap(p0, p1))
    {
     if (!m_pairCache->findPair(proxy0, proxy1))
     {
      m_pairCache->addOverlappingPair(proxy0, proxy1);
     }
    }
    else
    {
     if (!m_pairCache->hasDeferredRemoval())
     {
      if (m_pairCache->findPair(proxy0, proxy1))
      {
       m_pairCache->removeOverlappingPair(proxy0, proxy1, dispatcher);
      }
     }
    }
   }
  }

  m_LastHandleIndex = new_largest_index;

  if (m_ownsPairCache && m_pairCache->hasDeferredRemoval())
  {

   btBroadphasePairArray&	overlappingPairArray = m_pairCache->getOverlappingPairArray();

   //perform a sort, to find duplicates and to sort 'invalid' pairs to the end
   overlappingPairArray.quickSort(btBroadphasePairSortPredicate());

   overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
   m_invalidPair = 0;


   btBroadphasePair previousPair;
   previousPair.m_pProxy0 = 0;
   previousPair.m_pProxy1 = 0;
   previousPair.m_algorithm = 0;


   for (i = 0; i<overlappingPairArray.size(); i++)
   {

    btBroadphasePair& pair = overlappingPairArray[i];

    bool isDuplicate = (pair == previousPair);

    previousPair = pair;

    bool needsRemoval = false;

    if (!isDuplicate)
    {
     bool hasOverlap = testAabbOverlap(pair.m_pProxy0, pair.m_pProxy1);

     if (hasOverlap)
     {
      needsRemoval = false;//callback->processOverlap(pair);
     }
     else
     {
      needsRemoval = true;
     }
    }
    else
    {
     //remove duplicate
     needsRemoval = true;
     //should have no algorithm
     btAssert(!pair.m_algorithm);
    }

    if (needsRemoval)
    {
     m_pairCache->cleanOverlappingPair(pair, dispatcher);

     //		m_overlappingPairArray.swap(i,m_overlappingPairArray.size()-1);
     //		m_overlappingPairArray.pop_back();
     pair.m_pProxy0 = 0;
     pair.m_pProxy1 = 0;
     m_invalidPair++;
     gOverlappingPairs--;
    }

   }

   ///if you don't like to skip the invalid pairs in the array, execute following code:
#define CLEAN_INVALID_PAIRS 1
#ifdef CLEAN_INVALID_PAIRS

   //perform a sort, to sort 'invalid' pairs to the end
   overlappingPairArray.quickSort(btBroadphasePairSortPredicate());

   overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
   m_invalidPair = 0;
#endif//CLEAN_INVALID_PAIRS

  }
 }
}


bool btSimpleBroadphase::testAabbOverlap(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
 btSimpleBroadphaseProxy* p0 = getSimpleProxyFromProxy(proxy0);
 btSimpleBroadphaseProxy* p1 = getSimpleProxyFromProxy(proxy1);
 return aabbOverlap(p0, p1);
}

void	btSimpleBroadphase::resetPool(btDispatcher* dispatcher)
{
 //not yet
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  http://bulletphysics.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

btActivatingCollisionAlgorithm::btActivatingCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci)
 :btCollisionAlgorithm(ci)
 //,
 //m_colObj0(0),
 //m_colObj1(0)
{
}
btActivatingCollisionAlgorithm::btActivatingCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper*, const btCollisionObjectWrapper*)
 :btCollisionAlgorithm(ci)
 //,
 //m_colObj0(0),
 //m_colObj1(0)
{
 //	if (ci.m_dispatcher1->needsCollision(colObj0,colObj1))
 //	{
 //		m_colObj0 = colObj0;
 //		m_colObj1 = colObj1;
 //		
 //		m_colObj0->activate();
 //		m_colObj1->activate();
 //	}
}

btActivatingCollisionAlgorithm::~btActivatingCollisionAlgorithm()
{
 //		m_colObj0->activate();
 //		m_colObj1->activate();
}
/*
Bullet Continuous Collision Detection and Physics Library
* The b2CollidePolygons routines are Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///btBox2dBox2dCollisionAlgorithm, with modified b2CollidePolygons routines from the Box2D library.
///The modifications include: switching from b2Vec to btVector3, redefinition of b2Dot, b2Cross

#include "BulletCollision/CollisionDispatch/btBox2dBox2dCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btBoxBoxDetector.h"
#include "BulletCollision/CollisionShapes/btBox2dShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

#define USE_PERSISTENT_CONTACTS 1

btBox2dBox2dCollisionAlgorithm::btBox2dBox2dCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* obj0Wrap, const btCollisionObjectWrapper* obj1Wrap)
 : btActivatingCollisionAlgorithm(ci, obj0Wrap, obj1Wrap),
 m_ownManifold(false),
 m_manifoldPtr(mf)
{
 if (!m_manifoldPtr && m_dispatcher->needsCollision(obj0Wrap->getCollisionObject(), obj1Wrap->getCollisionObject()))
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(obj0Wrap->getCollisionObject(), obj1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
}

btBox2dBox2dCollisionAlgorithm::~btBox2dBox2dCollisionAlgorithm()
{

 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }

}


void b2CollidePolygons(btManifoldResult* manifold, const btBox2dShape* polyA, const btTransform& xfA, const btBox2dShape* polyB, const btTransform& xfB);

//#include <stdio.h>
void btBox2dBox2dCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 if (!m_manifoldPtr)
  return;


 const btBox2dShape* box0 = (const btBox2dShape*)body0Wrap->getCollisionShape();
 const btBox2dShape* box1 = (const btBox2dShape*)body1Wrap->getCollisionShape();

 resultOut->setPersistentManifold(m_manifoldPtr);

 b2CollidePolygons(resultOut, box0, body0Wrap->getWorldTransform(), box1, body1Wrap->getWorldTransform());

 //  refreshContactPoints is only necessary when using persistent contact points. otherwise all points are newly added
 if (m_ownManifold)
 {
  resultOut->refreshContactPoints();
 }

}

btScalar btBox2dBox2dCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* /*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
{
 //not yet
 return 1.f;
}


struct ClipVertex
{
 btVector3 v;
 int id;
 //b2ContactID id;
 //b2ContactID id;
};

#define b2Dot(a,b) (a).dot(b)
#define b2Mul(a,b) (a)*(b)
#define b2MulT(a,b) (a).transpose()*(b)
#define b2Cross(a,b) (a).cross(b)
#define btCrossS(a,s) btVector3(s * a.getY(), -s * a.getX(),0.f)

int b2_maxManifoldPoints = 2;

static int ClipSegmentToLine(ClipVertex vOut[2], ClipVertex vIn[2],
 const btVector3& normal, btScalar offset)
{
 // Start with no output points
 int numOut = 0;

 // Calculate the distance of end points to the line
 btScalar distance0 = b2Dot(normal, vIn[0].v) - offset;
 btScalar distance1 = b2Dot(normal, vIn[1].v) - offset;

 // If the points are behind the plane
 if (distance0 <= 0.0f) vOut[numOut++] = vIn[0];
 if (distance1 <= 0.0f) vOut[numOut++] = vIn[1];

 // If the points are on different sides of the plane
 if (distance0 * distance1 < 0.0f)
 {
  // Find intersection point of edge and plane
  btScalar interp = distance0 / (distance0 - distance1);
  vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
  if (distance0 > 0.0f)
  {
   vOut[numOut].id = vIn[0].id;
  }
  else
  {
   vOut[numOut].id = vIn[1].id;
  }
  ++numOut;
 }

 return numOut;
}

// Find the separation between poly1 and poly2 for a give edge normal on poly1.
static btScalar EdgeSeparation(const btBox2dShape* poly1, const btTransform& xf1, int edge1,
 const btBox2dShape* poly2, const btTransform& xf2)
{
 const btVector3* vertices1 = poly1->getVertices();
 const btVector3* normals1 = poly1->getNormals();

 int count2 = poly2->getVertexCount();
 const btVector3* vertices2 = poly2->getVertices();

 btAssert(0 <= edge1 && edge1 < poly1->getVertexCount());

 // Convert normal from poly1's frame into poly2's frame.
 btVector3 normal1World = b2Mul(xf1.getBasis(), normals1[edge1]);
 btVector3 normal1 = b2MulT(xf2.getBasis(), normal1World);

 // Find support vertex on poly2 for -normal.
 int index = 0;
 btScalar minDot = BT_LARGE_FLOAT;

 if (count2 > 0)
  index = (int)normal1.minDot(vertices2, count2, minDot);

 btVector3 v1 = b2Mul(xf1, vertices1[edge1]);
 btVector3 v2 = b2Mul(xf2, vertices2[index]);
 btScalar separation = b2Dot(v2 - v1, normal1World);
 return separation;
}

// Find the max separation between poly1 and poly2 using edge normals from poly1.
static btScalar FindMaxSeparation(int* edgeIndex,
 const btBox2dShape* poly1, const btTransform& xf1,
 const btBox2dShape* poly2, const btTransform& xf2)
{
 int count1 = poly1->getVertexCount();
 const btVector3* normals1 = poly1->getNormals();

 // Vector pointing from the centroid of poly1 to the centroid of poly2.
 btVector3 d = b2Mul(xf2, poly2->getCentroid()) - b2Mul(xf1, poly1->getCentroid());
 btVector3 dLocal1 = b2MulT(xf1.getBasis(), d);

 // Find edge normal on poly1 that has the largest projection onto d.
 int edge = 0;
 btScalar maxDot;
 if (count1 > 0)
  edge = (int)dLocal1.maxDot(normals1, count1, maxDot);

 // Get the separation for the edge normal.
 btScalar s = EdgeSeparation(poly1, xf1, edge, poly2, xf2);
 if (s > 0.0f)
 {
  return s;
 }

 // Check the separation for the previous edge normal.
 int prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
 btScalar sPrev = EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
 if (sPrev > 0.0f)
 {
  return sPrev;
 }

 // Check the separation for the next edge normal.
 int nextEdge = edge + 1 < count1 ? edge + 1 : 0;
 btScalar sNext = EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
 if (sNext > 0.0f)
 {
  return sNext;
 }

 // Find the best edge and the search direction.
 int bestEdge;
 btScalar bestSeparation;
 int increment;
 if (sPrev > s && sPrev > sNext)
 {
  increment = -1;
  bestEdge = prevEdge;
  bestSeparation = sPrev;
 }
 else if (sNext > s)
 {
  increment = 1;
  bestEdge = nextEdge;
  bestSeparation = sNext;
 }
 else
 {
  *edgeIndex = edge;
  return s;
 }

 // Perform a local search for the best edge normal.
 for (; ; )
 {
  if (increment == -1)
   edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
  else
   edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;

  s = EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  if (s > 0.0f)
  {
   return s;
  }

  if (s > bestSeparation)
  {
   bestEdge = edge;
   bestSeparation = s;
  }
  else
  {
   break;
  }
 }

 *edgeIndex = bestEdge;
 return bestSeparation;
}

static void FindIncidentEdge(ClipVertex c[2],
 const btBox2dShape* poly1, const btTransform& xf1, int edge1,
 const btBox2dShape* poly2, const btTransform& xf2)
{
 const btVector3* normals1 = poly1->getNormals();

 int count2 = poly2->getVertexCount();
 const btVector3* vertices2 = poly2->getVertices();
 const btVector3* normals2 = poly2->getNormals();

 btAssert(0 <= edge1 && edge1 < poly1->getVertexCount());

 // Get the normal of the reference edge in poly2's frame.
 btVector3 normal1 = b2MulT(xf2.getBasis(), b2Mul(xf1.getBasis(), normals1[edge1]));

 // Find the incident edge on poly2.
 int index = 0;
 btScalar minDot = BT_LARGE_FLOAT;
 for (int i = 0; i < count2; ++i)
 {
  btScalar dot = b2Dot(normal1, normals2[i]);
  if (dot < minDot)
  {
   minDot = dot;
   index = i;
  }
 }

 // Build the clip vertices for the incident edge.
 int i1 = index;
 int i2 = i1 + 1 < count2 ? i1 + 1 : 0;

 c[0].v = b2Mul(xf2, vertices2[i1]);
 //	c[0].id.features.referenceEdge = (unsigned char)edge1;
 //	c[0].id.features.incidentEdge = (unsigned char)i1;
 //	c[0].id.features.incidentVertex = 0;

 c[1].v = b2Mul(xf2, vertices2[i2]);
 //	c[1].id.features.referenceEdge = (unsigned char)edge1;
 //	c[1].id.features.incidentEdge = (unsigned char)i2;
 //	c[1].id.features.incidentVertex = 1;
}

// Find edge normal of max separation on A - return if separating axis is found
// Find edge normal of max separation on B - return if separation axis is found
// Choose reference edge as min(minA, minB)
// Find incident edge
// Clip

// The normal points from 1 to 2
void b2CollidePolygons(btManifoldResult* manifold,
 const btBox2dShape* polyA, const btTransform& xfA,
 const btBox2dShape* polyB, const btTransform& xfB)
{

 int edgeA = 0;
 btScalar separationA = FindMaxSeparation(&edgeA, polyA, xfA, polyB, xfB);
 if (separationA > 0.0f)
  return;

 int edgeB = 0;
 btScalar separationB = FindMaxSeparation(&edgeB, polyB, xfB, polyA, xfA);
 if (separationB > 0.0f)
  return;

 const btBox2dShape* poly1;	// reference poly
 const btBox2dShape* poly2;	// incident poly
 btTransform xf1, xf2;
 int edge1;		// reference edge
 unsigned char flip;
 const btScalar k_relativeTol = 0.98f;
 const btScalar k_absoluteTol = 0.001f;

 // TODO_ERIN use "radius" of poly for absolute tolerance.
 if (separationB > k_relativeTol * separationA + k_absoluteTol)
 {
  poly1 = polyB;
  poly2 = polyA;
  xf1 = xfB;
  xf2 = xfA;
  edge1 = edgeB;
  flip = 1;
 }
 else
 {
  poly1 = polyA;
  poly2 = polyB;
  xf1 = xfA;
  xf2 = xfB;
  edge1 = edgeA;
  flip = 0;
 }

 ClipVertex incidentEdge[2];
 FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

 int count1 = poly1->getVertexCount();
 const btVector3* vertices1 = poly1->getVertices();

 btVector3 v11 = vertices1[edge1];
 btVector3 v12 = edge1 + 1 < count1 ? vertices1[edge1 + 1] : vertices1[0];

 //btVector3 dv = v12 - v11;
 btVector3 sideNormal = b2Mul(xf1.getBasis(), v12 - v11);
 sideNormal.normalize();
 btVector3 frontNormal = btCrossS(sideNormal, 1.0f);


 v11 = b2Mul(xf1, v11);
 v12 = b2Mul(xf1, v12);

 btScalar frontOffset = b2Dot(frontNormal, v11);
 btScalar sideOffset1 = -b2Dot(sideNormal, v11);
 btScalar sideOffset2 = b2Dot(sideNormal, v12);

 // Clip incident edge against extruded edge1 side edges.
 ClipVertex clipPoints1[2];
 clipPoints1[0].v.setValue(0, 0, 0);
 clipPoints1[1].v.setValue(0, 0, 0);

 ClipVertex clipPoints2[2];
 clipPoints2[0].v.setValue(0, 0, 0);
 clipPoints2[1].v.setValue(0, 0, 0);


 int np;

 // Clip to box side 1
 np = ClipSegmentToLine(clipPoints1, incidentEdge, -sideNormal, sideOffset1);

 if (np < 2)
  return;

 // Clip to negative box side 1
 np = ClipSegmentToLine(clipPoints2, clipPoints1, sideNormal, sideOffset2);

 if (np < 2)
 {
  return;
 }

 // Now clipPoints2 contains the clipped points.
 btVector3 manifoldNormal = flip ? -frontNormal : frontNormal;

 int pointCount = 0;
 for (int i = 0; i < b2_maxManifoldPoints; ++i)
 {
  btScalar separation = b2Dot(frontNormal, clipPoints2[i].v) - frontOffset;

  if (separation <= 0.0f)
  {

   //b2ManifoldPoint* cp = manifold->points + pointCount;
   //btScalar separation = separation;
   //cp->localPoint1 = b2MulT(xfA, clipPoints2[i].v);
   //cp->localPoint2 = b2MulT(xfB, clipPoints2[i].v);

   manifold->addContactPoint(-manifoldNormal, clipPoints2[i].v, separation);

   //			cp->id = clipPoints2[i].id;
   //			cp->id.features.flip = flip;
   ++pointCount;
  }
 }

 //	manifold->pointCount = pointCount;}
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btBoxBoxCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btBoxBoxDetector.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
#define USE_PERSISTENT_CONTACTS 1

btBoxBoxCollisionAlgorithm::btBoxBoxCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_ownManifold(false),
 m_manifoldPtr(mf)
{
 if (!m_manifoldPtr && m_dispatcher->needsCollision(body0Wrap->getCollisionObject(), body1Wrap->getCollisionObject()))
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(body0Wrap->getCollisionObject(), body1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
}

btBoxBoxCollisionAlgorithm::~btBoxBoxCollisionAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void btBoxBoxCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 if (!m_manifoldPtr)
  return;


 const btBoxShape* box0 = (btBoxShape*)body0Wrap->getCollisionShape();
 const btBoxShape* box1 = (btBoxShape*)body1Wrap->getCollisionShape();



 /// report a contact. internally this will be kept persistent, and contact reduction is done
 resultOut->setPersistentManifold(m_manifoldPtr);
#ifndef USE_PERSISTENT_CONTACTS	
 m_manifoldPtr->clearManifold();
#endif //USE_PERSISTENT_CONTACTS

 btDiscreteCollisionDetectorInterface::ClosestPointInput input;
 input.m_maximumDistanceSquared = BT_LARGE_FLOAT;
 input.m_transformA = body0Wrap->getWorldTransform();
 input.m_transformB = body1Wrap->getWorldTransform();

 btBoxBoxDetector detector(box0, box1);
 detector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw);

#ifdef USE_PERSISTENT_CONTACTS
 //  refreshContactPoints is only necessary when using persistent contact points. otherwise all points are newly added
 if (m_ownManifold)
 {
  resultOut->refreshContactPoints();
 }
#endif //USE_PERSISTENT_CONTACTS

}

btScalar btBoxBoxCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* /*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
{
 //not yet
 return 1.f;
}
/*
* Box-Box collision detection re-distributed under the ZLib license with permission from Russell L. Smith
* Original version is from Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.
* All rights reserved.  Email: russ@q12.org   Web: www.q12.org
Bullet Continuous Collision Detection and Physics Library
Bullet is Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///ODE box-box collision detection is adapted to work with Bullet

#include "BulletCollision/CollisionDispatch/btBoxBoxDetector.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"

#include <float.h>
#include <string.h>

btBoxBoxDetector::btBoxBoxDetector(const btBoxShape* box1, const btBoxShape* box2)
 : m_box1(box1),
 m_box2(box2)
{

}


// given two boxes (p1,R1,side1) and (p2,R2,side2), collide them together and
// generate contact points. this returns 0 if there is no contact otherwise
// it returns the number of contacts generated.
// `normal' returns the contact normal.
// `depth' returns the maximum penetration depth along that normal.
// `return_code' returns a number indicating the type of contact that was
// detected:
//        1,2,3 = box 2 intersects with a face of box 1
//        4,5,6 = box 1 intersects with a face of box 2
//        7..15 = edge-edge contact
// `maxc' is the maximum number of contacts allowed to be generated, i.e.
// the size of the `contact' array.
// `contact' and `skip' are the contact array information provided to the
// collision functions. this function only fills in the position and depth
// fields.
struct dContactGeom;
#define dDOTpq(a,b,p,q) ((a)[0]*(b)[0] + (a)[p]*(b)[q] + (a)[2*(p)]*(b)[2*(q)])
#define dInfinity FLT_MAX


/*PURE_INLINE btScalar dDOT   (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,1,1); }
PURE_INLINE btScalar dDOT13 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,1,3); }
PURE_INLINE btScalar dDOT31 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,3,1); }
PURE_INLINE btScalar dDOT33 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,3,3); }
*/
static btScalar dDOT(const btScalar *a, const btScalar *b) { return dDOTpq(a, b, 1, 1); }
static btScalar dDOT44(const btScalar *a, const btScalar *b) { return dDOTpq(a, b, 4, 4); }
static btScalar dDOT41(const btScalar *a, const btScalar *b) { return dDOTpq(a, b, 4, 1); }
static btScalar dDOT14(const btScalar *a, const btScalar *b) { return dDOTpq(a, b, 1, 4); }
#define dMULTIPLYOP1_331(A,op,B,C) \
{\
  (A)[0] op dDOT41((B),(C)); \
  (A)[1] op dDOT41((B+1),(C)); \
  (A)[2] op dDOT41((B+2),(C)); \
}

#define dMULTIPLYOP0_331(A,op,B,C) \
{ \
  (A)[0] op dDOT((B),(C)); \
  (A)[1] op dDOT((B+4),(C)); \
  (A)[2] op dDOT((B+8),(C)); \
} 

#define dMULTIPLY1_331(A,B,C) dMULTIPLYOP1_331(A,=,B,C)
#define dMULTIPLY0_331(A,B,C) dMULTIPLYOP0_331(A,=,B,C)

typedef btScalar dMatrix3[4 * 3];

void dLineClosestApproach(const btVector3& pa, const btVector3& ua,
 const btVector3& pb, const btVector3& ub,
 btScalar *alpha, btScalar *beta);
void dLineClosestApproach(const btVector3& pa, const btVector3& ua,
 const btVector3& pb, const btVector3& ub,
 btScalar *alpha, btScalar *beta)
{
 btVector3 p;
 p[0] = pb[0] - pa[0];
 p[1] = pb[1] - pa[1];
 p[2] = pb[2] - pa[2];
 btScalar uaub = dDOT(ua, ub);
 btScalar q1 = dDOT(ua, p);
 btScalar q2 = -dDOT(ub, p);
 btScalar d = 1 - uaub*uaub;
 if (d <= btScalar(0.0001f)) {
  // @@@ this needs to be made more robust
  *alpha = 0;
  *beta = 0;
 }
 else {
  d = 1.f / d;
  *alpha = (q1 + uaub*q2)*d;
  *beta = (uaub*q1 + q2)*d;
 }
}



// find all the intersection points between the 2D rectangle with vertices
// at (+/-h[0],+/-h[1]) and the 2D quadrilateral with vertices (p[0],p[1]),
// (p[2],p[3]),(p[4],p[5]),(p[6],p[7]).
//
// the intersection points are returned as x,y pairs in the 'ret' array.
// the number of intersection points is returned by the function (this will
// be in the range 0 to 8).

static int intersectRectQuad2(btScalar h[2], btScalar p[8], btScalar ret[16])
{
 // q (and r) contain nq (and nr) coordinate points for the current (and
 // chopped) polygons
 int nq = 4, nr = 0;
 btScalar buffer[16];
 btScalar *q = p;
 btScalar *r = ret;
 for (int dir = 0; dir <= 1; dir++) {
  // direction notation: xy[0] = x axis, xy[1] = y axis
  for (int sign = -1; sign <= 1; sign += 2) {
   // chop q along the line xy[dir] = sign*h[dir]
   btScalar *pq = q;
   btScalar *pr = r;
   nr = 0;
   for (int i = nq; i > 0; i--) {
    // go through all points in q and all lines between adjacent points
    if (sign*pq[dir] < h[dir]) {
     // this point is inside the chopping line
     pr[0] = pq[0];
     pr[1] = pq[1];
     pr += 2;
     nr++;
     if (nr & 8) {
      q = r;
      goto done;
     }
    }
    btScalar *nextq = (i > 1) ? pq + 2 : q;
    if ((sign*pq[dir] < h[dir]) ^ (sign*nextq[dir] < h[dir])) {
     // this line crosses the chopping line
     pr[1 - dir] = pq[1 - dir] + (nextq[1 - dir] - pq[1 - dir]) /
      (nextq[dir] - pq[dir]) * (sign*h[dir] - pq[dir]);
     pr[dir] = sign*h[dir];
     pr += 2;
     nr++;
     if (nr & 8) {
      q = r;
      goto done;
     }
    }
    pq += 2;
   }
   q = r;
   r = (q == ret) ? buffer : ret;
   nq = nr;
  }
 }
done:
 if (q != ret) memcpy(ret, q, nr * 2 * sizeof(btScalar));
 return nr;
}


#define M__PI 3.14159265f

// given n points in the plane (array p, of size 2*n), generate m points that
// best represent the whole set. the definition of 'best' here is not
// predetermined - the idea is to select points that give good box-box
// collision detection behavior. the chosen point indexes are returned in the
// array iret (of size m). 'i0' is always the first entry in the array.
// n must be in the range [1..8]. m must be in the range [1..n]. i0 must be
// in the range [0..n-1].

void cullPoints2(int n, btScalar p[], int m, int i0, int iret[]);
void cullPoints2(int n, btScalar p[], int m, int i0, int iret[])
{
 // compute the centroid of the polygon in cx,cy
 int i, j;
 btScalar a, cx, cy, q;
 if (n == 1) {
  cx = p[0];
  cy = p[1];
 }
 else if (n == 2) {
  cx = btScalar(0.5)*(p[0] + p[2]);
  cy = btScalar(0.5)*(p[1] + p[3]);
 }
 else {
  a = 0;
  cx = 0;
  cy = 0;
  for (i = 0; i<(n - 1); i++) {
   q = p[i * 2] * p[i * 2 + 3] - p[i * 2 + 2] * p[i * 2 + 1];
   a += q;
   cx += q*(p[i * 2] + p[i * 2 + 2]);
   cy += q*(p[i * 2 + 1] + p[i * 2 + 3]);
  }
  q = p[n * 2 - 2] * p[1] - p[0] * p[n * 2 - 1];
  if (btFabs(a + q) > SIMD_EPSILON)
  {
   a = 1.f / (btScalar(3.0)*(a + q));
  }
  else
  {
   a = BT_LARGE_FLOAT;
  }
  cx = a*(cx + q*(p[n * 2 - 2] + p[0]));
  cy = a*(cy + q*(p[n * 2 - 1] + p[1]));
 }

 // compute the angle of each point w.r.t. the centroid
 btScalar A[8];
 for (i = 0; i<n; i++) A[i] = btAtan2(p[i * 2 + 1] - cy, p[i * 2] - cx);

 // search for points that have angles closest to A[i0] + i*(2*pi/m).
 int avail[8];
 for (i = 0; i<n; i++) avail[i] = 1;
 avail[i0] = 0;
 iret[0] = i0;
 iret++;
 for (j = 1; j<m; j++) {
  a = btScalar(j)*(2 * M__PI / m) + A[i0];
  if (a > M__PI) a -= 2 * M__PI;
  btScalar maxdiff = 1e9, diff;

  *iret = i0;			// iret is not allowed to keep this value, but it sometimes does, when diff=#QNAN0

  for (i = 0; i<n; i++) {
   if (avail[i]) {
    diff = btFabs(A[i] - a);
    if (diff > M__PI) diff = 2 * M__PI - diff;
    if (diff < maxdiff) {
     maxdiff = diff;
     *iret = i;
    }
   }
  }
#if defined(DEBUG) || defined (_DEBUG)
  btAssert(*iret != i0);	// ensure iret got set
#endif
  avail[*iret] = 0;
  iret++;
 }
}



int dBoxBox2(const btVector3& p1, const dMatrix3 R1,
 const btVector3& side1, const btVector3& p2,
 const dMatrix3 R2, const btVector3& side2,
 btVector3& normal, btScalar *depth, int *return_code,
 int maxc, dContactGeom * /*contact*/, int /*skip*/, btDiscreteCollisionDetectorInterface::Result& output);
int dBoxBox2(const btVector3& p1, const dMatrix3 R1,
 const btVector3& side1, const btVector3& p2,
 const dMatrix3 R2, const btVector3& side2,
 btVector3& normal, btScalar *depth, int *return_code,
 int maxc, dContactGeom * /*contact*/, int /*skip*/, btDiscreteCollisionDetectorInterface::Result& output)
{
 const btScalar fudge_factor = btScalar(1.05);
 btVector3 p, pp, normalC(0.f, 0.f, 0.f);
 const btScalar *normalR = 0;
 btScalar A[3], B[3], R11, R12, R13, R21, R22, R23, R31, R32, R33,
  Q11, Q12, Q13, Q21, Q22, Q23, Q31, Q32, Q33, s, s2, l;
 int i, j, invert_normal, code;

 // get vector from centers of box 1 to box 2, relative to box 1
 p = p2 - p1;
 dMULTIPLY1_331(pp, R1, p);		// get pp = p relative to body 1

                             // get side lengths / 2
 A[0] = side1[0] * btScalar(0.5);
 A[1] = side1[1] * btScalar(0.5);
 A[2] = side1[2] * btScalar(0.5);
 B[0] = side2[0] * btScalar(0.5);
 B[1] = side2[1] * btScalar(0.5);
 B[2] = side2[2] * btScalar(0.5);

 // Rij is R1'*R2, i.e. the relative rotation between R1 and R2
 R11 = dDOT44(R1 + 0, R2 + 0); R12 = dDOT44(R1 + 0, R2 + 1); R13 = dDOT44(R1 + 0, R2 + 2);
 R21 = dDOT44(R1 + 1, R2 + 0); R22 = dDOT44(R1 + 1, R2 + 1); R23 = dDOT44(R1 + 1, R2 + 2);
 R31 = dDOT44(R1 + 2, R2 + 0); R32 = dDOT44(R1 + 2, R2 + 1); R33 = dDOT44(R1 + 2, R2 + 2);

 Q11 = btFabs(R11); Q12 = btFabs(R12); Q13 = btFabs(R13);
 Q21 = btFabs(R21); Q22 = btFabs(R22); Q23 = btFabs(R23);
 Q31 = btFabs(R31); Q32 = btFabs(R32); Q33 = btFabs(R33);

 // for all 15 possible separating axes:
 //   * see if the axis separates the boxes. if so, return 0.
 //   * find the depth of the penetration along the separating axis (s2)
 //   * if this is the largest depth so far, record it.
 // the normal vector will be set to the separating axis with the smallest
 // depth. note: normalR is set to point to a column of R1 or R2 if that is
 // the smallest depth normal so far. otherwise normalR is 0 and normalC is
 // set to a vector relative to body 1. invert_normal is 1 if the sign of
 // the normal should be flipped.

#define TST(expr1,expr2,norm,cc) \
  s2 = btFabs(expr1) - (expr2); \
  if (s2 > 0) return 0; \
  if (s2 > s) { \
    s = s2; \
    normalR = norm; \
    invert_normal = ((expr1) < 0); \
    code = (cc); \
  }

 s = -dInfinity;
 invert_normal = 0;
 code = 0;

 // separating axis = u1,u2,u3
 TST(pp[0], (A[0] + B[0] * Q11 + B[1] * Q12 + B[2] * Q13), R1 + 0, 1);
 TST(pp[1], (A[1] + B[0] * Q21 + B[1] * Q22 + B[2] * Q23), R1 + 1, 2);
 TST(pp[2], (A[2] + B[0] * Q31 + B[1] * Q32 + B[2] * Q33), R1 + 2, 3);

 // separating axis = v1,v2,v3
 TST(dDOT41(R2 + 0, p), (A[0] * Q11 + A[1] * Q21 + A[2] * Q31 + B[0]), R2 + 0, 4);
 TST(dDOT41(R2 + 1, p), (A[0] * Q12 + A[1] * Q22 + A[2] * Q32 + B[1]), R2 + 1, 5);
 TST(dDOT41(R2 + 2, p), (A[0] * Q13 + A[1] * Q23 + A[2] * Q33 + B[2]), R2 + 2, 6);

 // note: cross product axes need to be scaled when s is computed.
 // normal (n1,n2,n3) is relative to box 1.
#undef TST
#define TST(expr1,expr2,n1,n2,n3,cc) \
  s2 = btFabs(expr1) - (expr2); \
  if (s2 > SIMD_EPSILON) return 0; \
  l = btSqrt((n1)*(n1) + (n2)*(n2) + (n3)*(n3)); \
  if (l > SIMD_EPSILON) { \
    s2 /= l; \
    if (s2*fudge_factor > s) { \
      s = s2; \
      normalR = 0; \
      normalC[0] = (n1)/l; normalC[1] = (n2)/l; normalC[2] = (n3)/l; \
      invert_normal = ((expr1) < 0); \
      code = (cc); \
    } \
  }

 btScalar fudge2(1.0e-5f);

 Q11 += fudge2;
 Q12 += fudge2;
 Q13 += fudge2;

 Q21 += fudge2;
 Q22 += fudge2;
 Q23 += fudge2;

 Q31 += fudge2;
 Q32 += fudge2;
 Q33 += fudge2;

 // separating axis = u1 x (v1,v2,v3)
 TST(pp[2] * R21 - pp[1] * R31, (A[1] * Q31 + A[2] * Q21 + B[1] * Q13 + B[2] * Q12), 0, -R31, R21, 7);
 TST(pp[2] * R22 - pp[1] * R32, (A[1] * Q32 + A[2] * Q22 + B[0] * Q13 + B[2] * Q11), 0, -R32, R22, 8);
 TST(pp[2] * R23 - pp[1] * R33, (A[1] * Q33 + A[2] * Q23 + B[0] * Q12 + B[1] * Q11), 0, -R33, R23, 9);

 // separating axis = u2 x (v1,v2,v3)
 TST(pp[0] * R31 - pp[2] * R11, (A[0] * Q31 + A[2] * Q11 + B[1] * Q23 + B[2] * Q22), R31, 0, -R11, 10);
 TST(pp[0] * R32 - pp[2] * R12, (A[0] * Q32 + A[2] * Q12 + B[0] * Q23 + B[2] * Q21), R32, 0, -R12, 11);
 TST(pp[0] * R33 - pp[2] * R13, (A[0] * Q33 + A[2] * Q13 + B[0] * Q22 + B[1] * Q21), R33, 0, -R13, 12);

 // separating axis = u3 x (v1,v2,v3)
 TST(pp[1] * R11 - pp[0] * R21, (A[0] * Q21 + A[1] * Q11 + B[1] * Q33 + B[2] * Q32), -R21, R11, 0, 13);
 TST(pp[1] * R12 - pp[0] * R22, (A[0] * Q22 + A[1] * Q12 + B[0] * Q33 + B[2] * Q31), -R22, R12, 0, 14);
 TST(pp[1] * R13 - pp[0] * R23, (A[0] * Q23 + A[1] * Q13 + B[0] * Q32 + B[1] * Q31), -R23, R13, 0, 15);

#undef TST

 if (!code) return 0;

 // if we get to this point, the boxes interpenetrate. compute the normal
 // in global coordinates.
 if (normalR) {
  normal[0] = normalR[0];
  normal[1] = normalR[4];
  normal[2] = normalR[8];
 }
 else {
  dMULTIPLY0_331(normal, R1, normalC);
 }
 if (invert_normal) {
  normal[0] = -normal[0];
  normal[1] = -normal[1];
  normal[2] = -normal[2];
 }
 *depth = -s;

 // compute contact point(s)

 if (code > 6) {
  // an edge from box 1 touches an edge from box 2.
  // find a point pa on the intersecting edge of box 1
  btVector3 pa;
  btScalar sign;
  for (i = 0; i<3; i++) pa[i] = p1[i];
  for (j = 0; j<3; j++) {
   sign = (dDOT14(normal, R1 + j) > 0) ? btScalar(1.0) : btScalar(-1.0);
   for (i = 0; i<3; i++) pa[i] += sign * A[j] * R1[i * 4 + j];
  }

  // find a point pb on the intersecting edge of box 2
  btVector3 pb;
  for (i = 0; i<3; i++) pb[i] = p2[i];
  for (j = 0; j<3; j++) {
   sign = (dDOT14(normal, R2 + j) > 0) ? btScalar(-1.0) : btScalar(1.0);
   for (i = 0; i<3; i++) pb[i] += sign * B[j] * R2[i * 4 + j];
  }

  btScalar alpha, beta;
  btVector3 ua, ub;
  for (i = 0; i<3; i++) ua[i] = R1[((code)-7) / 3 + i * 4];
  for (i = 0; i<3; i++) ub[i] = R2[((code)-7) % 3 + i * 4];

  dLineClosestApproach(pa, ua, pb, ub, &alpha, &beta);
  for (i = 0; i<3; i++) pa[i] += ua[i] * alpha;
  for (i = 0; i<3; i++) pb[i] += ub[i] * beta;

  {

   //contact[0].pos[i] = btScalar(0.5)*(pa[i]+pb[i]);
   //contact[0].depth = *depth;
   btVector3 pointInWorld;

#ifdef USE_CENTER_POINT
   for (i = 0; i<3; i++)
    pointInWorld[i] = (pa[i] + pb[i])*btScalar(0.5);
   output.addContactPoint(-normal, pointInWorld, -*depth);
#else
   output.addContactPoint(-normal, pb, -*depth);

#endif //
   *return_code = code;
  }
  return 1;
 }

 // okay, we have a face-something intersection (because the separating
 // axis is perpendicular to a face). define face 'a' to be the reference
 // face (i.e. the normal vector is perpendicular to this) and face 'b' to be
 // the incident face (the closest face of the other box).

 const btScalar *Ra, *Rb, *pa, *pb, *Sa, *Sb;
 if (code <= 3) {
  Ra = R1;
  Rb = R2;
  pa = p1;
  pb = p2;
  Sa = A;
  Sb = B;
 }
 else {
  Ra = R2;
  Rb = R1;
  pa = p2;
  pb = p1;
  Sa = B;
  Sb = A;
 }

 // nr = normal vector of reference face dotted with axes of incident box.
 // anr = absolute values of nr.
 btVector3 normal2, nr, anr;
 if (code <= 3) {
  normal2[0] = normal[0];
  normal2[1] = normal[1];
  normal2[2] = normal[2];
 }
 else {
  normal2[0] = -normal[0];
  normal2[1] = -normal[1];
  normal2[2] = -normal[2];
 }
 dMULTIPLY1_331(nr, Rb, normal2);
 anr[0] = btFabs(nr[0]);
 anr[1] = btFabs(nr[1]);
 anr[2] = btFabs(nr[2]);

 // find the largest compontent of anr: this corresponds to the normal
 // for the indident face. the other axis numbers of the indicent face
 // are stored in a1,a2.
 int lanr, a1, a2;
 if (anr[1] > anr[0]) {
  if (anr[1] > anr[2]) {
   a1 = 0;
   lanr = 1;
   a2 = 2;
  }
  else {
   a1 = 0;
   a2 = 1;
   lanr = 2;
  }
 }
 else {
  if (anr[0] > anr[2]) {
   lanr = 0;
   a1 = 1;
   a2 = 2;
  }
  else {
   a1 = 0;
   a2 = 1;
   lanr = 2;
  }
 }

 // compute center point of incident face, in reference-face coordinates
 btVector3 center;
 if (nr[lanr] < 0) {
  for (i = 0; i<3; i++) center[i] = pb[i] - pa[i] + Sb[lanr] * Rb[i * 4 + lanr];
 }
 else {
  for (i = 0; i<3; i++) center[i] = pb[i] - pa[i] - Sb[lanr] * Rb[i * 4 + lanr];
 }

 // find the normal and non-normal axis numbers of the reference box
 int codeN, code1, code2;
 if (code <= 3) codeN = code - 1; else codeN = code - 4;
 if (codeN == 0) {
  code1 = 1;
  code2 = 2;
 }
 else if (codeN == 1) {
  code1 = 0;
  code2 = 2;
 }
 else {
  code1 = 0;
  code2 = 1;
 }

 // find the four corners of the incident face, in reference-face coordinates
 btScalar quad[8];	// 2D coordinate of incident face (x,y pairs)
 btScalar c1, c2, m11, m12, m21, m22;
 c1 = dDOT14(center, Ra + code1);
 c2 = dDOT14(center, Ra + code2);
 // optimize this? - we have already computed this data above, but it is not
 // stored in an easy-to-index format. for now it's quicker just to recompute
 // the four dot products.
 m11 = dDOT44(Ra + code1, Rb + a1);
 m12 = dDOT44(Ra + code1, Rb + a2);
 m21 = dDOT44(Ra + code2, Rb + a1);
 m22 = dDOT44(Ra + code2, Rb + a2);
 {
  btScalar k1 = m11*Sb[a1];
  btScalar k2 = m21*Sb[a1];
  btScalar k3 = m12*Sb[a2];
  btScalar k4 = m22*Sb[a2];
  quad[0] = c1 - k1 - k3;
  quad[1] = c2 - k2 - k4;
  quad[2] = c1 - k1 + k3;
  quad[3] = c2 - k2 + k4;
  quad[4] = c1 + k1 + k3;
  quad[5] = c2 + k2 + k4;
  quad[6] = c1 + k1 - k3;
  quad[7] = c2 + k2 - k4;
 }

 // find the size of the reference face
 btScalar rect[2];
 rect[0] = Sa[code1];
 rect[1] = Sa[code2];

 // intersect the incident and reference faces
 btScalar ret[16];
 int n = intersectRectQuad2(rect, quad, ret);
 if (n < 1) return 0;		// this should never happen

                       // convert the intersection points into reference-face coordinates,
                       // and compute the contact position and depth for each point. only keep
                       // those points that have a positive (penetrating) depth. delete points in
                       // the 'ret' array as necessary so that 'point' and 'ret' correspond.
 btScalar point[3 * 8];		// penetrating contact points
 btScalar dep[8];			// depths for those points
 btScalar det1 = 1.f / (m11*m22 - m12*m21);
 m11 *= det1;
 m12 *= det1;
 m21 *= det1;
 m22 *= det1;
 int cnum = 0;			// number of penetrating contact points found
 for (j = 0; j < n; j++) {
  btScalar k1 = m22*(ret[j * 2] - c1) - m12*(ret[j * 2 + 1] - c2);
  btScalar k2 = -m21*(ret[j * 2] - c1) + m11*(ret[j * 2 + 1] - c2);
  for (i = 0; i<3; i++) point[cnum * 3 + i] =
   center[i] + k1*Rb[i * 4 + a1] + k2*Rb[i * 4 + a2];
  dep[cnum] = Sa[codeN] - dDOT(normal2, point + cnum * 3);
  if (dep[cnum] >= 0) {
   ret[cnum * 2] = ret[j * 2];
   ret[cnum * 2 + 1] = ret[j * 2 + 1];
   cnum++;
  }
 }
 if (cnum < 1) return 0;	// this should never happen

                         // we can't generate more contacts than we actually have
 if (maxc > cnum) maxc = cnum;
 if (maxc < 1) maxc = 1;

 if (cnum <= maxc) {

  if (code<4)
  {
   // we have less contacts than we need, so we use them all
   for (j = 0; j < cnum; j++)
   {
    btVector3 pointInWorld;
    for (i = 0; i<3; i++)
     pointInWorld[i] = point[j * 3 + i] + pa[i];
    output.addContactPoint(-normal, pointInWorld, -dep[j]);

   }
  }
  else
  {
   // we have less contacts than we need, so we use them all
   for (j = 0; j < cnum; j++)
   {
    btVector3 pointInWorld;
    for (i = 0; i<3; i++)
     pointInWorld[i] = point[j * 3 + i] + pa[i] - normal[i] * dep[j];
    //pointInWorld[i] = point[j*3+i] + pa[i];
    output.addContactPoint(-normal, pointInWorld, -dep[j]);
   }
  }
 }
 else {
  // we have more contacts than are wanted, some of them must be culled.
  // find the deepest point, it is always the first contact.
  int i1 = 0;
  btScalar maxdepth = dep[0];
  for (i = 1; i<cnum; i++) {
   if (dep[i] > maxdepth) {
    maxdepth = dep[i];
    i1 = i;
   }
  }

  int iret[8];
  cullPoints2(cnum, ret, maxc, i1, iret);

  for (j = 0; j < maxc; j++) {
   //      dContactGeom *con = CONTACT(contact,skip*j);
   //    for (i=0; i<3; i++) con->pos[i] = point[iret[j]*3+i] + pa[i];
   //  con->depth = dep[iret[j]];

   btVector3 posInWorld;
   for (i = 0; i<3; i++)
    posInWorld[i] = point[iret[j] * 3 + i] + pa[i];
   if (code<4)
   {
    output.addContactPoint(-normal, posInWorld, -dep[iret[j]]);
   }
   else
   {
    output.addContactPoint(-normal, posInWorld - normal*dep[iret[j]], -dep[iret[j]]);
   }
  }
  cnum = maxc;
 }

 *return_code = code;
 return cnum;
}

void	btBoxBoxDetector::getClosestPoints(const ClosestPointInput& input, Result& output, class btIDebugDraw* /*debugDraw*/, bool /*swapResults*/)
{

 const btTransform& transformA = input.m_transformA;
 const btTransform& transformB = input.m_transformB;

 int skip = 0;
 dContactGeom *contact = 0;

 dMatrix3 R1;
 dMatrix3 R2;

 for (int j = 0; j<3; j++)
 {
  R1[0 + 4 * j] = transformA.getBasis()[j].x();
  R2[0 + 4 * j] = transformB.getBasis()[j].x();

  R1[1 + 4 * j] = transformA.getBasis()[j].y();
  R2[1 + 4 * j] = transformB.getBasis()[j].y();


  R1[2 + 4 * j] = transformA.getBasis()[j].z();
  R2[2 + 4 * j] = transformB.getBasis()[j].z();

 }



 btVector3 normal;
 btScalar depth;
 int return_code;
 int maxc = 4;


 dBoxBox2(transformA.getOrigin(),
  R1,
  2.f*m_box1->getHalfExtentsWithMargin(),
  transformB.getOrigin(),
  R2,
  2.f*m_box2->getHalfExtentsWithMargin(),
  normal, &depth, &return_code,
  maxc, contact, skip,
  output
 );

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "LinearMath/btQuickprof.h"

#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"

#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btPoolAllocator.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

int gNumManifold = 0;

#ifdef BT_DEBUG
#include <stdio.h>
#endif


btCollisionDispatcher::btCollisionDispatcher(btCollisionConfiguration* collisionConfiguration) :
 m_dispatcherFlags(btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD),
 m_collisionConfiguration(collisionConfiguration)
{
 int i;

 setNearCallback(defaultNearCallback);

 m_collisionAlgorithmPoolAllocator = collisionConfiguration->getCollisionAlgorithmPool();

 m_persistentManifoldPoolAllocator = collisionConfiguration->getPersistentManifoldPool();

 for (i = 0; i<MAX_BROADPHASE_COLLISION_TYPES; i++)
 {
  for (int j = 0; j<MAX_BROADPHASE_COLLISION_TYPES; j++)
  {
   m_doubleDispatchContactPoints[i][j] = m_collisionConfiguration->getCollisionAlgorithmCreateFunc(i, j);
   btAssert(m_doubleDispatchContactPoints[i][j]);
   m_doubleDispatchClosestPoints[i][j] = m_collisionConfiguration->getClosestPointsAlgorithmCreateFunc(i, j);

  }
 }


}


void btCollisionDispatcher::registerCollisionCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc *createFunc)
{
 m_doubleDispatchContactPoints[proxyType0][proxyType1] = createFunc;
}

void btCollisionDispatcher::registerClosestPointsCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc *createFunc)
{
 m_doubleDispatchClosestPoints[proxyType0][proxyType1] = createFunc;
}

btCollisionDispatcher::~btCollisionDispatcher()
{
}

btPersistentManifold*	btCollisionDispatcher::getNewManifold(const btCollisionObject* body0, const btCollisionObject* body1)
{
 gNumManifold++;

 //btAssert(gNumManifold < 65535);



 //optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)

 btScalar contactBreakingThreshold = (m_dispatcherFlags & btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD) ?
  btMin(body0->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold), body1->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold))
  : gContactBreakingThreshold;

 btScalar contactProcessingThreshold = btMin(body0->getContactProcessingThreshold(), body1->getContactProcessingThreshold());

 void* mem = m_persistentManifoldPoolAllocator->allocate(sizeof(btPersistentManifold));
 if (NULL == mem)
 {
  //we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
  if ((m_dispatcherFlags&CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION) == 0)
  {
   mem = btAlignedAlloc(sizeof(btPersistentManifold), 16);
  }
  else
  {
   btAssert(0);
   //make sure to increase the m_defaultMaxPersistentManifoldPoolSize in the btDefaultCollisionConstructionInfo/btDefaultCollisionConfiguration
   return 0;
  }
 }
 btPersistentManifold* manifold = new(mem) btPersistentManifold(body0, body1, 0, contactBreakingThreshold, contactProcessingThreshold);
 manifold->m_index1a = m_manifoldsPtr.size();
 m_manifoldsPtr.push_back(manifold);

 return manifold;
}

void btCollisionDispatcher::clearManifold(btPersistentManifold* manifold)
{
 manifold->clearManifold();
}


void btCollisionDispatcher::releaseManifold(btPersistentManifold* manifold)
{

 gNumManifold--;

 //printf("releaseManifold: gNumManifold %d\n",gNumManifold);
 clearManifold(manifold);

 int findIndex = manifold->m_index1a;
 btAssert(findIndex < m_manifoldsPtr.size());
 m_manifoldsPtr.swap(findIndex, m_manifoldsPtr.size() - 1);
 m_manifoldsPtr[findIndex]->m_index1a = findIndex;
 m_manifoldsPtr.pop_back();

 manifold->~btPersistentManifold();
 if (m_persistentManifoldPoolAllocator->validPtr(manifold))
 {
  m_persistentManifoldPoolAllocator->freeMemory(manifold);
 }
 else
 {
  btAlignedFree(manifold);
 }

}




btCollisionAlgorithm* btCollisionDispatcher::findAlgorithm(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btPersistentManifold* sharedManifold, ebtDispatcherQueryType algoType)
{

 btCollisionAlgorithmConstructionInfo ci;

 ci.m_dispatcher1 = this;
 ci.m_manifold = sharedManifold;
 btCollisionAlgorithm* algo = 0;
 if (algoType == BT_CONTACT_POINT_ALGORITHMS)
 {
  algo = m_doubleDispatchContactPoints[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci, body0Wrap, body1Wrap);
 }
 else
 {
  algo = m_doubleDispatchClosestPoints[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci, body0Wrap, body1Wrap);
 }

 return algo;
}




bool	btCollisionDispatcher::needsResponse(const btCollisionObject* body0, const btCollisionObject* body1)
{
 //here you can do filtering
 bool hasResponse =
  (body0->hasContactResponse() && body1->hasContactResponse());
 //no response between two static/kinematic bodies:
 hasResponse = hasResponse &&
  ((!body0->isStaticOrKinematicObject()) || (!body1->isStaticOrKinematicObject()));
 return hasResponse;
}

bool	btCollisionDispatcher::needsCollision(const btCollisionObject* body0, const btCollisionObject* body1)
{
 btAssert(body0);
 btAssert(body1);

 bool needsCollision = true;

#ifdef BT_DEBUG
 if (!(m_dispatcherFlags & btCollisionDispatcher::CD_STATIC_STATIC_REPORTED))
 {
  //broadphase filtering already deals with this
  if (body0->isStaticOrKinematicObject() && body1->isStaticOrKinematicObject())
  {
   m_dispatcherFlags |= btCollisionDispatcher::CD_STATIC_STATIC_REPORTED;
   printf("warning btCollisionDispatcher::needsCollision: static-static collision!\n");
  }
 }
#endif //BT_DEBUG

 if ((!body0->isActive()) && (!body1->isActive()))
  needsCollision = false;
 else if ((!body0->checkCollideWith(body1)) || (!body1->checkCollideWith(body0)))
  needsCollision = false;

 return needsCollision;

}



///interface for iterating all overlapping collision pairs, no matter how those pairs are stored (array, set, map etc)
///this is useful for the collision dispatcher.
class btCollisionPairCallback : public btOverlapCallback
{
 const btDispatcherInfo& m_dispatchInfo;
 btCollisionDispatcher*	m_dispatcher;

public:

 btCollisionPairCallback(const btDispatcherInfo& dispatchInfo, btCollisionDispatcher*	dispatcher)
  :m_dispatchInfo(dispatchInfo),
  m_dispatcher(dispatcher)
 {
 }

 /*btCollisionPairCallback& operator=(btCollisionPairCallback& other)
 {
 m_dispatchInfo = other.m_dispatchInfo;
 m_dispatcher = other.m_dispatcher;
 return *this;
 }
 */


 virtual ~btCollisionPairCallback() {}


 virtual bool	processOverlap(btBroadphasePair& pair)
 {
  (*m_dispatcher->getNearCallback())(pair, *m_dispatcher, m_dispatchInfo);
  return false;
 }
};



void	btCollisionDispatcher::dispatchAllCollisionPairs(btOverlappingPairCache* pairCache, const btDispatcherInfo& dispatchInfo, btDispatcher* dispatcher)
{
 //m_blockedForChanges = true;

 btCollisionPairCallback	collisionCallback(dispatchInfo, this);

 pairCache->processAllOverlappingPairs(&collisionCallback, dispatcher);

 //m_blockedForChanges = false;

}



//by default, Bullet will use this near callback
void btCollisionDispatcher::defaultNearCallback(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo)
{
 btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
 btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;

 if (dispatcher.needsCollision(colObj0, colObj1))
 {
  btCollisionObjectWrapper obj0Wrap(0, colObj0->getCollisionShape(), colObj0, colObj0->getWorldTransform(), -1, -1);
  btCollisionObjectWrapper obj1Wrap(0, colObj1->getCollisionShape(), colObj1, colObj1->getWorldTransform(), -1, -1);


  //dispatcher will keep algorithms persistent in the collision pair
  if (!collisionPair.m_algorithm)
  {
   collisionPair.m_algorithm = dispatcher.findAlgorithm(&obj0Wrap, &obj1Wrap, 0, BT_CONTACT_POINT_ALGORITHMS);
  }

  if (collisionPair.m_algorithm)
  {
   btManifoldResult contactPointResult(&obj0Wrap, &obj1Wrap);

   if (dispatchInfo.m_dispatchFunc == btDispatcherInfo::DISPATCH_DISCRETE)
   {
    //discrete collision detection query

    collisionPair.m_algorithm->processCollision(&obj0Wrap, &obj1Wrap, dispatchInfo, &contactPointResult);
   }
   else
   {
    //continuous collision detection query, time of impact (toi)
    btScalar toi = collisionPair.m_algorithm->calculateTimeOfImpact(colObj0, colObj1, dispatchInfo, &contactPointResult);
    if (dispatchInfo.m_timeOfImpact > toi)
     dispatchInfo.m_timeOfImpact = toi;

   }
  }
 }

}


void* btCollisionDispatcher::allocateCollisionAlgorithm(int size)
{
 void* mem = m_collisionAlgorithmPoolAllocator->allocate(size);
 if (NULL == mem)
 {
  //warn user for overflow?
  return btAlignedAlloc(static_cast<size_t>(size), 16);
 }
 return mem;
}

void btCollisionDispatcher::freeCollisionAlgorithm(void* ptr)
{
 if (m_collisionAlgorithmPoolAllocator->validPtr(ptr))
 {
  m_collisionAlgorithmPoolAllocator->freeMemory(ptr);
 }
 else
 {
  btAlignedFree(ptr);
 }
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletCollision/CollisionDispatch/btCollisionDispatcherMt.h"
#include "LinearMath/btQuickprof.h"

#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"

#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btPoolAllocator.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"


btCollisionDispatcherMt::btCollisionDispatcherMt(btCollisionConfiguration* config, int grainSize)
 : btCollisionDispatcher(config)
{
 m_batchUpdating = false;
 m_grainSize = grainSize;  // iterations per task
}


btPersistentManifold* btCollisionDispatcherMt::getNewManifold(const btCollisionObject* body0, const btCollisionObject* body1)
{
 //optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)

 btScalar contactBreakingThreshold = (m_dispatcherFlags & btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD) ?
  btMin(body0->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold), body1->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold))
  : gContactBreakingThreshold;

 btScalar contactProcessingThreshold = btMin(body0->getContactProcessingThreshold(), body1->getContactProcessingThreshold());

 void* mem = m_persistentManifoldPoolAllocator->allocate(sizeof(btPersistentManifold));
 if (NULL == mem)
 {
  //we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
  if ((m_dispatcherFlags&CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION) == 0)
  {
   mem = btAlignedAlloc(sizeof(btPersistentManifold), 16);
  }
  else
  {
   btAssert(0);
   //make sure to increase the m_defaultMaxPersistentManifoldPoolSize in the btDefaultCollisionConstructionInfo/btDefaultCollisionConfiguration
   return 0;
  }
 }
 btPersistentManifold* manifold = new(mem) btPersistentManifold(body0, body1, 0, contactBreakingThreshold, contactProcessingThreshold);
 if (!m_batchUpdating)
 {
  // batch updater will update manifold pointers array after finishing, so
  // only need to update array when not batch-updating
  //btAssert( !btThreadsAreRunning() );
  manifold->m_index1a = m_manifoldsPtr.size();
  m_manifoldsPtr.push_back(manifold);
 }

 return manifold;
}

void btCollisionDispatcherMt::releaseManifold(btPersistentManifold* manifold)
{
 clearManifold(manifold);
 //btAssert( !btThreadsAreRunning() );
 if (!m_batchUpdating)
 {
  // batch updater will update manifold pointers array after finishing, so
  // only need to update array when not batch-updating
  int findIndex = manifold->m_index1a;
  btAssert(findIndex < m_manifoldsPtr.size());
  m_manifoldsPtr.swap(findIndex, m_manifoldsPtr.size() - 1);
  m_manifoldsPtr[findIndex]->m_index1a = findIndex;
  m_manifoldsPtr.pop_back();
 }

 manifold->~btPersistentManifold();
 if (m_persistentManifoldPoolAllocator->validPtr(manifold))
 {
  m_persistentManifoldPoolAllocator->freeMemory(manifold);
 }
 else
 {
  btAlignedFree(manifold);
 }
}

struct CollisionDispatcherUpdater : public btIParallelForBody
{
 btBroadphasePair* mPairArray;
 btNearCallback mCallback;
 btCollisionDispatcher* mDispatcher;
 const btDispatcherInfo* mInfo;

 CollisionDispatcherUpdater()
 {
  mPairArray = NULL;
  mCallback = NULL;
  mDispatcher = NULL;
  mInfo = NULL;
 }
 void forLoop(int iBegin, int iEnd) const
 {
  for (int i = iBegin; i < iEnd; ++i)
  {
   btBroadphasePair* pair = &mPairArray[i];
   mCallback(*pair, *mDispatcher, *mInfo);
  }
 }
};


void btCollisionDispatcherMt::dispatchAllCollisionPairs(btOverlappingPairCache* pairCache, const btDispatcherInfo& info, btDispatcher* dispatcher)
{
 int pairCount = pairCache->getNumOverlappingPairs();
 if (pairCount == 0)
 {
  return;
 }
 CollisionDispatcherUpdater updater;
 updater.mCallback = getNearCallback();
 updater.mPairArray = pairCache->getOverlappingPairArrayPtr();
 updater.mDispatcher = this;
 updater.mInfo = &info;

 m_batchUpdating = true;
 btParallelFor(0, pairCount, m_grainSize, updater);
 m_batchUpdating = false;

 // reconstruct the manifolds array to ensure determinism
 m_manifoldsPtr.resizeNoInitialize(0);

 btBroadphasePair* pairs = pairCache->getOverlappingPairArrayPtr();
 for (int i = 0; i < pairCount; ++i)
 {
  if (btCollisionAlgorithm* algo = pairs[i].m_algorithm)
  {
   algo->getAllContactManifolds(m_manifoldsPtr);
  }
 }

 // update the indices (used when releasing manifolds)
 for (int i = 0; i < m_manifoldsPtr.size(); ++i)
 {
  m_manifoldsPtr[i]->m_index1a = i;
 }
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "LinearMath/btSerializer.h"

btCollisionObject::btCollisionObject()
 : m_interpolationLinearVelocity(0.f, 0.f, 0.f),
 m_interpolationAngularVelocity(0.f, 0.f, 0.f),
 m_anisotropicFriction(1.f, 1.f, 1.f),
 m_hasAnisotropicFriction(false),
 m_contactProcessingThreshold(BT_LARGE_FLOAT),
 m_broadphaseHandle(0),
 m_collisionShape(0),
 m_extensionPointer(0),
 m_rootCollisionShape(0),
 m_collisionFlags(btCollisionObject::CF_STATIC_OBJECT),
 m_islandTag1(-1),
 m_companionId(-1),
 m_worldArrayIndex(-1),
 m_activationState1(1),
 m_deactivationTime(btScalar(0.)),
 m_friction(btScalar(0.5f)),
 m_restitution(btScalar(0.f)),
 m_rollingFriction(0.0f),
 m_spinningFriction(0.f),
 m_contactDamping(.1f),
 m_contactStiffness(1e4f),
 m_internalType(CO_COLLISION_OBJECT),
 m_userObjectPointer(0),
 m_userIndex2(-1),
 m_userIndex(-1),
 m_hitFraction(btScalar(1.f)),
 m_ccdSweptSphereRadius(btScalar(0.f)),
 m_ccdMotionThreshold(btScalar(0.f)),
 m_checkCollideWith(false),
 m_updateRevision(0)
{
 m_worldTransform.setIdentity();
 m_interpolationWorldTransform.setIdentity();
}

btCollisionObject::~btCollisionObject()
{
}

void btCollisionObject::setActivationState(int newState) const
{
 if ((m_activationState1 != DISABLE_DEACTIVATION) && (m_activationState1 != DISABLE_SIMULATION))
  m_activationState1 = newState;
}

void btCollisionObject::forceActivationState(int newState) const
{
 m_activationState1 = newState;
}

void btCollisionObject::activate(bool forceActivation) const
{
 if (forceActivation || !(m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT)))
 {
  setActivationState(ACTIVE_TAG);
  m_deactivationTime = btScalar(0.);
 }
}

const char* btCollisionObject::serialize(void* dataBuffer, btSerializer* serializer) const
{

 btCollisionObjectData* dataOut = (btCollisionObjectData*)dataBuffer;

 m_worldTransform.serialize(dataOut->m_worldTransform);
 m_interpolationWorldTransform.serialize(dataOut->m_interpolationWorldTransform);
 m_interpolationLinearVelocity.serialize(dataOut->m_interpolationLinearVelocity);
 m_interpolationAngularVelocity.serialize(dataOut->m_interpolationAngularVelocity);
 m_anisotropicFriction.serialize(dataOut->m_anisotropicFriction);
 dataOut->m_hasAnisotropicFriction = m_hasAnisotropicFriction;
 dataOut->m_contactProcessingThreshold = m_contactProcessingThreshold;
 dataOut->m_broadphaseHandle = 0;
 dataOut->m_collisionShape = serializer->getUniquePointer(m_collisionShape);
 dataOut->m_rootCollisionShape = 0;//@todo
 dataOut->m_collisionFlags = m_collisionFlags;
 dataOut->m_islandTag1 = m_islandTag1;
 dataOut->m_companionId = m_companionId;
 dataOut->m_activationState1 = m_activationState1;
 dataOut->m_deactivationTime = m_deactivationTime;
 dataOut->m_friction = m_friction;
 dataOut->m_rollingFriction = m_rollingFriction;
 dataOut->m_contactDamping = m_contactDamping;
 dataOut->m_contactStiffness = m_contactStiffness;
 dataOut->m_restitution = m_restitution;
 dataOut->m_internalType = m_internalType;

 char* name = (char*)serializer->findNameForPointer(this);
 dataOut->m_name = (char*)serializer->getUniquePointer(name);
 if (dataOut->m_name)
 {
  serializer->serializeName(name);
 }
 dataOut->m_hitFraction = m_hitFraction;
 dataOut->m_ccdSweptSphereRadius = m_ccdSweptSphereRadius;
 dataOut->m_ccdMotionThreshold = m_ccdMotionThreshold;
 dataOut->m_checkCollideWith = m_checkCollideWith;

 // Fill padding with zeros to appease msan.
 memset(dataOut->m_padding, 0, sizeof(dataOut->m_padding));

 return btCollisionObjectDataName;
}


void btCollisionObject::serializeSingleObject(class btSerializer* serializer) const
{
 int len = calculateSerializeBufferSize();
 btChunk* chunk = serializer->allocate(len, 1);
 const char* structType = serialize(chunk->m_oldPtr, serializer);
 serializer->finalizeChunk(chunk, structType, BT_COLLISIONOBJECT_CODE, (void*)this);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h" //for raycasting
#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h" //for raycasting
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//#define DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION


//#define USE_BRUTEFORCE_RAYBROADPHASE 1
//RECALCULATE_AABB is slower, but benefit is that you don't need to call 'stepSimulation'  or 'updateAabbs' before using a rayTest
//#define RECALCULATE_AABB_RAYCAST 1

//When the user doesn't provide dispatcher or broadphase, create basic versions (and delete them in destructor)
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"


///for debug drawing

//for debug rendering
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btTriangleCallback.h"
#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"



btCollisionWorld::btCollisionWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btCollisionConfiguration* collisionConfiguration)
 :m_dispatcher1(dispatcher),
 m_broadphasePairCache(pairCache),
 m_debugDrawer(0),
 m_forceUpdateAllAabbs(true)
{
}


btCollisionWorld::~btCollisionWorld()
{

 //clean up remaining objects
 int i;
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* collisionObject = m_collisionObjects[i];

  btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
  if (bp)
  {
   //
   // only clear the cached algorithms
   //
   getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
   getBroadphase()->destroyProxy(bp, m_dispatcher1);
   collisionObject->setBroadphaseHandle(0);
  }
 }


}










void	btCollisionWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{

 btAssert(collisionObject);

 //check that the object isn't already added
 btAssert(m_collisionObjects.findLinearSearch(collisionObject) == m_collisionObjects.size());
 btAssert(collisionObject->getWorldArrayIndex() == -1);  // do not add the same object to more than one collision world

 collisionObject->setWorldArrayIndex(m_collisionObjects.size());
 m_collisionObjects.push_back(collisionObject);

 //calculate new AABB
 btTransform trans = collisionObject->getWorldTransform();

 btVector3	minAabb;
 btVector3	maxAabb;
 collisionObject->getCollisionShape()->getAabb(trans, minAabb, maxAabb);

 int type = collisionObject->getCollisionShape()->getShapeType();
 collisionObject->setBroadphaseHandle(getBroadphase()->createProxy(
  minAabb,
  maxAabb,
  type,
  collisionObject,
  collisionFilterGroup,
  collisionFilterMask,
  m_dispatcher1));





}



void	btCollisionWorld::updateSingleAabb(btCollisionObject* colObj)
{
 btVector3 minAabb, maxAabb;
 colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
 //need to increase the aabb for contact thresholds
 btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
 minAabb -= contactThreshold;
 maxAabb += contactThreshold;

 if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
 {
  btVector3 minAabb2, maxAabb2;
  colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
  minAabb2 -= contactThreshold;
  maxAabb2 += contactThreshold;
  minAabb.setMin(minAabb2);
  maxAabb.setMax(maxAabb2);
 }

 btBroadphaseInterface* bp = (btBroadphaseInterface*)m_broadphasePairCache;

 //moving objects should be moderately sized, probably something wrong if not
 if (colObj->isStaticObject() || ((maxAabb - minAabb).length2() < btScalar(1e12)))
 {
  bp->setAabb(colObj->getBroadphaseHandle(), minAabb, maxAabb, m_dispatcher1);
 }
 else
 {
  //something went wrong, investigate
  //this assert is unwanted in 3D modelers (danger of loosing work)
  colObj->setActivationState(DISABLE_SIMULATION);

  static bool reportMe = true;
  if (reportMe && m_debugDrawer)
  {
   reportMe = false;
   m_debugDrawer->reportErrorWarning("Overflow in AABB, object removed from simulation");
   m_debugDrawer->reportErrorWarning("If you can reproduce this, please email bugs@continuousphysics.com\n");
   m_debugDrawer->reportErrorWarning("Please include above information, your Platform, version of OS.\n");
   m_debugDrawer->reportErrorWarning("Thanks.\n");
  }
 }
}

void	btCollisionWorld::updateAabbs()
{
 BT_PROFILE("updateAabbs");

 btTransform predictedTrans;
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btAssert(colObj->getWorldArrayIndex() == i);

  //only update aabb of active objects
  if (m_forceUpdateAllAabbs || colObj->isActive())
  {
   updateSingleAabb(colObj);
  }
 }
}


void	btCollisionWorld::computeOverlappingPairs()
{
 BT_PROFILE("calculateOverlappingPairs");
 m_broadphasePairCache->calculateOverlappingPairs(m_dispatcher1);
}

void	btCollisionWorld::performDiscreteCollisionDetection()
{
 BT_PROFILE("performDiscreteCollisionDetection");

 btDispatcherInfo& dispatchInfo = getDispatchInfo();

 updateAabbs();

 computeOverlappingPairs();

 btDispatcher* dispatcher = getDispatcher();
 {
  BT_PROFILE("dispatchAllCollisionPairs");
  if (dispatcher)
   dispatcher->dispatchAllCollisionPairs(m_broadphasePairCache->getOverlappingPairCache(), dispatchInfo, m_dispatcher1);
 }

}



void	btCollisionWorld::removeCollisionObject(btCollisionObject* collisionObject)
{


 //bool removeFromBroadphase = false;

 {

  btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
  if (bp)
  {
   //
   // only clear the cached algorithms
   //
   getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
   getBroadphase()->destroyProxy(bp, m_dispatcher1);
   collisionObject->setBroadphaseHandle(0);
  }
 }


 int iObj = collisionObject->getWorldArrayIndex();
 //    btAssert(iObj >= 0 && iObj < m_collisionObjects.size()); // trying to remove an object that was never added or already removed previously?
 if (iObj >= 0 && iObj < m_collisionObjects.size())
 {
  btAssert(collisionObject == m_collisionObjects[iObj]);
  m_collisionObjects.swap(iObj, m_collisionObjects.size() - 1);
  m_collisionObjects.pop_back();
  if (iObj < m_collisionObjects.size())
  {
   m_collisionObjects[iObj]->setWorldArrayIndex(iObj);
  }
 }
 else
 {
  // slow linear search
  //swapremove
  m_collisionObjects.remove(collisionObject);
 }
 collisionObject->setWorldArrayIndex(-1);
}


void	btCollisionWorld::rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
 btCollisionObject* collisionObject,
 const btCollisionShape* collisionShape,
 const btTransform& colObjWorldTransform,
 RayResultCallback& resultCallback)
{
 btCollisionObjectWrapper colObWrap(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
 btCollisionWorld::rayTestSingleInternal(rayFromTrans, rayToTrans, &colObWrap, resultCallback);
}

void	btCollisionWorld::rayTestSingleInternal(const btTransform& rayFromTrans, const btTransform& rayToTrans,
 const btCollisionObjectWrapper* collisionObjectWrap,
 RayResultCallback& resultCallback)
{
 btSphereShape pointShape(btScalar(0.0));
 pointShape.setMargin(0.f);
 const btConvexShape* castShape = &pointShape;
 const btCollisionShape* collisionShape = collisionObjectWrap->getCollisionShape();
 const btTransform& colObjWorldTransform = collisionObjectWrap->getWorldTransform();

 if (collisionShape->isConvex())
 {
  //		BT_PROFILE("rayTestConvex");
  btConvexCast::CastResult castResult;
  castResult.m_fraction = resultCallback.m_closestHitFraction;

  btConvexShape* convexShape = (btConvexShape*)collisionShape;
  btVoronoiSimplexSolver	simplexSolver;
  btSubsimplexConvexCast subSimplexConvexCaster(castShape, convexShape, &simplexSolver);

  btGjkConvexCast	gjkConvexCaster(castShape, convexShape, &simplexSolver);

  //btContinuousConvexCollision convexCaster(castShape,convexShape,&simplexSolver,0);

  btConvexCast* convexCasterPtr = 0;
  //use kF_UseSubSimplexConvexCastRaytest by default
  if (resultCallback.m_flags & btTriangleRaycastCallback::kF_UseGjkConvexCastRaytest)
   convexCasterPtr = &gjkConvexCaster;
  else
   convexCasterPtr = &subSimplexConvexCaster;

  btConvexCast& convexCaster = *convexCasterPtr;

  if (convexCaster.calcTimeOfImpact(rayFromTrans, rayToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
  {
   //add hit
   if (castResult.m_normal.length2() > btScalar(0.0001))
   {
    if (castResult.m_fraction < resultCallback.m_closestHitFraction)
    {
     //todo: figure out what this is about. When is rayFromTest.getBasis() not identity?
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
     //rotate normal into worldspace
     castResult.m_normal = rayFromTrans.getBasis() * castResult.m_normal;
#endif //USE_SUBSIMPLEX_CONVEX_CAST

     castResult.m_normal.normalize();
     btCollisionWorld::LocalRayResult localRayResult
     (
      collisionObjectWrap->getCollisionObject(),
      0,
      castResult.m_normal,
      castResult.m_fraction
     );

     bool normalInWorldSpace = true;
     resultCallback.addSingleResult(localRayResult, normalInWorldSpace);

    }
   }
  }
 }
 else {
  if (collisionShape->isConcave())
  {

   //ConvexCast::CastResult
   struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
   {
    btCollisionWorld::RayResultCallback* m_resultCallback;
    const btCollisionObject*	m_collisionObject;
    const btConcaveShape*	m_triangleMesh;

    btTransform m_colObjWorldTransform;

    BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
     btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, const btConcaveShape*	triangleMesh, const btTransform& colObjWorldTransform) :
     //@BP Mod
     btTriangleRaycastCallback(from, to, resultCallback->m_flags),
     m_resultCallback(resultCallback),
     m_collisionObject(collisionObject),
     m_triangleMesh(triangleMesh),
     m_colObjWorldTransform(colObjWorldTransform)
    {
    }


    virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
    {
     btCollisionWorld::LocalShapeInfo	shapeInfo;
     shapeInfo.m_shapePart = partId;
     shapeInfo.m_triangleIndex = triangleIndex;

     btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

     btCollisionWorld::LocalRayResult rayResult
     (m_collisionObject,
      &shapeInfo,
      hitNormalWorld,
      hitFraction);

     bool	normalInWorldSpace = true;
     return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
    }

   };

   btTransform worldTocollisionObject = colObjWorldTransform.inverse();
   btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
   btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

   //			BT_PROFILE("rayTestConcave");
   if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
   {
    ///optimized version for btBvhTriangleMeshShape
    btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;

    BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
    rcb.m_hitFraction = resultCallback.m_closestHitFraction;
    triangleMesh->performRaycast(&rcb, rayFromLocal, rayToLocal);
   }
   else
   {
    //generic (slower) case
    btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;

    btTransform worldTocollisionObject = colObjWorldTransform.inverse();

    btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
    btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

    //ConvexCast::CastResult

    struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
    {
     btCollisionWorld::RayResultCallback* m_resultCallback;
     const btCollisionObject*	m_collisionObject;
     btConcaveShape*	m_triangleMesh;

     btTransform m_colObjWorldTransform;

     BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
      btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape*	triangleMesh, const btTransform& colObjWorldTransform) :
      //@BP Mod
      btTriangleRaycastCallback(from, to, resultCallback->m_flags),
      m_resultCallback(resultCallback),
      m_collisionObject(collisionObject),
      m_triangleMesh(triangleMesh),
      m_colObjWorldTransform(colObjWorldTransform)
     {
     }


     virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
     {
      btCollisionWorld::LocalShapeInfo	shapeInfo;
      shapeInfo.m_shapePart = partId;
      shapeInfo.m_triangleIndex = triangleIndex;

      btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

      btCollisionWorld::LocalRayResult rayResult
      (m_collisionObject,
       &shapeInfo,
       hitNormalWorld,
       hitFraction);

      bool	normalInWorldSpace = true;
      return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
     }

    };


    BridgeTriangleRaycastCallback	rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
    rcb.m_hitFraction = resultCallback.m_closestHitFraction;

    btVector3 rayAabbMinLocal = rayFromLocal;
    rayAabbMinLocal.setMin(rayToLocal);
    btVector3 rayAabbMaxLocal = rayFromLocal;
    rayAabbMaxLocal.setMax(rayToLocal);

    concaveShape->processAllTriangles(&rcb, rayAabbMinLocal, rayAabbMaxLocal);
   }
  }
  else {
   //			BT_PROFILE("rayTestCompound");
   if (collisionShape->isCompound())
   {
    struct LocalInfoAdder2 : public RayResultCallback
    {
     RayResultCallback* m_userCallback;
     int m_i;

     LocalInfoAdder2(int i, RayResultCallback *user)
      : m_userCallback(user), m_i(i)
     {
      m_closestHitFraction = m_userCallback->m_closestHitFraction;
      m_flags = m_userCallback->m_flags;
     }
     virtual bool needsCollision(btBroadphaseProxy* p) const
     {
      return m_userCallback->needsCollision(p);
     }

     virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult &r, bool b)
     {
      btCollisionWorld::LocalShapeInfo shapeInfo;
      shapeInfo.m_shapePart = -1;
      shapeInfo.m_triangleIndex = m_i;
      if (r.m_localShapeInfo == NULL)
       r.m_localShapeInfo = &shapeInfo;

      const btScalar result = m_userCallback->addSingleResult(r, b);
      m_closestHitFraction = m_userCallback->m_closestHitFraction;
      return result;
     }
    };

    struct RayTester : btDbvt::ICollide
    {
     const btCollisionObject* m_collisionObject;
     const btCompoundShape* m_compoundShape;
     const btTransform& m_colObjWorldTransform;
     const btTransform& m_rayFromTrans;
     const btTransform& m_rayToTrans;
     RayResultCallback& m_resultCallback;

     RayTester(const btCollisionObject* collisionObject,
      const btCompoundShape* compoundShape,
      const btTransform& colObjWorldTransform,
      const btTransform& rayFromTrans,
      const btTransform& rayToTrans,
      RayResultCallback& resultCallback) :
      m_collisionObject(collisionObject),
      m_compoundShape(compoundShape),
      m_colObjWorldTransform(colObjWorldTransform),
      m_rayFromTrans(rayFromTrans),
      m_rayToTrans(rayToTrans),
      m_resultCallback(resultCallback)
     {

     }

     void ProcessLeaf(int i)
     {
      const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(i);
      const btTransform& childTrans = m_compoundShape->getChildTransform(i);
      btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

      btCollisionObjectWrapper tmpOb(0, childCollisionShape, m_collisionObject, childWorldTrans, -1, i);
      // replace collision shape so that callback can determine the triangle



      LocalInfoAdder2 my_cb(i, &m_resultCallback);

      rayTestSingleInternal(
       m_rayFromTrans,
       m_rayToTrans,
       &tmpOb,
       my_cb);

     }

     void Process(const btDbvtNode* leaf)
     {
      ProcessLeaf(leaf->dataAsInt);
     }
    };

    const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);
    const btDbvt* dbvt = compoundShape->getDynamicAabbTree();


    RayTester rayCB(
     collisionObjectWrap->getCollisionObject(),
     compoundShape,
     colObjWorldTransform,
     rayFromTrans,
     rayToTrans,
     resultCallback);
#ifndef	DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
    if (dbvt)
    {
     btVector3 localRayFrom = colObjWorldTransform.inverseTimes(rayFromTrans).getOrigin();
     btVector3 localRayTo = colObjWorldTransform.inverseTimes(rayToTrans).getOrigin();
     btDbvt::rayTest(dbvt->m_root, localRayFrom, localRayTo, rayCB);
    }
    else
#endif //DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
    {
     for (int i = 0, n = compoundShape->getNumChildShapes(); i < n; ++i)
     {
      rayCB.ProcessLeaf(i);
     }
    }
   }
  }
 }
}

void	btCollisionWorld::objectQuerySingle(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
 btCollisionObject* collisionObject,
 const btCollisionShape* collisionShape,
 const btTransform& colObjWorldTransform,
 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
 btCollisionObjectWrapper tmpOb(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
 btCollisionWorld::objectQuerySingleInternal(castShape, convexFromTrans, convexToTrans, &tmpOb, resultCallback, allowedPenetration);
}

void	btCollisionWorld::objectQuerySingleInternal(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
 const btCollisionObjectWrapper* colObjWrap,
 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
 const btCollisionShape* collisionShape = colObjWrap->getCollisionShape();
 const btTransform& colObjWorldTransform = colObjWrap->getWorldTransform();

 if (collisionShape->isConvex())
 {
  //BT_PROFILE("convexSweepConvex");
  btConvexCast::CastResult castResult;
  castResult.m_allowedPenetration = allowedPenetration;
  castResult.m_fraction = resultCallback.m_closestHitFraction;//btScalar(1.);//??

  btConvexShape* convexShape = (btConvexShape*)collisionShape;
  btVoronoiSimplexSolver	simplexSolver;
  btGjkEpaPenetrationDepthSolver	gjkEpaPenetrationSolver;

  btContinuousConvexCollision convexCaster1(castShape, convexShape, &simplexSolver, &gjkEpaPenetrationSolver);
  //btGjkConvexCast convexCaster2(castShape,convexShape,&simplexSolver);
  //btSubsimplexConvexCast convexCaster3(castShape,convexShape,&simplexSolver);

  btConvexCast* castPtr = &convexCaster1;



  if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
  {
   //add hit
   if (castResult.m_normal.length2() > btScalar(0.0001))
   {
    if (castResult.m_fraction < resultCallback.m_closestHitFraction)
    {
     castResult.m_normal.normalize();
     btCollisionWorld::LocalConvexResult localConvexResult
     (
      colObjWrap->getCollisionObject(),
      0,
      castResult.m_normal,
      castResult.m_hitPoint,
      castResult.m_fraction
     );

     bool normalInWorldSpace = true;
     resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);

    }
   }
  }
 }
 else {
  if (collisionShape->isConcave())
  {
   if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
   {
    //BT_PROFILE("convexSweepbtBvhTriangleMesh");
    btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;
    btTransform worldTocollisionObject = colObjWorldTransform.inverse();
    btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
    btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
    // rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
    btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

    //ConvexCast::CastResult
    struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
    {
     btCollisionWorld::ConvexResultCallback* m_resultCallback;
     const btCollisionObject*	m_collisionObject;
     btTriangleMeshShape*	m_triangleMesh;

     BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
      btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btTriangleMeshShape*	triangleMesh, const btTransform& triangleToWorld) :
      btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
      m_resultCallback(resultCallback),
      m_collisionObject(collisionObject),
      m_triangleMesh(triangleMesh)
     {
     }


     virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
     {
      btCollisionWorld::LocalShapeInfo	shapeInfo;
      shapeInfo.m_shapePart = partId;
      shapeInfo.m_triangleIndex = triangleIndex;
      if (hitFraction <= m_resultCallback->m_closestHitFraction)
      {

       btCollisionWorld::LocalConvexResult convexResult
       (m_collisionObject,
        &shapeInfo,
        hitNormalLocal,
        hitPointLocal,
        hitFraction);

       bool	normalInWorldSpace = true;


       return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
      }
      return hitFraction;
     }

    };

    BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
    tccb.m_hitFraction = resultCallback.m_closestHitFraction;
    tccb.m_allowedPenetration = allowedPenetration;
    btVector3 boxMinLocal, boxMaxLocal;
    castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);
    triangleMesh->performConvexcast(&tccb, convexFromLocal, convexToLocal, boxMinLocal, boxMaxLocal);
   }
   else
   {
    if (collisionShape->getShapeType() == STATIC_PLANE_PROXYTYPE)
    {
     btConvexCast::CastResult castResult;
     castResult.m_allowedPenetration = allowedPenetration;
     castResult.m_fraction = resultCallback.m_closestHitFraction;
     btStaticPlaneShape* planeShape = (btStaticPlaneShape*)collisionShape;
     btContinuousConvexCollision convexCaster1(castShape, planeShape);
     btConvexCast* castPtr = &convexCaster1;

     if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
     {
      //add hit
      if (castResult.m_normal.length2() > btScalar(0.0001))
      {
       if (castResult.m_fraction < resultCallback.m_closestHitFraction)
       {
        castResult.m_normal.normalize();
        btCollisionWorld::LocalConvexResult localConvexResult
        (
         colObjWrap->getCollisionObject(),
         0,
         castResult.m_normal,
         castResult.m_hitPoint,
         castResult.m_fraction
        );

        bool normalInWorldSpace = true;
        resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);
       }
      }
     }

    }
    else
    {
     //BT_PROFILE("convexSweepConcave");
     btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;
     btTransform worldTocollisionObject = colObjWorldTransform.inverse();
     btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
     btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
     // rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
     btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

     //ConvexCast::CastResult
     struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
     {
      btCollisionWorld::ConvexResultCallback* m_resultCallback;
      const btCollisionObject*	m_collisionObject;
      btConcaveShape*	m_triangleMesh;

      BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
       btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape*	triangleMesh, const btTransform& triangleToWorld) :
       btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
       m_resultCallback(resultCallback),
       m_collisionObject(collisionObject),
       m_triangleMesh(triangleMesh)
      {
      }


      virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
      {
       btCollisionWorld::LocalShapeInfo	shapeInfo;
       shapeInfo.m_shapePart = partId;
       shapeInfo.m_triangleIndex = triangleIndex;
       if (hitFraction <= m_resultCallback->m_closestHitFraction)
       {

        btCollisionWorld::LocalConvexResult convexResult
        (m_collisionObject,
         &shapeInfo,
         hitNormalLocal,
         hitPointLocal,
         hitFraction);

        bool	normalInWorldSpace = true;

        return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
       }
       return hitFraction;
      }

     };

     BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
     tccb.m_hitFraction = resultCallback.m_closestHitFraction;
     tccb.m_allowedPenetration = allowedPenetration;
     btVector3 boxMinLocal, boxMaxLocal;
     castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);

     btVector3 rayAabbMinLocal = convexFromLocal;
     rayAabbMinLocal.setMin(convexToLocal);
     btVector3 rayAabbMaxLocal = convexFromLocal;
     rayAabbMaxLocal.setMax(convexToLocal);
     rayAabbMinLocal += boxMinLocal;
     rayAabbMaxLocal += boxMaxLocal;
     concaveShape->processAllTriangles(&tccb, rayAabbMinLocal, rayAabbMaxLocal);
    }
   }
  }
  else {
   if (collisionShape->isCompound())
   {
    struct	btCompoundLeafCallback : btDbvt::ICollide
    {
     btCompoundLeafCallback(
      const btCollisionObjectWrapper* colObjWrap,
      const btConvexShape* castShape,
      const btTransform& convexFromTrans,
      const btTransform& convexToTrans,
      btScalar allowedPenetration,
      const btCompoundShape* compoundShape,
      const btTransform& colObjWorldTransform,
      ConvexResultCallback& resultCallback)
      :
      m_colObjWrap(colObjWrap),
      m_castShape(castShape),
      m_convexFromTrans(convexFromTrans),
      m_convexToTrans(convexToTrans),
      m_allowedPenetration(allowedPenetration),
      m_compoundShape(compoundShape),
      m_colObjWorldTransform(colObjWorldTransform),
      m_resultCallback(resultCallback) {
     }

     const btCollisionObjectWrapper* m_colObjWrap;
     const btConvexShape* m_castShape;
     const btTransform& m_convexFromTrans;
     const btTransform& m_convexToTrans;
     btScalar m_allowedPenetration;
     const btCompoundShape* m_compoundShape;
     const btTransform& m_colObjWorldTransform;
     ConvexResultCallback& m_resultCallback;

    public:

     void		ProcessChild(int index, const btTransform& childTrans, const btCollisionShape* childCollisionShape)
     {
      btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

      struct	LocalInfoAdder : public ConvexResultCallback {
       ConvexResultCallback* m_userCallback;
       int m_i;

       LocalInfoAdder(int i, ConvexResultCallback *user)
        : m_userCallback(user), m_i(i)
       {
        m_closestHitFraction = m_userCallback->m_closestHitFraction;
       }
       virtual bool needsCollision(btBroadphaseProxy* p) const
       {
        return m_userCallback->needsCollision(p);
       }
       virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult&	r, bool b)
       {
        btCollisionWorld::LocalShapeInfo	shapeInfo;
        shapeInfo.m_shapePart = -1;
        shapeInfo.m_triangleIndex = m_i;
        if (r.m_localShapeInfo == NULL)
         r.m_localShapeInfo = &shapeInfo;
        const btScalar result = m_userCallback->addSingleResult(r, b);
        m_closestHitFraction = m_userCallback->m_closestHitFraction;
        return result;

       }
      };

      LocalInfoAdder my_cb(index, &m_resultCallback);

      btCollisionObjectWrapper tmpObj(m_colObjWrap, childCollisionShape, m_colObjWrap->getCollisionObject(), childWorldTrans, -1, index);

      objectQuerySingleInternal(m_castShape, m_convexFromTrans, m_convexToTrans, &tmpObj, my_cb, m_allowedPenetration);
     }

     void		Process(const btDbvtNode* leaf)
     {
      // Processing leaf node
      int index = leaf->dataAsInt;

      btTransform childTrans = m_compoundShape->getChildTransform(index);
      const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(index);

      ProcessChild(index, childTrans, childCollisionShape);
     }
    };

    BT_PROFILE("convexSweepCompound");
    const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);

    btVector3 fromLocalAabbMin, fromLocalAabbMax;
    btVector3 toLocalAabbMin, toLocalAabbMax;

    castShape->getAabb(colObjWorldTransform.inverse() * convexFromTrans, fromLocalAabbMin, fromLocalAabbMax);
    castShape->getAabb(colObjWorldTransform.inverse() * convexToTrans, toLocalAabbMin, toLocalAabbMax);

    fromLocalAabbMin.setMin(toLocalAabbMin);
    fromLocalAabbMax.setMax(toLocalAabbMax);

    btCompoundLeafCallback callback(colObjWrap, castShape, convexFromTrans, convexToTrans,
     allowedPenetration, compoundShape, colObjWorldTransform, resultCallback);

    const btDbvt* tree = compoundShape->getDynamicAabbTree();
    if (tree) {
     const ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds = btDbvtVolume::FromMM(fromLocalAabbMin, fromLocalAabbMax);
     tree->collideTV(tree->m_root, bounds, callback);
    }
    else {
     int i;
     for (i = 0; i<compoundShape->getNumChildShapes(); i++)
     {
      const btCollisionShape* childCollisionShape = compoundShape->getChildShape(i);
      btTransform childTrans = compoundShape->getChildTransform(i);
      callback.ProcessChild(i, childTrans, childCollisionShape);
     }
    }
   }
  }
 }
}


struct btSingleRayCallback : public btBroadphaseRayCallback
{

 btVector3	m_rayFromWorld;
 btVector3	m_rayToWorld;
 btTransform	m_rayFromTrans;
 btTransform	m_rayToTrans;
 btVector3	m_hitNormal;

 const btCollisionWorld*	m_world;
 btCollisionWorld::RayResultCallback&	m_resultCallback;

 btSingleRayCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld, const btCollisionWorld* world, btCollisionWorld::RayResultCallback& resultCallback)
  :m_rayFromWorld(rayFromWorld),
  m_rayToWorld(rayToWorld),
  m_world(world),
  m_resultCallback(resultCallback)
 {
  m_rayFromTrans.setIdentity();
  m_rayFromTrans.setOrigin(m_rayFromWorld);
  m_rayToTrans.setIdentity();
  m_rayToTrans.setOrigin(m_rayToWorld);

  btVector3 rayDir = (rayToWorld - rayFromWorld);

  rayDir.normalize();
  ///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
  m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
  m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
  m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
  m_signs[0] = m_rayDirectionInverse[0] < 0.0;
  m_signs[1] = m_rayDirectionInverse[1] < 0.0;
  m_signs[2] = m_rayDirectionInverse[2] < 0.0;

  m_lambda_max = rayDir.dot(m_rayToWorld - m_rayFromWorld);

 }



 virtual bool	process(const btBroadphaseProxy* proxy)
 {
  ///terminate further ray tests, once the closestHitFraction reached zero
  if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
   return false;

  btCollisionObject*	collisionObject = (btCollisionObject*)proxy->m_clientObject;

  //only perform raycast if filterMask matches
  if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
  {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   //btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
#if 0
#ifdef RECALCULATE_AABB
   btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
   collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
#else
   //getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
   const btVector3& collisionObjectAabbMin = collisionObject->getBroadphaseHandle()->m_aabbMin;
   const btVector3& collisionObjectAabbMax = collisionObject->getBroadphaseHandle()->m_aabbMax;
#endif
#endif
   //btScalar hitLambda = m_resultCallback.m_closestHitFraction;
   //culling already done by broadphase
   //if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
   {
    m_world->rayTestSingle(m_rayFromTrans, m_rayToTrans,
     collisionObject,
     collisionObject->getCollisionShape(),
     collisionObject->getWorldTransform(),
     m_resultCallback);
   }
  }
  return true;
 }
};

void	btCollisionWorld::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const
{
 //BT_PROFILE("rayTest");
 /// use the broadphase to accelerate the search for objects, based on their aabb
 /// and for each object with ray-aabb overlap, perform an exact ray test
 btSingleRayCallback rayCB(rayFromWorld, rayToWorld, this, resultCallback);

#ifndef USE_BRUTEFORCE_RAYBROADPHASE
 m_broadphasePairCache->rayTest(rayFromWorld, rayToWorld, rayCB);
#else
 for (int i = 0; i<this->getNumCollisionObjects(); i++)
 {
  rayCB.process(m_collisionObjects[i]->getBroadphaseHandle());
 }
#endif //USE_BRUTEFORCE_RAYBROADPHASE

}


struct btSingleSweepCallback : public btBroadphaseRayCallback
{

 btTransform	m_convexFromTrans;
 btTransform	m_convexToTrans;
 btVector3	m_hitNormal;
 const btCollisionWorld*	m_world;
 btCollisionWorld::ConvexResultCallback&	m_resultCallback;
 btScalar	m_allowedCcdPenetration;
 const btConvexShape* m_castShape;


 btSingleSweepCallback(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans, const btCollisionWorld* world, btCollisionWorld::ConvexResultCallback& resultCallback, btScalar allowedPenetration)
  :m_convexFromTrans(convexFromTrans),
  m_convexToTrans(convexToTrans),
  m_world(world),
  m_resultCallback(resultCallback),
  m_allowedCcdPenetration(allowedPenetration),
  m_castShape(castShape)
 {
  btVector3 unnormalizedRayDir = (m_convexToTrans.getOrigin() - m_convexFromTrans.getOrigin());
  btVector3 rayDir = unnormalizedRayDir.normalized();
  ///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
  m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
  m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
  m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
  m_signs[0] = m_rayDirectionInverse[0] < 0.0;
  m_signs[1] = m_rayDirectionInverse[1] < 0.0;
  m_signs[2] = m_rayDirectionInverse[2] < 0.0;

  m_lambda_max = rayDir.dot(unnormalizedRayDir);

 }

 virtual bool	process(const btBroadphaseProxy* proxy)
 {
  ///terminate further convex sweep tests, once the closestHitFraction reached zero
  if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
   return false;

  btCollisionObject*	collisionObject = (btCollisionObject*)proxy->m_clientObject;

  //only perform raycast if filterMask matches
  if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle())) {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   m_world->objectQuerySingle(m_castShape, m_convexFromTrans, m_convexToTrans,
    collisionObject,
    collisionObject->getCollisionShape(),
    collisionObject->getWorldTransform(),
    m_resultCallback,
    m_allowedCcdPenetration);
  }

  return true;
 }
};



void	btCollisionWorld::convexSweepTest(const btConvexShape* castShape, const btTransform& convexFromWorld, const btTransform& convexToWorld, ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration) const
{

 BT_PROFILE("convexSweepTest");
 /// use the broadphase to accelerate the search for objects, based on their aabb
 /// and for each object with ray-aabb overlap, perform an exact ray test
 /// unfortunately the implementation for rayTest and convexSweepTest duplicated, albeit practically identical



 btTransform	convexFromTrans, convexToTrans;
 convexFromTrans = convexFromWorld;
 convexToTrans = convexToWorld;
 btVector3 castShapeAabbMin, castShapeAabbMax;
 /* Compute AABB that encompasses angular movement */
 {
  btVector3 linVel, angVel;
  btTransformUtil::calculateVelocity(convexFromTrans, convexToTrans, 1.0f, linVel, angVel);
  btVector3 zeroLinVel;
  zeroLinVel.setValue(0, 0, 0);
  btTransform R;
  R.setIdentity();
  R.setRotation(convexFromTrans.getRotation());
  castShape->calculateTemporalAabb(R, zeroLinVel, angVel, 1.0f, castShapeAabbMin, castShapeAabbMax);
 }

#ifndef USE_BRUTEFORCE_RAYBROADPHASE

 btSingleSweepCallback	convexCB(castShape, convexFromWorld, convexToWorld, this, resultCallback, allowedCcdPenetration);

 m_broadphasePairCache->rayTest(convexFromTrans.getOrigin(), convexToTrans.getOrigin(), convexCB, castShapeAabbMin, castShapeAabbMax);

#else
 /// go over all objects, and if the ray intersects their aabb + cast shape aabb,
 // do a ray-shape query using convexCaster (CCD)
 int i;
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject*	collisionObject = m_collisionObjects[i];
  //only perform raycast if filterMask matches
  if (resultCallback.needsCollision(collisionObject->getBroadphaseHandle())) {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
   collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
   AabbExpand(collisionObjectAabbMin, collisionObjectAabbMax, castShapeAabbMin, castShapeAabbMax);
   btScalar hitLambda = btScalar(1.); //could use resultCallback.m_closestHitFraction, but needs testing
   btVector3 hitNormal;
   if (btRayAabb(convexFromWorld.getOrigin(), convexToWorld.getOrigin(), collisionObjectAabbMin, collisionObjectAabbMax, hitLambda, hitNormal))
   {
    objectQuerySingle(castShape, convexFromTrans, convexToTrans,
     collisionObject,
     collisionObject->getCollisionShape(),
     collisionObject->getWorldTransform(),
     resultCallback,
     allowedCcdPenetration);
   }
  }
 }
#endif //USE_BRUTEFORCE_RAYBROADPHASE
}



struct btBridgedManifoldResult : public btManifoldResult
{

 btCollisionWorld::ContactResultCallback&	m_resultCallback;

 btBridgedManifoldResult(const btCollisionObjectWrapper* obj0Wrap, const btCollisionObjectWrapper* obj1Wrap, btCollisionWorld::ContactResultCallback& resultCallback)
  :btManifoldResult(obj0Wrap, obj1Wrap),
  m_resultCallback(resultCallback)
 {
 }

 virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
 {
  bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
  btVector3 pointA = pointInWorld + normalOnBInWorld * depth;
  btVector3 localA;
  btVector3 localB;
  if (isSwapped)
  {
   localA = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
   localB = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
  }
  else
  {
   localA = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
   localB = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
  }

  btManifoldPoint newPt(localA, localB, normalOnBInWorld, depth);
  newPt.m_positionWorldOnA = pointA;
  newPt.m_positionWorldOnB = pointInWorld;

  //BP mod, store contact triangles.
  if (isSwapped)
  {
   newPt.m_partId0 = m_partId1;
   newPt.m_partId1 = m_partId0;
   newPt.m_index0 = m_index1;
   newPt.m_index1 = m_index0;
  }
  else
  {
   newPt.m_partId0 = m_partId0;
   newPt.m_partId1 = m_partId1;
   newPt.m_index0 = m_index0;
   newPt.m_index1 = m_index1;
  }

  //experimental feature info, for per-triangle material etc.
  const btCollisionObjectWrapper* obj0Wrap = isSwapped ? m_body1Wrap : m_body0Wrap;
  const btCollisionObjectWrapper* obj1Wrap = isSwapped ? m_body0Wrap : m_body1Wrap;
  m_resultCallback.addSingleResult(newPt, obj0Wrap, newPt.m_partId0, newPt.m_index0, obj1Wrap, newPt.m_partId1, newPt.m_index1);

 }

};



struct btSingleContactCallback : public btBroadphaseAabbCallback
{

 btCollisionObject* m_collisionObject;
 btCollisionWorld*	m_world;
 btCollisionWorld::ContactResultCallback&	m_resultCallback;


 btSingleContactCallback(btCollisionObject* collisionObject, btCollisionWorld* world, btCollisionWorld::ContactResultCallback& resultCallback)
  :m_collisionObject(collisionObject),
  m_world(world),
  m_resultCallback(resultCallback)
 {
 }

 virtual bool	process(const btBroadphaseProxy* proxy)
 {
  btCollisionObject*	collisionObject = (btCollisionObject*)proxy->m_clientObject;
  if (collisionObject == m_collisionObject)
   return true;

  //only perform raycast if filterMask matches
  if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
  {
   btCollisionObjectWrapper ob0(0, m_collisionObject->getCollisionShape(), m_collisionObject, m_collisionObject->getWorldTransform(), -1, -1);
   btCollisionObjectWrapper ob1(0, collisionObject->getCollisionShape(), collisionObject, collisionObject->getWorldTransform(), -1, -1);

   btCollisionAlgorithm* algorithm = m_world->getDispatcher()->findAlgorithm(&ob0, &ob1, 0, BT_CLOSEST_POINT_ALGORITHMS);
   if (algorithm)
   {
    btBridgedManifoldResult contactPointResult(&ob0, &ob1, m_resultCallback);
    //discrete collision detection query

    algorithm->processCollision(&ob0, &ob1, m_world->getDispatchInfo(), &contactPointResult);

    algorithm->~btCollisionAlgorithm();
    m_world->getDispatcher()->freeCollisionAlgorithm(algorithm);
   }
  }
  return true;
 }
};


///contactTest performs a discrete collision test against all objects in the btCollisionWorld, and calls the resultCallback.
///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
void	btCollisionWorld::contactTest(btCollisionObject* colObj, ContactResultCallback& resultCallback)
{
 btVector3 aabbMin, aabbMax;
 colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), aabbMin, aabbMax);
 btSingleContactCallback	contactCB(colObj, this, resultCallback);

 m_broadphasePairCache->aabbTest(aabbMin, aabbMax, contactCB);
}


///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
///it reports one or more contact points (including the one with deepest penetration)
void	btCollisionWorld::contactPairTest(btCollisionObject* colObjA, btCollisionObject* colObjB, ContactResultCallback& resultCallback)
{
 btCollisionObjectWrapper obA(0, colObjA->getCollisionShape(), colObjA, colObjA->getWorldTransform(), -1, -1);
 btCollisionObjectWrapper obB(0, colObjB->getCollisionShape(), colObjB, colObjB->getWorldTransform(), -1, -1);

 btCollisionAlgorithm* algorithm = getDispatcher()->findAlgorithm(&obA, &obB, 0, BT_CLOSEST_POINT_ALGORITHMS);
 if (algorithm)
 {
  btBridgedManifoldResult contactPointResult(&obA, &obB, resultCallback);
  contactPointResult.m_closestPointDistanceThreshold = resultCallback.m_closestDistanceThreshold;
  //discrete collision detection query
  algorithm->processCollision(&obA, &obB, getDispatchInfo(), &contactPointResult);

  algorithm->~btCollisionAlgorithm();
  getDispatcher()->freeCollisionAlgorithm(algorithm);
 }

}




class DebugDrawcallback : public btTriangleCallback, public btInternalTriangleIndexCallback
{
 btIDebugDraw*	m_debugDrawer;
 btVector3	m_color;
 btTransform	m_worldTrans;

public:

 DebugDrawcallback(btIDebugDraw*	debugDrawer, const btTransform& worldTrans, const btVector3& color) :
  m_debugDrawer(debugDrawer),
  m_color(color),
  m_worldTrans(worldTrans)
 {
 }

 virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int  triangleIndex)
 {
  processTriangle(triangle, partId, triangleIndex);
 }

 virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
 {
  (void)partId;
  (void)triangleIndex;

  btVector3 wv0, wv1, wv2;
  wv0 = m_worldTrans*triangle[0];
  wv1 = m_worldTrans*triangle[1];
  wv2 = m_worldTrans*triangle[2];
  btVector3 center = (wv0 + wv1 + wv2)*btScalar(1. / 3.);

  if (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
  {
   btVector3 normal = (wv1 - wv0).cross(wv2 - wv0);
   normal.normalize();
   btVector3 normalColor(1, 1, 0);
   m_debugDrawer->drawLine(center, center + normal, normalColor);
  }
  m_debugDrawer->drawLine(wv0, wv1, m_color);
  m_debugDrawer->drawLine(wv1, wv2, m_color);
  m_debugDrawer->drawLine(wv2, wv0, m_color);
 }
};


void btCollisionWorld::debugDrawObject(const btTransform& worldTransform, const btCollisionShape* shape, const btVector3& color)
{
 // Draw a small simplex at the center of the object
 if (getDebugDrawer() && getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawFrames)
 {
  getDebugDrawer()->drawTransform(worldTransform, .1f);
 }

 if (shape->getShapeType() == COMPOUND_SHAPE_PROXYTYPE)
 {
  const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(shape);
  for (int i = compoundShape->getNumChildShapes() - 1; i >= 0; i--)
  {
   btTransform childTrans = compoundShape->getChildTransform(i);
   const btCollisionShape* colShape = compoundShape->getChildShape(i);
   debugDrawObject(worldTransform*childTrans, colShape, color);
  }

 }
 else
 {

  switch (shape->getShapeType())
  {

  case BOX_SHAPE_PROXYTYPE:
  {
   const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
   btVector3 halfExtents = boxShape->getHalfExtentsWithMargin();
   getDebugDrawer()->drawBox(-halfExtents, halfExtents, worldTransform, color);
   break;
  }

  case SPHERE_SHAPE_PROXYTYPE:
  {
   const btSphereShape* sphereShape = static_cast<const btSphereShape*>(shape);
   btScalar radius = sphereShape->getMargin();//radius doesn't include the margin, so draw with margin

   getDebugDrawer()->drawSphere(radius, worldTransform, color);
   break;
  }
  case MULTI_SPHERE_SHAPE_PROXYTYPE:
  {
   const btMultiSphereShape* multiSphereShape = static_cast<const btMultiSphereShape*>(shape);

   btTransform childTransform;
   childTransform.setIdentity();

   for (int i = multiSphereShape->getSphereCount() - 1; i >= 0; i--)
   {
    childTransform.setOrigin(multiSphereShape->getSpherePosition(i));
    getDebugDrawer()->drawSphere(multiSphereShape->getSphereRadius(i), worldTransform*childTransform, color);
   }

   break;
  }
  case CAPSULE_SHAPE_PROXYTYPE:
  {
   const btCapsuleShape* capsuleShape = static_cast<const btCapsuleShape*>(shape);

   btScalar radius = capsuleShape->getRadius();
   btScalar halfHeight = capsuleShape->getHalfHeight();

   int upAxis = capsuleShape->getUpAxis();
   getDebugDrawer()->drawCapsule(radius, halfHeight, upAxis, worldTransform, color);
   break;
  }
  case CONE_SHAPE_PROXYTYPE:
  {
   const btConeShape* coneShape = static_cast<const btConeShape*>(shape);
   btScalar radius = coneShape->getRadius();//+coneShape->getMargin();
   btScalar height = coneShape->getHeight();//+coneShape->getMargin();

   int upAxis = coneShape->getConeUpIndex();
   getDebugDrawer()->drawCone(radius, height, upAxis, worldTransform, color);
   break;

  }
  case CYLINDER_SHAPE_PROXYTYPE:
  {
   const btCylinderShape* cylinder = static_cast<const btCylinderShape*>(shape);
   int upAxis = cylinder->getUpAxis();
   btScalar radius = cylinder->getRadius();
   btScalar halfHeight = cylinder->getHalfExtentsWithMargin()[upAxis];
   getDebugDrawer()->drawCylinder(radius, halfHeight, upAxis, worldTransform, color);
   break;
  }

  case STATIC_PLANE_PROXYTYPE:
  {
   const btStaticPlaneShape* staticPlaneShape = static_cast<const btStaticPlaneShape*>(shape);
   btScalar planeConst = staticPlaneShape->getPlaneConstant();
   const btVector3& planeNormal = staticPlaneShape->getPlaneNormal();
   getDebugDrawer()->drawPlane(planeNormal, planeConst, worldTransform, color);
   break;

  }
  default:
  {

   /// for polyhedral shapes
   if (shape->isPolyhedral())
   {
    btPolyhedralConvexShape* polyshape = (btPolyhedralConvexShape*)shape;

    int i;
    if (polyshape->getConvexPolyhedron())
    {
     const btConvexPolyhedron* poly = polyshape->getConvexPolyhedron();
     for (i = 0; i<poly->m_faces.size(); i++)
     {
      btVector3 centroid(0, 0, 0);
      int numVerts = poly->m_faces[i].m_indices.size();
      if (numVerts)
      {
       int lastV = poly->m_faces[i].m_indices[numVerts - 1];
       for (int v = 0; v<poly->m_faces[i].m_indices.size(); v++)
       {
        int curVert = poly->m_faces[i].m_indices[v];
        centroid += poly->m_vertices[curVert];
        getDebugDrawer()->drawLine(worldTransform*poly->m_vertices[lastV], worldTransform*poly->m_vertices[curVert], color);
        lastV = curVert;
       }
      }
      centroid *= btScalar(1.f) / btScalar(numVerts);
      if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
      {
       btVector3 normalColor(1, 1, 0);
       btVector3 faceNormal(poly->m_faces[i].m_plane[0], poly->m_faces[i].m_plane[1], poly->m_faces[i].m_plane[2]);
       getDebugDrawer()->drawLine(worldTransform*centroid, worldTransform*(centroid + faceNormal), normalColor);
      }

     }


    }
    else
    {
     for (i = 0; i<polyshape->getNumEdges(); i++)
     {
      btVector3 a, b;
      polyshape->getEdge(i, a, b);
      btVector3 wa = worldTransform * a;
      btVector3 wb = worldTransform * b;
      getDebugDrawer()->drawLine(wa, wb, color);
     }
    }


   }

   if (shape->isConcave())
   {
    btConcaveShape* concaveMesh = (btConcaveShape*)shape;

    ///@todo pass camera, for some culling? no -> we are not a graphics lib
    btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
    btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));

    DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
    concaveMesh->processAllTriangles(&drawCallback, aabbMin, aabbMax);

   }

   if (shape->getShapeType() == CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE)
   {
    btConvexTriangleMeshShape* convexMesh = (btConvexTriangleMeshShape*)shape;
    //todo: pass camera for some culling			
    btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
    btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
    //DebugDrawcallback drawCallback;
    DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
    convexMesh->getMeshInterface()->InternalProcessAllTriangles(&drawCallback, aabbMin, aabbMax);
   }



  }

  }
 }
}


void	btCollisionWorld::debugDrawWorld()
{
 if (getDebugDrawer())
 {
  getDebugDrawer()->clearLines();

  btIDebugDraw::DefaultColors defaultColors = getDebugDrawer()->getDefaultColors();

  if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawContactPoints)
  {


   if (getDispatcher())
   {
    int numManifolds = getDispatcher()->getNumManifolds();

    for (int i = 0; i<numManifolds; i++)
    {
     btPersistentManifold* contactManifold = getDispatcher()->getManifoldByIndexInternal(i);
     //btCollisionObject* obA = static_cast<btCollisionObject*>(contactManifold->getBody0());
     //btCollisionObject* obB = static_cast<btCollisionObject*>(contactManifold->getBody1());

     int numContacts = contactManifold->getNumContacts();
     for (int j = 0; j<numContacts; j++)
     {
      btManifoldPoint& cp = contactManifold->getContactPoint(j);
      getDebugDrawer()->drawContactPoint(cp.m_positionWorldOnB, cp.m_normalWorldOnB, cp.getDistance(), cp.getLifeTime(), defaultColors.m_contactPoint);
     }
    }
   }
  }

  if ((getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb)))
  {
   int i;

   for (i = 0; i<m_collisionObjects.size(); i++)
   {
    btCollisionObject* colObj = m_collisionObjects[i];
    if ((colObj->getCollisionFlags() & btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT) == 0)
    {
     if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawWireframe))
     {
      btVector3 color(btScalar(0.4), btScalar(0.4), btScalar(0.4));

      switch (colObj->getActivationState())
      {
      case  ACTIVE_TAG:
       color = defaultColors.m_activeObject; break;
      case ISLAND_SLEEPING:
       color = defaultColors.m_deactivatedObject; break;
      case WANTS_DEACTIVATION:
       color = defaultColors.m_wantsDeactivationObject; break;
      case DISABLE_DEACTIVATION:
       color = defaultColors.m_disabledDeactivationObject; break;
      case DISABLE_SIMULATION:
       color = defaultColors.m_disabledSimulationObject; break;
      default:
      {
       color = btVector3(btScalar(.3), btScalar(0.3), btScalar(0.3));
      }
      };

      colObj->getCustomDebugColor(color);

      debugDrawObject(colObj->getWorldTransform(), colObj->getCollisionShape(), color);
     }
     if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
     {
      btVector3 minAabb, maxAabb;
      btVector3 colorvec = defaultColors.m_aabb;
      colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
      btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
      minAabb -= contactThreshold;
      maxAabb += contactThreshold;

      btVector3 minAabb2, maxAabb2;

      if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
      {
       colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
       minAabb2 -= contactThreshold;
       maxAabb2 += contactThreshold;
       minAabb.setMin(minAabb2);
       maxAabb.setMax(maxAabb2);
      }

      m_debugDrawer->drawAabb(minAabb, maxAabb, colorvec);
     }
    }
   }
  }
 }
}


void	btCollisionWorld::serializeCollisionObjects(btSerializer* serializer)
{
 int i;

 ///keep track of shapes already serialized
 btHashMap<btHashPtr, btCollisionShape*>	serializedShapes;

 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btCollisionShape* shape = colObj->getCollisionShape();

  if (!serializedShapes.find(shape))
  {
   serializedShapes.insert(shape, shape);
   shape->serializeSingleShape(serializer);
  }
 }

 //serialize all collision objects
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  if ((colObj->getInternalType() == btCollisionObject::CO_COLLISION_OBJECT) || (colObj->getInternalType() == btCollisionObject::CO_FEATHERSTONE_LINK))
  {
   colObj->serializeSingleObject(serializer);
  }
 }
}


void	btCollisionWorld::serialize(btSerializer* serializer)
{

 serializer->startSerialization();

 serializeCollisionObjects(serializer);

 serializer->finishSerialization();
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2014 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionWorldImporter.h"
#include "btBulletCollisionCommon.h"
#include "LinearMath/btSerializer.h" //for btBulletSerializedArrays definition

#ifdef SUPPORT_GIMPACT_SHAPE_IMPORT
#include "BulletCollision/Gimpact/btGImpactShape.h"
#endif //SUPPORT_GIMPACT_SHAPE_IMPORT

btCollisionWorldImporter::btCollisionWorldImporter(btCollisionWorld* world)
 :m_collisionWorld(world),
 m_verboseMode(0)
{

}

btCollisionWorldImporter::~btCollisionWorldImporter()
{
}





bool	btCollisionWorldImporter::convertAllObjects(btBulletSerializedArrays* arrays)
{

 m_shapeMap.clear();
 m_bodyMap.clear();

 int i;

 for (i = 0; i<arrays->m_bvhsDouble.size(); i++)
 {
  btOptimizedBvh* bvh = createOptimizedBvh();
  btQuantizedBvhDoubleData* bvhData = arrays->m_bvhsDouble[i];
  bvh->deSerializeDouble(*bvhData);
  m_bvhMap.insert(arrays->m_bvhsDouble[i], bvh);
 }
 for (i = 0; i<arrays->m_bvhsFloat.size(); i++)
 {
  btOptimizedBvh* bvh = createOptimizedBvh();
  btQuantizedBvhFloatData* bvhData = arrays->m_bvhsFloat[i];
  bvh->deSerializeFloat(*bvhData);
  m_bvhMap.insert(arrays->m_bvhsFloat[i], bvh);
 }





 for (i = 0; i<arrays->m_colShapeData.size(); i++)
 {
  btCollisionShapeData* shapeData = arrays->m_colShapeData[i];
  btCollisionShape* shape = convertCollisionShape(shapeData);
  if (shape)
  {
   //		printf("shapeMap.insert(%x,%x)\n",shapeData,shape);
   m_shapeMap.insert(shapeData, shape);
  }

  if (shape&& shapeData->m_name)
  {
   char* newname = duplicateName(shapeData->m_name);
   m_objectNameMap.insert(shape, newname);
   m_nameShapeMap.insert(newname, shape);
  }
 }


 for (i = 0; i<arrays->m_collisionObjectDataDouble.size(); i++)
 {
  btCollisionObjectDoubleData* colObjData = arrays->m_collisionObjectDataDouble[i];
  btCollisionShape** shapePtr = m_shapeMap.find(colObjData->m_collisionShape);
  if (shapePtr && *shapePtr)
  {
   btTransform startTransform;
   colObjData->m_worldTransform.m_origin.m_floats[3] = 0.f;
   startTransform.deSerializeDouble(colObjData->m_worldTransform);

   btCollisionShape* shape = (btCollisionShape*)*shapePtr;
   btCollisionObject* body = createCollisionObject(startTransform, shape, colObjData->m_name);
   body->setFriction(btScalar(colObjData->m_friction));
   body->setRestitution(btScalar(colObjData->m_restitution));

#ifdef USE_INTERNAL_EDGE_UTILITY
   if (shape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
   {
    btBvhTriangleMeshShape* trimesh = (btBvhTriangleMeshShape*)shape;
    if (trimesh->getTriangleInfoMap())
    {
     body->setCollisionFlags(body->getCollisionFlags() | btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK);
    }
   }
#endif //USE_INTERNAL_EDGE_UTILITY
   m_bodyMap.insert(colObjData, body);
  }
  else
  {
   printf("error: no shape found\n");
  }
 }
 for (i = 0; i<arrays->m_collisionObjectDataFloat.size(); i++)
 {
  btCollisionObjectFloatData* colObjData = arrays->m_collisionObjectDataFloat[i];
  btCollisionShape** shapePtr = m_shapeMap.find(colObjData->m_collisionShape);
  if (shapePtr && *shapePtr)
  {
   btTransform startTransform;
   colObjData->m_worldTransform.m_origin.m_floats[3] = 0.f;
   startTransform.deSerializeFloat(colObjData->m_worldTransform);

   btCollisionShape* shape = (btCollisionShape*)*shapePtr;
   btCollisionObject* body = createCollisionObject(startTransform, shape, colObjData->m_name);

#ifdef USE_INTERNAL_EDGE_UTILITY
   if (shape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
   {
    btBvhTriangleMeshShape* trimesh = (btBvhTriangleMeshShape*)shape;
    if (trimesh->getTriangleInfoMap())
    {
     body->setCollisionFlags(body->getCollisionFlags() | btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK);
    }
   }
#endif //USE_INTERNAL_EDGE_UTILITY
   m_bodyMap.insert(colObjData, body);
  }
  else
  {
   printf("error: no shape found\n");
  }
 }

 return true;
}



void btCollisionWorldImporter::deleteAllData()
{
 int i;

 for (i = 0; i<m_allocatedCollisionObjects.size(); i++)
 {
  if (m_collisionWorld)
   m_collisionWorld->removeCollisionObject(m_allocatedCollisionObjects[i]);
  delete m_allocatedCollisionObjects[i];
 }

 m_allocatedCollisionObjects.clear();


 for (i = 0; i<m_allocatedCollisionShapes.size(); i++)
 {
  delete m_allocatedCollisionShapes[i];
 }
 m_allocatedCollisionShapes.clear();


 for (i = 0; i<m_allocatedBvhs.size(); i++)
 {
  delete m_allocatedBvhs[i];
 }
 m_allocatedBvhs.clear();

 for (i = 0; i<m_allocatedTriangleInfoMaps.size(); i++)
 {
  delete m_allocatedTriangleInfoMaps[i];
 }
 m_allocatedTriangleInfoMaps.clear();
 for (i = 0; i<m_allocatedTriangleIndexArrays.size(); i++)
 {
  delete m_allocatedTriangleIndexArrays[i];
 }
 m_allocatedTriangleIndexArrays.clear();
 for (i = 0; i<m_allocatedNames.size(); i++)
 {
  delete[] m_allocatedNames[i];
 }
 m_allocatedNames.clear();

 for (i = 0; i<m_allocatedbtStridingMeshInterfaceDatas.size(); i++)
 {
  btStridingMeshInterfaceData* curData = m_allocatedbtStridingMeshInterfaceDatas[i];

  for (int a = 0; a < curData->m_numMeshParts; a++)
  {
   btMeshPartData* curPart = &curData->m_meshPartsPtr[a];
   if (curPart->m_vertices3f)
    delete[] curPart->m_vertices3f;

   if (curPart->m_vertices3d)
    delete[] curPart->m_vertices3d;

   if (curPart->m_indices32)
    delete[] curPart->m_indices32;

   if (curPart->m_3indices16)
    delete[] curPart->m_3indices16;

   if (curPart->m_indices16)
    delete[] curPart->m_indices16;

   if (curPart->m_3indices8)
    delete[] curPart->m_3indices8;

  }
  delete[] curData->m_meshPartsPtr;
  delete curData;
 }
 m_allocatedbtStridingMeshInterfaceDatas.clear();

 for (i = 0; i<m_indexArrays.size(); i++)
 {
  btAlignedFree(m_indexArrays[i]);
 }
 m_indexArrays.clear();

 for (i = 0; i<m_shortIndexArrays.size(); i++)
 {
  btAlignedFree(m_shortIndexArrays[i]);
 }
 m_shortIndexArrays.clear();

 for (i = 0; i<m_charIndexArrays.size(); i++)
 {
  btAlignedFree(m_charIndexArrays[i]);
 }
 m_charIndexArrays.clear();

 for (i = 0; i<m_floatVertexArrays.size(); i++)
 {
  btAlignedFree(m_floatVertexArrays[i]);
 }
 m_floatVertexArrays.clear();

 for (i = 0; i<m_doubleVertexArrays.size(); i++)
 {
  btAlignedFree(m_doubleVertexArrays[i]);
 }
 m_doubleVertexArrays.clear();


}



btCollisionShape* btCollisionWorldImporter::convertCollisionShape(btCollisionShapeData* shapeData)
{
 btCollisionShape* shape = 0;

 switch (shapeData->m_shapeType)
 {
 case STATIC_PLANE_PROXYTYPE:
 {
  btStaticPlaneShapeData* planeData = (btStaticPlaneShapeData*)shapeData;
  btVector3 planeNormal, localScaling;
  planeNormal.deSerializeFloat(planeData->m_planeNormal);
  localScaling.deSerializeFloat(planeData->m_localScaling);
  shape = createPlaneShape(planeNormal, planeData->m_planeConstant);
  shape->setLocalScaling(localScaling);

  break;
 }
 case SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE:
 {
  btScaledTriangleMeshShapeData* scaledMesh = (btScaledTriangleMeshShapeData*)shapeData;
  btCollisionShapeData* colShapeData = (btCollisionShapeData*)&scaledMesh->m_trimeshShapeData;
  colShapeData->m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
  btCollisionShape* childShape = convertCollisionShape(colShapeData);
  btBvhTriangleMeshShape* meshShape = (btBvhTriangleMeshShape*)childShape;
  btVector3 localScaling;
  localScaling.deSerializeFloat(scaledMesh->m_localScaling);

  shape = createScaledTrangleMeshShape(meshShape, localScaling);
  break;
 }
#ifdef SUPPORT_GIMPACT_SHAPE_IMPORT
 case GIMPACT_SHAPE_PROXYTYPE:
 {
  btGImpactMeshShapeData* gimpactData = (btGImpactMeshShapeData*)shapeData;
  if (gimpactData->m_gimpactSubType == CONST_GIMPACT_TRIMESH_SHAPE)
  {
   btStridingMeshInterfaceData* interfaceData = createStridingMeshInterfaceData(&gimpactData->m_meshInterface);
   btTriangleIndexVertexArray* meshInterface = createMeshInterface(*interfaceData);


   btGImpactMeshShape* gimpactShape = createGimpactShape(meshInterface);
   btVector3 localScaling;
   localScaling.deSerializeFloat(gimpactData->m_localScaling);
   gimpactShape->setLocalScaling(localScaling);
   gimpactShape->setMargin(btScalar(gimpactData->m_collisionMargin));
   gimpactShape->updateBound();
   shape = gimpactShape;
  }
  else
  {
   printf("unsupported gimpact sub type\n");
  }
  break;
 }
#endif //SUPPORT_GIMPACT_SHAPE_IMPORT
 //The btCapsuleShape* API has issue passing the margin/scaling/halfextents unmodified through the API
 //so deal with this
 case CAPSULE_SHAPE_PROXYTYPE:
 {
  btCapsuleShapeData* capData = (btCapsuleShapeData*)shapeData;


  switch (capData->m_upAxis)
  {
  case 0:
  {
   shape = createCapsuleShapeX(1, 1);
   break;
  }
  case 1:
  {
   shape = createCapsuleShapeY(1, 1);
   break;
  }
  case 2:
  {
   shape = createCapsuleShapeZ(1, 1);
   break;
  }
  default:
  {
   printf("error: wrong up axis for btCapsuleShape\n");
  }


  };
  if (shape)
  {
   btCapsuleShape* cap = (btCapsuleShape*)shape;
   cap->deSerializeFloat(capData);
  }
  break;
 }
 case CYLINDER_SHAPE_PROXYTYPE:
 case CONE_SHAPE_PROXYTYPE:
 case BOX_SHAPE_PROXYTYPE:
 case SPHERE_SHAPE_PROXYTYPE:
 case MULTI_SPHERE_SHAPE_PROXYTYPE:
 case CONVEX_HULL_SHAPE_PROXYTYPE:
 {
  btConvexInternalShapeData* bsd = (btConvexInternalShapeData*)shapeData;
  btVector3 implicitShapeDimensions;
  implicitShapeDimensions.deSerializeFloat(bsd->m_implicitShapeDimensions);
  btVector3 localScaling;
  localScaling.deSerializeFloat(bsd->m_localScaling);
  btVector3 margin(bsd->m_collisionMargin, bsd->m_collisionMargin, bsd->m_collisionMargin);
  switch (shapeData->m_shapeType)
  {
  case BOX_SHAPE_PROXYTYPE:
  {
   btBoxShape* box = (btBoxShape*)createBoxShape(implicitShapeDimensions / localScaling + margin);
   //box->initializePolyhedralFeatures();
   shape = box;

   break;
  }
  case SPHERE_SHAPE_PROXYTYPE:
  {
   shape = createSphereShape(implicitShapeDimensions.getX());
   break;
  }

  case CYLINDER_SHAPE_PROXYTYPE:
  {
   btCylinderShapeData* cylData = (btCylinderShapeData*)shapeData;
   btVector3 halfExtents = implicitShapeDimensions + margin;
   switch (cylData->m_upAxis)
   {
   case 0:
   {
    shape = createCylinderShapeX(halfExtents.getY(), halfExtents.getX());
    break;
   }
   case 1:
   {
    shape = createCylinderShapeY(halfExtents.getX(), halfExtents.getY());
    break;
   }
   case 2:
   {
    shape = createCylinderShapeZ(halfExtents.getX(), halfExtents.getZ());
    break;
   }
   default:
   {
    printf("unknown Cylinder up axis\n");
   }

   };



   break;
  }
  case CONE_SHAPE_PROXYTYPE:
  {
   btConeShapeData* conData = (btConeShapeData*)shapeData;
   btVector3 halfExtents = implicitShapeDimensions;//+margin;
   switch (conData->m_upIndex)
   {
   case 0:
   {
    shape = createConeShapeX(halfExtents.getY(), halfExtents.getX());
    break;
   }
   case 1:
   {
    shape = createConeShapeY(halfExtents.getX(), halfExtents.getY());
    break;
   }
   case 2:
   {
    shape = createConeShapeZ(halfExtents.getX(), halfExtents.getZ());
    break;
   }
   default:
   {
    printf("unknown Cone up axis\n");
   }

   };



   break;
  }
  case MULTI_SPHERE_SHAPE_PROXYTYPE:
  {
   btMultiSphereShapeData* mss = (btMultiSphereShapeData*)bsd;
   int numSpheres = mss->m_localPositionArraySize;

   btAlignedObjectArray<btVector3> tmpPos;
   btAlignedObjectArray<btScalar> radii;
   radii.resize(numSpheres);
   tmpPos.resize(numSpheres);
   int i;
   for (i = 0; i<numSpheres; i++)
   {
    tmpPos[i].deSerializeFloat(mss->m_localPositionArrayPtr[i].m_pos);
    radii[i] = mss->m_localPositionArrayPtr[i].m_radius;
   }
   shape = createMultiSphereShape(&tmpPos[0], &radii[0], numSpheres);
   break;
  }
  case CONVEX_HULL_SHAPE_PROXYTYPE:
  {
   //	int sz = sizeof(btConvexHullShapeData);
   //	int sz2 = sizeof(btConvexInternalShapeData);
   //	int sz3 = sizeof(btCollisionShapeData);
   btConvexHullShapeData* convexData = (btConvexHullShapeData*)bsd;
   int numPoints = convexData->m_numUnscaledPoints;

   btAlignedObjectArray<btVector3> tmpPoints;
   tmpPoints.resize(numPoints);
   int i;
   for (i = 0; i<numPoints; i++)
   {
#ifdef BT_USE_DOUBLE_PRECISION
    if (convexData->m_unscaledPointsDoublePtr)
     tmpPoints[i].deSerialize(convexData->m_unscaledPointsDoublePtr[i]);
    if (convexData->m_unscaledPointsFloatPtr)
     tmpPoints[i].deSerializeFloat(convexData->m_unscaledPointsFloatPtr[i]);
#else
    if (convexData->m_unscaledPointsFloatPtr)
     tmpPoints[i].deSerialize(convexData->m_unscaledPointsFloatPtr[i]);
    if (convexData->m_unscaledPointsDoublePtr)
     tmpPoints[i].deSerializeDouble(convexData->m_unscaledPointsDoublePtr[i]);
#endif //BT_USE_DOUBLE_PRECISION
   }
   btConvexHullShape* hullShape = createConvexHullShape();
   for (i = 0; i<numPoints; i++)
   {
    hullShape->addPoint(tmpPoints[i]);
   }
   hullShape->setMargin(bsd->m_collisionMargin);
   //hullShape->initializePolyhedralFeatures();
   shape = hullShape;
   break;
  }
  default:
  {
   printf("error: cannot create shape type (%d)\n", shapeData->m_shapeType);
  }
  }

  if (shape)
  {
   shape->setMargin(bsd->m_collisionMargin);

   btVector3 localScaling;
   localScaling.deSerializeFloat(bsd->m_localScaling);
   shape->setLocalScaling(localScaling);

  }
  break;
 }
 case TRIANGLE_MESH_SHAPE_PROXYTYPE:
 {
  btTriangleMeshShapeData* trimesh = (btTriangleMeshShapeData*)shapeData;
  btStridingMeshInterfaceData* interfaceData = createStridingMeshInterfaceData(&trimesh->m_meshInterface);
  btTriangleIndexVertexArray* meshInterface = createMeshInterface(*interfaceData);
  if (!meshInterface->getNumSubParts())
  {
   return 0;
  }

  btVector3 scaling; scaling.deSerializeFloat(trimesh->m_meshInterface.m_scaling);
  meshInterface->setScaling(scaling);


  btOptimizedBvh* bvh = 0;
#if 1
  if (trimesh->m_quantizedFloatBvh)
  {
   btOptimizedBvh** bvhPtr = m_bvhMap.find(trimesh->m_quantizedFloatBvh);
   if (bvhPtr && *bvhPtr)
   {
    bvh = *bvhPtr;
   }
   else
   {
    bvh = createOptimizedBvh();
    bvh->deSerializeFloat(*trimesh->m_quantizedFloatBvh);
   }
  }
  if (trimesh->m_quantizedDoubleBvh)
  {
   btOptimizedBvh** bvhPtr = m_bvhMap.find(trimesh->m_quantizedDoubleBvh);
   if (bvhPtr && *bvhPtr)
   {
    bvh = *bvhPtr;
   }
   else
   {
    bvh = createOptimizedBvh();
    bvh->deSerializeDouble(*trimesh->m_quantizedDoubleBvh);
   }
  }
#endif


  btBvhTriangleMeshShape* trimeshShape = createBvhTriangleMeshShape(meshInterface, bvh);
  trimeshShape->setMargin(trimesh->m_collisionMargin);
  shape = trimeshShape;

  if (trimesh->m_triangleInfoMap)
  {
   btTriangleInfoMap* map = createTriangleInfoMap();
   map->deSerialize(*trimesh->m_triangleInfoMap);
   trimeshShape->setTriangleInfoMap(map);

#ifdef USE_INTERNAL_EDGE_UTILITY
   gContactAddedCallback = btAdjustInternalEdgeContactsCallback;
#endif //USE_INTERNAL_EDGE_UTILITY

  }

  //printf("trimesh->m_collisionMargin=%f\n",trimesh->m_collisionMargin);
  break;
 }
 case COMPOUND_SHAPE_PROXYTYPE:
 {
  btCompoundShapeData* compoundData = (btCompoundShapeData*)shapeData;
  btCompoundShape* compoundShape = createCompoundShape();

  //btCompoundShapeChildData* childShapeDataArray = &compoundData->m_childShapePtr[0];


  btAlignedObjectArray<btCollisionShape*> childShapes;
  for (int i = 0; i<compoundData->m_numChildShapes; i++)
  {
   //btCompoundShapeChildData* ptr = &compoundData->m_childShapePtr[i];

   btCollisionShapeData* cd = compoundData->m_childShapePtr[i].m_childShape;

   btCollisionShape* childShape = convertCollisionShape(cd);
   if (childShape)
   {
    btTransform localTransform;
    localTransform.deSerializeFloat(compoundData->m_childShapePtr[i].m_transform);
    compoundShape->addChildShape(localTransform, childShape);
   }
   else
   {
#ifdef _DEBUG
    printf("error: couldn't create childShape for compoundShape\n");
#endif
   }

  }
  shape = compoundShape;

  break;
 }
 case SOFTBODY_SHAPE_PROXYTYPE:
 {
  return 0;
 }
 default:
 {
#ifdef _DEBUG
  printf("unsupported shape type (%d)\n", shapeData->m_shapeType);
#endif
 }
 }

 return shape;

}



char* btCollisionWorldImporter::duplicateName(const char* name)
{
 if (name)
 {
  int l = (int)strlen(name);
  char* newName = new char[l + 1];
  memcpy(newName, name, l);
  newName[l] = 0;
  m_allocatedNames.push_back(newName);
  return newName;
 }
 return 0;
}











btTriangleIndexVertexArray* btCollisionWorldImporter::createMeshInterface(btStridingMeshInterfaceData&  meshData)
{
 btTriangleIndexVertexArray* meshInterface = createTriangleMeshContainer();

 for (int i = 0; i<meshData.m_numMeshParts; i++)
 {
  btIndexedMesh meshPart;
  meshPart.m_numTriangles = meshData.m_meshPartsPtr[i].m_numTriangles;
  meshPart.m_numVertices = meshData.m_meshPartsPtr[i].m_numVertices;


  if (meshData.m_meshPartsPtr[i].m_indices32)
  {
   meshPart.m_indexType = PHY_INTEGER;
   meshPart.m_triangleIndexStride = 3 * sizeof(int);
   int* indexArray = (int*)btAlignedAlloc(sizeof(int) * 3 * meshPart.m_numTriangles, 16);
   m_indexArrays.push_back(indexArray);
   for (int j = 0; j<3 * meshPart.m_numTriangles; j++)
   {
    indexArray[j] = meshData.m_meshPartsPtr[i].m_indices32[j].m_value;
   }
   meshPart.m_triangleIndexBase = (const unsigned char*)indexArray;
  }
  else
  {
   if (meshData.m_meshPartsPtr[i].m_3indices16)
   {
    meshPart.m_indexType = PHY_SHORT;
    meshPart.m_triangleIndexStride = sizeof(short int) * 3;//sizeof(btShortIntIndexTripletData);

    short int* indexArray = (short int*)btAlignedAlloc(sizeof(short int) * 3 * meshPart.m_numTriangles, 16);
    m_shortIndexArrays.push_back(indexArray);

    for (int j = 0; j<meshPart.m_numTriangles; j++)
    {
     indexArray[3 * j] = meshData.m_meshPartsPtr[i].m_3indices16[j].m_values[0];
     indexArray[3 * j + 1] = meshData.m_meshPartsPtr[i].m_3indices16[j].m_values[1];
     indexArray[3 * j + 2] = meshData.m_meshPartsPtr[i].m_3indices16[j].m_values[2];
    }

    meshPart.m_triangleIndexBase = (const unsigned char*)indexArray;
   }
   if (meshData.m_meshPartsPtr[i].m_indices16)
   {
    meshPart.m_indexType = PHY_SHORT;
    meshPart.m_triangleIndexStride = 3 * sizeof(short int);
    short int* indexArray = (short int*)btAlignedAlloc(sizeof(short int) * 3 * meshPart.m_numTriangles, 16);
    m_shortIndexArrays.push_back(indexArray);
    for (int j = 0; j<3 * meshPart.m_numTriangles; j++)
    {
     indexArray[j] = meshData.m_meshPartsPtr[i].m_indices16[j].m_value;
    }

    meshPart.m_triangleIndexBase = (const unsigned char*)indexArray;
   }

   if (meshData.m_meshPartsPtr[i].m_3indices8)
   {
    meshPart.m_indexType = PHY_UCHAR;
    meshPart.m_triangleIndexStride = sizeof(unsigned char) * 3;

    unsigned char* indexArray = (unsigned char*)btAlignedAlloc(sizeof(unsigned char) * 3 * meshPart.m_numTriangles, 16);
    m_charIndexArrays.push_back(indexArray);

    for (int j = 0; j<meshPart.m_numTriangles; j++)
    {
     indexArray[3 * j] = meshData.m_meshPartsPtr[i].m_3indices8[j].m_values[0];
     indexArray[3 * j + 1] = meshData.m_meshPartsPtr[i].m_3indices8[j].m_values[1];
     indexArray[3 * j + 2] = meshData.m_meshPartsPtr[i].m_3indices8[j].m_values[2];
    }

    meshPart.m_triangleIndexBase = (const unsigned char*)indexArray;
   }
  }

  if (meshData.m_meshPartsPtr[i].m_vertices3f)
  {
   meshPart.m_vertexType = PHY_FLOAT;
   meshPart.m_vertexStride = sizeof(btVector3FloatData);
   btVector3FloatData* vertices = (btVector3FloatData*)btAlignedAlloc(sizeof(btVector3FloatData)*meshPart.m_numVertices, 16);
   m_floatVertexArrays.push_back(vertices);

   for (int j = 0; j<meshPart.m_numVertices; j++)
   {
    vertices[j].m_floats[0] = meshData.m_meshPartsPtr[i].m_vertices3f[j].m_floats[0];
    vertices[j].m_floats[1] = meshData.m_meshPartsPtr[i].m_vertices3f[j].m_floats[1];
    vertices[j].m_floats[2] = meshData.m_meshPartsPtr[i].m_vertices3f[j].m_floats[2];
    vertices[j].m_floats[3] = meshData.m_meshPartsPtr[i].m_vertices3f[j].m_floats[3];
   }
   meshPart.m_vertexBase = (const unsigned char*)vertices;
  }
  else
  {
   meshPart.m_vertexType = PHY_DOUBLE;
   meshPart.m_vertexStride = sizeof(btVector3DoubleData);


   btVector3DoubleData* vertices = (btVector3DoubleData*)btAlignedAlloc(sizeof(btVector3DoubleData)*meshPart.m_numVertices, 16);
   m_doubleVertexArrays.push_back(vertices);

   for (int j = 0; j<meshPart.m_numVertices; j++)
   {
    vertices[j].m_floats[0] = meshData.m_meshPartsPtr[i].m_vertices3d[j].m_floats[0];
    vertices[j].m_floats[1] = meshData.m_meshPartsPtr[i].m_vertices3d[j].m_floats[1];
    vertices[j].m_floats[2] = meshData.m_meshPartsPtr[i].m_vertices3d[j].m_floats[2];
    vertices[j].m_floats[3] = meshData.m_meshPartsPtr[i].m_vertices3d[j].m_floats[3];
   }
   meshPart.m_vertexBase = (const unsigned char*)vertices;
  }

  if (meshPart.m_triangleIndexBase && meshPart.m_vertexBase)
  {
   meshInterface->addIndexedMesh(meshPart, meshPart.m_indexType);
  }
 }

 return meshInterface;
}


btStridingMeshInterfaceData* btCollisionWorldImporter::createStridingMeshInterfaceData(btStridingMeshInterfaceData* interfaceData)
{
 //create a new btStridingMeshInterfaceData that is an exact copy of shapedata and store it in the WorldImporter
 btStridingMeshInterfaceData* newData = new btStridingMeshInterfaceData;

 newData->m_scaling = interfaceData->m_scaling;
 newData->m_numMeshParts = interfaceData->m_numMeshParts;
 newData->m_meshPartsPtr = new btMeshPartData[newData->m_numMeshParts];

 for (int i = 0; i < newData->m_numMeshParts; i++)
 {
  btMeshPartData* curPart = &interfaceData->m_meshPartsPtr[i];
  btMeshPartData* curNewPart = &newData->m_meshPartsPtr[i];

  curNewPart->m_numTriangles = curPart->m_numTriangles;
  curNewPart->m_numVertices = curPart->m_numVertices;

  if (curPart->m_vertices3f)
  {
   curNewPart->m_vertices3f = new btVector3FloatData[curNewPart->m_numVertices];
   memcpy(curNewPart->m_vertices3f, curPart->m_vertices3f, sizeof(btVector3FloatData) * curNewPart->m_numVertices);
  }
  else
   curNewPart->m_vertices3f = NULL;

  if (curPart->m_vertices3d)
  {
   curNewPart->m_vertices3d = new btVector3DoubleData[curNewPart->m_numVertices];
   memcpy(curNewPart->m_vertices3d, curPart->m_vertices3d, sizeof(btVector3DoubleData) * curNewPart->m_numVertices);
  }
  else
   curNewPart->m_vertices3d = NULL;

  int numIndices = curNewPart->m_numTriangles * 3;
  ///the m_3indices8 was not initialized in some Bullet versions, this can cause crashes at loading time
  ///we catch it by only dealing with m_3indices8 if none of the other indices are initialized
  bool uninitialized3indices8Workaround = false;

  if (curPart->m_indices32)
  {
   uninitialized3indices8Workaround = true;
   curNewPart->m_indices32 = new btIntIndexData[numIndices];
   memcpy(curNewPart->m_indices32, curPart->m_indices32, sizeof(btIntIndexData) * numIndices);
  }
  else
   curNewPart->m_indices32 = NULL;

  if (curPart->m_3indices16)
  {
   uninitialized3indices8Workaround = true;
   curNewPart->m_3indices16 = new btShortIntIndexTripletData[curNewPart->m_numTriangles];
   memcpy(curNewPart->m_3indices16, curPart->m_3indices16, sizeof(btShortIntIndexTripletData) * curNewPart->m_numTriangles);
  }
  else
   curNewPart->m_3indices16 = NULL;

  if (curPart->m_indices16)
  {
   uninitialized3indices8Workaround = true;
   curNewPart->m_indices16 = new btShortIntIndexData[numIndices];
   memcpy(curNewPart->m_indices16, curPart->m_indices16, sizeof(btShortIntIndexData) * numIndices);
  }
  else
   curNewPart->m_indices16 = NULL;

  if (!uninitialized3indices8Workaround && curPart->m_3indices8)
  {
   curNewPart->m_3indices8 = new btCharIndexTripletData[curNewPart->m_numTriangles];
   memcpy(curNewPart->m_3indices8, curPart->m_3indices8, sizeof(btCharIndexTripletData) * curNewPart->m_numTriangles);
  }
  else
   curNewPart->m_3indices8 = NULL;

 }

 m_allocatedbtStridingMeshInterfaceDatas.push_back(newData);

 return(newData);
}

#ifdef USE_INTERNAL_EDGE_UTILITY
extern ContactAddedCallback		gContactAddedCallback;

static bool btAdjustInternalEdgeContactsCallback(btManifoldPoint& cp, const btCollisionObject* colObj0, int partId0, int index0, const btCollisionObject* colObj1, int partId1, int index1)
{

 btAdjustInternalEdgeContacts(cp, colObj1, colObj0, partId1, index1);
 //btAdjustInternalEdgeContacts(cp,colObj1,colObj0, partId1,index1, BT_TRIANGLE_CONVEX_BACKFACE_MODE);
 //btAdjustInternalEdgeContacts(cp,colObj1,colObj0, partId1,index1, BT_TRIANGLE_CONVEX_DOUBLE_SIDED+BT_TRIANGLE_CONCAVE_DOUBLE_SIDED);
 return true;
}
#endif //USE_INTERNAL_EDGE_UTILITY


/*
btRigidBody*  btWorldImporter::createRigidBody(bool isDynamic, btScalar mass, const btTransform& startTransform,btCollisionShape* shape,const char* bodyName)
{
btVector3 localInertia;
localInertia.setZero();

if (mass)
shape->calculateLocalInertia(mass,localInertia);

btRigidBody* body = new btRigidBody(mass,0,shape,localInertia);
body->setWorldTransform(startTransform);

if (m_dynamicsWorld)
m_dynamicsWorld->addRigidBody(body);

if (bodyName)
{
char* newname = duplicateName(bodyName);
m_objectNameMap.insert(body,newname);
m_nameBodyMap.insert(newname,body);
}
m_allocatedRigidBodies.push_back(body);
return body;

}
*/

btCollisionObject* btCollisionWorldImporter::getCollisionObjectByName(const char* name)
{
 btCollisionObject** bodyPtr = m_nameColObjMap.find(name);
 if (bodyPtr && *bodyPtr)
 {
  return *bodyPtr;
 }
 return 0;
}

btCollisionObject* btCollisionWorldImporter::createCollisionObject(const btTransform& startTransform, btCollisionShape* shape, const char* bodyName)
{
 btCollisionObject* colObj = new btCollisionObject();
 colObj->setWorldTransform(startTransform);
 colObj->setCollisionShape(shape);
 m_collisionWorld->addCollisionObject(colObj);//todo: flags etc

 if (bodyName)
 {
  char* newname = duplicateName(bodyName);
  m_objectNameMap.insert(colObj, newname);
  m_nameColObjMap.insert(newname, colObj);
 }
 m_allocatedCollisionObjects.push_back(colObj);

 return colObj;
}



btCollisionShape* btCollisionWorldImporter::createPlaneShape(const btVector3& planeNormal, btScalar planeConstant)
{
 btStaticPlaneShape* shape = new btStaticPlaneShape(planeNormal, planeConstant);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}
btCollisionShape* btCollisionWorldImporter::createBoxShape(const btVector3& halfExtents)
{
 btBoxShape* shape = new btBoxShape(halfExtents);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}
btCollisionShape* btCollisionWorldImporter::createSphereShape(btScalar radius)
{
 btSphereShape* shape = new btSphereShape(radius);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}


btCollisionShape* btCollisionWorldImporter::createCapsuleShapeX(btScalar radius, btScalar height)
{
 btCapsuleShapeX* shape = new btCapsuleShapeX(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createCapsuleShapeY(btScalar radius, btScalar height)
{
 btCapsuleShape* shape = new btCapsuleShape(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createCapsuleShapeZ(btScalar radius, btScalar height)
{
 btCapsuleShapeZ* shape = new btCapsuleShapeZ(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createCylinderShapeX(btScalar radius, btScalar height)
{
 btCylinderShapeX* shape = new btCylinderShapeX(btVector3(height, radius, radius));
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createCylinderShapeY(btScalar radius, btScalar height)
{
 btCylinderShape* shape = new btCylinderShape(btVector3(radius, height, radius));
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createCylinderShapeZ(btScalar radius, btScalar height)
{
 btCylinderShapeZ* shape = new btCylinderShapeZ(btVector3(radius, radius, height));
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createConeShapeX(btScalar radius, btScalar height)
{
 btConeShapeX* shape = new btConeShapeX(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createConeShapeY(btScalar radius, btScalar height)
{
 btConeShape* shape = new btConeShape(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCollisionShape* btCollisionWorldImporter::createConeShapeZ(btScalar radius, btScalar height)
{
 btConeShapeZ* shape = new btConeShapeZ(radius, height);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btTriangleIndexVertexArray*	btCollisionWorldImporter::createTriangleMeshContainer()
{
 btTriangleIndexVertexArray* in = new btTriangleIndexVertexArray();
 m_allocatedTriangleIndexArrays.push_back(in);
 return in;
}

btOptimizedBvh*	btCollisionWorldImporter::createOptimizedBvh()
{
 btOptimizedBvh* bvh = new btOptimizedBvh();
 m_allocatedBvhs.push_back(bvh);
 return bvh;
}


btTriangleInfoMap* btCollisionWorldImporter::createTriangleInfoMap()
{
 btTriangleInfoMap* tim = new btTriangleInfoMap();
 m_allocatedTriangleInfoMaps.push_back(tim);
 return tim;
}

btBvhTriangleMeshShape* btCollisionWorldImporter::createBvhTriangleMeshShape(btStridingMeshInterface* trimesh, btOptimizedBvh* bvh)
{
 if (bvh)
 {
  btBvhTriangleMeshShape* bvhTriMesh = new btBvhTriangleMeshShape(trimesh, bvh->isQuantized(), false);
  bvhTriMesh->setOptimizedBvh(bvh);
  m_allocatedCollisionShapes.push_back(bvhTriMesh);
  return bvhTriMesh;
 }

 btBvhTriangleMeshShape* ts = new btBvhTriangleMeshShape(trimesh, true);
 m_allocatedCollisionShapes.push_back(ts);
 return ts;

}
btCollisionShape* btCollisionWorldImporter::createConvexTriangleMeshShape(btStridingMeshInterface* trimesh)
{
 return 0;
}
#ifdef SUPPORT_GIMPACT_SHAPE_IMPORT
btGImpactMeshShape* btCollisionWorldImporter::createGimpactShape(btStridingMeshInterface* trimesh)
{
 btGImpactMeshShape* shape = new btGImpactMeshShape(trimesh);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;

}
#endif //SUPPORT_GIMPACT_SHAPE_IMPORT

btConvexHullShape* btCollisionWorldImporter::createConvexHullShape()
{
 btConvexHullShape* shape = new btConvexHullShape();
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btCompoundShape* btCollisionWorldImporter::createCompoundShape()
{
 btCompoundShape* shape = new btCompoundShape();
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}


btScaledBvhTriangleMeshShape* btCollisionWorldImporter::createScaledTrangleMeshShape(btBvhTriangleMeshShape* meshShape, const btVector3& localScaling)
{
 btScaledBvhTriangleMeshShape* shape = new btScaledBvhTriangleMeshShape(meshShape, localScaling);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}

btMultiSphereShape* btCollisionWorldImporter::createMultiSphereShape(const btVector3* positions, const btScalar* radi, int numSpheres)
{
 btMultiSphereShape* shape = new btMultiSphereShape(positions, radi, numSpheres);
 m_allocatedCollisionShapes.push_back(shape);
 return shape;
}



// query for data
int	btCollisionWorldImporter::getNumCollisionShapes() const
{
 return m_allocatedCollisionShapes.size();
}

btCollisionShape* btCollisionWorldImporter::getCollisionShapeByIndex(int index)
{
 return m_allocatedCollisionShapes[index];
}

btCollisionShape* btCollisionWorldImporter::getCollisionShapeByName(const char* name)
{
 btCollisionShape** shapePtr = m_nameShapeMap.find(name);
 if (shapePtr&& *shapePtr)
 {
  return *shapePtr;
 }
 return 0;
}


const char*	btCollisionWorldImporter::getNameForPointer(const void* ptr) const
{
 const char*const * namePtr = m_objectNameMap.find(ptr);
 if (namePtr && *namePtr)
  return *namePtr;
 return 0;
}


int btCollisionWorldImporter::getNumRigidBodies() const
{
 return m_allocatedRigidBodies.size();
}

btCollisionObject* btCollisionWorldImporter::getRigidBodyByIndex(int index) const
{
 return m_allocatedRigidBodies[index];
}


int btCollisionWorldImporter::getNumBvhs() const
{
 return m_allocatedBvhs.size();
}
btOptimizedBvh* btCollisionWorldImporter::getBvhByIndex(int index) const
{
 return m_allocatedBvhs[index];
}

int btCollisionWorldImporter::getNumTriangleInfoMaps() const
{
 return m_allocatedTriangleInfoMaps.size();
}

btTriangleInfoMap* btCollisionWorldImporter::getTriangleInfoMapByIndex(int index) const
{
 return m_allocatedTriangleInfoMaps[index];
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

*/

#include "BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btAabbUtil2.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

btShapePairCallback gCompoundChildShapePairCallback = 0;

btCompoundCollisionAlgorithm::btCompoundCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped)
 :btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_isSwapped(isSwapped),
 m_sharedManifold(ci.m_manifold)
{
 m_ownsManifold = false;

 const btCollisionObjectWrapper* colObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 btAssert(colObjWrap->getCollisionShape()->isCompound());

 const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(colObjWrap->getCollisionShape());
 m_compoundShapeRevision = compoundShape->getUpdateRevision();


 preallocateChildAlgorithms(body0Wrap, body1Wrap);
}

void	btCompoundCollisionAlgorithm::preallocateChildAlgorithms(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
{
 const btCollisionObjectWrapper* colObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* otherObjWrap = m_isSwapped ? body0Wrap : body1Wrap;
 btAssert(colObjWrap->getCollisionShape()->isCompound());

 const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(colObjWrap->getCollisionShape());

 int numChildren = compoundShape->getNumChildShapes();
 int i;

 m_childCollisionAlgorithms.resize(numChildren);
 for (i = 0; i<numChildren; i++)
 {
  if (compoundShape->getDynamicAabbTree())
  {
   m_childCollisionAlgorithms[i] = 0;
  }
  else
  {

   const btCollisionShape* childShape = compoundShape->getChildShape(i);

   btCollisionObjectWrapper childWrap(colObjWrap, childShape, colObjWrap->getCollisionObject(), colObjWrap->getWorldTransform(), -1, i);//wrong child trans, but unused (hopefully)
   m_childCollisionAlgorithms[i] = m_dispatcher->findAlgorithm(&childWrap, otherObjWrap, m_sharedManifold, BT_CONTACT_POINT_ALGORITHMS);


   btAlignedObjectArray<btCollisionAlgorithm*> m_childCollisionAlgorithmsContact;
   btAlignedObjectArray<btCollisionAlgorithm*> m_childCollisionAlgorithmsClosestPoints;


  }
 }
}

void	btCompoundCollisionAlgorithm::removeChildAlgorithms()
{
 int numChildren = m_childCollisionAlgorithms.size();
 int i;
 for (i = 0; i<numChildren; i++)
 {
  if (m_childCollisionAlgorithms[i])
  {
   m_childCollisionAlgorithms[i]->~btCollisionAlgorithm();
   m_dispatcher->freeCollisionAlgorithm(m_childCollisionAlgorithms[i]);
  }
 }
}

btCompoundCollisionAlgorithm::~btCompoundCollisionAlgorithm()
{
 removeChildAlgorithms();
}




struct	btCompoundLeafCallback : btDbvt::ICollide
{

public:

 const btCollisionObjectWrapper* m_compoundColObjWrap;
 const btCollisionObjectWrapper* m_otherObjWrap;
 btDispatcher* m_dispatcher;
 const btDispatcherInfo& m_dispatchInfo;
 btManifoldResult*	m_resultOut;
 btCollisionAlgorithm**	m_childCollisionAlgorithms;
 btPersistentManifold*	m_sharedManifold;

 btCompoundLeafCallback(const btCollisionObjectWrapper* compoundObjWrap, const btCollisionObjectWrapper* otherObjWrap, btDispatcher* dispatcher, const btDispatcherInfo& dispatchInfo, btManifoldResult*	resultOut, btCollisionAlgorithm**	childCollisionAlgorithms, btPersistentManifold*	sharedManifold)
  :m_compoundColObjWrap(compoundObjWrap), m_otherObjWrap(otherObjWrap), m_dispatcher(dispatcher), m_dispatchInfo(dispatchInfo), m_resultOut(resultOut),
  m_childCollisionAlgorithms(childCollisionAlgorithms),
  m_sharedManifold(sharedManifold)
 {

 }


 void	ProcessChildShape(const btCollisionShape* childShape, int index)
 {
  btAssert(index >= 0);
  const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(m_compoundColObjWrap->getCollisionShape());
  btAssert(index<compoundShape->getNumChildShapes());


  //backup
  btTransform	orgTrans = m_compoundColObjWrap->getWorldTransform();

  const btTransform& childTrans = compoundShape->getChildTransform(index);
  btTransform	newChildWorldTrans = orgTrans*childTrans;

  //perform an AABB check first
  btVector3 aabbMin0, aabbMax0;
  childShape->getAabb(newChildWorldTrans, aabbMin0, aabbMax0);

  btVector3 extendAabb(m_resultOut->m_closestPointDistanceThreshold, m_resultOut->m_closestPointDistanceThreshold, m_resultOut->m_closestPointDistanceThreshold);
  aabbMin0 -= extendAabb;
  aabbMax0 += extendAabb;

  btVector3 aabbMin1, aabbMax1;
  m_otherObjWrap->getCollisionShape()->getAabb(m_otherObjWrap->getWorldTransform(), aabbMin1, aabbMax1);

  if (gCompoundChildShapePairCallback)
  {
   if (!gCompoundChildShapePairCallback(m_otherObjWrap->getCollisionShape(), childShape))
    return;
  }

  if (TestAabbAgainstAabb2(aabbMin0, aabbMax0, aabbMin1, aabbMax1))
  {

   btCollisionObjectWrapper compoundWrap(this->m_compoundColObjWrap, childShape, m_compoundColObjWrap->getCollisionObject(), newChildWorldTrans, -1, index);

   btCollisionAlgorithm* algo = 0;

   if (m_resultOut->m_closestPointDistanceThreshold > 0)
   {
    algo = m_dispatcher->findAlgorithm(&compoundWrap, m_otherObjWrap, 0, BT_CLOSEST_POINT_ALGORITHMS);
   }
   else
   {
    //the contactpoint is still projected back using the original inverted worldtrans
    if (!m_childCollisionAlgorithms[index])
    {
     m_childCollisionAlgorithms[index] = m_dispatcher->findAlgorithm(&compoundWrap, m_otherObjWrap, m_sharedManifold, BT_CONTACT_POINT_ALGORITHMS);
    }
    algo = m_childCollisionAlgorithms[index];
   }

   const btCollisionObjectWrapper* tmpWrap = 0;

   ///detect swapping case
   if (m_resultOut->getBody0Internal() == m_compoundColObjWrap->getCollisionObject())
   {
    tmpWrap = m_resultOut->getBody0Wrap();
    m_resultOut->setBody0Wrap(&compoundWrap);
    m_resultOut->setShapeIdentifiersA(-1, index);
   }
   else
   {
    tmpWrap = m_resultOut->getBody1Wrap();
    m_resultOut->setBody1Wrap(&compoundWrap);
    m_resultOut->setShapeIdentifiersB(-1, index);
   }

   algo->processCollision(&compoundWrap, m_otherObjWrap, m_dispatchInfo, m_resultOut);

#if 0
   if (m_dispatchInfo.m_debugDraw && (m_dispatchInfo.m_debugDraw->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
   {
    btVector3 worldAabbMin, worldAabbMax;
    m_dispatchInfo.m_debugDraw->drawAabb(aabbMin0, aabbMax0, btVector3(1, 1, 1));
    m_dispatchInfo.m_debugDraw->drawAabb(aabbMin1, aabbMax1, btVector3(1, 1, 1));
   }
#endif

   if (m_resultOut->getBody0Internal() == m_compoundColObjWrap->getCollisionObject())
   {
    m_resultOut->setBody0Wrap(tmpWrap);
   }
   else
   {
    m_resultOut->setBody1Wrap(tmpWrap);
   }

  }
 }
 void		Process(const btDbvtNode* leaf)
 {
  int index = leaf->dataAsInt;

  const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(m_compoundColObjWrap->getCollisionShape());
  const btCollisionShape* childShape = compoundShape->getChildShape(index);

#if 0
  if (m_dispatchInfo.m_debugDraw && (m_dispatchInfo.m_debugDraw->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
  {
   btVector3 worldAabbMin, worldAabbMax;
   btTransform	orgTrans = m_compoundColObjWrap->getWorldTransform();
   btTransformAabb(leaf->volume.Mins(), leaf->volume.Maxs(), 0., orgTrans, worldAabbMin, worldAabbMax);
   m_dispatchInfo.m_debugDraw->drawAabb(worldAabbMin, worldAabbMax, btVector3(1, 0, 0));
  }
#endif

  ProcessChildShape(childShape, index);

 }
};






void btCompoundCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 const btCollisionObjectWrapper* colObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* otherObjWrap = m_isSwapped ? body0Wrap : body1Wrap;

 btAssert(colObjWrap->getCollisionShape()->isCompound());
 const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(colObjWrap->getCollisionShape());

 ///btCompoundShape might have changed:
 ////make sure the internal child collision algorithm caches are still valid
 if (compoundShape->getUpdateRevision() != m_compoundShapeRevision)
 {
  ///clear and update all
  removeChildAlgorithms();

  preallocateChildAlgorithms(body0Wrap, body1Wrap);
  m_compoundShapeRevision = compoundShape->getUpdateRevision();
 }

 if (m_childCollisionAlgorithms.size() == 0)
  return;

 const btDbvt* tree = compoundShape->getDynamicAabbTree();
 //use a dynamic aabb tree to cull potential child-overlaps
 btCompoundLeafCallback  callback(colObjWrap, otherObjWrap, m_dispatcher, dispatchInfo, resultOut, &m_childCollisionAlgorithms[0], m_sharedManifold);

 ///we need to refresh all contact manifolds
 ///note that we should actually recursively traverse all children, btCompoundShape can nested more then 1 level deep
 ///so we should add a 'refreshManifolds' in the btCollisionAlgorithm
 {
  int i;
  manifoldArray.resize(0);
  for (i = 0; i<m_childCollisionAlgorithms.size(); i++)
  {
   if (m_childCollisionAlgorithms[i])
   {
    m_childCollisionAlgorithms[i]->getAllContactManifolds(manifoldArray);
    for (int m = 0; m<manifoldArray.size(); m++)
    {
     if (manifoldArray[m]->getNumContacts())
     {
      resultOut->setPersistentManifold(manifoldArray[m]);
      resultOut->refreshContactPoints();
      resultOut->setPersistentManifold(0);//??necessary?
     }
    }
    manifoldArray.resize(0);
   }
  }
 }

 if (tree)
 {

  btVector3 localAabbMin, localAabbMax;
  btTransform otherInCompoundSpace;
  otherInCompoundSpace = colObjWrap->getWorldTransform().inverse() * otherObjWrap->getWorldTransform();
  otherObjWrap->getCollisionShape()->getAabb(otherInCompoundSpace, localAabbMin, localAabbMax);
  btVector3 extraExtends(resultOut->m_closestPointDistanceThreshold, resultOut->m_closestPointDistanceThreshold, resultOut->m_closestPointDistanceThreshold);
  localAabbMin -= extraExtends;
  localAabbMax += extraExtends;

  const ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds = btDbvtVolume::FromMM(localAabbMin, localAabbMax);
  //process all children, that overlap with  the given AABB bounds
  tree->collideTVNoStackAlloc(tree->m_root, bounds, stack2, callback);

 }
 else
 {
  //iterate over all children, perform an AABB check inside ProcessChildShape
  int numChildren = m_childCollisionAlgorithms.size();
  int i;
  for (i = 0; i<numChildren; i++)
  {
   callback.ProcessChildShape(compoundShape->getChildShape(i), i);
  }
 }

 {
  //iterate over all children, perform an AABB check inside ProcessChildShape
  int numChildren = m_childCollisionAlgorithms.size();
  int i;
  manifoldArray.resize(0);
  const btCollisionShape* childShape = 0;
  btTransform	orgTrans;

  btTransform	newChildWorldTrans;
  btVector3 aabbMin0, aabbMax0, aabbMin1, aabbMax1;

  for (i = 0; i<numChildren; i++)
  {
   if (m_childCollisionAlgorithms[i])
   {
    childShape = compoundShape->getChildShape(i);
    //if not longer overlapping, remove the algorithm
    orgTrans = colObjWrap->getWorldTransform();

    const btTransform& childTrans = compoundShape->getChildTransform(i);
    newChildWorldTrans = orgTrans*childTrans;

    //perform an AABB check first
    childShape->getAabb(newChildWorldTrans, aabbMin0, aabbMax0);
    otherObjWrap->getCollisionShape()->getAabb(otherObjWrap->getWorldTransform(), aabbMin1, aabbMax1);

    if (!TestAabbAgainstAabb2(aabbMin0, aabbMax0, aabbMin1, aabbMax1))
    {
     m_childCollisionAlgorithms[i]->~btCollisionAlgorithm();
     m_dispatcher->freeCollisionAlgorithm(m_childCollisionAlgorithms[i]);
     m_childCollisionAlgorithms[i] = 0;
    }
   }
  }
 }
}

btScalar	btCompoundCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 btAssert(0);
 //needs to be fixed, using btCollisionObjectWrapper and NOT modifying internal data structures
 btCollisionObject* colObj = m_isSwapped ? body1 : body0;
 btCollisionObject* otherObj = m_isSwapped ? body0 : body1;

 btAssert(colObj->getCollisionShape()->isCompound());

 btCompoundShape* compoundShape = static_cast<btCompoundShape*>(colObj->getCollisionShape());

 //We will use the OptimizedBVH, AABB tree to cull potential child-overlaps
 //If both proxies are Compound, we will deal with that directly, by performing sequential/parallel tree traversals
 //given Proxy0 and Proxy1, if both have a tree, Tree0 and Tree1, this means:
 //determine overlapping nodes of Proxy1 using Proxy0 AABB against Tree1
 //then use each overlapping node AABB against Tree0
 //and vise versa.

 btScalar hitFraction = btScalar(1.);

 int numChildren = m_childCollisionAlgorithms.size();
 int i;
 btTransform	orgTrans;
 btScalar frac;
 for (i = 0; i<numChildren; i++)
 {
  //btCollisionShape* childShape = compoundShape->getChildShape(i);

  //backup
  orgTrans = colObj->getWorldTransform();

  const btTransform& childTrans = compoundShape->getChildTransform(i);
  //btTransform	newChildWorldTrans = orgTrans*childTrans ;
  colObj->setWorldTransform(orgTrans*childTrans);

  //btCollisionShape* tmpShape = colObj->getCollisionShape();
  //colObj->internalSetTemporaryCollisionShape( childShape );
  frac = m_childCollisionAlgorithms[i]->calculateTimeOfImpact(colObj, otherObj, dispatchInfo, resultOut);
  if (frac<hitFraction)
  {
   hitFraction = frac;
  }
  //revert back
  //colObj->internalSetTemporaryCollisionShape( tmpShape);
  colObj->setWorldTransform(orgTrans);
 }
 return hitFraction;

}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

*/

#include "BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h"
#include "LinearMath/btQuickprof.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btAabbUtil2.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//USE_LOCAL_STACK will avoid most (often all) dynamic memory allocations due to resizing in processCollision and MycollideTT
#define USE_LOCAL_STACK 1

btShapePairCallback gCompoundCompoundChildShapePairCallback = 0;

btCompoundCompoundCollisionAlgorithm::btCompoundCompoundCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped)
 :btCompoundCollisionAlgorithm(ci, body0Wrap, body1Wrap, isSwapped)
{

 void* ptr = btAlignedAlloc(sizeof(btHashedSimplePairCache), 16);
 m_childCollisionAlgorithmCache = new(ptr) btHashedSimplePairCache();

 const btCollisionObjectWrapper* col0ObjWrap = body0Wrap;
 btAssert(col0ObjWrap->getCollisionShape()->isCompound());

 const btCollisionObjectWrapper* col1ObjWrap = body1Wrap;
 btAssert(col1ObjWrap->getCollisionShape()->isCompound());

 const btCompoundShape* compoundShape0 = static_cast<const btCompoundShape*>(col0ObjWrap->getCollisionShape());
 m_compoundShapeRevision0 = compoundShape0->getUpdateRevision();

 const btCompoundShape* compoundShape1 = static_cast<const btCompoundShape*>(col1ObjWrap->getCollisionShape());
 m_compoundShapeRevision1 = compoundShape1->getUpdateRevision();


}


btCompoundCompoundCollisionAlgorithm::~btCompoundCompoundCollisionAlgorithm()
{
 removeChildAlgorithms();
 m_childCollisionAlgorithmCache->~btHashedSimplePairCache();
 btAlignedFree(m_childCollisionAlgorithmCache);
}

void	btCompoundCompoundCollisionAlgorithm::getAllContactManifolds(btManifoldArray&	manifoldArray)
{
 int i;
 btSimplePairArray& pairs = m_childCollisionAlgorithmCache->getOverlappingPairArray();
 for (i = 0; i<pairs.size(); i++)
 {
  if (pairs[i].m_userPointer)
  {

   ((btCollisionAlgorithm*)pairs[i].m_userPointer)->getAllContactManifolds(manifoldArray);
  }
 }
}


void	btCompoundCompoundCollisionAlgorithm::removeChildAlgorithms()
{
 btSimplePairArray& pairs = m_childCollisionAlgorithmCache->getOverlappingPairArray();

 int numChildren = pairs.size();
 int i;
 for (i = 0; i<numChildren; i++)
 {
  if (pairs[i].m_userPointer)
  {
   btCollisionAlgorithm* algo = (btCollisionAlgorithm*)pairs[i].m_userPointer;
   algo->~btCollisionAlgorithm();
   m_dispatcher->freeCollisionAlgorithm(algo);
  }
 }
 m_childCollisionAlgorithmCache->removeAllPairs();
}

struct	btCompoundCompoundLeafCallback : btDbvt::ICollide
{
 int m_numOverlapPairs;


 const btCollisionObjectWrapper* m_compound0ColObjWrap;
 const btCollisionObjectWrapper* m_compound1ColObjWrap;
 btDispatcher* m_dispatcher;
 const btDispatcherInfo& m_dispatchInfo;
 btManifoldResult*	m_resultOut;


 class btHashedSimplePairCache*	m_childCollisionAlgorithmCache;

 btPersistentManifold*	m_sharedManifold;

 btCompoundCompoundLeafCallback(const btCollisionObjectWrapper* compound1ObjWrap,
  const btCollisionObjectWrapper* compound0ObjWrap,
  btDispatcher* dispatcher,
  const btDispatcherInfo& dispatchInfo,
  btManifoldResult*	resultOut,
  btHashedSimplePairCache* childAlgorithmsCache,
  btPersistentManifold*	sharedManifold)
  :m_numOverlapPairs(0), m_compound0ColObjWrap(compound1ObjWrap), m_compound1ColObjWrap(compound0ObjWrap), m_dispatcher(dispatcher), m_dispatchInfo(dispatchInfo), m_resultOut(resultOut),
  m_childCollisionAlgorithmCache(childAlgorithmsCache),
  m_sharedManifold(sharedManifold)
 {

 }




 void		Process(const btDbvtNode* leaf0, const btDbvtNode* leaf1)
 {
  BT_PROFILE("btCompoundCompoundLeafCallback::Process");
  m_numOverlapPairs++;


  int childIndex0 = leaf0->dataAsInt;
  int childIndex1 = leaf1->dataAsInt;


  btAssert(childIndex0 >= 0);
  btAssert(childIndex1 >= 0);


  const btCompoundShape* compoundShape0 = static_cast<const btCompoundShape*>(m_compound0ColObjWrap->getCollisionShape());
  btAssert(childIndex0<compoundShape0->getNumChildShapes());

  const btCompoundShape* compoundShape1 = static_cast<const btCompoundShape*>(m_compound1ColObjWrap->getCollisionShape());
  btAssert(childIndex1<compoundShape1->getNumChildShapes());

  const btCollisionShape* childShape0 = compoundShape0->getChildShape(childIndex0);
  const btCollisionShape* childShape1 = compoundShape1->getChildShape(childIndex1);

  //backup
  btTransform	orgTrans0 = m_compound0ColObjWrap->getWorldTransform();
  const btTransform& childTrans0 = compoundShape0->getChildTransform(childIndex0);
  btTransform	newChildWorldTrans0 = orgTrans0*childTrans0;

  btTransform	orgTrans1 = m_compound1ColObjWrap->getWorldTransform();
  const btTransform& childTrans1 = compoundShape1->getChildTransform(childIndex1);
  btTransform	newChildWorldTrans1 = orgTrans1*childTrans1;


  //perform an AABB check first
  btVector3 aabbMin0, aabbMax0, aabbMin1, aabbMax1;
  childShape0->getAabb(newChildWorldTrans0, aabbMin0, aabbMax0);
  childShape1->getAabb(newChildWorldTrans1, aabbMin1, aabbMax1);

  btVector3 thresholdVec(m_resultOut->m_closestPointDistanceThreshold, m_resultOut->m_closestPointDistanceThreshold, m_resultOut->m_closestPointDistanceThreshold);

  aabbMin0 -= thresholdVec;
  aabbMax0 += thresholdVec;

  if (gCompoundCompoundChildShapePairCallback)
  {
   if (!gCompoundCompoundChildShapePairCallback(childShape0, childShape1))
    return;
  }

  if (TestAabbAgainstAabb2(aabbMin0, aabbMax0, aabbMin1, aabbMax1))
  {
   btCollisionObjectWrapper compoundWrap0(this->m_compound0ColObjWrap, childShape0, m_compound0ColObjWrap->getCollisionObject(), newChildWorldTrans0, -1, childIndex0);
   btCollisionObjectWrapper compoundWrap1(this->m_compound1ColObjWrap, childShape1, m_compound1ColObjWrap->getCollisionObject(), newChildWorldTrans1, -1, childIndex1);


   btSimplePair* pair = m_childCollisionAlgorithmCache->findPair(childIndex0, childIndex1);

   btCollisionAlgorithm* colAlgo = 0;
   if (m_resultOut->m_closestPointDistanceThreshold > 0)
   {
    colAlgo = m_dispatcher->findAlgorithm(&compoundWrap0, &compoundWrap1, 0, BT_CLOSEST_POINT_ALGORITHMS);
   }
   else
   {
    if (pair)
    {
     colAlgo = (btCollisionAlgorithm*)pair->m_userPointer;

    }
    else
    {
     colAlgo = m_dispatcher->findAlgorithm(&compoundWrap0, &compoundWrap1, m_sharedManifold, BT_CONTACT_POINT_ALGORITHMS);
     pair = m_childCollisionAlgorithmCache->addOverlappingPair(childIndex0, childIndex1);
     btAssert(pair);
     pair->m_userPointer = colAlgo;
    }
   }

   btAssert(colAlgo);

   const btCollisionObjectWrapper* tmpWrap0 = 0;
   const btCollisionObjectWrapper* tmpWrap1 = 0;

   tmpWrap0 = m_resultOut->getBody0Wrap();
   tmpWrap1 = m_resultOut->getBody1Wrap();

   m_resultOut->setBody0Wrap(&compoundWrap0);
   m_resultOut->setBody1Wrap(&compoundWrap1);

   m_resultOut->setShapeIdentifiersA(-1, childIndex0);
   m_resultOut->setShapeIdentifiersB(-1, childIndex1);


   colAlgo->processCollision(&compoundWrap0, &compoundWrap1, m_dispatchInfo, m_resultOut);

   m_resultOut->setBody0Wrap(tmpWrap0);
   m_resultOut->setBody1Wrap(tmpWrap1);



  }
 }
};


static DBVT_INLINE bool		MyIntersect(const btDbvtAabbMm& a,
 const btDbvtAabbMm& b, const btTransform& xform, btScalar distanceThreshold)
{
 btVector3 newmin, newmax;
 btTransformAabb(b.Mins(), b.Maxs(), 0.f, xform, newmin, newmax);
 newmin -= btVector3(distanceThreshold, distanceThreshold, distanceThreshold);
 newmax += btVector3(distanceThreshold, distanceThreshold, distanceThreshold);
 btDbvtAabbMm newb = btDbvtAabbMm::FromMM(newmin, newmax);
 return Intersect(a, newb);
}


static inline void		MycollideTT(const btDbvtNode* root0,
 const btDbvtNode* root1,
 const btTransform& xform,
 btCompoundCompoundLeafCallback* callback, btScalar distanceThreshold)
{

 if (root0&&root1)
 {
  int								depth = 1;
  int								treshold = btDbvt::DOUBLE_STACKSIZE - 4;
  btAlignedObjectArray<btDbvt::sStkNN>	stkStack;
#ifdef USE_LOCAL_STACK
  ATTRIBUTE_ALIGNED16(btDbvt::sStkNN localStack[btDbvt::DOUBLE_STACKSIZE]);
  stkStack.initializeFromBuffer(&localStack, btDbvt::DOUBLE_STACKSIZE, btDbvt::DOUBLE_STACKSIZE);
#else
  stkStack.resize(btDbvt::DOUBLE_STACKSIZE);
#endif
  stkStack[0] = btDbvt::sStkNN(root0, root1);
  do {
   btDbvt::sStkNN	p = stkStack[--depth];
   if (MyIntersect(p.a->volume, p.b->volume, xform, distanceThreshold))
   {
    if (depth>treshold)
    {
     stkStack.resize(stkStack.size() * 2);
     treshold = stkStack.size() - 4;
    }
    if (p.a->isinternal())
    {
     if (p.b->isinternal())
     {
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[0], p.b->childs[0]);
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[1], p.b->childs[0]);
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[0], p.b->childs[1]);
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[1], p.b->childs[1]);
     }
     else
     {
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[0], p.b);
      stkStack[depth++] = btDbvt::sStkNN(p.a->childs[1], p.b);
     }
    }
    else
    {
     if (p.b->isinternal())
     {
      stkStack[depth++] = btDbvt::sStkNN(p.a, p.b->childs[0]);
      stkStack[depth++] = btDbvt::sStkNN(p.a, p.b->childs[1]);
     }
     else
     {
      callback->Process(p.a, p.b);
     }
    }
   }
  } while (depth);
 }
}

void btCompoundCompoundCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{

 const btCollisionObjectWrapper* col0ObjWrap = body0Wrap;
 const btCollisionObjectWrapper* col1ObjWrap = body1Wrap;

 btAssert(col0ObjWrap->getCollisionShape()->isCompound());
 btAssert(col1ObjWrap->getCollisionShape()->isCompound());
 const btCompoundShape* compoundShape0 = static_cast<const btCompoundShape*>(col0ObjWrap->getCollisionShape());
 const btCompoundShape* compoundShape1 = static_cast<const btCompoundShape*>(col1ObjWrap->getCollisionShape());

 const btDbvt* tree0 = compoundShape0->getDynamicAabbTree();
 const btDbvt* tree1 = compoundShape1->getDynamicAabbTree();
 if (!tree0 || !tree1)
 {
  return btCompoundCollisionAlgorithm::processCollision(body0Wrap, body1Wrap, dispatchInfo, resultOut);
 }
 ///btCompoundShape might have changed:
 ////make sure the internal child collision algorithm caches are still valid
 if ((compoundShape0->getUpdateRevision() != m_compoundShapeRevision0) || (compoundShape1->getUpdateRevision() != m_compoundShapeRevision1))
 {
  ///clear all
  removeChildAlgorithms();
  m_compoundShapeRevision0 = compoundShape0->getUpdateRevision();
  m_compoundShapeRevision1 = compoundShape1->getUpdateRevision();

 }


 ///we need to refresh all contact manifolds
 ///note that we should actually recursively traverse all children, btCompoundShape can nested more then 1 level deep
 ///so we should add a 'refreshManifolds' in the btCollisionAlgorithm
 {
  int i;
  btManifoldArray manifoldArray;
#ifdef USE_LOCAL_STACK 
  btPersistentManifold localManifolds[4];
  manifoldArray.initializeFromBuffer(&localManifolds, 0, 4);
#endif
  btSimplePairArray& pairs = m_childCollisionAlgorithmCache->getOverlappingPairArray();
  for (i = 0; i<pairs.size(); i++)
  {
   if (pairs[i].m_userPointer)
   {
    btCollisionAlgorithm* algo = (btCollisionAlgorithm*)pairs[i].m_userPointer;
    algo->getAllContactManifolds(manifoldArray);
    for (int m = 0; m<manifoldArray.size(); m++)
    {
     if (manifoldArray[m]->getNumContacts())
     {
      resultOut->setPersistentManifold(manifoldArray[m]);
      resultOut->refreshContactPoints();
      resultOut->setPersistentManifold(0);
     }
    }
    manifoldArray.resize(0);
   }
  }
 }




 btCompoundCompoundLeafCallback callback(col0ObjWrap, col1ObjWrap, this->m_dispatcher, dispatchInfo, resultOut, this->m_childCollisionAlgorithmCache, m_sharedManifold);


 const btTransform	xform = col0ObjWrap->getWorldTransform().inverse()*col1ObjWrap->getWorldTransform();
 MycollideTT(tree0->m_root, tree1->m_root, xform, &callback, resultOut->m_closestPointDistanceThreshold);

 //printf("#compound-compound child/leaf overlap =%d                      \r",callback.m_numOverlapPairs);

 //remove non-overlapping child pairs

 {
  btAssert(m_removePairs.size() == 0);

  //iterate over all children, perform an AABB check inside ProcessChildShape
  btSimplePairArray& pairs = m_childCollisionAlgorithmCache->getOverlappingPairArray();

  int i;
  btManifoldArray	manifoldArray;





  btVector3 aabbMin0, aabbMax0, aabbMin1, aabbMax1;

  for (i = 0; i<pairs.size(); i++)
  {
   if (pairs[i].m_userPointer)
   {
    btCollisionAlgorithm* algo = (btCollisionAlgorithm*)pairs[i].m_userPointer;

    {
     btTransform	orgTrans0;
     const btCollisionShape* childShape0 = 0;

     btTransform	newChildWorldTrans0;
     btTransform	orgInterpolationTrans0;
     childShape0 = compoundShape0->getChildShape(pairs[i].m_indexA);
     orgTrans0 = col0ObjWrap->getWorldTransform();
     orgInterpolationTrans0 = col0ObjWrap->getWorldTransform();
     const btTransform& childTrans0 = compoundShape0->getChildTransform(pairs[i].m_indexA);
     newChildWorldTrans0 = orgTrans0*childTrans0;
     childShape0->getAabb(newChildWorldTrans0, aabbMin0, aabbMax0);
    }
    btVector3 thresholdVec(resultOut->m_closestPointDistanceThreshold, resultOut->m_closestPointDistanceThreshold, resultOut->m_closestPointDistanceThreshold);
    aabbMin0 -= thresholdVec;
    aabbMax0 += thresholdVec;
    {
     btTransform	orgInterpolationTrans1;
     const btCollisionShape* childShape1 = 0;
     btTransform	orgTrans1;
     btTransform	newChildWorldTrans1;

     childShape1 = compoundShape1->getChildShape(pairs[i].m_indexB);
     orgTrans1 = col1ObjWrap->getWorldTransform();
     orgInterpolationTrans1 = col1ObjWrap->getWorldTransform();
     const btTransform& childTrans1 = compoundShape1->getChildTransform(pairs[i].m_indexB);
     newChildWorldTrans1 = orgTrans1*childTrans1;
     childShape1->getAabb(newChildWorldTrans1, aabbMin1, aabbMax1);
    }

    aabbMin1 -= thresholdVec;
    aabbMax1 += thresholdVec;

    if (!TestAabbAgainstAabb2(aabbMin0, aabbMax0, aabbMin1, aabbMax1))
    {
     algo->~btCollisionAlgorithm();
     m_dispatcher->freeCollisionAlgorithm(algo);
     m_removePairs.push_back(btSimplePair(pairs[i].m_indexA, pairs[i].m_indexB));
    }
   }
  }
  for (int i = 0; i<m_removePairs.size(); i++)
  {
   m_childCollisionAlgorithmCache->removeOverlappingPair(m_removePairs[i].m_indexA, m_removePairs[i].m_indexB);
  }
  m_removePairs.clear();
 }

}

btScalar	btCompoundCompoundCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 btAssert(0);
 return 0.f;

}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.h"

//#include <stdio.h>
#include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"


#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"

#include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"



#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletCollision/NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h"

#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

btConvex2dConvex2dAlgorithm::CreateFunc::CreateFunc(btSimplexSolverInterface*			simplexSolver, btConvexPenetrationDepthSolver* pdSolver)
{
 m_simplexSolver = simplexSolver;
 m_pdSolver = pdSolver;
}

btConvex2dConvex2dAlgorithm::CreateFunc::~CreateFunc()
{
}

btConvex2dConvex2dAlgorithm::btConvex2dConvex2dAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* pdSolver, int /* numPerturbationIterations */, int /* minimumPointsPerturbationThreshold */)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_simplexSolver(simplexSolver),
 m_pdSolver(pdSolver),
 m_ownManifold(false),
 m_manifoldPtr(mf),
 m_lowLevelOfDetail(false)
{
 (void)body0Wrap;
 (void)body1Wrap;
}




btConvex2dConvex2dAlgorithm::~btConvex2dConvex2dAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void	btConvex2dConvex2dAlgorithm::setLowLevelOfDetail(bool useLowLevel)
{
 m_lowLevelOfDetail = useLowLevel;
}



extern btScalar gContactBreakingThreshold;


//
// Convex-Convex collision algorithm
//
void btConvex2dConvex2dAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{

 if (!m_manifoldPtr)
 {
  //swapped?
  m_manifoldPtr = m_dispatcher->getNewManifold(body0Wrap->getCollisionObject(), body1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
 resultOut->setPersistentManifold(m_manifoldPtr);

 //comment-out next line to test multi-contact generation
 //resultOut->getPersistentManifold()->clearManifold();


 const btConvexShape* min0 = static_cast<const btConvexShape*>(body0Wrap->getCollisionShape());
 const btConvexShape* min1 = static_cast<const btConvexShape*>(body1Wrap->getCollisionShape());

 btVector3  normalOnB;
 btVector3  pointOnBWorld;

 {


  btGjkPairDetector::ClosestPointInput input;

  btGjkPairDetector	gjkPairDetector(min0, min1, m_simplexSolver, m_pdSolver);
  //TODO: if (dispatchInfo.m_useContinuous)
  gjkPairDetector.setMinkowskiA(min0);
  gjkPairDetector.setMinkowskiB(min1);

  {
   input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactBreakingThreshold();
   input.m_maximumDistanceSquared *= input.m_maximumDistanceSquared;
  }

  input.m_transformA = body0Wrap->getWorldTransform();
  input.m_transformB = body1Wrap->getWorldTransform();

  gjkPairDetector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw);

  btVector3 v0, v1;
  btVector3 sepNormalWorldSpace;

 }

 if (m_ownManifold)
 {
  resultOut->refreshContactPoints();
 }

}




btScalar	btConvex2dConvex2dAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 ///Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold

 ///Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold
 ///col0->m_worldTransform,
 btScalar resultFraction = btScalar(1.);


 btScalar squareMot0 = (col0->getInterpolationWorldTransform().getOrigin() - col0->getWorldTransform().getOrigin()).length2();
 btScalar squareMot1 = (col1->getInterpolationWorldTransform().getOrigin() - col1->getWorldTransform().getOrigin()).length2();

 if (squareMot0 < col0->getCcdSquareMotionThreshold() &&
  squareMot1 < col1->getCcdSquareMotionThreshold())
  return resultFraction;


 //An adhoc way of testing the Continuous Collision Detection algorithms
 //One object is approximated as a sphere, to simplify things
 //Starting in penetration should report no time of impact
 //For proper CCD, better accuracy and handling of 'allowed' penetration should be added
 //also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)


 /// Convex0 against sphere for Convex1
 {
  btConvexShape* convex0 = static_cast<btConvexShape*>(col0->getCollisionShape());

  btSphereShape	sphere1(col1->getCcdSweptSphereRadius()); //todo: allow non-zero sphere sizes, for better approximation
  btConvexCast::CastResult result;
  btVoronoiSimplexSolver voronoiSimplex;
  //SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
  ///Simplification, one object is simplified as a sphere
  btGjkConvexCast ccd1(convex0, &sphere1, &voronoiSimplex);
  //ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
  if (ccd1.calcTimeOfImpact(col0->getWorldTransform(), col0->getInterpolationWorldTransform(),
   col1->getWorldTransform(), col1->getInterpolationWorldTransform(), result))
  {

   //store result.m_fraction in both bodies

   if (col0->getHitFraction()> result.m_fraction)
    col0->setHitFraction(result.m_fraction);

   if (col1->getHitFraction() > result.m_fraction)
    col1->setHitFraction(result.m_fraction);

   if (resultFraction > result.m_fraction)
    resultFraction = result.m_fraction;

  }




 }

 /// Sphere (for convex0) against Convex1
 {
  btConvexShape* convex1 = static_cast<btConvexShape*>(col1->getCollisionShape());

  btSphereShape	sphere0(col0->getCcdSweptSphereRadius()); //todo: allow non-zero sphere sizes, for better approximation
  btConvexCast::CastResult result;
  btVoronoiSimplexSolver voronoiSimplex;
  //SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
  ///Simplification, one object is simplified as a sphere
  btGjkConvexCast ccd1(&sphere0, convex1, &voronoiSimplex);
  //ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
  if (ccd1.calcTimeOfImpact(col0->getWorldTransform(), col0->getInterpolationWorldTransform(),
   col1->getWorldTransform(), col1->getInterpolationWorldTransform(), result))
  {

   //store result.m_fraction in both bodies

   if (col0->getHitFraction()	> result.m_fraction)
    col0->setHitFraction(result.m_fraction);

   if (col1->getHitFraction() > result.m_fraction)
    col1->setHitFraction(result.m_fraction);

   if (resultFraction > result.m_fraction)
    resultFraction = result.m_fraction;

  }
 }

 return resultFraction;

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h"
#include "LinearMath/btQuickprof.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionShapes/btConcaveShape.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

btConvexConcaveCollisionAlgorithm::btConvexConcaveCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_btConvexTriangleCallback(ci.m_dispatcher1, body0Wrap, body1Wrap, isSwapped),
 m_isSwapped(isSwapped)
{
}

btConvexConcaveCollisionAlgorithm::~btConvexConcaveCollisionAlgorithm()
{
}

void	btConvexConcaveCollisionAlgorithm::getAllContactManifolds(btManifoldArray&	manifoldArray)
{
 if (m_btConvexTriangleCallback.m_manifoldPtr)
 {
  manifoldArray.push_back(m_btConvexTriangleCallback.m_manifoldPtr);
 }
}


btConvexTriangleCallback::btConvexTriangleCallback(btDispatcher*  dispatcher, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped) :
 m_dispatcher(dispatcher),
 m_dispatchInfoPtr(0)
{
 m_convexBodyWrap = isSwapped ? body1Wrap : body0Wrap;
 m_triBodyWrap = isSwapped ? body0Wrap : body1Wrap;

 //
 // create the manifold from the dispatcher 'manifold pool'
 //
 m_manifoldPtr = m_dispatcher->getNewManifold(m_convexBodyWrap->getCollisionObject(), m_triBodyWrap->getCollisionObject());

 clearCache();
}

btConvexTriangleCallback::~btConvexTriangleCallback()
{
 clearCache();
 m_dispatcher->releaseManifold(m_manifoldPtr);

}


void	btConvexTriangleCallback::clearCache()
{
 m_dispatcher->clearManifold(m_manifoldPtr);
}


void btConvexTriangleCallback::processTriangle(btVector3* triangle, int
 partId, int triangleIndex)
{
 BT_PROFILE("btConvexTriangleCallback::processTriangle");

 if (!TestTriangleAgainstAabb2(triangle, m_aabbMin, m_aabbMax))
 {
  return;
 }

 //just for debugging purposes
 //printf("triangle %d",m_triangleCount++);



 btCollisionAlgorithmConstructionInfo ci;
 ci.m_dispatcher1 = m_dispatcher;



#if 0	

 ///debug drawing of the overlapping triangles
 if (m_dispatchInfoPtr && m_dispatchInfoPtr->m_debugDraw && (m_dispatchInfoPtr->m_debugDraw->getDebugMode() &btIDebugDraw::DBG_DrawWireframe))
 {
  const btCollisionObject* ob = const_cast<btCollisionObject*>(m_triBodyWrap->getCollisionObject());
  btVector3 color(1, 1, 0);
  btTransform& tr = ob->getWorldTransform();
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[0]), tr(triangle[1]), color);
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[1]), tr(triangle[2]), color);
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[2]), tr(triangle[0]), color);
 }
#endif

 if (m_convexBodyWrap->getCollisionShape()->isConvex())
 {
  btTriangleShape tm(triangle[0], triangle[1], triangle[2]);
  tm.setMargin(m_collisionMarginTriangle);


  btCollisionObjectWrapper triObWrap(m_triBodyWrap, &tm, m_triBodyWrap->getCollisionObject(), m_triBodyWrap->getWorldTransform(), partId, triangleIndex);//correct transform?
  btCollisionAlgorithm* colAlgo = 0;

  if (m_resultOut->m_closestPointDistanceThreshold > 0)
  {
   colAlgo = ci.m_dispatcher1->findAlgorithm(m_convexBodyWrap, &triObWrap, 0, BT_CLOSEST_POINT_ALGORITHMS);
  }
  else
  {
   colAlgo = ci.m_dispatcher1->findAlgorithm(m_convexBodyWrap, &triObWrap, m_manifoldPtr, BT_CONTACT_POINT_ALGORITHMS);
  }
  const btCollisionObjectWrapper* tmpWrap = 0;

  if (m_resultOut->getBody0Internal() == m_triBodyWrap->getCollisionObject())
  {
   tmpWrap = m_resultOut->getBody0Wrap();
   m_resultOut->setBody0Wrap(&triObWrap);
   m_resultOut->setShapeIdentifiersA(partId, triangleIndex);
  }
  else
  {
   tmpWrap = m_resultOut->getBody1Wrap();
   m_resultOut->setBody1Wrap(&triObWrap);
   m_resultOut->setShapeIdentifiersB(partId, triangleIndex);
  }

  colAlgo->processCollision(m_convexBodyWrap, &triObWrap, *m_dispatchInfoPtr, m_resultOut);

  if (m_resultOut->getBody0Internal() == m_triBodyWrap->getCollisionObject())
  {
   m_resultOut->setBody0Wrap(tmpWrap);
  }
  else
  {
   m_resultOut->setBody1Wrap(tmpWrap);
  }



  colAlgo->~btCollisionAlgorithm();
  ci.m_dispatcher1->freeCollisionAlgorithm(colAlgo);
 }

}



void	btConvexTriangleCallback::setTimeStepAndCounters(btScalar collisionMarginTriangle, const btDispatcherInfo& dispatchInfo, const btCollisionObjectWrapper* convexBodyWrap, const btCollisionObjectWrapper* triBodyWrap, btManifoldResult* resultOut)
{
 m_convexBodyWrap = convexBodyWrap;
 m_triBodyWrap = triBodyWrap;

 m_dispatchInfoPtr = &dispatchInfo;
 m_collisionMarginTriangle = collisionMarginTriangle;
 m_resultOut = resultOut;

 //recalc aabbs
 btTransform convexInTriangleSpace;
 convexInTriangleSpace = m_triBodyWrap->getWorldTransform().inverse() * m_convexBodyWrap->getWorldTransform();
 const btCollisionShape* convexShape = static_cast<const btCollisionShape*>(m_convexBodyWrap->getCollisionShape());
 //CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);
 convexShape->getAabb(convexInTriangleSpace, m_aabbMin, m_aabbMax);
 btScalar extraMargin = collisionMarginTriangle + resultOut->m_closestPointDistanceThreshold;

 btVector3 extra(extraMargin, extraMargin, extraMargin);

 m_aabbMax += extra;
 m_aabbMin -= extra;

}

void btConvexConcaveCollisionAlgorithm::clearCache()
{
 m_btConvexTriangleCallback.clearCache();

}

void btConvexConcaveCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 BT_PROFILE("btConvexConcaveCollisionAlgorithm::processCollision");

 const btCollisionObjectWrapper* convexBodyWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* triBodyWrap = m_isSwapped ? body0Wrap : body1Wrap;

 if (triBodyWrap->getCollisionShape()->isConcave())
 {



  const btConcaveShape* concaveShape = static_cast<const btConcaveShape*>(triBodyWrap->getCollisionShape());

  if (convexBodyWrap->getCollisionShape()->isConvex())
  {
   btScalar collisionMarginTriangle = concaveShape->getMargin();

   resultOut->setPersistentManifold(m_btConvexTriangleCallback.m_manifoldPtr);
   m_btConvexTriangleCallback.setTimeStepAndCounters(collisionMarginTriangle, dispatchInfo, convexBodyWrap, triBodyWrap, resultOut);

   m_btConvexTriangleCallback.m_manifoldPtr->setBodies(convexBodyWrap->getCollisionObject(), triBodyWrap->getCollisionObject());

   concaveShape->processAllTriangles(&m_btConvexTriangleCallback, m_btConvexTriangleCallback.getAabbMin(), m_btConvexTriangleCallback.getAabbMax());

   resultOut->refreshContactPoints();

   m_btConvexTriangleCallback.clearWrapperData();

  }

 }

}


btScalar btConvexConcaveCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 btCollisionObject* convexbody = m_isSwapped ? body1 : body0;
 btCollisionObject* triBody = m_isSwapped ? body0 : body1;


 //quick approximation using raycast, todo: hook up to the continuous collision detection (one of the btConvexCast)

 //only perform CCD above a certain threshold, this prevents blocking on the long run
 //because object in a blocked ccd state (hitfraction<1) get their linear velocity halved each frame...
 btScalar squareMot0 = (convexbody->getInterpolationWorldTransform().getOrigin() - convexbody->getWorldTransform().getOrigin()).length2();
 if (squareMot0 < convexbody->getCcdSquareMotionThreshold())
 {
  return btScalar(1.);
 }

 //const btVector3& from = convexbody->m_worldTransform.getOrigin();
 //btVector3 to = convexbody->m_interpolationWorldTransform.getOrigin();
 //todo: only do if the motion exceeds the 'radius'

 btTransform triInv = triBody->getWorldTransform().inverse();
 btTransform convexFromLocal = triInv * convexbody->getWorldTransform();
 btTransform convexToLocal = triInv * convexbody->getInterpolationWorldTransform();

 struct LocalTriangleSphereCastCallback : public btTriangleCallback
 {
  btTransform m_ccdSphereFromTrans;
  btTransform m_ccdSphereToTrans;
  btTransform	m_meshTransform;

  btScalar	m_ccdSphereRadius;
  btScalar	m_hitFraction;


  LocalTriangleSphereCastCallback(const btTransform& from, const btTransform& to, btScalar ccdSphereRadius, btScalar hitFraction)
   :m_ccdSphereFromTrans(from),
   m_ccdSphereToTrans(to),
   m_ccdSphereRadius(ccdSphereRadius),
   m_hitFraction(hitFraction)
  {
  }


  virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
  {
   BT_PROFILE("processTriangle");
   (void)partId;
   (void)triangleIndex;
   //do a swept sphere for now
   btTransform ident;
   ident.setIdentity();
   btConvexCast::CastResult castResult;
   castResult.m_fraction = m_hitFraction;
   btSphereShape	pointShape(m_ccdSphereRadius);
   btTriangleShape	triShape(triangle[0], triangle[1], triangle[2]);
   btVoronoiSimplexSolver	simplexSolver;
   btSubsimplexConvexCast convexCaster(&pointShape, &triShape, &simplexSolver);
   //GjkConvexCast	convexCaster(&pointShape,convexShape,&simplexSolver);
   //ContinuousConvexCollision convexCaster(&pointShape,convexShape,&simplexSolver,0);
   //local space?

   if (convexCaster.calcTimeOfImpact(m_ccdSphereFromTrans, m_ccdSphereToTrans,
    ident, ident, castResult))
   {
    if (m_hitFraction > castResult.m_fraction)
     m_hitFraction = castResult.m_fraction;
   }

  }

 };





 if (triBody->getCollisionShape()->isConcave())
 {
  btVector3 rayAabbMin = convexFromLocal.getOrigin();
  rayAabbMin.setMin(convexToLocal.getOrigin());
  btVector3 rayAabbMax = convexFromLocal.getOrigin();
  rayAabbMax.setMax(convexToLocal.getOrigin());
  btScalar ccdRadius0 = convexbody->getCcdSweptSphereRadius();
  rayAabbMin -= btVector3(ccdRadius0, ccdRadius0, ccdRadius0);
  rayAabbMax += btVector3(ccdRadius0, ccdRadius0, ccdRadius0);

  btScalar curHitFraction = btScalar(1.); //is this available?
  LocalTriangleSphereCastCallback raycastCallback(convexFromLocal, convexToLocal,
   convexbody->getCcdSweptSphereRadius(), curHitFraction);

  raycastCallback.m_hitFraction = convexbody->getHitFraction();

  btCollisionObject* concavebody = triBody;

  btConcaveShape* triangleMesh = (btConcaveShape*)concavebody->getCollisionShape();

  if (triangleMesh)
  {
   triangleMesh->processAllTriangles(&raycastCallback, rayAabbMin, rayAabbMax);
  }



  if (raycastCallback.m_hitFraction < convexbody->getHitFraction())
  {
   convexbody->setHitFraction(raycastCallback.m_hitFraction);
   return raycastCallback.m_hitFraction;
  }
 }

 return btScalar(1.);

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///Specialized capsule-capsule collision algorithm has been added for Bullet 2.75 release to increase ragdoll performance
///If you experience problems with capsule-capsule collision, try to define BT_DISABLE_CAPSULE_CAPSULE_COLLIDER and report it in the Bullet forums
///with reproduction case
//#define BT_DISABLE_CAPSULE_CAPSULE_COLLIDER 1
//#define ZERO_MARGIN

#include "BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h"

//#include <stdio.h>
#include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"



#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"

#include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"



#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletCollision/NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h"

#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

///////////



static SIMD_FORCE_INLINE void segmentsClosestPoints(
 btVector3& ptsVector,
 btVector3& offsetA,
 btVector3& offsetB,
 btScalar& tA, btScalar& tB,
 const btVector3& translation,
 const btVector3& dirA, btScalar hlenA,
 const btVector3& dirB, btScalar hlenB)
{
 // compute the parameters of the closest points on each line segment

 btScalar dirA_dot_dirB = btDot(dirA, dirB);
 btScalar dirA_dot_trans = btDot(dirA, translation);
 btScalar dirB_dot_trans = btDot(dirB, translation);

 btScalar denom = 1.0f - dirA_dot_dirB * dirA_dot_dirB;

 if (denom == 0.0f) {
  tA = 0.0f;
 }
 else {
  tA = (dirA_dot_trans - dirB_dot_trans * dirA_dot_dirB) / denom;
  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }

 tB = tA * dirA_dot_dirB - dirB_dot_trans;

 if (tB < -hlenB) {
  tB = -hlenB;
  tA = tB * dirA_dot_dirB + dirA_dot_trans;

  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }
 else if (tB > hlenB) {
  tB = hlenB;
  tA = tB * dirA_dot_dirB + dirA_dot_trans;

  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }

 // compute the closest points relative to segment centers.

 offsetA = dirA * tA;
 offsetB = dirB * tB;

 ptsVector = translation - offsetA + offsetB;
}


static SIMD_FORCE_INLINE btScalar capsuleCapsuleDistance(
 btVector3& normalOnB,
 btVector3& pointOnB,
 btScalar capsuleLengthA,
 btScalar	capsuleRadiusA,
 btScalar capsuleLengthB,
 btScalar	capsuleRadiusB,
 int capsuleAxisA,
 int capsuleAxisB,
 const btTransform& transformA,
 const btTransform& transformB,
 btScalar distanceThreshold)
{
 btVector3 directionA = transformA.getBasis().getColumn(capsuleAxisA);
 btVector3 translationA = transformA.getOrigin();
 btVector3 directionB = transformB.getBasis().getColumn(capsuleAxisB);
 btVector3 translationB = transformB.getOrigin();

 // translation between centers

 btVector3 translation = translationB - translationA;

 // compute the closest points of the capsule line segments

 btVector3 ptsVector;           // the vector between the closest points

 btVector3 offsetA, offsetB;    // offsets from segment centers to their closest points
 btScalar tA, tB;              // parameters on line segment

 segmentsClosestPoints(ptsVector, offsetA, offsetB, tA, tB, translation,
  directionA, capsuleLengthA, directionB, capsuleLengthB);

 btScalar distance = ptsVector.length() - capsuleRadiusA - capsuleRadiusB;

 if (distance > distanceThreshold)
  return distance;

 btScalar lenSqr = ptsVector.length2();
 if (lenSqr <= (SIMD_EPSILON*SIMD_EPSILON))
 {
  //degenerate case where 2 capsules are likely at the same location: take a vector tangential to 'directionA'
  btVector3 q;
  btPlaneSpace1(directionA, normalOnB, q);
 }
 else
 {
  // compute the contact normal
  normalOnB = ptsVector*-btRecipSqrt(lenSqr);
 }
 pointOnB = transformB.getOrigin() + offsetB + normalOnB * capsuleRadiusB;

 return distance;
}







//////////





btConvexConvexAlgorithm::CreateFunc::CreateFunc(btConvexPenetrationDepthSolver* pdSolver)
{
 m_numPerturbationIterations = 0;
 m_minimumPointsPerturbationThreshold = 3;
 m_pdSolver = pdSolver;
}

btConvexConvexAlgorithm::CreateFunc::~CreateFunc()
{
}

btConvexConvexAlgorithm::btConvexConvexAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btConvexPenetrationDepthSolver* pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_pdSolver(pdSolver),
 m_ownManifold(false),
 m_manifoldPtr(mf),
 m_lowLevelOfDetail(false),
#ifdef USE_SEPDISTANCE_UTIL2
 m_sepDistance((static_cast<btConvexShape*>(body0->getCollisionShape()))->getAngularMotionDisc(),
 (static_cast<btConvexShape*>(body1->getCollisionShape()))->getAngularMotionDisc()),
#endif
 m_numPerturbationIterations(numPerturbationIterations),
 m_minimumPointsPerturbationThreshold(minimumPointsPerturbationThreshold)
{
 (void)body0Wrap;
 (void)body1Wrap;
}




btConvexConvexAlgorithm::~btConvexConvexAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void	btConvexConvexAlgorithm::setLowLevelOfDetail(bool useLowLevel)
{
 m_lowLevelOfDetail = useLowLevel;
}


struct btPerturbedContactResult : public btManifoldResult
{
 btManifoldResult* m_originalManifoldResult;
 btTransform m_transformA;
 btTransform m_transformB;
 btTransform	m_unPerturbedTransform;
 bool	m_perturbA;
 btIDebugDraw*	m_debugDrawer;


 btPerturbedContactResult(btManifoldResult* originalResult, const btTransform& transformA, const btTransform& transformB, const btTransform& unPerturbedTransform, bool perturbA, btIDebugDraw* debugDrawer)
  :m_originalManifoldResult(originalResult),
  m_transformA(transformA),
  m_transformB(transformB),
  m_unPerturbedTransform(unPerturbedTransform),
  m_perturbA(perturbA),
  m_debugDrawer(debugDrawer)
 {
 }
 virtual ~btPerturbedContactResult()
 {
 }

 virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar orgDepth)
 {
  btVector3 endPt, startPt;
  btScalar newDepth;
  btVector3 newNormal;

  if (m_perturbA)
  {
   btVector3 endPtOrg = pointInWorld + normalOnBInWorld*orgDepth;
   endPt = (m_unPerturbedTransform*m_transformA.inverse())(endPtOrg);
   newDepth = (endPt - pointInWorld).dot(normalOnBInWorld);
   startPt = endPt + normalOnBInWorld*newDepth;
  }
  else
  {
   endPt = pointInWorld + normalOnBInWorld*orgDepth;
   startPt = (m_unPerturbedTransform*m_transformB.inverse())(pointInWorld);
   newDepth = (endPt - startPt).dot(normalOnBInWorld);

  }

  //#define DEBUG_CONTACTS 1
#ifdef DEBUG_CONTACTS
  m_debugDrawer->drawLine(startPt, endPt, btVector3(1, 0, 0));
  m_debugDrawer->drawSphere(startPt, 0.05, btVector3(0, 1, 0));
  m_debugDrawer->drawSphere(endPt, 0.05, btVector3(0, 0, 1));
#endif //DEBUG_CONTACTS


  m_originalManifoldResult->addContactPoint(normalOnBInWorld, startPt, newDepth);
 }

};

extern btScalar gContactBreakingThreshold;


//
// Convex-Convex collision algorithm
//
void btConvexConvexAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{

 if (!m_manifoldPtr)
 {
  //swapped?
  m_manifoldPtr = m_dispatcher->getNewManifold(body0Wrap->getCollisionObject(), body1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
 resultOut->setPersistentManifold(m_manifoldPtr);

 //comment-out next line to test multi-contact generation
 //resultOut->getPersistentManifold()->clearManifold();


 const btConvexShape* min0 = static_cast<const btConvexShape*>(body0Wrap->getCollisionShape());
 const btConvexShape* min1 = static_cast<const btConvexShape*>(body1Wrap->getCollisionShape());

 btVector3  normalOnB;
 btVector3  pointOnBWorld;
#ifndef BT_DISABLE_CAPSULE_CAPSULE_COLLIDER
 if ((min0->getShapeType() == CAPSULE_SHAPE_PROXYTYPE) && (min1->getShapeType() == CAPSULE_SHAPE_PROXYTYPE))
 {
  //m_manifoldPtr->clearManifold();

  btCapsuleShape* capsuleA = (btCapsuleShape*)min0;
  btCapsuleShape* capsuleB = (btCapsuleShape*)min1;

  btScalar threshold = m_manifoldPtr->getContactBreakingThreshold();

  btScalar dist = capsuleCapsuleDistance(normalOnB, pointOnBWorld, capsuleA->getHalfHeight(), capsuleA->getRadius(),
   capsuleB->getHalfHeight(), capsuleB->getRadius(), capsuleA->getUpAxis(), capsuleB->getUpAxis(),
   body0Wrap->getWorldTransform(), body1Wrap->getWorldTransform(), threshold);

  if (dist<threshold)
  {
   btAssert(normalOnB.length2() >= (SIMD_EPSILON*SIMD_EPSILON));
   resultOut->addContactPoint(normalOnB, pointOnBWorld, dist);
  }
  resultOut->refreshContactPoints();
  return;
 }

 if ((min0->getShapeType() == CAPSULE_SHAPE_PROXYTYPE) && (min1->getShapeType() == SPHERE_SHAPE_PROXYTYPE))
 {
  //m_manifoldPtr->clearManifold();

  btCapsuleShape* capsuleA = (btCapsuleShape*)min0;
  btSphereShape* capsuleB = (btSphereShape*)min1;

  btScalar threshold = m_manifoldPtr->getContactBreakingThreshold();

  btScalar dist = capsuleCapsuleDistance(normalOnB, pointOnBWorld, capsuleA->getHalfHeight(), capsuleA->getRadius(),
   0., capsuleB->getRadius(), capsuleA->getUpAxis(), 1,
   body0Wrap->getWorldTransform(), body1Wrap->getWorldTransform(), threshold);

  if (dist<threshold)
  {
   btAssert(normalOnB.length2() >= (SIMD_EPSILON*SIMD_EPSILON));
   resultOut->addContactPoint(normalOnB, pointOnBWorld, dist);
  }
  resultOut->refreshContactPoints();
  return;
 }

 if ((min0->getShapeType() == SPHERE_SHAPE_PROXYTYPE) && (min1->getShapeType() == CAPSULE_SHAPE_PROXYTYPE))
 {
  //m_manifoldPtr->clearManifold();

  btSphereShape* capsuleA = (btSphereShape*)min0;
  btCapsuleShape* capsuleB = (btCapsuleShape*)min1;

  btScalar threshold = m_manifoldPtr->getContactBreakingThreshold();

  btScalar dist = capsuleCapsuleDistance(normalOnB, pointOnBWorld, 0., capsuleA->getRadius(),
   capsuleB->getHalfHeight(), capsuleB->getRadius(), 1, capsuleB->getUpAxis(),
   body0Wrap->getWorldTransform(), body1Wrap->getWorldTransform(), threshold);

  if (dist<threshold)
  {
   btAssert(normalOnB.length2() >= (SIMD_EPSILON*SIMD_EPSILON));
   resultOut->addContactPoint(normalOnB, pointOnBWorld, dist);
  }
  resultOut->refreshContactPoints();
  return;
 }
#endif //BT_DISABLE_CAPSULE_CAPSULE_COLLIDER




#ifdef USE_SEPDISTANCE_UTIL2
 if (dispatchInfo.m_useConvexConservativeDistanceUtil)
 {
  m_sepDistance.updateSeparatingDistance(body0->getWorldTransform(), body1->getWorldTransform());
 }

 if (!dispatchInfo.m_useConvexConservativeDistanceUtil || m_sepDistance.getConservativeSeparatingDistance() <= 0.f)
#endif //USE_SEPDISTANCE_UTIL2

 {


  btGjkPairDetector::ClosestPointInput input;
  btVoronoiSimplexSolver simplexSolver;
  btGjkPairDetector	gjkPairDetector(min0, min1, &simplexSolver, m_pdSolver);
  //TODO: if (dispatchInfo.m_useContinuous)
  gjkPairDetector.setMinkowskiA(min0);
  gjkPairDetector.setMinkowskiB(min1);

#ifdef USE_SEPDISTANCE_UTIL2
  if (dispatchInfo.m_useConvexConservativeDistanceUtil)
  {
   input.m_maximumDistanceSquared = BT_LARGE_FLOAT;
  }
  else
#endif //USE_SEPDISTANCE_UTIL2
  {
   //if (dispatchInfo.m_convexMaxDistanceUseCPT)
   //{
   //	input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactProcessingThreshold();
   //} else
   //{
   input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactBreakingThreshold() + resultOut->m_closestPointDistanceThreshold;
   //		}

   input.m_maximumDistanceSquared *= input.m_maximumDistanceSquared;
  }

  input.m_transformA = body0Wrap->getWorldTransform();
  input.m_transformB = body1Wrap->getWorldTransform();





#ifdef USE_SEPDISTANCE_UTIL2
  btScalar sepDist = 0.f;
  if (dispatchInfo.m_useConvexConservativeDistanceUtil)
  {
   sepDist = gjkPairDetector.getCachedSeparatingDistance();
   if (sepDist>SIMD_EPSILON)
   {
    sepDist += dispatchInfo.m_convexConservativeDistanceThreshold;
    //now perturbe directions to get multiple contact points

   }
  }
#endif //USE_SEPDISTANCE_UTIL2

  if (min0->isPolyhedral() && min1->isPolyhedral())
  {


   struct btDummyResult : public btDiscreteCollisionDetectorInterface::Result
   {
    virtual void setShapeIdentifiersA(int partId0, int index0) {}
    virtual void setShapeIdentifiersB(int partId1, int index1) {}
    virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
    {
    }
   };


   struct btWithoutMarginResult : public btDiscreteCollisionDetectorInterface::Result
   {
    btDiscreteCollisionDetectorInterface::Result* m_originalResult;
    btVector3	m_reportedNormalOnWorld;
    btScalar m_marginOnA;
    btScalar m_marginOnB;
    btScalar	m_reportedDistance;

    bool		m_foundResult;
    btWithoutMarginResult(btDiscreteCollisionDetectorInterface::Result* result, btScalar marginOnA, btScalar marginOnB)
     :m_originalResult(result),
     m_marginOnA(marginOnA),
     m_marginOnB(marginOnB),
     m_foundResult(false)
    {
    }

    virtual void setShapeIdentifiersA(int partId0, int index0) {}
    virtual void setShapeIdentifiersB(int partId1, int index1) {}
    virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorldOrg, btScalar depthOrg)
    {
     m_reportedDistance = depthOrg;
     m_reportedNormalOnWorld = normalOnBInWorld;

     btVector3 adjustedPointB = pointInWorldOrg - normalOnBInWorld*m_marginOnB;
     m_reportedDistance = depthOrg + (m_marginOnA + m_marginOnB);
     if (m_reportedDistance<0.f)
     {
      m_foundResult = true;
     }
     m_originalResult->addContactPoint(normalOnBInWorld, adjustedPointB, m_reportedDistance);
    }
   };


   btDummyResult dummy;

   ///btBoxShape is an exception: its vertices are created WITH margin so don't subtract it

   btScalar min0Margin = min0->getShapeType() == BOX_SHAPE_PROXYTYPE ? 0.f : min0->getMargin();
   btScalar min1Margin = min1->getShapeType() == BOX_SHAPE_PROXYTYPE ? 0.f : min1->getMargin();

   btWithoutMarginResult	withoutMargin(resultOut, min0Margin, min1Margin);

   btPolyhedralConvexShape* polyhedronA = (btPolyhedralConvexShape*)min0;
   btPolyhedralConvexShape* polyhedronB = (btPolyhedralConvexShape*)min1;
   if (polyhedronA->getConvexPolyhedron() && polyhedronB->getConvexPolyhedron())
   {




    btScalar threshold = m_manifoldPtr->getContactBreakingThreshold();

    btScalar minDist = -1e30f;
    btVector3 sepNormalWorldSpace;
    bool foundSepAxis = true;

    if (dispatchInfo.m_enableSatConvex)
    {
     foundSepAxis = btPolyhedralContactClipping::findSeparatingAxis(
      *polyhedronA->getConvexPolyhedron(), *polyhedronB->getConvexPolyhedron(),
      body0Wrap->getWorldTransform(),
      body1Wrap->getWorldTransform(),
      sepNormalWorldSpace, *resultOut);
    }
    else
    {
#ifdef ZERO_MARGIN
     gjkPairDetector.setIgnoreMargin(true);
     gjkPairDetector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw);
#else


     gjkPairDetector.getClosestPoints(input, withoutMargin, dispatchInfo.m_debugDraw);
     //gjkPairDetector.getClosestPoints(input,dummy,dispatchInfo.m_debugDraw);
#endif //ZERO_MARGIN
     //btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();
     //if (l2>SIMD_EPSILON)
     {
      sepNormalWorldSpace = withoutMargin.m_reportedNormalOnWorld;//gjkPairDetector.getCachedSeparatingAxis()*(1.f/l2);
                                                                  //minDist = -1e30f;//gjkPairDetector.getCachedSeparatingDistance();
      minDist = withoutMargin.m_reportedDistance;//gjkPairDetector.getCachedSeparatingDistance()+min0->getMargin()+min1->getMargin();

#ifdef ZERO_MARGIN
      foundSepAxis = true;//gjkPairDetector.getCachedSeparatingDistance()<0.f;
#else
      foundSepAxis = withoutMargin.m_foundResult && minDist<0;//-(min0->getMargin()+min1->getMargin());
#endif
     }
    }
    if (foundSepAxis)
    {

     //				printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());

     worldVertsB1.resize(0);
     btPolyhedralContactClipping::clipHullAgainstHull(sepNormalWorldSpace, *polyhedronA->getConvexPolyhedron(), *polyhedronB->getConvexPolyhedron(),
      body0Wrap->getWorldTransform(),
      body1Wrap->getWorldTransform(), minDist - threshold, threshold, worldVertsB1, worldVertsB2,
      *resultOut);

    }
    if (m_ownManifold)
    {
     resultOut->refreshContactPoints();
    }
    return;

   }
   else
   {
    //we can also deal with convex versus triangle (without connectivity data)
    if (polyhedronA->getConvexPolyhedron() && polyhedronB->getShapeType() == TRIANGLE_SHAPE_PROXYTYPE)
    {

     btVertexArray vertices;
     btTriangleShape* tri = (btTriangleShape*)polyhedronB;
     vertices.push_back(body1Wrap->getWorldTransform()*tri->m_vertices1[0]);
     vertices.push_back(body1Wrap->getWorldTransform()*tri->m_vertices1[1]);
     vertices.push_back(body1Wrap->getWorldTransform()*tri->m_vertices1[2]);

     //tri->initializePolyhedralFeatures();

     btScalar threshold = m_manifoldPtr->getContactBreakingThreshold();

     btVector3 sepNormalWorldSpace;
     btScalar minDist = -1e30f;
     btScalar maxDist = threshold;

     bool foundSepAxis = false;
     if (0)
     {
      polyhedronB->initializePolyhedralFeatures();
      foundSepAxis = btPolyhedralContactClipping::findSeparatingAxis(
       *polyhedronA->getConvexPolyhedron(), *polyhedronB->getConvexPolyhedron(),
       body0Wrap->getWorldTransform(),
       body1Wrap->getWorldTransform(),
       sepNormalWorldSpace, *resultOut);
      //	 printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());

     }
     else
     {
#ifdef ZERO_MARGIN
      gjkPairDetector.setIgnoreMargin(true);
      gjkPairDetector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw);
#else
      gjkPairDetector.getClosestPoints(input, dummy, dispatchInfo.m_debugDraw);
#endif//ZERO_MARGIN

      btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();
      if (l2>SIMD_EPSILON)
      {
       sepNormalWorldSpace = gjkPairDetector.getCachedSeparatingAxis()*(1.f / l2);
       //minDist = gjkPairDetector.getCachedSeparatingDistance();
       //maxDist = threshold;
       minDist = gjkPairDetector.getCachedSeparatingDistance() - min0->getMargin() - min1->getMargin();
       foundSepAxis = true;
      }
     }


     if (foundSepAxis)
     {
      worldVertsB2.resize(0);
      btPolyhedralContactClipping::clipFaceAgainstHull(sepNormalWorldSpace, *polyhedronA->getConvexPolyhedron(),
       body0Wrap->getWorldTransform(), vertices, worldVertsB2, minDist - threshold, maxDist, *resultOut);
     }


     if (m_ownManifold)
     {
      resultOut->refreshContactPoints();
     }

     return;
    }

   }


  }

  gjkPairDetector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw);

  //now perform 'm_numPerturbationIterations' collision queries with the perturbated collision objects

  //perform perturbation when more then 'm_minimumPointsPerturbationThreshold' points
  if (m_numPerturbationIterations && resultOut->getPersistentManifold()->getNumContacts() < m_minimumPointsPerturbationThreshold)
  {

   int i;
   btVector3 v0, v1;
   btVector3 sepNormalWorldSpace;
   btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();

   if (l2>SIMD_EPSILON)
   {
    sepNormalWorldSpace = gjkPairDetector.getCachedSeparatingAxis()*(1.f / l2);

    btPlaneSpace1(sepNormalWorldSpace, v0, v1);


    bool perturbeA = true;
    const btScalar angleLimit = 0.125f * SIMD_PI;
    btScalar perturbeAngle;
    btScalar radiusA = min0->getAngularMotionDisc();
    btScalar radiusB = min1->getAngularMotionDisc();
    if (radiusA < radiusB)
    {
     perturbeAngle = gContactBreakingThreshold / radiusA;
     perturbeA = true;
    }
    else
    {
     perturbeAngle = gContactBreakingThreshold / radiusB;
     perturbeA = false;
    }
    if (perturbeAngle > angleLimit)
     perturbeAngle = angleLimit;

    btTransform unPerturbedTransform;
    if (perturbeA)
    {
     unPerturbedTransform = input.m_transformA;
    }
    else
    {
     unPerturbedTransform = input.m_transformB;
    }

    for (i = 0; i<m_numPerturbationIterations; i++)
    {
     if (v0.length2()>SIMD_EPSILON)
     {
      btQuaternion perturbeRot(v0, perturbeAngle);
      btScalar iterationAngle = i*(SIMD_2_PI / btScalar(m_numPerturbationIterations));
      btQuaternion rotq(sepNormalWorldSpace, iterationAngle);


      if (perturbeA)
      {
       input.m_transformA.setBasis(btMatrix3x3(rotq.inverse()*perturbeRot*rotq)*body0Wrap->getWorldTransform().getBasis());
       input.m_transformB = body1Wrap->getWorldTransform();
#ifdef DEBUG_CONTACTS
       dispatchInfo.m_debugDraw->drawTransform(input.m_transformA, 10.0);
#endif //DEBUG_CONTACTS
      }
      else
      {
       input.m_transformA = body0Wrap->getWorldTransform();
       input.m_transformB.setBasis(btMatrix3x3(rotq.inverse()*perturbeRot*rotq)*body1Wrap->getWorldTransform().getBasis());
#ifdef DEBUG_CONTACTS
       dispatchInfo.m_debugDraw->drawTransform(input.m_transformB, 10.0);
#endif
      }

      btPerturbedContactResult perturbedResultOut(resultOut, input.m_transformA, input.m_transformB, unPerturbedTransform, perturbeA, dispatchInfo.m_debugDraw);
      gjkPairDetector.getClosestPoints(input, perturbedResultOut, dispatchInfo.m_debugDraw);
     }
    }
   }
  }



#ifdef USE_SEPDISTANCE_UTIL2
  if (dispatchInfo.m_useConvexConservativeDistanceUtil && (sepDist>SIMD_EPSILON))
  {
   m_sepDistance.initSeparatingDistance(gjkPairDetector.getCachedSeparatingAxis(), sepDist, body0->getWorldTransform(), body1->getWorldTransform());
  }
#endif //USE_SEPDISTANCE_UTIL2


 }

 if (m_ownManifold)
 {
  resultOut->refreshContactPoints();
 }

}



bool disableCcd = false;
btScalar	btConvexConvexAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 ///Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold

 ///Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold
 ///col0->m_worldTransform,
 btScalar resultFraction = btScalar(1.);


 btScalar squareMot0 = (col0->getInterpolationWorldTransform().getOrigin() - col0->getWorldTransform().getOrigin()).length2();
 btScalar squareMot1 = (col1->getInterpolationWorldTransform().getOrigin() - col1->getWorldTransform().getOrigin()).length2();

 if (squareMot0 < col0->getCcdSquareMotionThreshold() &&
  squareMot1 < col1->getCcdSquareMotionThreshold())
  return resultFraction;

 if (disableCcd)
  return btScalar(1.);


 //An adhoc way of testing the Continuous Collision Detection algorithms
 //One object is approximated as a sphere, to simplify things
 //Starting in penetration should report no time of impact
 //For proper CCD, better accuracy and handling of 'allowed' penetration should be added
 //also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)


 /// Convex0 against sphere for Convex1
 {
  btConvexShape* convex0 = static_cast<btConvexShape*>(col0->getCollisionShape());

  btSphereShape	sphere1(col1->getCcdSweptSphereRadius()); //todo: allow non-zero sphere sizes, for better approximation
  btConvexCast::CastResult result;
  btVoronoiSimplexSolver voronoiSimplex;
  //SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
  ///Simplification, one object is simplified as a sphere
  btGjkConvexCast ccd1(convex0, &sphere1, &voronoiSimplex);
  //ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
  if (ccd1.calcTimeOfImpact(col0->getWorldTransform(), col0->getInterpolationWorldTransform(),
   col1->getWorldTransform(), col1->getInterpolationWorldTransform(), result))
  {

   //store result.m_fraction in both bodies

   if (col0->getHitFraction()> result.m_fraction)
    col0->setHitFraction(result.m_fraction);

   if (col1->getHitFraction() > result.m_fraction)
    col1->setHitFraction(result.m_fraction);

   if (resultFraction > result.m_fraction)
    resultFraction = result.m_fraction;

  }




 }

 /// Sphere (for convex0) against Convex1
 {
  btConvexShape* convex1 = static_cast<btConvexShape*>(col1->getCollisionShape());

  btSphereShape	sphere0(col0->getCcdSweptSphereRadius()); //todo: allow non-zero sphere sizes, for better approximation
  btConvexCast::CastResult result;
  btVoronoiSimplexSolver voronoiSimplex;
  //SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
  ///Simplification, one object is simplified as a sphere
  btGjkConvexCast ccd1(&sphere0, convex1, &voronoiSimplex);
  //ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
  if (ccd1.calcTimeOfImpact(col0->getWorldTransform(), col0->getInterpolationWorldTransform(),
   col1->getWorldTransform(), col1->getInterpolationWorldTransform(), result))
  {

   //store result.m_fraction in both bodies

   if (col0->getHitFraction()	> result.m_fraction)
    col0->setHitFraction(result.m_fraction);

   if (col1->getHitFraction() > result.m_fraction)
    col1->setHitFraction(result.m_fraction);

   if (resultFraction > result.m_fraction)
    resultFraction = result.m_fraction;

  }
 }

 return resultFraction;

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btConvexPlaneCollisionAlgorithm.h"

#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//#include <stdio.h>

btConvexPlaneCollisionAlgorithm::btConvexPlaneCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap, bool isSwapped, int numPerturbationIterations, int minimumPointsPerturbationThreshold)
 : btCollisionAlgorithm(ci),
 m_ownManifold(false),
 m_manifoldPtr(mf),
 m_isSwapped(isSwapped),
 m_numPerturbationIterations(numPerturbationIterations),
 m_minimumPointsPerturbationThreshold(minimumPointsPerturbationThreshold)
{
 const btCollisionObjectWrapper* convexObjWrap = m_isSwapped ? col1Wrap : col0Wrap;
 const btCollisionObjectWrapper* planeObjWrap = m_isSwapped ? col0Wrap : col1Wrap;

 if (!m_manifoldPtr && m_dispatcher->needsCollision(convexObjWrap->getCollisionObject(), planeObjWrap->getCollisionObject()))
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(convexObjWrap->getCollisionObject(), planeObjWrap->getCollisionObject());
  m_ownManifold = true;
 }
}


btConvexPlaneCollisionAlgorithm::~btConvexPlaneCollisionAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void btConvexPlaneCollisionAlgorithm::collideSingleContact(const btQuaternion& perturbeRot, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 const btCollisionObjectWrapper* convexObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* planeObjWrap = m_isSwapped ? body0Wrap : body1Wrap;

 btConvexShape* convexShape = (btConvexShape*)convexObjWrap->getCollisionShape();
 btStaticPlaneShape* planeShape = (btStaticPlaneShape*)planeObjWrap->getCollisionShape();

 bool hasCollision = false;
 const btVector3& planeNormal = planeShape->getPlaneNormal();
 const btScalar& planeConstant = planeShape->getPlaneConstant();

 btTransform convexWorldTransform = convexObjWrap->getWorldTransform();
 btTransform convexInPlaneTrans;
 convexInPlaneTrans = planeObjWrap->getWorldTransform().inverse() * convexWorldTransform;
 //now perturbe the convex-world transform
 convexWorldTransform.getBasis() *= btMatrix3x3(perturbeRot);
 btTransform planeInConvex;
 planeInConvex = convexWorldTransform.inverse() * planeObjWrap->getWorldTransform();

 btVector3 vtx = convexShape->localGetSupportingVertex(planeInConvex.getBasis()*-planeNormal);

 btVector3 vtxInPlane = convexInPlaneTrans(vtx);
 btScalar distance = (planeNormal.dot(vtxInPlane) - planeConstant);

 btVector3 vtxInPlaneProjected = vtxInPlane - distance*planeNormal;
 btVector3 vtxInPlaneWorld = planeObjWrap->getWorldTransform() * vtxInPlaneProjected;

 hasCollision = distance < m_manifoldPtr->getContactBreakingThreshold();
 resultOut->setPersistentManifold(m_manifoldPtr);
 if (hasCollision)
 {
  /// report a contact. internally this will be kept persistent, and contact reduction is done
  btVector3 normalOnSurfaceB = planeObjWrap->getWorldTransform().getBasis() * planeNormal;
  btVector3 pOnB = vtxInPlaneWorld;
  resultOut->addContactPoint(normalOnSurfaceB, pOnB, distance);
 }
}


void btConvexPlaneCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)dispatchInfo;
 if (!m_manifoldPtr)
  return;

 const btCollisionObjectWrapper* convexObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* planeObjWrap = m_isSwapped ? body0Wrap : body1Wrap;

 btConvexShape* convexShape = (btConvexShape*)convexObjWrap->getCollisionShape();
 btStaticPlaneShape* planeShape = (btStaticPlaneShape*)planeObjWrap->getCollisionShape();

 bool hasCollision = false;
 const btVector3& planeNormal = planeShape->getPlaneNormal();
 const btScalar& planeConstant = planeShape->getPlaneConstant();
 btTransform planeInConvex;
 planeInConvex = convexObjWrap->getWorldTransform().inverse() * planeObjWrap->getWorldTransform();
 btTransform convexInPlaneTrans;
 convexInPlaneTrans = planeObjWrap->getWorldTransform().inverse() * convexObjWrap->getWorldTransform();

 btVector3 vtx = convexShape->localGetSupportingVertex(planeInConvex.getBasis()*-planeNormal);
 btVector3 vtxInPlane = convexInPlaneTrans(vtx);
 btScalar distance = (planeNormal.dot(vtxInPlane) - planeConstant);

 btVector3 vtxInPlaneProjected = vtxInPlane - distance*planeNormal;
 btVector3 vtxInPlaneWorld = planeObjWrap->getWorldTransform() * vtxInPlaneProjected;

 hasCollision = distance < m_manifoldPtr->getContactBreakingThreshold();
 resultOut->setPersistentManifold(m_manifoldPtr);
 if (hasCollision)
 {
  /// report a contact. internally this will be kept persistent, and contact reduction is done
  btVector3 normalOnSurfaceB = planeObjWrap->getWorldTransform().getBasis() * planeNormal;
  btVector3 pOnB = vtxInPlaneWorld;
  resultOut->addContactPoint(normalOnSurfaceB, pOnB, distance);
 }

 //the perturbation algorithm doesn't work well with implicit surfaces such as spheres, cylinder and cones:
 //they keep on rolling forever because of the additional off-center contact points
 //so only enable the feature for polyhedral shapes (btBoxShape, btConvexHullShape etc)
 if (convexShape->isPolyhedral() && resultOut->getPersistentManifold()->getNumContacts()<m_minimumPointsPerturbationThreshold)
 {
  btVector3 v0, v1;
  btPlaneSpace1(planeNormal, v0, v1);
  //now perform 'm_numPerturbationIterations' collision queries with the perturbated collision objects

  const btScalar angleLimit = 0.125f * SIMD_PI;
  btScalar perturbeAngle;
  btScalar radius = convexShape->getAngularMotionDisc();
  perturbeAngle = gContactBreakingThreshold / radius;
  if (perturbeAngle > angleLimit)
   perturbeAngle = angleLimit;

  btQuaternion perturbeRot(v0, perturbeAngle);
  for (int i = 0; i<m_numPerturbationIterations; i++)
  {
   btScalar iterationAngle = i*(SIMD_2_PI / btScalar(m_numPerturbationIterations));
   btQuaternion rotq(planeNormal, iterationAngle);
   collideSingleContact(rotq.inverse()*perturbeRot*rotq, body0Wrap, body1Wrap, dispatchInfo, resultOut);
  }
 }

 if (m_ownManifold)
 {
  if (m_manifoldPtr->getNumContacts())
  {
   resultOut->refreshContactPoints();
  }
 }
}

btScalar btConvexPlaneCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 (void)col0;
 (void)col1;

 //not yet
 return btScalar(1.);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h"

#include "BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btEmptyCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h"

#include "BulletCollision/CollisionDispatch/btConvexPlaneCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btBoxBoxCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btSphereSphereCollisionAlgorithm.h"
#ifdef USE_BUGGY_SPHERE_BOX_ALGORITHM
#include "BulletCollision/CollisionDispatch/btSphereBoxCollisionAlgorithm.h"
#endif //USE_BUGGY_SPHERE_BOX_ALGORITHM
#include "BulletCollision/CollisionDispatch/btSphereTriangleCollisionAlgorithm.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"



#include "LinearMath/btPoolAllocator.h"





btDefaultCollisionConfiguration::btDefaultCollisionConfiguration(const btDefaultCollisionConstructionInfo& constructionInfo)
//btDefaultCollisionConfiguration::btDefaultCollisionConfiguration(btStackAlloc*	stackAlloc,btPoolAllocator*	persistentManifoldPool,btPoolAllocator*	collisionAlgorithmPool)
{

 void* mem = NULL;
 if (constructionInfo.m_useEpaPenetrationAlgorithm)
 {
  mem = btAlignedAlloc(sizeof(btGjkEpaPenetrationDepthSolver), 16);
  m_pdSolver = new (mem)btGjkEpaPenetrationDepthSolver;
 }
 else
 {
  mem = btAlignedAlloc(sizeof(btMinkowskiPenetrationDepthSolver), 16);
  m_pdSolver = new (mem)btMinkowskiPenetrationDepthSolver;
 }

 //default CreationFunctions, filling the m_doubleDispatch table
 mem = btAlignedAlloc(sizeof(btConvexConvexAlgorithm::CreateFunc), 16);
 m_convexConvexCreateFunc = new(mem) btConvexConvexAlgorithm::CreateFunc(m_pdSolver);
 mem = btAlignedAlloc(sizeof(btConvexConcaveCollisionAlgorithm::CreateFunc), 16);
 m_convexConcaveCreateFunc = new (mem)btConvexConcaveCollisionAlgorithm::CreateFunc;
 mem = btAlignedAlloc(sizeof(btConvexConcaveCollisionAlgorithm::CreateFunc), 16);
 m_swappedConvexConcaveCreateFunc = new (mem)btConvexConcaveCollisionAlgorithm::SwappedCreateFunc;
 mem = btAlignedAlloc(sizeof(btCompoundCollisionAlgorithm::CreateFunc), 16);
 m_compoundCreateFunc = new (mem)btCompoundCollisionAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btCompoundCompoundCollisionAlgorithm::CreateFunc), 16);
 m_compoundCompoundCreateFunc = new (mem)btCompoundCompoundCollisionAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btCompoundCollisionAlgorithm::SwappedCreateFunc), 16);
 m_swappedCompoundCreateFunc = new (mem)btCompoundCollisionAlgorithm::SwappedCreateFunc;
 mem = btAlignedAlloc(sizeof(btEmptyAlgorithm::CreateFunc), 16);
 m_emptyCreateFunc = new(mem) btEmptyAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btSphereSphereCollisionAlgorithm::CreateFunc), 16);
 m_sphereSphereCF = new(mem) btSphereSphereCollisionAlgorithm::CreateFunc;
#ifdef USE_BUGGY_SPHERE_BOX_ALGORITHM
 mem = btAlignedAlloc(sizeof(btSphereBoxCollisionAlgorithm::CreateFunc), 16);
 m_sphereBoxCF = new(mem) btSphereBoxCollisionAlgorithm::CreateFunc;
 mem = btAlignedAlloc(sizeof(btSphereBoxCollisionAlgorithm::CreateFunc), 16);
 m_boxSphereCF = new (mem)btSphereBoxCollisionAlgorithm::CreateFunc;
 m_boxSphereCF->m_swapped = true;
#endif //USE_BUGGY_SPHERE_BOX_ALGORITHM

 mem = btAlignedAlloc(sizeof(btSphereTriangleCollisionAlgorithm::CreateFunc), 16);
 m_sphereTriangleCF = new (mem)btSphereTriangleCollisionAlgorithm::CreateFunc;
 mem = btAlignedAlloc(sizeof(btSphereTriangleCollisionAlgorithm::CreateFunc), 16);
 m_triangleSphereCF = new (mem)btSphereTriangleCollisionAlgorithm::CreateFunc;
 m_triangleSphereCF->m_swapped = true;

 mem = btAlignedAlloc(sizeof(btBoxBoxCollisionAlgorithm::CreateFunc), 16);
 m_boxBoxCF = new(mem)btBoxBoxCollisionAlgorithm::CreateFunc;

 //convex versus plane
 mem = btAlignedAlloc(sizeof(btConvexPlaneCollisionAlgorithm::CreateFunc), 16);
 m_convexPlaneCF = new (mem) btConvexPlaneCollisionAlgorithm::CreateFunc;
 mem = btAlignedAlloc(sizeof(btConvexPlaneCollisionAlgorithm::CreateFunc), 16);
 m_planeConvexCF = new (mem) btConvexPlaneCollisionAlgorithm::CreateFunc;
 m_planeConvexCF->m_swapped = true;

 ///calculate maximum element size, big enough to fit any collision algorithm in the memory pool
 int maxSize = sizeof(btConvexConvexAlgorithm);
 int maxSize2 = sizeof(btConvexConcaveCollisionAlgorithm);
 int maxSize3 = sizeof(btCompoundCollisionAlgorithm);
 int maxSize4 = sizeof(btCompoundCompoundCollisionAlgorithm);

 int	collisionAlgorithmMaxElementSize = btMax(maxSize, constructionInfo.m_customCollisionAlgorithmMaxElementSize);
 collisionAlgorithmMaxElementSize = btMax(collisionAlgorithmMaxElementSize, maxSize2);
 collisionAlgorithmMaxElementSize = btMax(collisionAlgorithmMaxElementSize, maxSize3);
 collisionAlgorithmMaxElementSize = btMax(collisionAlgorithmMaxElementSize, maxSize4);

 if (constructionInfo.m_persistentManifoldPool)
 {
  m_ownsPersistentManifoldPool = false;
  m_persistentManifoldPool = constructionInfo.m_persistentManifoldPool;
 }
 else
 {
  m_ownsPersistentManifoldPool = true;
  void* mem = btAlignedAlloc(sizeof(btPoolAllocator), 16);
  m_persistentManifoldPool = new (mem) btPoolAllocator(sizeof(btPersistentManifold), constructionInfo.m_defaultMaxPersistentManifoldPoolSize);
 }

 collisionAlgorithmMaxElementSize = (collisionAlgorithmMaxElementSize + 16) & 0xffffffffffff0;
 if (constructionInfo.m_collisionAlgorithmPool)
 {
  m_ownsCollisionAlgorithmPool = false;
  m_collisionAlgorithmPool = constructionInfo.m_collisionAlgorithmPool;
 }
 else
 {
  m_ownsCollisionAlgorithmPool = true;
  void* mem = btAlignedAlloc(sizeof(btPoolAllocator), 16);
  m_collisionAlgorithmPool = new(mem) btPoolAllocator(collisionAlgorithmMaxElementSize, constructionInfo.m_defaultMaxCollisionAlgorithmPoolSize);
 }


}

btDefaultCollisionConfiguration::~btDefaultCollisionConfiguration()
{
 if (m_ownsCollisionAlgorithmPool)
 {
  m_collisionAlgorithmPool->~btPoolAllocator();
  btAlignedFree(m_collisionAlgorithmPool);
 }
 if (m_ownsPersistentManifoldPool)
 {
  m_persistentManifoldPool->~btPoolAllocator();
  btAlignedFree(m_persistentManifoldPool);
 }

 m_convexConvexCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_convexConvexCreateFunc);

 m_convexConcaveCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_convexConcaveCreateFunc);
 m_swappedConvexConcaveCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_swappedConvexConcaveCreateFunc);

 m_compoundCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_compoundCreateFunc);

 m_compoundCompoundCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_compoundCompoundCreateFunc);

 m_swappedCompoundCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_swappedCompoundCreateFunc);

 m_emptyCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_emptyCreateFunc);

 m_sphereSphereCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_sphereSphereCF);

#ifdef USE_BUGGY_SPHERE_BOX_ALGORITHM
 m_sphereBoxCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_sphereBoxCF);
 m_boxSphereCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_boxSphereCF);
#endif //USE_BUGGY_SPHERE_BOX_ALGORITHM

 m_sphereTriangleCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_sphereTriangleCF);
 m_triangleSphereCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_triangleSphereCF);
 m_boxBoxCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_boxBoxCF);

 m_convexPlaneCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_convexPlaneCF);
 m_planeConvexCF->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_planeConvexCF);

 m_pdSolver->~btConvexPenetrationDepthSolver();

 btAlignedFree(m_pdSolver);


}

btCollisionAlgorithmCreateFunc* btDefaultCollisionConfiguration::getClosestPointsAlgorithmCreateFunc(int proxyType0, int proxyType1)
{


 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_sphereSphereCF;
 }
#ifdef USE_BUGGY_SPHERE_BOX_ALGORITHM
 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == BOX_SHAPE_PROXYTYPE))
 {
  return	m_sphereBoxCF;
 }

 if ((proxyType0 == BOX_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_boxSphereCF;
 }
#endif //USE_BUGGY_SPHERE_BOX_ALGORITHM


 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == TRIANGLE_SHAPE_PROXYTYPE))
 {
  return	m_sphereTriangleCF;
 }

 if ((proxyType0 == TRIANGLE_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_triangleSphereCF;
 }

 if (btBroadphaseProxy::isConvex(proxyType0) && (proxyType1 == STATIC_PLANE_PROXYTYPE))
 {
  return m_convexPlaneCF;
 }

 if (btBroadphaseProxy::isConvex(proxyType1) && (proxyType0 == STATIC_PLANE_PROXYTYPE))
 {
  return m_planeConvexCF;
 }



 if (btBroadphaseProxy::isConvex(proxyType0) && btBroadphaseProxy::isConvex(proxyType1))
 {
  return m_convexConvexCreateFunc;
 }

 if (btBroadphaseProxy::isConvex(proxyType0) && btBroadphaseProxy::isConcave(proxyType1))
 {
  return m_convexConcaveCreateFunc;
 }

 if (btBroadphaseProxy::isConvex(proxyType1) && btBroadphaseProxy::isConcave(proxyType0))
 {
  return m_swappedConvexConcaveCreateFunc;
 }


 if (btBroadphaseProxy::isCompound(proxyType0) && btBroadphaseProxy::isCompound(proxyType1))
 {
  return m_compoundCompoundCreateFunc;
 }

 if (btBroadphaseProxy::isCompound(proxyType0))
 {
  return m_compoundCreateFunc;
 }
 else
 {
  if (btBroadphaseProxy::isCompound(proxyType1))
  {
   return m_swappedCompoundCreateFunc;
  }
 }

 //failed to find an algorithm
 return m_emptyCreateFunc;

}

btCollisionAlgorithmCreateFunc* btDefaultCollisionConfiguration::getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1)
{



 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_sphereSphereCF;
 }
#ifdef USE_BUGGY_SPHERE_BOX_ALGORITHM
 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == BOX_SHAPE_PROXYTYPE))
 {
  return	m_sphereBoxCF;
 }

 if ((proxyType0 == BOX_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_boxSphereCF;
 }
#endif //USE_BUGGY_SPHERE_BOX_ALGORITHM


 if ((proxyType0 == SPHERE_SHAPE_PROXYTYPE) && (proxyType1 == TRIANGLE_SHAPE_PROXYTYPE))
 {
  return	m_sphereTriangleCF;
 }

 if ((proxyType0 == TRIANGLE_SHAPE_PROXYTYPE) && (proxyType1 == SPHERE_SHAPE_PROXYTYPE))
 {
  return	m_triangleSphereCF;
 }

 if ((proxyType0 == BOX_SHAPE_PROXYTYPE) && (proxyType1 == BOX_SHAPE_PROXYTYPE))
 {
  return m_boxBoxCF;
 }

 if (btBroadphaseProxy::isConvex(proxyType0) && (proxyType1 == STATIC_PLANE_PROXYTYPE))
 {
  return m_convexPlaneCF;
 }

 if (btBroadphaseProxy::isConvex(proxyType1) && (proxyType0 == STATIC_PLANE_PROXYTYPE))
 {
  return m_planeConvexCF;
 }



 if (btBroadphaseProxy::isConvex(proxyType0) && btBroadphaseProxy::isConvex(proxyType1))
 {
  return m_convexConvexCreateFunc;
 }

 if (btBroadphaseProxy::isConvex(proxyType0) && btBroadphaseProxy::isConcave(proxyType1))
 {
  return m_convexConcaveCreateFunc;
 }

 if (btBroadphaseProxy::isConvex(proxyType1) && btBroadphaseProxy::isConcave(proxyType0))
 {
  return m_swappedConvexConcaveCreateFunc;
 }


 if (btBroadphaseProxy::isCompound(proxyType0) && btBroadphaseProxy::isCompound(proxyType1))
 {
  return m_compoundCompoundCreateFunc;
 }

 if (btBroadphaseProxy::isCompound(proxyType0))
 {
  return m_compoundCreateFunc;
 }
 else
 {
  if (btBroadphaseProxy::isCompound(proxyType1))
  {
   return m_swappedCompoundCreateFunc;
  }
 }

 //failed to find an algorithm
 return m_emptyCreateFunc;
}

void btDefaultCollisionConfiguration::setConvexConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold)
{
 btConvexConvexAlgorithm::CreateFunc* convexConvex = (btConvexConvexAlgorithm::CreateFunc*) m_convexConvexCreateFunc;
 convexConvex->m_numPerturbationIterations = numPerturbationIterations;
 convexConvex->m_minimumPointsPerturbationThreshold = minimumPointsPerturbationThreshold;
}

void	btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold)
{
 btConvexPlaneCollisionAlgorithm::CreateFunc* cpCF = (btConvexPlaneCollisionAlgorithm::CreateFunc*)m_convexPlaneCF;
 cpCF->m_numPerturbationIterations = numPerturbationIterations;
 cpCF->m_minimumPointsPerturbationThreshold = minimumPointsPerturbationThreshold;

 btConvexPlaneCollisionAlgorithm::CreateFunc* pcCF = (btConvexPlaneCollisionAlgorithm::CreateFunc*)m_planeConvexCF;
 pcCF->m_numPerturbationIterations = numPerturbationIterations;
 pcCF->m_minimumPointsPerturbationThreshold = minimumPointsPerturbationThreshold;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btEmptyCollisionAlgorithm.h"



btEmptyAlgorithm::btEmptyAlgorithm(const btCollisionAlgorithmConstructionInfo& ci)
 : btCollisionAlgorithm(ci)
{
}

void btEmptyAlgorithm::processCollision(const btCollisionObjectWrapper*, const btCollisionObjectWrapper*, const btDispatcherInfo&, btManifoldResult*)
{
}

btScalar btEmptyAlgorithm::calculateTimeOfImpact(btCollisionObject*, btCollisionObject*, const btDispatcherInfo&, btManifoldResult*)
{
 return btScalar(1.);
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  http://bulletphysics.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btGhostObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btAabbUtil2.h"

btGhostObject::btGhostObject()
{
 m_internalType = CO_GHOST_OBJECT;
}

btGhostObject::~btGhostObject()
{
 ///btGhostObject should have been removed from the world, so no overlapping objects
 btAssert(!m_overlappingObjects.size());
}


void btGhostObject::addOverlappingObjectInternal(btBroadphaseProxy* otherProxy, btBroadphaseProxy* thisProxy)
{
 btCollisionObject* otherObject = (btCollisionObject*)otherProxy->m_clientObject;
 btAssert(otherObject);
 ///if this linearSearch becomes too slow (too many overlapping objects) we should add a more appropriate data structure
 int index = m_overlappingObjects.findLinearSearch(otherObject);
 if (index == m_overlappingObjects.size())
 {
  //not found
  m_overlappingObjects.push_back(otherObject);
 }
}

void btGhostObject::removeOverlappingObjectInternal(btBroadphaseProxy* otherProxy, btDispatcher* dispatcher, btBroadphaseProxy* thisProxy)
{
 btCollisionObject* otherObject = (btCollisionObject*)otherProxy->m_clientObject;
 btAssert(otherObject);
 int index = m_overlappingObjects.findLinearSearch(otherObject);
 if (index<m_overlappingObjects.size())
 {
  m_overlappingObjects[index] = m_overlappingObjects[m_overlappingObjects.size() - 1];
  m_overlappingObjects.pop_back();
 }
}


btPairCachingGhostObject::btPairCachingGhostObject()
{
 m_hashPairCache = new (btAlignedAlloc(sizeof(btHashedOverlappingPairCache), 16)) btHashedOverlappingPairCache();
}

btPairCachingGhostObject::~btPairCachingGhostObject()
{
 m_hashPairCache->~btHashedOverlappingPairCache();
 btAlignedFree(m_hashPairCache);
}

void btPairCachingGhostObject::addOverlappingObjectInternal(btBroadphaseProxy* otherProxy, btBroadphaseProxy* thisProxy)
{
 btBroadphaseProxy*actualThisProxy = thisProxy ? thisProxy : getBroadphaseHandle();
 btAssert(actualThisProxy);

 btCollisionObject* otherObject = (btCollisionObject*)otherProxy->m_clientObject;
 btAssert(otherObject);
 int index = m_overlappingObjects.findLinearSearch(otherObject);
 if (index == m_overlappingObjects.size())
 {
  m_overlappingObjects.push_back(otherObject);
  m_hashPairCache->addOverlappingPair(actualThisProxy, otherProxy);
 }
}

void btPairCachingGhostObject::removeOverlappingObjectInternal(btBroadphaseProxy* otherProxy, btDispatcher* dispatcher, btBroadphaseProxy* thisProxy1)
{
 btCollisionObject* otherObject = (btCollisionObject*)otherProxy->m_clientObject;
 btBroadphaseProxy* actualThisProxy = thisProxy1 ? thisProxy1 : getBroadphaseHandle();
 btAssert(actualThisProxy);

 btAssert(otherObject);
 int index = m_overlappingObjects.findLinearSearch(otherObject);
 if (index<m_overlappingObjects.size())
 {
  m_overlappingObjects[index] = m_overlappingObjects[m_overlappingObjects.size() - 1];
  m_overlappingObjects.pop_back();
  m_hashPairCache->removeOverlappingPair(actualThisProxy, otherProxy, dispatcher);
 }
}


void	btGhostObject::convexSweepTest(const btConvexShape* castShape, const btTransform& convexFromWorld, const btTransform& convexToWorld, btCollisionWorld::ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration) const
{
 btTransform	convexFromTrans, convexToTrans;
 convexFromTrans = convexFromWorld;
 convexToTrans = convexToWorld;
 btVector3 castShapeAabbMin, castShapeAabbMax;
 /* Compute AABB that encompasses angular movement */
 {
  btVector3 linVel, angVel;
  btTransformUtil::calculateVelocity(convexFromTrans, convexToTrans, 1.0, linVel, angVel);
  btTransform R;
  R.setIdentity();
  R.setRotation(convexFromTrans.getRotation());
  castShape->calculateTemporalAabb(R, linVel, angVel, 1.0, castShapeAabbMin, castShapeAabbMax);
 }

 /// go over all objects, and if the ray intersects their aabb + cast shape aabb,
 // do a ray-shape query using convexCaster (CCD)
 int i;
 for (i = 0; i<m_overlappingObjects.size(); i++)
 {
  btCollisionObject*	collisionObject = m_overlappingObjects[i];
  //only perform raycast if filterMask matches
  if (resultCallback.needsCollision(collisionObject->getBroadphaseHandle())) {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
   collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
   AabbExpand(collisionObjectAabbMin, collisionObjectAabbMax, castShapeAabbMin, castShapeAabbMax);
   btScalar hitLambda = btScalar(1.); //could use resultCallback.m_closestHitFraction, but needs testing
   btVector3 hitNormal;
   if (btRayAabb(convexFromWorld.getOrigin(), convexToWorld.getOrigin(), collisionObjectAabbMin, collisionObjectAabbMax, hitLambda, hitNormal))
   {
    btCollisionWorld::objectQuerySingle(castShape, convexFromTrans, convexToTrans,
     collisionObject,
     collisionObject->getCollisionShape(),
     collisionObject->getWorldTransform(),
     resultCallback,
     allowedCcdPenetration);
   }
  }
 }

}

void	btGhostObject::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, btCollisionWorld::RayResultCallback& resultCallback) const
{
 btTransform rayFromTrans;
 rayFromTrans.setIdentity();
 rayFromTrans.setOrigin(rayFromWorld);
 btTransform  rayToTrans;
 rayToTrans.setIdentity();
 rayToTrans.setOrigin(rayToWorld);


 int i;
 for (i = 0; i<m_overlappingObjects.size(); i++)
 {
  btCollisionObject*	collisionObject = m_overlappingObjects[i];
  //only perform raycast if filterMask matches
  if (resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
  {
   btCollisionWorld::rayTestSingle(rayFromTrans, rayToTrans,
    collisionObject,
    collisionObject->getCollisionShape(),
    collisionObject->getWorldTransform(),
    resultCallback);
  }
 }
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletCollision/CollisionDispatch/btHashedSimplePairCache.h"


#include <stdio.h>

int	gOverlappingSimplePairs = 0;
int gRemoveSimplePairs = 0;
int gAddedSimplePairs = 0;
int gFindSimplePairs = 0;




btHashedSimplePairCache::btHashedSimplePairCache() {
 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
 growTables();
}




btHashedSimplePairCache::~btHashedSimplePairCache()
{
}






void btHashedSimplePairCache::removeAllPairs()
{
 m_overlappingPairArray.clear();
 m_hashTable.clear();
 m_next.clear();

 int initialAllocatedSize = 2;
 m_overlappingPairArray.reserve(initialAllocatedSize);
 growTables();
}



btSimplePair* btHashedSimplePairCache::findPair(int indexA, int indexB)
{
 gFindSimplePairs++;


 /*if (indexA > indexB)
 btSwap(indexA, indexB);*/

 int hash = static_cast<int>(getHash(static_cast<unsigned int>(indexA), static_cast<unsigned int>(indexB)) & (m_overlappingPairArray.capacity() - 1));

 if (hash >= m_hashTable.size())
 {
  return NULL;
 }

 int index = m_hashTable[hash];
 while (index != BT_SIMPLE_NULL_PAIR && equalsPair(m_overlappingPairArray[index], indexA, indexB) == false)
 {
  index = m_next[index];
 }

 if (index == BT_SIMPLE_NULL_PAIR)
 {
  return NULL;
 }

 btAssert(index < m_overlappingPairArray.size());

 return &m_overlappingPairArray[index];
}

//#include <stdio.h>

void	btHashedSimplePairCache::growTables()
{

 int newCapacity = m_overlappingPairArray.capacity();

 if (m_hashTable.size() < newCapacity)
 {
  //grow hashtable and next table
  int curHashtableSize = m_hashTable.size();

  m_hashTable.resize(newCapacity);
  m_next.resize(newCapacity);


  int i;

  for (i = 0; i < newCapacity; ++i)
  {
   m_hashTable[i] = BT_SIMPLE_NULL_PAIR;
  }
  for (i = 0; i < newCapacity; ++i)
  {
   m_next[i] = BT_SIMPLE_NULL_PAIR;
  }

  for (i = 0; i<curHashtableSize; i++)
  {

   const btSimplePair& pair = m_overlappingPairArray[i];
   int indexA = pair.m_indexA;
   int indexB = pair.m_indexB;

   int	hashValue = static_cast<int>(getHash(static_cast<unsigned int>(indexA), static_cast<unsigned int>(indexB)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask
   m_next[i] = m_hashTable[hashValue];
   m_hashTable[hashValue] = i;
  }


 }
}

btSimplePair* btHashedSimplePairCache::internalAddPair(int indexA, int indexB)
{

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(indexA), static_cast<unsigned int>(indexB)) & (m_overlappingPairArray.capacity() - 1));	// New hash value with new mask


 btSimplePair* pair = internalFindPair(indexA, indexB, hash);
 if (pair != NULL)
 {
  return pair;
 }

 int count = m_overlappingPairArray.size();
 int oldCapacity = m_overlappingPairArray.capacity();
 void* mem = &m_overlappingPairArray.expandNonInitializing();

 int newCapacity = m_overlappingPairArray.capacity();

 if (oldCapacity < newCapacity)
 {
  growTables();
  //hash with new capacity
  hash = static_cast<int>(getHash(static_cast<unsigned int>(indexA), static_cast<unsigned int>(indexB)) & (m_overlappingPairArray.capacity() - 1));
 }

 pair = new (mem) btSimplePair(indexA, indexB);

 pair->m_userPointer = 0;

 m_next[count] = m_hashTable[hash];
 m_hashTable[hash] = count;

 return pair;
}



void* btHashedSimplePairCache::removeOverlappingPair(int indexA, int indexB)
{
 gRemoveSimplePairs++;


 /*if (indexA > indexB)
 btSwap(indexA, indexB);*/

 int	hash = static_cast<int>(getHash(static_cast<unsigned int>(indexA), static_cast<unsigned int>(indexB)) & (m_overlappingPairArray.capacity() - 1));

 btSimplePair* pair = internalFindPair(indexA, indexB, hash);
 if (pair == NULL)
 {
  return 0;
 }


 void* userData = pair->m_userPointer;


 int pairIndex = int(pair - &m_overlappingPairArray[0]);
 btAssert(pairIndex < m_overlappingPairArray.size());

 // Remove the pair from the hash table.
 int index = m_hashTable[hash];
 btAssert(index != BT_SIMPLE_NULL_PAIR);

 int previous = BT_SIMPLE_NULL_PAIR;
 while (index != pairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != BT_SIMPLE_NULL_PAIR)
 {
  btAssert(m_next[previous] == pairIndex);
  m_next[previous] = m_next[pairIndex];
 }
 else
 {
  m_hashTable[hash] = m_next[pairIndex];
 }

 // We now move the last pair into spot of the
 // pair being removed. We need to fix the hash
 // table indices to support the move.

 int lastPairIndex = m_overlappingPairArray.size() - 1;

 // If the removed pair is the last pair, we are done.
 if (lastPairIndex == pairIndex)
 {
  m_overlappingPairArray.pop_back();
  return userData;
 }

 // Remove the last pair from the hash table.
 const btSimplePair* last = &m_overlappingPairArray[lastPairIndex];
 /* missing swap here too, Nat. */
 int lastHash = static_cast<int>(getHash(static_cast<unsigned int>(last->m_indexA), static_cast<unsigned int>(last->m_indexB)) & (m_overlappingPairArray.capacity() - 1));

 index = m_hashTable[lastHash];
 btAssert(index != BT_SIMPLE_NULL_PAIR);

 previous = BT_SIMPLE_NULL_PAIR;
 while (index != lastPairIndex)
 {
  previous = index;
  index = m_next[index];
 }

 if (previous != BT_SIMPLE_NULL_PAIR)
 {
  btAssert(m_next[previous] == lastPairIndex);
  m_next[previous] = m_next[lastPairIndex];
 }
 else
 {
  m_hashTable[lastHash] = m_next[lastPairIndex];
 }

 // Copy the last pair into the remove pair's spot.
 m_overlappingPairArray[pairIndex] = m_overlappingPairArray[lastPairIndex];

 // Insert the last pair into the hash table
 m_next[pairIndex] = m_hashTable[lastHash];
 m_hashTable[lastHash] = pairIndex;

 m_overlappingPairArray.pop_back();

 return userData;
}
//#include <stdio.h>










#include "BulletCollision/CollisionDispatch/btInternalEdgeUtility.h"

#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//#define DEBUG_INTERNAL_EDGE

#ifdef DEBUG_INTERNAL_EDGE
#include <stdio.h>
#endif //DEBUG_INTERNAL_EDGE


#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
static btIDebugDraw* gDebugDrawer = 0;

void	btSetDebugDrawer(btIDebugDraw* debugDrawer)
{
 gDebugDrawer = debugDrawer;
}

static void    btDebugDrawLine(const btVector3& from, const btVector3& to, const btVector3& color)
{
 if (gDebugDrawer)
  gDebugDrawer->drawLine(from, to, color);
}
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW


static int	btGetHash(int partId, int triangleIndex)
{
 int hash = (partId << (31 - MAX_NUM_PARTS_IN_BITS)) | triangleIndex;
 return hash;
}



static btScalar btGetAngle(const btVector3& edgeA, const btVector3& normalA, const btVector3& normalB)
{
 const btVector3 refAxis0 = edgeA;
 const btVector3 refAxis1 = normalA;
 const btVector3 swingAxis = normalB;
 btScalar angle = btAtan2(swingAxis.dot(refAxis0), swingAxis.dot(refAxis1));
 return  angle;
}


struct btConnectivityProcessor : public btTriangleCallback
{
 int				m_partIdA;
 int				m_triangleIndexA;
 btVector3*		m_triangleVerticesA;
 btTriangleInfoMap*	m_triangleInfoMap;


 virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
 {
  //skip self-collisions
  if ((m_partIdA == partId) && (m_triangleIndexA == triangleIndex))
   return;

  //skip duplicates (disabled for now)
  //if ((m_partIdA <= partId) && (m_triangleIndexA <= triangleIndex))
  //	return;

  //search for shared vertices and edges
  int numshared = 0;
  int sharedVertsA[3] = { -1,-1,-1 };
  int sharedVertsB[3] = { -1,-1,-1 };

  ///skip degenerate triangles
  btScalar crossBSqr = ((triangle[1] - triangle[0]).cross(triangle[2] - triangle[0])).length2();
  if (crossBSqr < m_triangleInfoMap->m_equalVertexThreshold)
   return;


  btScalar crossASqr = ((m_triangleVerticesA[1] - m_triangleVerticesA[0]).cross(m_triangleVerticesA[2] - m_triangleVerticesA[0])).length2();
  ///skip degenerate triangles
  if (crossASqr< m_triangleInfoMap->m_equalVertexThreshold)
   return;

#if 0
  printf("triangle A[0]	=	(%f,%f,%f)\ntriangle A[1]	=	(%f,%f,%f)\ntriangle A[2]	=	(%f,%f,%f)\n",
   m_triangleVerticesA[0].getX(), m_triangleVerticesA[0].getY(), m_triangleVerticesA[0].getZ(),
   m_triangleVerticesA[1].getX(), m_triangleVerticesA[1].getY(), m_triangleVerticesA[1].getZ(),
   m_triangleVerticesA[2].getX(), m_triangleVerticesA[2].getY(), m_triangleVerticesA[2].getZ());

  printf("partId=%d, triangleIndex=%d\n", partId, triangleIndex);
  printf("triangle B[0]	=	(%f,%f,%f)\ntriangle B[1]	=	(%f,%f,%f)\ntriangle B[2]	=	(%f,%f,%f)\n",
   triangle[0].getX(), triangle[0].getY(), triangle[0].getZ(),
   triangle[1].getX(), triangle[1].getY(), triangle[1].getZ(),
   triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
#endif

  for (int i = 0; i<3; i++)
  {
   for (int j = 0; j<3; j++)
   {
    if ((m_triangleVerticesA[i] - triangle[j]).length2() < m_triangleInfoMap->m_equalVertexThreshold)
    {
     sharedVertsA[numshared] = i;
     sharedVertsB[numshared] = j;
     numshared++;
     ///degenerate case
     if (numshared >= 3)
      return;
    }
   }
   ///degenerate case
   if (numshared >= 3)
    return;
  }
  switch (numshared)
  {
  case 0:
  {
   break;
  }
  case 1:
  {
   //shared vertex
   break;
  }
  case 2:
  {
   //shared edge
   //we need to make sure the edge is in the order V2V0 and not V0V2 so that the signs are correct
   if (sharedVertsA[0] == 0 && sharedVertsA[1] == 2)
   {
    sharedVertsA[0] = 2;
    sharedVertsA[1] = 0;
    int tmp = sharedVertsB[1];
    sharedVertsB[1] = sharedVertsB[0];
    sharedVertsB[0] = tmp;
   }

   int hash = btGetHash(m_partIdA, m_triangleIndexA);

   btTriangleInfo* info = m_triangleInfoMap->find(hash);
   if (!info)
   {
    btTriangleInfo tmp;
    m_triangleInfoMap->insert(hash, tmp);
    info = m_triangleInfoMap->find(hash);
   }

   int sumvertsA = sharedVertsA[0] + sharedVertsA[1];
   int otherIndexA = 3 - sumvertsA;


   btVector3 edge(m_triangleVerticesA[sharedVertsA[1]] - m_triangleVerticesA[sharedVertsA[0]]);

   btTriangleShape tA(m_triangleVerticesA[0], m_triangleVerticesA[1], m_triangleVerticesA[2]);
   int otherIndexB = 3 - (sharedVertsB[0] + sharedVertsB[1]);

   btTriangleShape tB(triangle[sharedVertsB[1]], triangle[sharedVertsB[0]], triangle[otherIndexB]);
   //btTriangleShape tB(triangle[0],triangle[1],triangle[2]);

   btVector3 normalA;
   btVector3 normalB;
   tA.calcNormal(normalA);
   tB.calcNormal(normalB);
   edge.normalize();
   btVector3 edgeCrossA = edge.cross(normalA).normalize();

   {
    btVector3 tmp = m_triangleVerticesA[otherIndexA] - m_triangleVerticesA[sharedVertsA[0]];
    if (edgeCrossA.dot(tmp) < 0)
    {
     edgeCrossA *= -1;
    }
   }

   btVector3 edgeCrossB = edge.cross(normalB).normalize();

   {
    btVector3 tmp = triangle[otherIndexB] - triangle[sharedVertsB[0]];
    if (edgeCrossB.dot(tmp) < 0)
    {
     edgeCrossB *= -1;
    }
   }

   btScalar	angle2 = 0;
   btScalar	ang4 = 0.f;


   btVector3 calculatedEdge = edgeCrossA.cross(edgeCrossB);
   btScalar len2 = calculatedEdge.length2();

   btScalar correctedAngle(0);
   //btVector3 calculatedNormalB = normalA;
   bool isConvex = false;

   if (len2<m_triangleInfoMap->m_planarEpsilon)
   {
    angle2 = 0.f;
    ang4 = 0.f;
   }
   else
   {

    calculatedEdge.normalize();
    btVector3 calculatedNormalA = calculatedEdge.cross(edgeCrossA);
    calculatedNormalA.normalize();
    angle2 = btGetAngle(calculatedNormalA, edgeCrossA, edgeCrossB);
    ang4 = SIMD_PI - angle2;
    btScalar dotA = normalA.dot(edgeCrossB);
    ///@todo: check if we need some epsilon, due to floating point imprecision
    isConvex = (dotA<0.);

    correctedAngle = isConvex ? ang4 : -ang4;
   }





   //alternatively use 
   //btVector3 calculatedNormalB2 = quatRotate(orn,normalA);


   switch (sumvertsA)
   {
   case 1:
   {
    btVector3 edge = m_triangleVerticesA[0] - m_triangleVerticesA[1];
    btQuaternion orn(edge, -correctedAngle);
    btVector3 computedNormalB = quatRotate(orn, normalA);
    btScalar bla = computedNormalB.dot(normalB);
    if (bla<0)
    {
     computedNormalB *= -1;
     info->m_flags |= TRI_INFO_V0V1_SWAP_NORMALB;
    }
#ifdef DEBUG_INTERNAL_EDGE
    if ((computedNormalB - normalB).length()>0.0001)
    {
     printf("warning: normals not identical\n");
    }
#endif//DEBUG_INTERNAL_EDGE

    info->m_edgeV0V1Angle = -correctedAngle;

    if (isConvex)
     info->m_flags |= TRI_INFO_V0V1_CONVEX;
    break;
   }
   case 2:
   {
    btVector3 edge = m_triangleVerticesA[2] - m_triangleVerticesA[0];
    btQuaternion orn(edge, -correctedAngle);
    btVector3 computedNormalB = quatRotate(orn, normalA);
    if (computedNormalB.dot(normalB)<0)
    {
     computedNormalB *= -1;
     info->m_flags |= TRI_INFO_V2V0_SWAP_NORMALB;
    }

#ifdef DEBUG_INTERNAL_EDGE
    if ((computedNormalB - normalB).length()>0.0001)
    {
     printf("warning: normals not identical\n");
    }
#endif //DEBUG_INTERNAL_EDGE
    info->m_edgeV2V0Angle = -correctedAngle;
    if (isConvex)
     info->m_flags |= TRI_INFO_V2V0_CONVEX;
    break;
   }
   case 3:
   {
    btVector3 edge = m_triangleVerticesA[1] - m_triangleVerticesA[2];
    btQuaternion orn(edge, -correctedAngle);
    btVector3 computedNormalB = quatRotate(orn, normalA);
    if (computedNormalB.dot(normalB)<0)
    {
     info->m_flags |= TRI_INFO_V1V2_SWAP_NORMALB;
     computedNormalB *= -1;
    }
#ifdef DEBUG_INTERNAL_EDGE
    if ((computedNormalB - normalB).length()>0.0001)
    {
     printf("warning: normals not identical\n");
    }
#endif //DEBUG_INTERNAL_EDGE
    info->m_edgeV1V2Angle = -correctedAngle;

    if (isConvex)
     info->m_flags |= TRI_INFO_V1V2_CONVEX;
    break;
   }
   }

   break;
  }
  default:
  {
   //				printf("warning: duplicate triangle\n");
  }

  }
 }
};
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

void btGenerateInternalEdgeInfo(btBvhTriangleMeshShape*trimeshShape, btTriangleInfoMap* triangleInfoMap)
{
 //the user pointer shouldn't already be used for other purposes, we intend to store connectivity info there!
 if (trimeshShape->getTriangleInfoMap())
  return;

 trimeshShape->setTriangleInfoMap(triangleInfoMap);

 btStridingMeshInterface* meshInterface = trimeshShape->getMeshInterface();
 const btVector3& meshScaling = meshInterface->getScaling();

 for (int partId = 0; partId< meshInterface->getNumSubParts(); partId++)
 {
  const unsigned char *vertexbase = 0;
  int numverts = 0;
  PHY_ScalarType type = PHY_INTEGER;
  int stride = 0;
  const unsigned char *indexbase = 0;
  int indexstride = 0;
  int numfaces = 0;
  PHY_ScalarType indicestype = PHY_INTEGER;
  //PHY_ScalarType indexType=0;

  btVector3 triangleVerts[3];
  meshInterface->getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numfaces, indicestype, partId);
  btVector3 aabbMin, aabbMax;

  for (int triangleIndex = 0; triangleIndex < numfaces; triangleIndex++)
  {
   unsigned int* gfxbase = (unsigned int*)(indexbase + triangleIndex*indexstride);

   for (int j = 2; j >= 0; j--)
   {

    int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : gfxbase[j];
    if (type == PHY_FLOAT)
    {
     float* graphicsbase = (float*)(vertexbase + graphicsindex*stride);
     triangleVerts[j] = btVector3(
      graphicsbase[0] * meshScaling.getX(),
      graphicsbase[1] * meshScaling.getY(),
      graphicsbase[2] * meshScaling.getZ());
    }
    else
    {
     double* graphicsbase = (double*)(vertexbase + graphicsindex*stride);
     triangleVerts[j] = btVector3(btScalar(graphicsbase[0] * meshScaling.getX()), btScalar(graphicsbase[1] * meshScaling.getY()), btScalar(graphicsbase[2] * meshScaling.getZ()));
    }
   }
   aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
   aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
   aabbMin.setMin(triangleVerts[0]);
   aabbMax.setMax(triangleVerts[0]);
   aabbMin.setMin(triangleVerts[1]);
   aabbMax.setMax(triangleVerts[1]);
   aabbMin.setMin(triangleVerts[2]);
   aabbMax.setMax(triangleVerts[2]);

   btConnectivityProcessor connectivityProcessor;
   connectivityProcessor.m_partIdA = partId;
   connectivityProcessor.m_triangleIndexA = triangleIndex;
   connectivityProcessor.m_triangleVerticesA = &triangleVerts[0];
   connectivityProcessor.m_triangleInfoMap = triangleInfoMap;

   trimeshShape->processAllTriangles(&connectivityProcessor, aabbMin, aabbMax);
  }

 }

}




// Given a point and a line segment (defined by two points), compute the closest point
// in the line.  Cap the point at the endpoints of the line segment.
void btNearestPointInLineSegment(const btVector3 &point, const btVector3& line0, const btVector3& line1, btVector3& nearestPoint)
{
 btVector3 lineDelta = line1 - line0;

 // Handle degenerate lines
 if (lineDelta.fuzzyZero())
 {
  nearestPoint = line0;
 }
 else
 {
  btScalar delta = (point - line0).dot(lineDelta) / (lineDelta).dot(lineDelta);

  // Clamp the point to conform to the segment's endpoints
  if (delta < 0)
   delta = 0;
  else if (delta > 1)
   delta = 1;

  nearestPoint = line0 + lineDelta*delta;
 }
}




bool	btClampNormal(const btVector3& edge, const btVector3& tri_normal_org, const btVector3& localContactNormalOnB, btScalar correctedEdgeAngle, btVector3 & clampedLocalNormal)
{
 btVector3 tri_normal = tri_normal_org;
 //we only have a local triangle normal, not a local contact normal -> only normal in world space...
 //either compute the current angle all in local space, or all in world space

 btVector3 edgeCross = edge.cross(tri_normal).normalize();
 btScalar curAngle = btGetAngle(edgeCross, tri_normal, localContactNormalOnB);

 if (correctedEdgeAngle<0)
 {
  if (curAngle < correctedEdgeAngle)
  {
   btScalar diffAngle = correctedEdgeAngle - curAngle;
   btQuaternion rotation(edge, diffAngle);
   clampedLocalNormal = btMatrix3x3(rotation)*localContactNormalOnB;
   return true;
  }
 }

 if (correctedEdgeAngle >= 0)
 {
  if (curAngle > correctedEdgeAngle)
  {
   btScalar diffAngle = correctedEdgeAngle - curAngle;
   btQuaternion rotation(edge, diffAngle);
   clampedLocalNormal = btMatrix3x3(rotation)*localContactNormalOnB;
   return true;
  }
 }
 return false;
}



/// Changes a btManifoldPoint collision normal to the normal from the mesh.
void btAdjustInternalEdgeContacts(btManifoldPoint& cp, const btCollisionObjectWrapper* colObj0Wrap, const btCollisionObjectWrapper* colObj1Wrap, int partId0, int index0, int normalAdjustFlags)
{
 //btAssert(colObj0->getCollisionShape()->getShapeType() == TRIANGLE_SHAPE_PROXYTYPE);
 if (colObj0Wrap->getCollisionShape()->getShapeType() != TRIANGLE_SHAPE_PROXYTYPE)
  return;

 btBvhTriangleMeshShape* trimesh = 0;

 if (colObj0Wrap->getCollisionObject()->getCollisionShape()->getShapeType() == SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE)
  trimesh = ((btScaledBvhTriangleMeshShape*)colObj0Wrap->getCollisionObject()->getCollisionShape())->getChildShape();
 else
  trimesh = (btBvhTriangleMeshShape*)colObj0Wrap->getCollisionObject()->getCollisionShape();

 btTriangleInfoMap* triangleInfoMapPtr = (btTriangleInfoMap*)trimesh->getTriangleInfoMap();
 if (!triangleInfoMapPtr)
  return;

 int hash = btGetHash(partId0, index0);


 btTriangleInfo* info = triangleInfoMapPtr->find(hash);
 if (!info)
  return;

 btScalar frontFacing = (normalAdjustFlags & BT_TRIANGLE_CONVEX_BACKFACE_MODE) == 0 ? 1.f : -1.f;

 const btTriangleShape* tri_shape = static_cast<const btTriangleShape*>(colObj0Wrap->getCollisionShape());
 btVector3 v0, v1, v2;
 tri_shape->getVertex(0, v0);
 tri_shape->getVertex(1, v1);
 tri_shape->getVertex(2, v2);

 //btVector3 center = (v0+v1+v2)*btScalar(1./3.);

 btVector3 red(1, 0, 0), green(0, 1, 0), blue(0, 0, 1), white(1, 1, 1), black(0, 0, 0);
 btVector3 tri_normal;
 tri_shape->calcNormal(tri_normal);

 //btScalar dot = tri_normal.dot(cp.m_normalWorldOnB);
 btVector3 nearest;
 btNearestPointInLineSegment(cp.m_localPointB, v0, v1, nearest);

 btVector3 contact = cp.m_localPointB;
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 const btTransform& tr = colObj0->getWorldTransform();
 btDebugDrawLine(tr*nearest, tr*cp.m_localPointB, red);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW



 bool isNearEdge = false;

 int numConcaveEdgeHits = 0;
 int numConvexEdgeHits = 0;

 btVector3 localContactNormalOnB = colObj0Wrap->getWorldTransform().getBasis().transpose() * cp.m_normalWorldOnB;
 localContactNormalOnB.normalize();//is this necessary?

                                   // Get closest edge
 int      bestedge = -1;
 btScalar    disttobestedge = BT_LARGE_FLOAT;
 //
 // Edge 0 -> 1
 if (btFabs(info->m_edgeV0V1Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {
  btVector3 nearest;
  btNearestPointInLineSegment(cp.m_localPointB, v0, v1, nearest);
  btScalar     len = (contact - nearest).length();
  //
  if (len < disttobestedge)
  {
   bestedge = 0;
   disttobestedge = len;
  }
 }
 // Edge 1 -> 2
 if (btFabs(info->m_edgeV1V2Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {
  btVector3 nearest;
  btNearestPointInLineSegment(cp.m_localPointB, v1, v2, nearest);
  btScalar     len = (contact - nearest).length();
  //
  if (len < disttobestedge)
  {
   bestedge = 1;
   disttobestedge = len;
  }
 }
 // Edge 2 -> 0
 if (btFabs(info->m_edgeV2V0Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {
  btVector3 nearest;
  btNearestPointInLineSegment(cp.m_localPointB, v2, v0, nearest);
  btScalar     len = (contact - nearest).length();
  //
  if (len < disttobestedge)
  {
   bestedge = 2;
   disttobestedge = len;
  }
 }

#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 btVector3 upfix = tri_normal * btVector3(0.1f, 0.1f, 0.1f);
 btDebugDrawLine(tr * v0 + upfix, tr * v1 + upfix, red);
#endif   
 if (btFabs(info->m_edgeV0V1Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
  btDebugDrawLine(tr*contact, tr*(contact + cp.m_normalWorldOnB * 10), black);
#endif
  btScalar len = (contact - nearest).length();
  if (len<triangleInfoMapPtr->m_edgeDistanceThreshold)
   if (bestedge == 0)
   {
    btVector3 edge(v0 - v1);
    isNearEdge = true;

    if (info->m_edgeV0V1Angle == btScalar(0))
    {
     numConcaveEdgeHits++;
    }
    else
    {

     bool isEdgeConvex = (info->m_flags & TRI_INFO_V0V1_CONVEX);
     btScalar swapFactor = isEdgeConvex ? btScalar(1) : btScalar(-1);
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
     btDebugDrawLine(tr*nearest, tr*(nearest + swapFactor*tri_normal * 10), white);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

     btVector3 nA = swapFactor * tri_normal;

     btQuaternion orn(edge, info->m_edgeV0V1Angle);
     btVector3 computedNormalB = quatRotate(orn, tri_normal);
     if (info->m_flags & TRI_INFO_V0V1_SWAP_NORMALB)
      computedNormalB *= -1;
     btVector3 nB = swapFactor*computedNormalB;

     btScalar	NdotA = localContactNormalOnB.dot(nA);
     btScalar	NdotB = localContactNormalOnB.dot(nB);
     bool backFacingNormal = (NdotA< triangleInfoMapPtr->m_convexEpsilon) && (NdotB<triangleInfoMapPtr->m_convexEpsilon);

#ifdef DEBUG_INTERNAL_EDGE
     {

      btDebugDrawLine(cp.getPositionWorldOnB(), cp.getPositionWorldOnB() + tr.getBasis()*(nB * 20), red);
     }
#endif //DEBUG_INTERNAL_EDGE


     if (backFacingNormal)
     {
      numConcaveEdgeHits++;
     }
     else
     {
      numConvexEdgeHits++;
      btVector3 clampedLocalNormal;
      bool isClamped = btClampNormal(edge, swapFactor*tri_normal, localContactNormalOnB, info->m_edgeV0V1Angle, clampedLocalNormal);
      if (isClamped)
      {
       if (((normalAdjustFlags & BT_TRIANGLE_CONVEX_DOUBLE_SIDED) != 0) || (clampedLocalNormal.dot(frontFacing*tri_normal)>0))
       {
        btVector3 newNormal = colObj0Wrap->getWorldTransform().getBasis() * clampedLocalNormal;
        //					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
        cp.m_normalWorldOnB = newNormal;
        // Reproject collision point along normal. (what about cp.m_distance1?)
        cp.m_positionWorldOnB = cp.m_positionWorldOnA - cp.m_normalWorldOnB * cp.m_distance1;
        cp.m_localPointB = colObj0Wrap->getWorldTransform().invXform(cp.m_positionWorldOnB);

       }
      }
     }
    }
   }
 }

 btNearestPointInLineSegment(contact, v1, v2, nearest);
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 btDebugDrawLine(tr*nearest, tr*cp.m_localPointB, green);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 btDebugDrawLine(tr * v1 + upfix, tr * v2 + upfix, green);
#endif   

 if (btFabs(info->m_edgeV1V2Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
  btDebugDrawLine(tr*contact, tr*(contact + cp.m_normalWorldOnB * 10), black);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW



  btScalar len = (contact - nearest).length();
  if (len<triangleInfoMapPtr->m_edgeDistanceThreshold)
   if (bestedge == 1)
   {
    isNearEdge = true;
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
    btDebugDrawLine(tr*nearest, tr*(nearest + tri_normal * 10), white);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

    btVector3 edge(v1 - v2);

    isNearEdge = true;

    if (info->m_edgeV1V2Angle == btScalar(0))
    {
     numConcaveEdgeHits++;
    }
    else
    {
     bool isEdgeConvex = (info->m_flags & TRI_INFO_V1V2_CONVEX) != 0;
     btScalar swapFactor = isEdgeConvex ? btScalar(1) : btScalar(-1);
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
     btDebugDrawLine(tr*nearest, tr*(nearest + swapFactor*tri_normal * 10), white);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

     btVector3 nA = swapFactor * tri_normal;

     btQuaternion orn(edge, info->m_edgeV1V2Angle);
     btVector3 computedNormalB = quatRotate(orn, tri_normal);
     if (info->m_flags & TRI_INFO_V1V2_SWAP_NORMALB)
      computedNormalB *= -1;
     btVector3 nB = swapFactor*computedNormalB;

#ifdef DEBUG_INTERNAL_EDGE
     {
      btDebugDrawLine(cp.getPositionWorldOnB(), cp.getPositionWorldOnB() + tr.getBasis()*(nB * 20), red);
     }
#endif //DEBUG_INTERNAL_EDGE


     btScalar	NdotA = localContactNormalOnB.dot(nA);
     btScalar	NdotB = localContactNormalOnB.dot(nB);
     bool backFacingNormal = (NdotA< triangleInfoMapPtr->m_convexEpsilon) && (NdotB<triangleInfoMapPtr->m_convexEpsilon);

     if (backFacingNormal)
     {
      numConcaveEdgeHits++;
     }
     else
     {
      numConvexEdgeHits++;
      btVector3 localContactNormalOnB = colObj0Wrap->getWorldTransform().getBasis().transpose() * cp.m_normalWorldOnB;
      btVector3 clampedLocalNormal;
      bool isClamped = btClampNormal(edge, swapFactor*tri_normal, localContactNormalOnB, info->m_edgeV1V2Angle, clampedLocalNormal);
      if (isClamped)
      {
       if (((normalAdjustFlags & BT_TRIANGLE_CONVEX_DOUBLE_SIDED) != 0) || (clampedLocalNormal.dot(frontFacing*tri_normal)>0))
       {
        btVector3 newNormal = colObj0Wrap->getWorldTransform().getBasis() * clampedLocalNormal;
        //					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
        cp.m_normalWorldOnB = newNormal;
        // Reproject collision point along normal.
        cp.m_positionWorldOnB = cp.m_positionWorldOnA - cp.m_normalWorldOnB * cp.m_distance1;
        cp.m_localPointB = colObj0Wrap->getWorldTransform().invXform(cp.m_positionWorldOnB);
       }
      }
     }
    }
   }
 }

 btNearestPointInLineSegment(contact, v2, v0, nearest);
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 btDebugDrawLine(tr*nearest, tr*cp.m_localPointB, blue);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
 btDebugDrawLine(tr * v2 + upfix, tr * v0 + upfix, blue);
#endif   

 if (btFabs(info->m_edgeV2V0Angle)< triangleInfoMapPtr->m_maxEdgeAngleThreshold)
 {

#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
  btDebugDrawLine(tr*contact, tr*(contact + cp.m_normalWorldOnB * 10), black);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

  btScalar len = (contact - nearest).length();
  if (len<triangleInfoMapPtr->m_edgeDistanceThreshold)
   if (bestedge == 2)
   {
    isNearEdge = true;
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
    btDebugDrawLine(tr*nearest, tr*(nearest + tri_normal * 10), white);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

    btVector3 edge(v2 - v0);

    if (info->m_edgeV2V0Angle == btScalar(0))
    {
     numConcaveEdgeHits++;
    }
    else
    {

     bool isEdgeConvex = (info->m_flags & TRI_INFO_V2V0_CONVEX) != 0;
     btScalar swapFactor = isEdgeConvex ? btScalar(1) : btScalar(-1);
#ifdef BT_INTERNAL_EDGE_DEBUG_DRAW
     btDebugDrawLine(tr*nearest, tr*(nearest + swapFactor*tri_normal * 10), white);
#endif //BT_INTERNAL_EDGE_DEBUG_DRAW

     btVector3 nA = swapFactor * tri_normal;
     btQuaternion orn(edge, info->m_edgeV2V0Angle);
     btVector3 computedNormalB = quatRotate(orn, tri_normal);
     if (info->m_flags & TRI_INFO_V2V0_SWAP_NORMALB)
      computedNormalB *= -1;
     btVector3 nB = swapFactor*computedNormalB;

#ifdef DEBUG_INTERNAL_EDGE
     {
      btDebugDrawLine(cp.getPositionWorldOnB(), cp.getPositionWorldOnB() + tr.getBasis()*(nB * 20), red);
     }
#endif //DEBUG_INTERNAL_EDGE

     btScalar	NdotA = localContactNormalOnB.dot(nA);
     btScalar	NdotB = localContactNormalOnB.dot(nB);
     bool backFacingNormal = (NdotA< triangleInfoMapPtr->m_convexEpsilon) && (NdotB<triangleInfoMapPtr->m_convexEpsilon);

     if (backFacingNormal)
     {
      numConcaveEdgeHits++;
     }
     else
     {
      numConvexEdgeHits++;
      //				printf("hitting convex edge\n");


      btVector3 localContactNormalOnB = colObj0Wrap->getWorldTransform().getBasis().transpose() * cp.m_normalWorldOnB;
      btVector3 clampedLocalNormal;
      bool isClamped = btClampNormal(edge, swapFactor*tri_normal, localContactNormalOnB, info->m_edgeV2V0Angle, clampedLocalNormal);
      if (isClamped)
      {
       if (((normalAdjustFlags & BT_TRIANGLE_CONVEX_DOUBLE_SIDED) != 0) || (clampedLocalNormal.dot(frontFacing*tri_normal)>0))
       {
        btVector3 newNormal = colObj0Wrap->getWorldTransform().getBasis() * clampedLocalNormal;
        //					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
        cp.m_normalWorldOnB = newNormal;
        // Reproject collision point along normal.
        cp.m_positionWorldOnB = cp.m_positionWorldOnA - cp.m_normalWorldOnB * cp.m_distance1;
        cp.m_localPointB = colObj0Wrap->getWorldTransform().invXform(cp.m_positionWorldOnB);
       }
      }
     }
    }


   }
 }

#ifdef DEBUG_INTERNAL_EDGE
 {
  btVector3 color(0, 1, 1);
  btDebugDrawLine(cp.getPositionWorldOnB(), cp.getPositionWorldOnB() + cp.m_normalWorldOnB * 10, color);
 }
#endif //DEBUG_INTERNAL_EDGE

 if (isNearEdge)
 {

  if (numConcaveEdgeHits>0)
  {
   if ((normalAdjustFlags & BT_TRIANGLE_CONCAVE_DOUBLE_SIDED) != 0)
   {
    //fix tri_normal so it pointing the same direction as the current local contact normal
    if (tri_normal.dot(localContactNormalOnB) < 0)
    {
     tri_normal *= -1;
    }
    cp.m_normalWorldOnB = colObj0Wrap->getWorldTransform().getBasis()*tri_normal;
   }
   else
   {
    btVector3 newNormal = tri_normal *frontFacing;
    //if the tri_normal is pointing opposite direction as the current local contact normal, skip it
    btScalar d = newNormal.dot(localContactNormalOnB);
    if (d< 0)
    {
     return;
    }
    //modify the normal to be the triangle normal (or backfacing normal)
    cp.m_normalWorldOnB = colObj0Wrap->getWorldTransform().getBasis() *newNormal;
   }

   // Reproject collision point along normal.
   cp.m_positionWorldOnB = cp.m_positionWorldOnA - cp.m_normalWorldOnB * cp.m_distance1;
   cp.m_localPointB = colObj0Wrap->getWorldTransform().invXform(cp.m_positionWorldOnB);
  }
 }
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

///This is to allow MaterialCombiner/Custom Friction/Restitution values
ContactAddedCallback		gContactAddedCallback = 0;



btScalar	btManifoldResult::calculateCombinedRollingFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
 btScalar friction = body0->getRollingFriction() * body1->getFriction() + body1->getRollingFriction() * body0->getFriction();

 const btScalar MAX_FRICTION = btScalar(10.);
 if (friction < -MAX_FRICTION)
  friction = -MAX_FRICTION;
 if (friction > MAX_FRICTION)
  friction = MAX_FRICTION;
 return friction;

}

btScalar	btManifoldResult::calculateCombinedSpinningFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
 btScalar friction = body0->getSpinningFriction() * body1->getFriction() + body1->getSpinningFriction() * body0->getFriction();

 const btScalar MAX_FRICTION = btScalar(10.);
 if (friction < -MAX_FRICTION)
  friction = -MAX_FRICTION;
 if (friction > MAX_FRICTION)
  friction = MAX_FRICTION;
 return friction;
}

///User can override this material combiner by implementing gContactAddedCallback and setting body0->m_collisionFlags |= btCollisionObject::customMaterialCallback;
btScalar	btManifoldResult::calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
 btScalar friction = body0->getFriction() * body1->getFriction();

 const btScalar MAX_FRICTION = btScalar(10.);
 if (friction < -MAX_FRICTION)
  friction = -MAX_FRICTION;
 if (friction > MAX_FRICTION)
  friction = MAX_FRICTION;
 return friction;

}

btScalar	btManifoldResult::calculateCombinedRestitution(const btCollisionObject* body0, const btCollisionObject* body1)
{
 return body0->getRestitution() * body1->getRestitution();
}

btScalar	btManifoldResult::calculateCombinedContactDamping(const btCollisionObject* body0, const btCollisionObject* body1)
{
 return body0->getContactDamping() + body1->getContactDamping();
}

btScalar	btManifoldResult::calculateCombinedContactStiffness(const btCollisionObject* body0, const btCollisionObject* body1)
{

 btScalar s0 = body0->getContactStiffness();
 btScalar s1 = body1->getContactStiffness();

 btScalar tmp0 = btScalar(1) / s0;
 btScalar tmp1 = btScalar(1) / s1;
 btScalar combinedStiffness = btScalar(1) / (tmp0 + tmp1);
 return combinedStiffness;
}


btManifoldResult::btManifoldResult(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
 :m_manifoldPtr(0),
 m_body0Wrap(body0Wrap),
 m_body1Wrap(body1Wrap)
#ifdef DEBUG_PART_INDEX
 , m_partId0(-1),
 m_partId1(-1),
 m_index0(-1),
 m_index1(-1)
#endif //DEBUG_PART_INDEX
 , m_closestPointDistanceThreshold(0)
{
}


void btManifoldResult::addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
{
 btAssert(m_manifoldPtr);
 //order in manifold needs to match

 if (depth > m_manifoldPtr->getContactBreakingThreshold())
  //	if (depth > m_manifoldPtr->getContactProcessingThreshold())
  return;

 bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
 bool isNewCollision = m_manifoldPtr->getNumContacts() == 0;

 btVector3 pointA = pointInWorld + normalOnBInWorld * depth;

 btVector3 localA;
 btVector3 localB;

 if (isSwapped)
 {
  localA = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
  localB = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
 }
 else
 {
  localA = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
  localB = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
 }

 btManifoldPoint newPt(localA, localB, normalOnBInWorld, depth);
 newPt.m_positionWorldOnA = pointA;
 newPt.m_positionWorldOnB = pointInWorld;

 int insertIndex = m_manifoldPtr->getCacheEntry(newPt);

 newPt.m_combinedFriction = calculateCombinedFriction(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
 newPt.m_combinedRestitution = calculateCombinedRestitution(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
 newPt.m_combinedRollingFriction = calculateCombinedRollingFriction(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
 newPt.m_combinedSpinningFriction = calculateCombinedSpinningFriction(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());

 if ((m_body0Wrap->getCollisionObject()->getCollisionFlags()& btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING) ||
  (m_body1Wrap->getCollisionObject()->getCollisionFlags()& btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING))
 {
  newPt.m_combinedContactDamping1 = calculateCombinedContactDamping(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
  newPt.m_combinedContactStiffness1 = calculateCombinedContactStiffness(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
  newPt.m_contactPointFlags |= BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING;
 }

 if ((m_body0Wrap->getCollisionObject()->getCollisionFlags()& btCollisionObject::CF_HAS_FRICTION_ANCHOR) ||
  (m_body1Wrap->getCollisionObject()->getCollisionFlags()& btCollisionObject::CF_HAS_FRICTION_ANCHOR))
 {
  newPt.m_contactPointFlags |= BT_CONTACT_FLAG_FRICTION_ANCHOR;
 }

 btPlaneSpace1(newPt.m_normalWorldOnB, newPt.m_lateralFrictionDir1, newPt.m_lateralFrictionDir2);



 //BP mod, store contact triangles.
 if (isSwapped)
 {
  newPt.m_partId0 = m_partId1;
  newPt.m_partId1 = m_partId0;
  newPt.m_index0 = m_index1;
  newPt.m_index1 = m_index0;
 }
 else
 {
  newPt.m_partId0 = m_partId0;
  newPt.m_partId1 = m_partId1;
  newPt.m_index0 = m_index0;
  newPt.m_index1 = m_index1;
 }
 //printf("depth=%f\n",depth);
 ///@todo, check this for any side effects
 if (insertIndex >= 0)
 {
  //const btManifoldPoint& oldPoint = m_manifoldPtr->getContactPoint(insertIndex);
  m_manifoldPtr->replaceContactPoint(newPt, insertIndex);
 }
 else
 {
  insertIndex = m_manifoldPtr->addManifoldPoint(newPt);
 }

 //User can override friction and/or restitution
 if (gContactAddedCallback &&
  //and if either of the two bodies requires custom material
  ((m_body0Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK) ||
  (m_body1Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK)))
 {
  //experimental feature info, for per-triangle material etc.
  const btCollisionObjectWrapper* obj0Wrap = isSwapped ? m_body1Wrap : m_body0Wrap;
  const btCollisionObjectWrapper* obj1Wrap = isSwapped ? m_body0Wrap : m_body1Wrap;
  (*gContactAddedCallback)(m_manifoldPtr->getContactPoint(insertIndex), obj0Wrap, newPt.m_partId0, newPt.m_index0, obj1Wrap, newPt.m_partId1, newPt.m_index1);
 }

 if (gContactStartedCallback && isNewCollision)
 {
  gContactStartedCallback(m_manifoldPtr);
 }
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btScalar.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"

//#include <stdio.h>
#include "LinearMath/btQuickprof.h"

btSimulationIslandManager::btSimulationIslandManager() :
 m_splitIslands(true)
{
}

btSimulationIslandManager::~btSimulationIslandManager()
{
}


void btSimulationIslandManager::initUnionFind(int n)
{
 m_unionFind.reset(n);
}


void btSimulationIslandManager::findUnions(btDispatcher* /* dispatcher */, btCollisionWorld* colWorld)
{

 {
  btOverlappingPairCache* pairCachePtr = colWorld->getPairCache();
  const int numOverlappingPairs = pairCachePtr->getNumOverlappingPairs();
  if (numOverlappingPairs)
  {
   btBroadphasePair* pairPtr = pairCachePtr->getOverlappingPairArrayPtr();

   for (int i = 0; i<numOverlappingPairs; i++)
   {
    const btBroadphasePair& collisionPair = pairPtr[i];
    btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
    btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;

    if (((colObj0) && ((colObj0)->mergesSimulationIslands())) &&
     ((colObj1) && ((colObj1)->mergesSimulationIslands())))
    {

     m_unionFind.unite((colObj0)->getIslandTag(),
      (colObj1)->getIslandTag());
    }
   }
  }
 }
}

#ifdef STATIC_SIMULATION_ISLAND_OPTIMIZATION
void   btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{

 // put the index into m_controllers into m_tag   
 int index = 0;
 {

  int i;
  for (i = 0; i<colWorld->getCollisionObjectArray().size(); i++)
  {
   btCollisionObject*   collisionObject = colWorld->getCollisionObjectArray()[i];
   //Adding filtering here
   if (!collisionObject->isStaticOrKinematicObject())
   {
    collisionObject->setIslandTag(index++);
   }
   collisionObject->setCompanionId(-1);
   collisionObject->setHitFraction(btScalar(1.));
  }
 }
 // do the union find

 initUnionFind(index);

 findUnions(dispatcher, colWorld);
}

void   btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
 // put the islandId ('find' value) into m_tag   
 {
  int index = 0;
  int i;
  for (i = 0; i<colWorld->getCollisionObjectArray().size(); i++)
  {
   btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
   if (!collisionObject->isStaticOrKinematicObject())
   {
    collisionObject->setIslandTag(m_unionFind.find(index));
    //Set the correct object offset in Collision Object Array
    m_unionFind.getElement(index).m_sz = i;
    collisionObject->setCompanionId(-1);
    index++;
   }
   else
   {
    collisionObject->setIslandTag(-1);
    collisionObject->setCompanionId(-2);
   }
  }
 }
}


#else //STATIC_SIMULATION_ISLAND_OPTIMIZATION
void	btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{

 initUnionFind(int(colWorld->getCollisionObjectArray().size()));

 // put the index into m_controllers into m_tag	
 {

  int index = 0;
  int i;
  for (i = 0; i<colWorld->getCollisionObjectArray().size(); i++)
  {
   btCollisionObject*	collisionObject = colWorld->getCollisionObjectArray()[i];
   collisionObject->setIslandTag(index);
   collisionObject->setCompanionId(-1);
   collisionObject->setHitFraction(btScalar(1.));
   index++;

  }
 }
 // do the union find

 findUnions(dispatcher, colWorld);
}

void	btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
 // put the islandId ('find' value) into m_tag	
 {


  int index = 0;
  int i;
  for (i = 0; i<colWorld->getCollisionObjectArray().size(); i++)
  {
   btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
   if (!collisionObject->isStaticOrKinematicObject())
   {
    collisionObject->setIslandTag(m_unionFind.find(index));
    collisionObject->setCompanionId(-1);
   }
   else
   {
    collisionObject->setIslandTag(-1);
    collisionObject->setCompanionId(-2);
   }
   index++;
  }
 }
}

#endif //STATIC_SIMULATION_ISLAND_OPTIMIZATION

inline	int	getIslandId(const btPersistentManifold* lhs)
{
 int islandId;
 const btCollisionObject* rcolObj0 = static_cast<const btCollisionObject*>(lhs->getBody0());
 const btCollisionObject* rcolObj1 = static_cast<const btCollisionObject*>(lhs->getBody1());
 islandId = rcolObj0->getIslandTag() >= 0 ? rcolObj0->getIslandTag() : rcolObj1->getIslandTag();
 return islandId;

}



/// function object that routes calls to operator<
class btPersistentManifoldSortPredicate
{
public:

 SIMD_FORCE_INLINE bool operator() (const btPersistentManifold* lhs, const btPersistentManifold* rhs) const
 {
  return getIslandId(lhs) < getIslandId(rhs);
 }
};


void btSimulationIslandManager::buildIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld)
{

 BT_PROFILE("islandUnionFindAndQuickSort");

 btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

 m_islandmanifold.resize(0);

 //we are going to sort the unionfind array, and store the element id in the size
 //afterwards, we clean unionfind, to make sure no-one uses it anymore

 getUnionFind().sortIslands();
 int numElem = getUnionFind().getNumElements();

 int endIslandIndex = 1;
 int startIslandIndex;


 //update the sleeping state for bodies, if all are sleeping
 for (startIslandIndex = 0; startIslandIndex<numElem; startIslandIndex = endIslandIndex)
 {
  int islandId = getUnionFind().getElement(startIslandIndex).m_id;
  for (endIslandIndex = startIslandIndex + 1; (endIslandIndex<numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
  {
  }

  //int numSleeping = 0;

  bool allSleeping = true;

  int idx;
  for (idx = startIslandIndex; idx<endIslandIndex; idx++)
  {
   int i = getUnionFind().getElement(idx).m_sz;

   btCollisionObject* colObj0 = collisionObjects[i];
   if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
   {
    //				printf("error in island management\n");
   }

   btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));
   if (colObj0->getIslandTag() == islandId)
   {
    if (colObj0->getActivationState() == ACTIVE_TAG)
    {
     allSleeping = false;
    }
    if (colObj0->getActivationState() == DISABLE_DEACTIVATION)
    {
     allSleeping = false;
    }
   }
  }


  if (allSleeping)
  {
   int idx;
   for (idx = startIslandIndex; idx<endIslandIndex; idx++)
   {
    int i = getUnionFind().getElement(idx).m_sz;
    btCollisionObject* colObj0 = collisionObjects[i];
    if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
    {
     //					printf("error in island management\n");
    }

    btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

    if (colObj0->getIslandTag() == islandId)
    {
     colObj0->setActivationState(ISLAND_SLEEPING);
    }
   }
  }
  else
  {

   int idx;
   for (idx = startIslandIndex; idx<endIslandIndex; idx++)
   {
    int i = getUnionFind().getElement(idx).m_sz;

    btCollisionObject* colObj0 = collisionObjects[i];
    if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
    {
     //					printf("error in island management\n");
    }

    btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

    if (colObj0->getIslandTag() == islandId)
    {
     if (colObj0->getActivationState() == ISLAND_SLEEPING)
     {
      colObj0->setActivationState(WANTS_DEACTIVATION);
      colObj0->setDeactivationTime(0.f);
     }
    }
   }
  }
 }


 int i;
 int maxNumManifolds = dispatcher->getNumManifolds();

 //#define SPLIT_ISLANDS 1
 //#ifdef SPLIT_ISLANDS


 //#endif //SPLIT_ISLANDS


 for (i = 0; i<maxNumManifolds; i++)
 {
  btPersistentManifold* manifold = dispatcher->getManifoldByIndexInternal(i);

  const btCollisionObject* colObj0 = static_cast<const btCollisionObject*>(manifold->getBody0());
  const btCollisionObject* colObj1 = static_cast<const btCollisionObject*>(manifold->getBody1());

  ///@todo: check sleeping conditions!
  if (((colObj0) && colObj0->getActivationState() != ISLAND_SLEEPING) ||
   ((colObj1) && colObj1->getActivationState() != ISLAND_SLEEPING))
  {

   //kinematic objects don't merge islands, but wake up all connected objects
   if (colObj0->isKinematicObject() && colObj0->getActivationState() != ISLAND_SLEEPING)
   {
    if (colObj0->hasContactResponse())
     colObj1->activate();
   }
   if (colObj1->isKinematicObject() && colObj1->getActivationState() != ISLAND_SLEEPING)
   {
    if (colObj1->hasContactResponse())
     colObj0->activate();
   }
   if (m_splitIslands)
   {
    //filtering for response
    if (dispatcher->needsResponse(colObj0, colObj1))
     m_islandmanifold.push_back(manifold);
   }
  }
 }
}



///@todo: this is random access, it can be walked 'cache friendly'!
void btSimulationIslandManager::buildAndProcessIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback)
{
 btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

 buildIslands(dispatcher, collisionWorld);

 int endIslandIndex = 1;
 int startIslandIndex;
 int numElem = getUnionFind().getNumElements();

 BT_PROFILE("processIslands");

 if (!m_splitIslands)
 {
  btPersistentManifold** manifold = dispatcher->getInternalManifoldPointer();
  int maxNumManifolds = dispatcher->getNumManifolds();
  callback->processIsland(&collisionObjects[0], collisionObjects.size(), manifold, maxNumManifolds, -1);
 }
 else
 {
  // Sort manifolds, based on islands
  // Sort the vector using predicate and std::sort
  //std::sort(islandmanifold.begin(), islandmanifold.end(), btPersistentManifoldSortPredicate);

  int numManifolds = int(m_islandmanifold.size());

  //tried a radix sort, but quicksort/heapsort seems still faster
  //@todo rewrite island management
  m_islandmanifold.quickSort(btPersistentManifoldSortPredicate());
  //m_islandmanifold.heapSort(btPersistentManifoldSortPredicate());

  //now process all active islands (sets of manifolds for now)

  int startManifoldIndex = 0;
  int endManifoldIndex = 1;

  //int islandId;



  //	printf("Start Islands\n");

  //traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
  for (startIslandIndex = 0; startIslandIndex<numElem; startIslandIndex = endIslandIndex)
  {
   int islandId = getUnionFind().getElement(startIslandIndex).m_id;


   bool islandSleeping = true;

   for (endIslandIndex = startIslandIndex; (endIslandIndex<numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
   {
    int i = getUnionFind().getElement(endIslandIndex).m_sz;
    btCollisionObject* colObj0 = collisionObjects[i];
    m_islandBodies.push_back(colObj0);
    if (colObj0->isActive())
     islandSleeping = false;
   }


   //find the accompanying contact manifold for this islandId
   int numIslandManifolds = 0;
   btPersistentManifold** startManifold = 0;

   if (startManifoldIndex<numManifolds)
   {
    int curIslandId = getIslandId(m_islandmanifold[startManifoldIndex]);
    if (curIslandId == islandId)
    {
     startManifold = &m_islandmanifold[startManifoldIndex];

     for (endManifoldIndex = startManifoldIndex + 1; (endManifoldIndex<numManifolds) && (islandId == getIslandId(m_islandmanifold[endManifoldIndex])); endManifoldIndex++)
     {

     }
     /// Process the actual simulation, only if not sleeping/deactivated
     numIslandManifolds = endManifoldIndex - startManifoldIndex;
    }

   }

   if (!islandSleeping)
   {
    callback->processIsland(&m_islandBodies[0], m_islandBodies.size(), startManifold, numIslandManifolds, islandId);
    //			printf("Island callback of size:%d bodies, %d manifolds\n",islandBodies.size(),numIslandManifolds);
   }

   if (numIslandManifolds)
   {
    startManifoldIndex = endManifoldIndex;
   }

   m_islandBodies.resize(0);
  }
 } // else if(!splitIslands) 

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btSphereBoxCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
//#include <stdio.h>

btSphereBoxCollisionAlgorithm::btSphereBoxCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap, bool isSwapped)
 : btActivatingCollisionAlgorithm(ci, col0Wrap, col1Wrap),
 m_ownManifold(false),
 m_manifoldPtr(mf),
 m_isSwapped(isSwapped)
{
 const btCollisionObjectWrapper* sphereObjWrap = m_isSwapped ? col1Wrap : col0Wrap;
 const btCollisionObjectWrapper* boxObjWrap = m_isSwapped ? col0Wrap : col1Wrap;

 if (!m_manifoldPtr && m_dispatcher->needsCollision(sphereObjWrap->getCollisionObject(), boxObjWrap->getCollisionObject()))
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(sphereObjWrap->getCollisionObject(), boxObjWrap->getCollisionObject());
  m_ownManifold = true;
 }
}


btSphereBoxCollisionAlgorithm::~btSphereBoxCollisionAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}



void btSphereBoxCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)dispatchInfo;
 (void)resultOut;
 if (!m_manifoldPtr)
  return;

 const btCollisionObjectWrapper* sphereObjWrap = m_isSwapped ? body1Wrap : body0Wrap;
 const btCollisionObjectWrapper* boxObjWrap = m_isSwapped ? body0Wrap : body1Wrap;

 btVector3 pOnBox;

 btVector3 normalOnSurfaceB;
 btScalar penetrationDepth;
 btVector3 sphereCenter = sphereObjWrap->getWorldTransform().getOrigin();
 const btSphereShape* sphere0 = (const btSphereShape*)sphereObjWrap->getCollisionShape();
 btScalar radius = sphere0->getRadius();
 btScalar maxContactDistance = m_manifoldPtr->getContactBreakingThreshold();

 resultOut->setPersistentManifold(m_manifoldPtr);

 if (getSphereDistance(boxObjWrap, pOnBox, normalOnSurfaceB, penetrationDepth, sphereCenter, radius, maxContactDistance))
 {
  /// report a contact. internally this will be kept persistent, and contact reduction is done
  resultOut->addContactPoint(normalOnSurfaceB, pOnBox, penetrationDepth);
 }

 if (m_ownManifold)
 {
  if (m_manifoldPtr->getNumContacts())
  {
   resultOut->refreshContactPoints();
  }
 }

}

btScalar btSphereBoxCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 (void)col0;
 (void)col1;

 //not yet
 return btScalar(1.);
}


bool btSphereBoxCollisionAlgorithm::getSphereDistance(const btCollisionObjectWrapper* boxObjWrap, btVector3& pointOnBox, btVector3& normal, btScalar& penetrationDepth, const btVector3& sphereCenter, btScalar fRadius, btScalar maxContactDistance)
{
 const btBoxShape* boxShape = (const btBoxShape*)boxObjWrap->getCollisionShape();
 btVector3 const &boxHalfExtent = boxShape->getHalfExtentsWithoutMargin();
 btScalar boxMargin = boxShape->getMargin();
 penetrationDepth = 1.0f;

 // convert the sphere position to the box's local space
 btTransform const &m44T = boxObjWrap->getWorldTransform();
 btVector3 sphereRelPos = m44T.invXform(sphereCenter);

 // Determine the closest point to the sphere center in the box
 btVector3 closestPoint = sphereRelPos;
 closestPoint.setX(btMin(boxHalfExtent.getX(), closestPoint.getX()));
 closestPoint.setX(btMax(-boxHalfExtent.getX(), closestPoint.getX()));
 closestPoint.setY(btMin(boxHalfExtent.getY(), closestPoint.getY()));
 closestPoint.setY(btMax(-boxHalfExtent.getY(), closestPoint.getY()));
 closestPoint.setZ(btMin(boxHalfExtent.getZ(), closestPoint.getZ()));
 closestPoint.setZ(btMax(-boxHalfExtent.getZ(), closestPoint.getZ()));

 btScalar intersectionDist = fRadius + boxMargin;
 btScalar contactDist = intersectionDist + maxContactDistance;
 normal = sphereRelPos - closestPoint;

 //if there is no penetration, we are done
 btScalar dist2 = normal.length2();
 if (dist2 > contactDist * contactDist)
 {
  return false;
 }

 btScalar distance;

 //special case if the sphere center is inside the box
 if (dist2 <= SIMD_EPSILON)
 {
  distance = -getSpherePenetration(boxHalfExtent, sphereRelPos, closestPoint, normal);
 }
 else //compute the penetration details
 {
  distance = normal.length();
  normal /= distance;
 }

 pointOnBox = closestPoint + normal * boxMargin;
 //	v3PointOnSphere = sphereRelPos - (normal * fRadius);	
 penetrationDepth = distance - intersectionDist;

 // transform back in world space
 btVector3 tmp = m44T(pointOnBox);
 pointOnBox = tmp;
 //	tmp = m44T(v3PointOnSphere);
 //	v3PointOnSphere = tmp;
 tmp = m44T.getBasis() * normal;
 normal = tmp;

 return true;
}

btScalar btSphereBoxCollisionAlgorithm::getSpherePenetration(btVector3 const &boxHalfExtent, btVector3 const &sphereRelPos, btVector3 &closestPoint, btVector3& normal)
{
 //project the center of the sphere on the closest face of the box
 btScalar faceDist = boxHalfExtent.getX() - sphereRelPos.getX();
 btScalar minDist = faceDist;
 closestPoint.setX(boxHalfExtent.getX());
 normal.setValue(btScalar(1.0f), btScalar(0.0f), btScalar(0.0f));

 faceDist = boxHalfExtent.getX() + sphereRelPos.getX();
 if (faceDist < minDist)
 {
  minDist = faceDist;
  closestPoint = sphereRelPos;
  closestPoint.setX(-boxHalfExtent.getX());
  normal.setValue(btScalar(-1.0f), btScalar(0.0f), btScalar(0.0f));
 }

 faceDist = boxHalfExtent.getY() - sphereRelPos.getY();
 if (faceDist < minDist)
 {
  minDist = faceDist;
  closestPoint = sphereRelPos;
  closestPoint.setY(boxHalfExtent.getY());
  normal.setValue(btScalar(0.0f), btScalar(1.0f), btScalar(0.0f));
 }

 faceDist = boxHalfExtent.getY() + sphereRelPos.getY();
 if (faceDist < minDist)
 {
  minDist = faceDist;
  closestPoint = sphereRelPos;
  closestPoint.setY(-boxHalfExtent.getY());
  normal.setValue(btScalar(0.0f), btScalar(-1.0f), btScalar(0.0f));
 }

 faceDist = boxHalfExtent.getZ() - sphereRelPos.getZ();
 if (faceDist < minDist)
 {
  minDist = faceDist;
  closestPoint = sphereRelPos;
  closestPoint.setZ(boxHalfExtent.getZ());
  normal.setValue(btScalar(0.0f), btScalar(0.0f), btScalar(1.0f));
 }

 faceDist = boxHalfExtent.getZ() + sphereRelPos.getZ();
 if (faceDist < minDist)
 {
  minDist = faceDist;
  closestPoint = sphereRelPos;
  closestPoint.setZ(-boxHalfExtent.getZ());
  normal.setValue(btScalar(0.0f), btScalar(0.0f), btScalar(-1.0f));
 }

 return minDist;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#define CLEAR_MANIFOLD 1

#include "BulletCollision/CollisionDispatch/btSphereSphereCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

btSphereSphereCollisionAlgorithm::btSphereSphereCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap)
 : btActivatingCollisionAlgorithm(ci, col0Wrap, col1Wrap),
 m_ownManifold(false),
 m_manifoldPtr(mf)
{
 if (!m_manifoldPtr)
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(col0Wrap->getCollisionObject(), col1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
}

btSphereSphereCollisionAlgorithm::~btSphereSphereCollisionAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void btSphereSphereCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)dispatchInfo;

 if (!m_manifoldPtr)
  return;

 resultOut->setPersistentManifold(m_manifoldPtr);

 btSphereShape* sphere0 = (btSphereShape*)col0Wrap->getCollisionShape();
 btSphereShape* sphere1 = (btSphereShape*)col1Wrap->getCollisionShape();

 btVector3 diff = col0Wrap->getWorldTransform().getOrigin() - col1Wrap->getWorldTransform().getOrigin();
 btScalar len = diff.length();
 btScalar radius0 = sphere0->getRadius();
 btScalar radius1 = sphere1->getRadius();

#ifdef CLEAR_MANIFOLD
 m_manifoldPtr->clearManifold(); //don't do this, it disables warmstarting
#endif

                                 ///iff distance positive, don't generate a new contact
 if (len > (radius0 + radius1 + resultOut->m_closestPointDistanceThreshold))
 {
#ifndef CLEAR_MANIFOLD
  resultOut->refreshContactPoints();
#endif //CLEAR_MANIFOLD
  return;
 }
 ///distance (negative means penetration)
 btScalar dist = len - (radius0 + radius1);

 btVector3 normalOnSurfaceB(1, 0, 0);
 if (len > SIMD_EPSILON)
 {
  normalOnSurfaceB = diff / len;
 }

 ///point on A (worldspace)
 ///btVector3 pos0 = col0->getWorldTransform().getOrigin() - radius0 * normalOnSurfaceB;
 ///point on B (worldspace)
 btVector3 pos1 = col1Wrap->getWorldTransform().getOrigin() + radius1* normalOnSurfaceB;

 /// report a contact. internally this will be kept persistent, and contact reduction is done


 resultOut->addContactPoint(normalOnSurfaceB, pos1, dist);

#ifndef CLEAR_MANIFOLD
 resultOut->refreshContactPoints();
#endif //CLEAR_MANIFOLD

}

btScalar btSphereSphereCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)col0;
 (void)col1;
 (void)dispatchInfo;
 (void)resultOut;

 //not yet
 return btScalar(1.);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionDispatch/btSphereTriangleCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/SphereTriangleDetector.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

btSphereTriangleCollisionAlgorithm::btSphereTriangleCollisionAlgorithm(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool swapped)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap),
 m_ownManifold(false),
 m_manifoldPtr(mf),
 m_swapped(swapped)
{
 if (!m_manifoldPtr)
 {
  m_manifoldPtr = m_dispatcher->getNewManifold(body0Wrap->getCollisionObject(), body1Wrap->getCollisionObject());
  m_ownManifold = true;
 }
}

btSphereTriangleCollisionAlgorithm::~btSphereTriangleCollisionAlgorithm()
{
 if (m_ownManifold)
 {
  if (m_manifoldPtr)
   m_dispatcher->releaseManifold(m_manifoldPtr);
 }
}

void btSphereTriangleCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 if (!m_manifoldPtr)
  return;

 const btCollisionObjectWrapper* sphereObjWrap = m_swapped ? col1Wrap : col0Wrap;
 const btCollisionObjectWrapper* triObjWrap = m_swapped ? col0Wrap : col1Wrap;

 btSphereShape* sphere = (btSphereShape*)sphereObjWrap->getCollisionShape();
 btTriangleShape* triangle = (btTriangleShape*)triObjWrap->getCollisionShape();

 /// report a contact. internally this will be kept persistent, and contact reduction is done
 resultOut->setPersistentManifold(m_manifoldPtr);
 SphereTriangleDetector detector(sphere, triangle, m_manifoldPtr->getContactBreakingThreshold() + resultOut->m_closestPointDistanceThreshold);

 btDiscreteCollisionDetectorInterface::ClosestPointInput input;
 input.m_maximumDistanceSquared = btScalar(BT_LARGE_FLOAT);///@todo: tighter bounds
 input.m_transformA = sphereObjWrap->getWorldTransform();
 input.m_transformB = triObjWrap->getWorldTransform();

 bool swapResults = m_swapped;

 detector.getClosestPoints(input, *resultOut, dispatchInfo.m_debugDraw, swapResults);

 if (m_ownManifold)
  resultOut->refreshContactPoints();

}

btScalar btSphereTriangleCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 (void)col0;
 (void)col1;

 //not yet
 return btScalar(1.);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btUnionFind.h"



btUnionFind::~btUnionFind()
{
 Free();

}

btUnionFind::btUnionFind()
{

}

void	btUnionFind::allocate(int N)
{
 m_elements.resize(N);
}
void	btUnionFind::Free()
{
 m_elements.clear();
}


void	btUnionFind::reset(int N)
{
 allocate(N);

 for (int i = 0; i < N; i++)
 {
  m_elements[i].m_id = i; m_elements[i].m_sz = 1;
 }
}


class btUnionFindElementSortPredicate
{
public:

 bool operator() (const btElement& lhs, const btElement& rhs) const
 {
  return lhs.m_id < rhs.m_id;
 }
};

///this is a special operation, destroying the content of btUnionFind.
///it sorts the elements, based on island id, in order to make it easy to iterate over islands
void	btUnionFind::sortIslands()
{

 //first store the original body index, and islandId
 int numElements = m_elements.size();

 for (int i = 0; i<numElements; i++)
 {
  m_elements[i].m_id = find(i);
#ifndef STATIC_SIMULATION_ISLAND_OPTIMIZATION
  m_elements[i].m_sz = i;
#endif //STATIC_SIMULATION_ISLAND_OPTIMIZATION
 }

 // Sort the vector using predicate and std::sort
 //std::sort(m_elements.begin(), m_elements.end(), btUnionFindElementSortPredicate);
 m_elements.quickSort(btUnionFindElementSortPredicate());

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btScalar.h"
#include "BulletCollision/CollisionDispatch/SphereTriangleDetector.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"


SphereTriangleDetector::SphereTriangleDetector(btSphereShape* sphere, btTriangleShape* triangle, btScalar contactBreakingThreshold)
 :m_sphere(sphere),
 m_triangle(triangle),
 m_contactBreakingThreshold(contactBreakingThreshold)
{

}

void	SphereTriangleDetector::getClosestPoints(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw, bool swapResults)
{

 (void)debugDraw;
 const btTransform& transformA = input.m_transformA;
 const btTransform& transformB = input.m_transformB;

 btVector3 point, normal;
 btScalar timeOfImpact = btScalar(1.);
 btScalar depth = btScalar(0.);
 //	output.m_distance = btScalar(BT_LARGE_FLOAT);
 //move sphere into triangle space
 btTransform	sphereInTr = transformB.inverseTimes(transformA);

 if (collide(sphereInTr.getOrigin(), point, normal, depth, timeOfImpact, m_contactBreakingThreshold))
 {
  if (swapResults)
  {
   btVector3 normalOnB = transformB.getBasis()*normal;
   btVector3 normalOnA = -normalOnB;
   btVector3 pointOnA = transformB*point + normalOnB*depth;
   output.addContactPoint(normalOnA, pointOnA, depth);
  }
  else
  {
   output.addContactPoint(transformB.getBasis()*normal, transformB*point, depth);
  }
 }

}



// See also geometrictools.com
// Basic idea: D = |p - (lo + t0*lv)| where t0 = lv . (p - lo) / lv . lv
btScalar SegmentSqrDistance(const btVector3& from, const btVector3& to, const btVector3 &p, btVector3 &nearest);

btScalar SegmentSqrDistance(const btVector3& from, const btVector3& to, const btVector3 &p, btVector3 &nearest) {
 btVector3 diff = p - from;
 btVector3 v = to - from;
 btScalar t = v.dot(diff);

 if (t > 0) {
  btScalar dotVV = v.dot(v);
  if (t < dotVV) {
   t /= dotVV;
   diff -= t*v;
  }
  else {
   t = 1;
   diff -= v;
  }
 }
 else
  t = 0;

 nearest = from + t*v;
 return diff.dot(diff);
}

bool SphereTriangleDetector::facecontains(const btVector3 &p, const btVector3* vertices, btVector3& normal) {
 btVector3 lp(p);
 btVector3 lnormal(normal);

 return pointInTriangle(vertices, lnormal, &lp);
}

bool SphereTriangleDetector::collide(const btVector3& sphereCenter, btVector3 &point, btVector3& resultNormal, btScalar& depth, btScalar &timeOfImpact, btScalar contactBreakingThreshold)
{

 const btVector3* vertices = &m_triangle->getVertexPtr(0);

 btScalar radius = m_sphere->getRadius();
 btScalar radiusWithThreshold = radius + contactBreakingThreshold;

 btVector3 normal = (vertices[1] - vertices[0]).cross(vertices[2] - vertices[0]);

 btScalar l2 = normal.length2();
 bool hasContact = false;
 btVector3 contactPoint;

 if (l2 >= SIMD_EPSILON*SIMD_EPSILON)
 {
  normal /= btSqrt(l2);

  btVector3 p1ToCentre = sphereCenter - vertices[0];
  btScalar distanceFromPlane = p1ToCentre.dot(normal);

  if (distanceFromPlane < btScalar(0.))
  {
   //triangle facing the other way
   distanceFromPlane *= btScalar(-1.);
   normal *= btScalar(-1.);
  }

  bool isInsideContactPlane = distanceFromPlane < radiusWithThreshold;

  // Check for contact / intersection

  if (isInsideContactPlane) {
   if (facecontains(sphereCenter, vertices, normal)) {
    // Inside the contact wedge - touches a point on the shell plane
    hasContact = true;
    contactPoint = sphereCenter - normal*distanceFromPlane;
   }
   else {
    // Could be inside one of the contact capsules
    btScalar contactCapsuleRadiusSqr = radiusWithThreshold*radiusWithThreshold;
    btVector3 nearestOnEdge;
    for (int i = 0; i < m_triangle->getNumEdges(); i++) {

     btVector3 pa;
     btVector3 pb;

     m_triangle->getEdge(i, pa, pb);

     btScalar distanceSqr = SegmentSqrDistance(pa, pb, sphereCenter, nearestOnEdge);
     if (distanceSqr < contactCapsuleRadiusSqr) {
      // Yep, we're inside a capsule
      hasContact = true;
      contactPoint = nearestOnEdge;
     }

    }
   }
  }
 }

 if (hasContact) {
  btVector3 contactToCentre = sphereCenter - contactPoint;
  btScalar distanceSqr = contactToCentre.length2();

  if (distanceSqr < radiusWithThreshold*radiusWithThreshold)
  {
   if (distanceSqr>SIMD_EPSILON)
   {
    btScalar distance = btSqrt(distanceSqr);
    resultNormal = contactToCentre;
    resultNormal.normalize();
    point = contactPoint;
    depth = -(radius - distance);
   }
   else
   {
    resultNormal = normal;
    point = contactPoint;
    depth = -radius;
   }
   return true;
  }
 }

 return false;
}


bool SphereTriangleDetector::pointInTriangle(const btVector3 vertices[], const btVector3 &normal, btVector3 *p)
{
 const btVector3* p1 = &vertices[0];
 const btVector3* p2 = &vertices[1];
 const btVector3* p3 = &vertices[2];

 btVector3 edge1(*p2 - *p1);
 btVector3 edge2(*p3 - *p2);
 btVector3 edge3(*p1 - *p3);

 btVector3 p1_to_p(*p - *p1);
 btVector3 p2_to_p(*p - *p2);
 btVector3 p3_to_p(*p - *p3);

 btVector3 edge1_normal(edge1.cross(normal));
 btVector3 edge2_normal(edge2.cross(normal));
 btVector3 edge3_normal(edge3.cross(normal));

 btScalar r1, r2, r3;
 r1 = edge1_normal.dot(p1_to_p);
 r2 = edge2_normal.dot(p2_to_p);
 r3 = edge3_normal.dot(p3_to_p);
 if ((r1 > 0 && r2 > 0 && r3 > 0) ||
  (r1 <= 0 && r2 <= 0 && r3 <= 0))
  return true;
 return false;

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btBox2dShape.h"


//{ 


void btBox2dShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}


void	btBox2dShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 //btScalar margin = btScalar(0.);
 btVector3 halfExtents = getHalfExtentsWithMargin();

 btScalar lx = btScalar(2.)*(halfExtents.x());
 btScalar ly = btScalar(2.)*(halfExtents.y());
 btScalar lz = btScalar(2.)*(halfExtents.z());

 inertia.setValue(mass / (btScalar(12.0)) * (ly*ly + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + ly*ly));

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btBoxShape.h"

btBoxShape::btBoxShape(const btVector3& boxHalfExtents)
 : btPolyhedralConvexShape()
{
 m_shapeType = BOX_SHAPE_PROXYTYPE;

 btVector3 margin(getMargin(), getMargin(), getMargin());
 m_implicitShapeDimensions = (boxHalfExtents * m_localScaling) - margin;

 setSafeMargin(boxHalfExtents);
};




void btBoxShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}


void	btBoxShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 //btScalar margin = btScalar(0.);
 btVector3 halfExtents = getHalfExtentsWithMargin();

 btScalar lx = btScalar(2.)*(halfExtents.x());
 btScalar ly = btScalar(2.)*(halfExtents.y());
 btScalar lz = btScalar(2.)*(halfExtents.z());

 inertia.setValue(mass / (btScalar(12.0)) * (ly*ly + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + ly*ly));

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//#define DISABLE_BVH

#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
#include "LinearMath/btSerializer.h"

///Bvh Concave triangle mesh is a static-triangle mesh shape with Bounding Volume Hierarchy optimization.
///Uses an interface to access the triangles to allow for sharing graphics/physics triangles.
btBvhTriangleMeshShape::btBvhTriangleMeshShape(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, bool buildBvh)
 :btTriangleMeshShape(meshInterface),
 m_bvh(0),
 m_triangleInfoMap(0),
 m_useQuantizedAabbCompression(useQuantizedAabbCompression),
 m_ownsBvh(false)
{
 m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
 //construct bvh from meshInterface
#ifndef DISABLE_BVH

 if (buildBvh)
 {
  buildOptimizedBvh();
 }

#endif //DISABLE_BVH

}

btBvhTriangleMeshShape::btBvhTriangleMeshShape(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, bool buildBvh)
 :btTriangleMeshShape(meshInterface),
 m_bvh(0),
 m_triangleInfoMap(0),
 m_useQuantizedAabbCompression(useQuantizedAabbCompression),
 m_ownsBvh(false)
{
 m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
 //construct bvh from meshInterface
#ifndef DISABLE_BVH

 if (buildBvh)
 {
  void* mem = btAlignedAlloc(sizeof(btOptimizedBvh), 16);
  m_bvh = new (mem) btOptimizedBvh();

  m_bvh->build(meshInterface, m_useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
  m_ownsBvh = true;
 }

#endif //DISABLE_BVH

}

void	btBvhTriangleMeshShape::partialRefitTree(const btVector3& aabbMin, const btVector3& aabbMax)
{
 m_bvh->refitPartial(m_meshInterface, aabbMin, aabbMax);

 m_localAabbMin.setMin(aabbMin);
 m_localAabbMax.setMax(aabbMax);
}


void	btBvhTriangleMeshShape::refitTree(const btVector3& aabbMin, const btVector3& aabbMax)
{
 m_bvh->refit(m_meshInterface, aabbMin, aabbMax);

 recalcLocalAabb();
}

btBvhTriangleMeshShape::~btBvhTriangleMeshShape()
{
 if (m_ownsBvh)
 {
  m_bvh->~btOptimizedBvh();
  btAlignedFree(m_bvh);
 }
}

void	btBvhTriangleMeshShape::performRaycast(btTriangleCallback* callback, const btVector3& raySource, const btVector3& rayTarget)
{
 struct	MyNodeOverlapCallback : public btNodeOverlapCallback
 {
  btStridingMeshInterface*	m_meshInterface;
  btTriangleCallback* m_callback;

  MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
   :m_meshInterface(meshInterface),
   m_callback(callback)
  {
  }

  virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
  {
   btVector3 m_triangle[3];
   const unsigned char *vertexbase;
   int numverts;
   PHY_ScalarType type;
   int stride;
   const unsigned char *indexbase;
   int indexstride;
   int numfaces;
   PHY_ScalarType indicestype;

   m_meshInterface->getLockedReadOnlyVertexIndexBase(
    &vertexbase,
    numverts,
    type,
    stride,
    &indexbase,
    indexstride,
    numfaces,
    indicestype,
    nodeSubPart);

   unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex*indexstride);
   btAssert(indicestype == PHY_INTEGER || indicestype == PHY_SHORT);

   const btVector3& meshScaling = m_meshInterface->getScaling();
   for (int j = 2; j >= 0; j--)
   {
    int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : gfxbase[j];

    if (type == PHY_FLOAT)
    {
     float* graphicsbase = (float*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
    }
    else
    {
     double* graphicsbase = (double*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(btScalar(graphicsbase[0])*meshScaling.getX(), btScalar(graphicsbase[1])*meshScaling.getY(), btScalar(graphicsbase[2])*meshScaling.getZ());
    }
   }

   /* Perform ray vs. triangle collision here */
   m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
   m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
  }
 };

 MyNodeOverlapCallback	myNodeCallback(callback, m_meshInterface);

 m_bvh->reportRayOverlappingNodex(&myNodeCallback, raySource, rayTarget);
}

void	btBvhTriangleMeshShape::performConvexcast(btTriangleCallback* callback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax)
{
 struct	MyNodeOverlapCallback : public btNodeOverlapCallback
 {
  btStridingMeshInterface*	m_meshInterface;
  btTriangleCallback* m_callback;

  MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
   :m_meshInterface(meshInterface),
   m_callback(callback)
  {
  }

  virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
  {
   btVector3 m_triangle[3];
   const unsigned char *vertexbase;
   int numverts;
   PHY_ScalarType type;
   int stride;
   const unsigned char *indexbase;
   int indexstride;
   int numfaces;
   PHY_ScalarType indicestype;

   m_meshInterface->getLockedReadOnlyVertexIndexBase(
    &vertexbase,
    numverts,
    type,
    stride,
    &indexbase,
    indexstride,
    numfaces,
    indicestype,
    nodeSubPart);

   unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex*indexstride);
   btAssert(indicestype == PHY_INTEGER || indicestype == PHY_SHORT);

   const btVector3& meshScaling = m_meshInterface->getScaling();
   for (int j = 2; j >= 0; j--)
   {
    int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : gfxbase[j];

    if (type == PHY_FLOAT)
    {
     float* graphicsbase = (float*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
    }
    else
    {
     double* graphicsbase = (double*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(btScalar(graphicsbase[0])*meshScaling.getX(), btScalar(graphicsbase[1])*meshScaling.getY(), btScalar(graphicsbase[2])*meshScaling.getZ());
    }
   }

   /* Perform ray vs. triangle collision here */
   m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
   m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
  }
 };

 MyNodeOverlapCallback	myNodeCallback(callback, m_meshInterface);

 m_bvh->reportBoxCastOverlappingNodex(&myNodeCallback, raySource, rayTarget, aabbMin, aabbMax);
}

//perform bvh tree traversal and report overlapping triangles to 'callback'
void	btBvhTriangleMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{

#ifdef DISABLE_BVH
 //brute force traverse all triangles
 btTriangleMeshShape::processAllTriangles(callback, aabbMin, aabbMax);
#else

 //first get all the nodes


 struct	MyNodeOverlapCallback : public btNodeOverlapCallback
 {
  btStridingMeshInterface*	m_meshInterface;
  btTriangleCallback*		m_callback;
  btVector3				m_triangle[3];
  int m_numOverlap;

  MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
   :m_meshInterface(meshInterface),
   m_callback(callback),
   m_numOverlap(0)
  {
  }

  virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
  {
   m_numOverlap++;
   const unsigned char *vertexbase;
   int numverts;
   PHY_ScalarType type;
   int stride;
   const unsigned char *indexbase;
   int indexstride;
   int numfaces;
   PHY_ScalarType indicestype;


   m_meshInterface->getLockedReadOnlyVertexIndexBase(
    &vertexbase,
    numverts,
    type,
    stride,
    &indexbase,
    indexstride,
    numfaces,
    indicestype,
    nodeSubPart);

   unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex*indexstride);
   btAssert(indicestype == PHY_INTEGER || indicestype == PHY_SHORT || indicestype == PHY_UCHAR);

   const btVector3& meshScaling = m_meshInterface->getScaling();
   for (int j = 2; j >= 0; j--)
   {

    int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : indicestype == PHY_INTEGER ? gfxbase[j] : ((unsigned char*)gfxbase)[j];


#ifdef DEBUG_TRIANGLE_MESH
    printf("%d ,", graphicsindex);
#endif //DEBUG_TRIANGLE_MESH
    if (type == PHY_FLOAT)
    {
     float* graphicsbase = (float*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(
      graphicsbase[0] * meshScaling.getX(),
      graphicsbase[1] * meshScaling.getY(),
      graphicsbase[2] * meshScaling.getZ());
    }
    else
    {
     double* graphicsbase = (double*)(vertexbase + graphicsindex*stride);

     m_triangle[j] = btVector3(
      btScalar(graphicsbase[0])*meshScaling.getX(),
      btScalar(graphicsbase[1])*meshScaling.getY(),
      btScalar(graphicsbase[2])*meshScaling.getZ());
    }
#ifdef DEBUG_TRIANGLE_MESH
    printf("triangle vertices:%f,%f,%f\n", triangle[j].x(), triangle[j].y(), triangle[j].z());
#endif //DEBUG_TRIANGLE_MESH
   }

   m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
   m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
  }

 };

 MyNodeOverlapCallback	myNodeCallback(callback, m_meshInterface);

 m_bvh->reportAabbOverlappingNodex(&myNodeCallback, aabbMin, aabbMax);

#endif//DISABLE_BVH


}

void   btBvhTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
 if ((getLocalScaling() - scaling).length2() > SIMD_EPSILON)
 {
  btTriangleMeshShape::setLocalScaling(scaling);
  buildOptimizedBvh();
 }
}

void   btBvhTriangleMeshShape::buildOptimizedBvh()
{
 if (m_ownsBvh)
 {
  m_bvh->~btOptimizedBvh();
  btAlignedFree(m_bvh);
 }
 ///m_localAabbMin/m_localAabbMax is already re-calculated in btTriangleMeshShape. We could just scale aabb, but this needs some more work
 void* mem = btAlignedAlloc(sizeof(btOptimizedBvh), 16);
 m_bvh = new(mem) btOptimizedBvh();
 //rebuild the bvh...
 m_bvh->build(m_meshInterface, m_useQuantizedAabbCompression, m_localAabbMin, m_localAabbMax);
 m_ownsBvh = true;
}

void   btBvhTriangleMeshShape::setOptimizedBvh(btOptimizedBvh* bvh, const btVector3& scaling)
{
 btAssert(!m_bvh);
 btAssert(!m_ownsBvh);

 m_bvh = bvh;
 m_ownsBvh = false;
 // update the scaling without rebuilding the bvh
 if ((getLocalScaling() - scaling).length2() > SIMD_EPSILON)
 {
  btTriangleMeshShape::setLocalScaling(scaling);
 }
}



///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btBvhTriangleMeshShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btTriangleMeshShapeData* trimeshData = (btTriangleMeshShapeData*)dataBuffer;

 btCollisionShape::serialize(&trimeshData->m_collisionShapeData, serializer);

 m_meshInterface->serialize(&trimeshData->m_meshInterface, serializer);

 trimeshData->m_collisionMargin = float(m_collisionMargin);



 if (m_bvh && !(serializer->getSerializationFlags()&BT_SERIALIZE_NO_BVH))
 {
  void* chunk = serializer->findPointer(m_bvh);
  if (chunk)
  {
#ifdef BT_USE_DOUBLE_PRECISION
   trimeshData->m_quantizedDoubleBvh = (btQuantizedBvhData*)chunk;
   trimeshData->m_quantizedFloatBvh = 0;
#else
   trimeshData->m_quantizedFloatBvh = (btQuantizedBvhData*)chunk;
   trimeshData->m_quantizedDoubleBvh = 0;
#endif //BT_USE_DOUBLE_PRECISION
  }
  else
  {

#ifdef BT_USE_DOUBLE_PRECISION
   trimeshData->m_quantizedDoubleBvh = (btQuantizedBvhData*)serializer->getUniquePointer(m_bvh);
   trimeshData->m_quantizedFloatBvh = 0;
#else
   trimeshData->m_quantizedFloatBvh = (btQuantizedBvhData*)serializer->getUniquePointer(m_bvh);
   trimeshData->m_quantizedDoubleBvh = 0;
#endif //BT_USE_DOUBLE_PRECISION

   int sz = m_bvh->calculateSerializeBufferSizeNew();
   btChunk* chunk = serializer->allocate(sz, 1);
   const char* structType = m_bvh->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_QUANTIZED_BVH_CODE, m_bvh);
  }
 }
 else
 {
  trimeshData->m_quantizedFloatBvh = 0;
  trimeshData->m_quantizedDoubleBvh = 0;
 }



 if (m_triangleInfoMap && !(serializer->getSerializationFlags()&BT_SERIALIZE_NO_TRIANGLEINFOMAP))
 {
  void* chunk = serializer->findPointer(m_triangleInfoMap);
  if (chunk)
  {
   trimeshData->m_triangleInfoMap = (btTriangleInfoMapData*)chunk;
  }
  else
  {
   trimeshData->m_triangleInfoMap = (btTriangleInfoMapData*)serializer->getUniquePointer(m_triangleInfoMap);
   int sz = m_triangleInfoMap->calculateSerializeBufferSize();
   btChunk* chunk = serializer->allocate(sz, 1);
   const char* structType = m_triangleInfoMap->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_TRIANLGE_INFO_MAP, m_triangleInfoMap);
  }
 }
 else
 {
  trimeshData->m_triangleInfoMap = 0;
 }

 // Fill padding with zeros to appease msan.
 memset(trimeshData->m_pad3, 0, sizeof(trimeshData->m_pad3));

 return "btTriangleMeshShapeData";
}

void	btBvhTriangleMeshShape::serializeSingleBvh(btSerializer* serializer) const
{
 if (m_bvh)
 {
  int len = m_bvh->calculateSerializeBufferSizeNew(); //make sure not to use calculateSerializeBufferSize because it is used for in-place
  btChunk* chunk = serializer->allocate(len, 1);
  const char* structType = m_bvh->serialize(chunk->m_oldPtr, serializer);
  serializer->finalizeChunk(chunk, structType, BT_QUANTIZED_BVH_CODE, (void*)m_bvh);
 }
}

void	btBvhTriangleMeshShape::serializeSingleTriangleInfoMap(btSerializer* serializer) const
{
 if (m_triangleInfoMap)
 {
  int len = m_triangleInfoMap->calculateSerializeBufferSize();
  btChunk* chunk = serializer->allocate(len, 1);
  const char* structType = m_triangleInfoMap->serialize(chunk->m_oldPtr, serializer);
  serializer->finalizeChunk(chunk, structType, BT_TRIANLGE_INFO_MAP, (void*)m_triangleInfoMap);
 }
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btCapsuleShape.h"

#include "LinearMath/btQuaternion.h"

btCapsuleShape::btCapsuleShape(btScalar radius, btScalar height) : btConvexInternalShape()
{
 m_collisionMargin = radius;
 m_shapeType = CAPSULE_SHAPE_PROXYTYPE;
 m_upAxis = 1;
 m_implicitShapeDimensions.setValue(radius, 0.5f*height, radius);
}


btVector3	btCapsuleShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0)const
{

 btVector3 supVec(0, 0, 0);

 btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

 btVector3 vec = vec0;
 btScalar lenSqr = vec.length2();
 if (lenSqr < btScalar(0.0001))
 {
  vec.setValue(1, 0, 0);
 }
 else
 {
  btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
  vec *= rlen;
 }

 btVector3 vtx;
 btScalar newDot;



 {
  btVector3 pos(0, 0, 0);
  pos[getUpAxis()] = getHalfHeight();

  vtx = pos;
  newDot = vec.dot(vtx);
  if (newDot > maxDot)
  {
   maxDot = newDot;
   supVec = vtx;
  }
 }
 {
  btVector3 pos(0, 0, 0);
  pos[getUpAxis()] = -getHalfHeight();

  vtx = pos;
  newDot = vec.dot(vtx);
  if (newDot > maxDot)
  {
   maxDot = newDot;
   supVec = vtx;
  }
 }

 return supVec;

}

void	btCapsuleShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{



 for (int j = 0; j<numVectors; j++)
 {
  btScalar maxDot(btScalar(-BT_LARGE_FLOAT));
  const btVector3& vec = vectors[j];

  btVector3 vtx;
  btScalar newDot;
  {
   btVector3 pos(0, 0, 0);
   pos[getUpAxis()] = getHalfHeight();
   vtx = pos;
   newDot = vec.dot(vtx);
   if (newDot > maxDot)
   {
    maxDot = newDot;
    supportVerticesOut[j] = vtx;
   }
  }
  {
   btVector3 pos(0, 0, 0);
   pos[getUpAxis()] = -getHalfHeight();
   vtx = pos;
   newDot = vec.dot(vtx);
   if (newDot > maxDot)
   {
    maxDot = newDot;
    supportVerticesOut[j] = vtx;
   }
  }

 }
}


void	btCapsuleShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 //as an approximation, take the inertia of the box that bounds the spheres

 btTransform ident;
 ident.setIdentity();


 btScalar radius = getRadius();

 btVector3 halfExtents(radius, radius, radius);
 halfExtents[getUpAxis()] += getHalfHeight();

 btScalar lx = btScalar(2.)*(halfExtents[0]);
 btScalar ly = btScalar(2.)*(halfExtents[1]);
 btScalar lz = btScalar(2.)*(halfExtents[2]);
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(.08333333);

 inertia[0] = scaledmass * (y2 + z2);
 inertia[1] = scaledmass * (x2 + z2);
 inertia[2] = scaledmass * (x2 + y2);

}

btCapsuleShapeX::btCapsuleShapeX(btScalar radius, btScalar height)
{
 m_collisionMargin = radius;
 m_upAxis = 0;
 m_implicitShapeDimensions.setValue(0.5f*height, radius, radius);
}






btCapsuleShapeZ::btCapsuleShapeZ(btScalar radius, btScalar height)
{
 m_collisionMargin = radius;
 m_upAxis = 2;
 m_implicitShapeDimensions.setValue(radius, radius, 0.5f*height);
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "LinearMath/btSerializer.h"

/*
Make sure this dummy function never changes so that it
can be used by probes that are checking whether the
library is actually installed.
*/
extern "C"
{
 void btBulletCollisionProbe();

 void btBulletCollisionProbe() {}
}



void	btCollisionShape::getBoundingSphere(btVector3& center, btScalar& radius) const
{
 btTransform tr;
 tr.setIdentity();
 btVector3 aabbMin, aabbMax;

 getAabb(tr, aabbMin, aabbMax);

 radius = (aabbMax - aabbMin).length()*btScalar(0.5);
 center = (aabbMin + aabbMax)*btScalar(0.5);
}


btScalar	btCollisionShape::getContactBreakingThreshold(btScalar defaultContactThreshold) const
{
 return getAngularMotionDisc() * defaultContactThreshold;
}

btScalar	btCollisionShape::getAngularMotionDisc() const
{
 ///@todo cache this value, to improve performance
 btVector3	center;
 btScalar disc;
 getBoundingSphere(center, disc);
 disc += (center).length();
 return disc;
}

void btCollisionShape::calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const
{
 //start with static aabb
 getAabb(curTrans, temporalAabbMin, temporalAabbMax);

 btScalar temporalAabbMaxx = temporalAabbMax.getX();
 btScalar temporalAabbMaxy = temporalAabbMax.getY();
 btScalar temporalAabbMaxz = temporalAabbMax.getZ();
 btScalar temporalAabbMinx = temporalAabbMin.getX();
 btScalar temporalAabbMiny = temporalAabbMin.getY();
 btScalar temporalAabbMinz = temporalAabbMin.getZ();

 // add linear motion
 btVector3 linMotion = linvel*timeStep;
 ///@todo: simd would have a vector max/min operation, instead of per-element access
 if (linMotion.x() > btScalar(0.))
  temporalAabbMaxx += linMotion.x();
 else
  temporalAabbMinx += linMotion.x();
 if (linMotion.y() > btScalar(0.))
  temporalAabbMaxy += linMotion.y();
 else
  temporalAabbMiny += linMotion.y();
 if (linMotion.z() > btScalar(0.))
  temporalAabbMaxz += linMotion.z();
 else
  temporalAabbMinz += linMotion.z();

 //add conservative angular motion
 btScalar angularMotion = angvel.length() * getAngularMotionDisc() * timeStep;
 btVector3 angularMotion3d(angularMotion, angularMotion, angularMotion);
 temporalAabbMin = btVector3(temporalAabbMinx, temporalAabbMiny, temporalAabbMinz);
 temporalAabbMax = btVector3(temporalAabbMaxx, temporalAabbMaxy, temporalAabbMaxz);

 temporalAabbMin -= angularMotion3d;
 temporalAabbMax += angularMotion3d;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btCollisionShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btCollisionShapeData* shapeData = (btCollisionShapeData*)dataBuffer;
 char* name = (char*)serializer->findNameForPointer(this);
 shapeData->m_name = (char*)serializer->getUniquePointer(name);
 if (shapeData->m_name)
 {
  serializer->serializeName(name);
 }
 shapeData->m_shapeType = m_shapeType;

 // Fill padding with zeros to appease msan.
 memset(shapeData->m_padding, 0, sizeof(shapeData->m_padding));

 return "btCollisionShapeData";
}

void	btCollisionShape::serializeSingleShape(btSerializer* serializer) const
{
 int len = calculateSerializeBufferSize();
 btChunk* chunk = serializer->allocate(len, 1);
 const char* structType = serialize(chunk->m_oldPtr, serializer);
 serializer->finalizeChunk(chunk, structType, BT_SHAPE_CODE, (void*)this);
}/*
 Bullet Continuous Collision Detection and Physics Library
 Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from the use of this software.
 Permission is granted to anyone to use this software for any purpose,
 including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.
 */

#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btSerializer.h"

btCompoundShape::btCompoundShape(bool enableDynamicAabbTree, const int initialChildCapacity)
 : m_localAabbMin(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT)),
 m_localAabbMax(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT)),
 m_dynamicAabbTree(0),
 m_updateRevision(1),
 m_collisionMargin(btScalar(0.)),
 m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.))
{
 m_shapeType = COMPOUND_SHAPE_PROXYTYPE;

 if (enableDynamicAabbTree)
 {
  void* mem = btAlignedAlloc(sizeof(btDbvt), 16);
  m_dynamicAabbTree = new(mem) btDbvt();
  btAssert(mem == m_dynamicAabbTree);
 }

 m_children.reserve(initialChildCapacity);
}


btCompoundShape::~btCompoundShape()
{
 if (m_dynamicAabbTree)
 {
  m_dynamicAabbTree->~btDbvt();
  btAlignedFree(m_dynamicAabbTree);
 }
}

void	btCompoundShape::addChildShape(const btTransform& localTransform, btCollisionShape* shape)
{
 m_updateRevision++;
 //m_childTransforms.push_back(localTransform);
 //m_childShapes.push_back(shape);
 btCompoundShapeChild child;
 child.m_node = 0;
 child.m_transform = localTransform;
 child.m_childShape = shape;
 child.m_childShapeType = shape->getShapeType();
 child.m_childMargin = shape->getMargin();


 //extend the local aabbMin/aabbMax
 btVector3 localAabbMin, localAabbMax;
 shape->getAabb(localTransform, localAabbMin, localAabbMax);
 for (int i = 0; i<3; i++)
 {
  if (m_localAabbMin[i] > localAabbMin[i])
  {
   m_localAabbMin[i] = localAabbMin[i];
  }
  if (m_localAabbMax[i] < localAabbMax[i])
  {
   m_localAabbMax[i] = localAabbMax[i];
  }

 }
 if (m_dynamicAabbTree)
 {
  const btDbvtVolume	bounds = btDbvtVolume::FromMM(localAabbMin, localAabbMax);
  size_t index = m_children.size();
  child.m_node = m_dynamicAabbTree->insert(bounds, reinterpret_cast<void*>(index));
 }

 m_children.push_back(child);

}

void	btCompoundShape::updateChildTransform(int childIndex, const btTransform& newChildTransform, bool shouldRecalculateLocalAabb)
{
 m_children[childIndex].m_transform = newChildTransform;

 if (m_dynamicAabbTree)
 {
  ///update the dynamic aabb tree
  btVector3 localAabbMin, localAabbMax;
  m_children[childIndex].m_childShape->getAabb(newChildTransform, localAabbMin, localAabbMax);
  ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds = btDbvtVolume::FromMM(localAabbMin, localAabbMax);
  //int index = m_children.size()-1;
  m_dynamicAabbTree->update(m_children[childIndex].m_node, bounds);
 }

 if (shouldRecalculateLocalAabb)
 {
  recalculateLocalAabb();
 }
}

void btCompoundShape::removeChildShapeByIndex(int childShapeIndex)
{
 m_updateRevision++;
 btAssert(childShapeIndex >= 0 && childShapeIndex < m_children.size());
 if (m_dynamicAabbTree)
 {
  m_dynamicAabbTree->remove(m_children[childShapeIndex].m_node);
 }
 m_children.swap(childShapeIndex, m_children.size() - 1);
 if (m_dynamicAabbTree)
  m_children[childShapeIndex].m_node->dataAsInt = childShapeIndex;
 m_children.pop_back();

}



void btCompoundShape::removeChildShape(btCollisionShape* shape)
{
 m_updateRevision++;
 // Find the children containing the shape specified, and remove those children.
 //note: there might be multiple children using the same shape!
 for (int i = m_children.size() - 1; i >= 0; i--)
 {
  if (m_children[i].m_childShape == shape)
  {
   removeChildShapeByIndex(i);
  }
 }



 recalculateLocalAabb();
}

void btCompoundShape::recalculateLocalAabb()
{
 // Recalculate the local aabb
 // Brute force, it iterates over all the shapes left.

 m_localAabbMin = btVector3(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 m_localAabbMax = btVector3(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));

 //extend the local aabbMin/aabbMax
 for (int j = 0; j < m_children.size(); j++)
 {
  btVector3 localAabbMin, localAabbMax;
  m_children[j].m_childShape->getAabb(m_children[j].m_transform, localAabbMin, localAabbMax);
  for (int i = 0; i<3; i++)
  {
   if (m_localAabbMin[i] > localAabbMin[i])
    m_localAabbMin[i] = localAabbMin[i];
   if (m_localAabbMax[i] < localAabbMax[i])
    m_localAabbMax[i] = localAabbMax[i];
  }
 }
}

///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
void btCompoundShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
 btVector3 localHalfExtents = btScalar(0.5)*(m_localAabbMax - m_localAabbMin);
 btVector3 localCenter = btScalar(0.5)*(m_localAabbMax + m_localAabbMin);

 //avoid an illegal AABB when there are no children
 if (!m_children.size())
 {
  localHalfExtents.setValue(0, 0, 0);
  localCenter.setValue(0, 0, 0);
 }
 localHalfExtents += btVector3(getMargin(), getMargin(), getMargin());


 btMatrix3x3 abs_b = trans.getBasis().absolute();

 btVector3 center = trans(localCenter);

 btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
 aabbMin = center - extent;
 aabbMax = center + extent;

}

void	btCompoundShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 //approximation: take the inertia from the aabb for now
 btTransform ident;
 ident.setIdentity();
 btVector3 aabbMin, aabbMax;
 getAabb(ident, aabbMin, aabbMax);

 btVector3 halfExtents = (aabbMax - aabbMin)*btScalar(0.5);

 btScalar lx = btScalar(2.)*(halfExtents.x());
 btScalar ly = btScalar(2.)*(halfExtents.y());
 btScalar lz = btScalar(2.)*(halfExtents.z());

 inertia[0] = mass / (btScalar(12.0)) * (ly*ly + lz*lz);
 inertia[1] = mass / (btScalar(12.0)) * (lx*lx + lz*lz);
 inertia[2] = mass / (btScalar(12.0)) * (lx*lx + ly*ly);

}




void btCompoundShape::calculatePrincipalAxisTransform(btScalar* masses, btTransform& principal, btVector3& inertia) const
{
 int n = m_children.size();

 btScalar totalMass = 0;
 btVector3 center(0, 0, 0);
 int k;

 for (k = 0; k < n; k++)
 {
  btAssert(masses[k]>0);
  center += m_children[k].m_transform.getOrigin() * masses[k];
  totalMass += masses[k];
 }

 btAssert(totalMass>0);

 center /= totalMass;
 principal.setOrigin(center);

 btMatrix3x3 tensor(0, 0, 0, 0, 0, 0, 0, 0, 0);
 for (k = 0; k < n; k++)
 {
  btVector3 i;
  m_children[k].m_childShape->calculateLocalInertia(masses[k], i);

  const btTransform& t = m_children[k].m_transform;
  btVector3 o = t.getOrigin() - center;

  //compute inertia tensor in coordinate system of compound shape
  btMatrix3x3 j = t.getBasis().transpose();
  j[0] *= i[0];
  j[1] *= i[1];
  j[2] *= i[2];
  j = t.getBasis() * j;

  //add inertia tensor
  tensor[0] += j[0];
  tensor[1] += j[1];
  tensor[2] += j[2];

  //compute inertia tensor of pointmass at o
  btScalar o2 = o.length2();
  j[0].setValue(o2, 0, 0);
  j[1].setValue(0, o2, 0);
  j[2].setValue(0, 0, o2);
  j[0] += o * -o.x();
  j[1] += o * -o.y();
  j[2] += o * -o.z();

  //add inertia tensor of pointmass
  tensor[0] += masses[k] * j[0];
  tensor[1] += masses[k] * j[1];
  tensor[2] += masses[k] * j[2];
 }

 tensor.diagonalize(principal.getBasis(), btScalar(0.00001), 20);
 inertia.setValue(tensor[0][0], tensor[1][1], tensor[2][2]);
}





void btCompoundShape::setLocalScaling(const btVector3& scaling)
{

 for (int i = 0; i < m_children.size(); i++)
 {
  btTransform childTrans = getChildTransform(i);
  btVector3 childScale = m_children[i].m_childShape->getLocalScaling();
  //		childScale = childScale * (childTrans.getBasis() * scaling);
  childScale = childScale * scaling / m_localScaling;
  m_children[i].m_childShape->setLocalScaling(childScale);
  childTrans.setOrigin((childTrans.getOrigin()) * scaling / m_localScaling);
  updateChildTransform(i, childTrans, false);
 }

 m_localScaling = scaling;
 recalculateLocalAabb();

}


void btCompoundShape::createAabbTreeFromChildren()
{
 if (!m_dynamicAabbTree)
 {
  void* mem = btAlignedAlloc(sizeof(btDbvt), 16);
  m_dynamicAabbTree = new(mem) btDbvt();
  btAssert(mem == m_dynamicAabbTree);

  for (int index = 0; index < m_children.size(); index++)
  {
   btCompoundShapeChild &child = m_children[index];

   //extend the local aabbMin/aabbMax
   btVector3 localAabbMin, localAabbMax;
   child.m_childShape->getAabb(child.m_transform, localAabbMin, localAabbMax);

   const btDbvtVolume  bounds = btDbvtVolume::FromMM(localAabbMin, localAabbMax);
   size_t index2 = index;
   child.m_node = m_dynamicAabbTree->insert(bounds, reinterpret_cast<void*>(index2));
  }
 }
}


///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btCompoundShape::serialize(void* dataBuffer, btSerializer* serializer) const
{

 btCompoundShapeData* shapeData = (btCompoundShapeData*)dataBuffer;
 btCollisionShape::serialize(&shapeData->m_collisionShapeData, serializer);

 shapeData->m_collisionMargin = float(m_collisionMargin);
 shapeData->m_numChildShapes = m_children.size();
 shapeData->m_childShapePtr = 0;
 if (shapeData->m_numChildShapes)
 {
  btChunk* chunk = serializer->allocate(sizeof(btCompoundShapeChildData), shapeData->m_numChildShapes);
  btCompoundShapeChildData* memPtr = (btCompoundShapeChildData*)chunk->m_oldPtr;
  shapeData->m_childShapePtr = (btCompoundShapeChildData*)serializer->getUniquePointer(memPtr);

  for (int i = 0; i<shapeData->m_numChildShapes; i++, memPtr++)
  {
   memPtr->m_childMargin = float(m_children[i].m_childMargin);
   memPtr->m_childShape = (btCollisionShapeData*)serializer->getUniquePointer(m_children[i].m_childShape);
   //don't serialize shapes that already have been serialized
   if (!serializer->findPointer(m_children[i].m_childShape))
   {
    btChunk* chunk = serializer->allocate(m_children[i].m_childShape->calculateSerializeBufferSize(), 1);
    const char* structType = m_children[i].m_childShape->serialize(chunk->m_oldPtr, serializer);
    serializer->finalizeChunk(chunk, structType, BT_SHAPE_CODE, m_children[i].m_childShape);
   }

   memPtr->m_childShapeType = m_children[i].m_childShapeType;
   m_children[i].m_transform.serializeFloat(memPtr->m_transform);
  }
  serializer->finalizeChunk(chunk, "btCompoundShapeChildData", BT_ARRAY_CODE, chunk->m_oldPtr);
 }
 return "btCompoundShapeData";
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btConcaveShape.h"

btConcaveShape::btConcaveShape() : m_collisionMargin(btScalar(0.))
{

}

btConcaveShape::~btConcaveShape()
{

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConeShape.h"



btConeShape::btConeShape(btScalar radius, btScalar height) : btConvexInternalShape(),
m_radius(radius),
m_height(height)
{
 m_shapeType = CONE_SHAPE_PROXYTYPE;
 setConeUpIndex(1);
 btVector3 halfExtents;
 m_sinAngle = (m_radius / btSqrt(m_radius * m_radius + m_height * m_height));
}

btConeShapeZ::btConeShapeZ(btScalar radius, btScalar height) :
 btConeShape(radius, height)
{
 setConeUpIndex(2);
}

btConeShapeX::btConeShapeX(btScalar radius, btScalar height) :
 btConeShape(radius, height)
{
 setConeUpIndex(0);
}

///choose upAxis index
void	btConeShape::setConeUpIndex(int upIndex)
{
 switch (upIndex)
 {
 case 0:
  m_coneIndices[0] = 1;
  m_coneIndices[1] = 0;
  m_coneIndices[2] = 2;
  break;
 case 1:
  m_coneIndices[0] = 0;
  m_coneIndices[1] = 1;
  m_coneIndices[2] = 2;
  break;
 case 2:
  m_coneIndices[0] = 0;
  m_coneIndices[1] = 2;
  m_coneIndices[2] = 1;
  break;
 default:
  btAssert(0);
 };

 m_implicitShapeDimensions[m_coneIndices[0]] = m_radius;
 m_implicitShapeDimensions[m_coneIndices[1]] = m_height;
 m_implicitShapeDimensions[m_coneIndices[2]] = m_radius;
}

btVector3 btConeShape::coneLocalSupport(const btVector3& v) const
{

 btScalar halfHeight = m_height * btScalar(0.5);

 if (v[m_coneIndices[1]] > v.length() * m_sinAngle)
 {
  btVector3 tmp;

  tmp[m_coneIndices[0]] = btScalar(0.);
  tmp[m_coneIndices[1]] = halfHeight;
  tmp[m_coneIndices[2]] = btScalar(0.);
  return tmp;
 }
 else {
  btScalar s = btSqrt(v[m_coneIndices[0]] * v[m_coneIndices[0]] + v[m_coneIndices[2]] * v[m_coneIndices[2]]);
  if (s > SIMD_EPSILON) {
   btScalar d = m_radius / s;
   btVector3 tmp;
   tmp[m_coneIndices[0]] = v[m_coneIndices[0]] * d;
   tmp[m_coneIndices[1]] = -halfHeight;
   tmp[m_coneIndices[2]] = v[m_coneIndices[2]] * d;
   return tmp;
  }
  else {
   btVector3 tmp;
   tmp[m_coneIndices[0]] = btScalar(0.);
   tmp[m_coneIndices[1]] = -halfHeight;
   tmp[m_coneIndices[2]] = btScalar(0.);
   return tmp;
  }
 }

}

btVector3	btConeShape::localGetSupportingVertexWithoutMargin(const btVector3& vec) const
{
 return coneLocalSupport(vec);
}

void	btConeShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 for (int i = 0; i<numVectors; i++)
 {
  const btVector3& vec = vectors[i];
  supportVerticesOut[i] = coneLocalSupport(vec);
 }
}


btVector3	btConeShape::localGetSupportingVertex(const btVector3& vec)  const
{
 btVector3 supVertex = coneLocalSupport(vec);
 if (getMargin() != btScalar(0.))
 {
  btVector3 vecnorm = vec;
  if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
  {
   vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
  }
  vecnorm.normalize();
  supVertex += getMargin() * vecnorm;
 }
 return supVertex;
}


void	btConeShape::setLocalScaling(const btVector3& scaling)
{
 int axis = m_coneIndices[1];
 int r1 = m_coneIndices[0];
 int r2 = m_coneIndices[2];
 m_height *= scaling[axis] / m_localScaling[axis];
 m_radius *= (scaling[r1] / m_localScaling[r1] + scaling[r2] / m_localScaling[r2]) / 2;
 m_sinAngle = (m_radius / btSqrt(m_radius * m_radius + m_height * m_height));
 btConvexInternalShape::setLocalScaling(scaling);
}/*
 Bullet Continuous Collision Detection and Physics Library
 Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from the use of this software.
 Permission is granted to anyone to use this software for any purpose,
 including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.
 */

#include "BulletCollision/CollisionShapes/btConvex2dShape.h"

btConvex2dShape::btConvex2dShape(btConvexShape* convexChildShape) :
 btConvexShape(), m_childConvexShape(convexChildShape)
{
 m_shapeType = CONVEX_2D_SHAPE_PROXYTYPE;
}

btConvex2dShape::~btConvex2dShape()
{
}



btVector3	btConvex2dShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 return m_childConvexShape->localGetSupportingVertexWithoutMargin(vec);
}

void	btConvex2dShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 m_childConvexShape->batchedUnitVectorGetSupportingVertexWithoutMargin(vectors, supportVerticesOut, numVectors);
}


btVector3	btConvex2dShape::localGetSupportingVertex(const btVector3& vec)const
{
 return m_childConvexShape->localGetSupportingVertex(vec);
}


void	btConvex2dShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 ///this linear upscaling is not realistic, but we don't deal with large mass ratios...
 m_childConvexShape->calculateLocalInertia(mass, inertia);
}


///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
void btConvex2dShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 m_childConvexShape->getAabb(t, aabbMin, aabbMax);
}

void btConvex2dShape::getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 m_childConvexShape->getAabbSlow(t, aabbMin, aabbMax);
}

void	btConvex2dShape::setLocalScaling(const btVector3& scaling)
{
 m_childConvexShape->setLocalScaling(scaling);
}

const btVector3& btConvex2dShape::getLocalScaling() const
{
 return m_childConvexShape->getLocalScaling();
}

void	btConvex2dShape::setMargin(btScalar margin)
{
 m_childConvexShape->setMargin(margin);
}
btScalar	btConvex2dShape::getMargin() const
{
 return m_childConvexShape->getMargin();
}

int		btConvex2dShape::getNumPreferredPenetrationDirections() const
{
 return m_childConvexShape->getNumPreferredPenetrationDirections();
}

void	btConvex2dShape::getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
{
 m_childConvexShape->getPreferredPenetrationDirection(index, penetrationVector);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined (_WIN32) || defined (__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btConvexHullComputer.h"

btConvexHullShape::btConvexHullShape(const btScalar* points, int numPoints, int stride) : btPolyhedralConvexAabbCachingShape()
{
 m_shapeType = CONVEX_HULL_SHAPE_PROXYTYPE;
 m_unscaledPoints.resize(numPoints);

 unsigned char* pointsAddress = (unsigned char*)points;

 for (int i = 0; i<numPoints; i++)
 {
  btScalar* point = (btScalar*)pointsAddress;
  m_unscaledPoints[i] = btVector3(point[0], point[1], point[2]);
  pointsAddress += stride;
 }

 recalcLocalAabb();

}



void btConvexHullShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling;
 recalcLocalAabb();
}

void btConvexHullShape::addPoint(const btVector3& point, bool recalculateLocalAabb)
{
 m_unscaledPoints.push_back(point);
 if (recalculateLocalAabb)
  recalcLocalAabb();

}

btVector3	btConvexHullShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 btVector3 supVec(btScalar(0.), btScalar(0.), btScalar(0.));
 btScalar maxDot = btScalar(-BT_LARGE_FLOAT);

 // Here we take advantage of dot(a, b*c) = dot(a*b, c).  Note: This is true mathematically, but not numerically. 
 if (0 < m_unscaledPoints.size())
 {
  btVector3 scaled = vec * m_localScaling;
  int index = (int)scaled.maxDot(&m_unscaledPoints[0], m_unscaledPoints.size(), maxDot); // FIXME: may violate encapsulation of m_unscaledPoints
  return m_unscaledPoints[index] * m_localScaling;
 }

 return supVec;
}

void	btConvexHullShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 btScalar newDot;
 //use 'w' component of supportVerticesOut?
 {
  for (int i = 0; i<numVectors; i++)
  {
   supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
  }
 }

 for (int j = 0; j<numVectors; j++)
 {
  btVector3 vec = vectors[j] * m_localScaling;        // dot(a*b,c) = dot(a,b*c)
  if (0 <  m_unscaledPoints.size())
  {
   int i = (int)vec.maxDot(&m_unscaledPoints[0], m_unscaledPoints.size(), newDot);
   supportVerticesOut[j] = getScaledPoint(i);
   supportVerticesOut[j][3] = newDot;
  }
  else
   supportVerticesOut[j][3] = -BT_LARGE_FLOAT;
 }



}



btVector3	btConvexHullShape::localGetSupportingVertex(const btVector3& vec)const
{
 btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

 if (getMargin() != btScalar(0.))
 {
  btVector3 vecnorm = vec;
  if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
  {
   vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
  }
  vecnorm.normalize();
  supVertex += getMargin() * vecnorm;
 }
 return supVertex;
}


void btConvexHullShape::optimizeConvexHull()
{
 btConvexHullComputer conv;
 conv.compute(&m_unscaledPoints[0].getX(), sizeof(btVector3), m_unscaledPoints.size(), 0.f, 0.f);
 int numVerts = conv.vertices.size();
 m_unscaledPoints.resize(0);
 for (int i = 0; i<numVerts; i++)
 {
  m_unscaledPoints.push_back(conv.vertices[i]);
 }
}



//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexHullShape with the Raytracer Demo
int	btConvexHullShape::getNumVertices() const
{
 return m_unscaledPoints.size();
}

int btConvexHullShape::getNumEdges() const
{
 return m_unscaledPoints.size();
}

void btConvexHullShape::getEdge(int i, btVector3& pa, btVector3& pb) const
{

 int index0 = i%m_unscaledPoints.size();
 int index1 = (i + 1) % m_unscaledPoints.size();
 pa = getScaledPoint(index0);
 pb = getScaledPoint(index1);
}

void btConvexHullShape::getVertex(int i, btVector3& vtx) const
{
 vtx = getScaledPoint(i);
}

int	btConvexHullShape::getNumPlanes() const
{
 return 0;
}

void btConvexHullShape::getPlane(btVector3&, btVector3&, int) const
{

 btAssert(0);
}

//not yet
bool btConvexHullShape::isInside(const btVector3&, btScalar) const
{
 btAssert(0);
 return false;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btConvexHullShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
 //int szc = sizeof(btConvexHullShapeData);
 btConvexHullShapeData* shapeData = (btConvexHullShapeData*)dataBuffer;
 btConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serializer);

 int numElem = m_unscaledPoints.size();
 shapeData->m_numUnscaledPoints = numElem;
#ifdef BT_USE_DOUBLE_PRECISION
 shapeData->m_unscaledPointsFloatPtr = 0;
 shapeData->m_unscaledPointsDoublePtr = numElem ? (btVector3Data*)serializer->getUniquePointer((void*)&m_unscaledPoints[0]) : 0;
#else
 shapeData->m_unscaledPointsFloatPtr = numElem ? (btVector3Data*)serializer->getUniquePointer((void*)&m_unscaledPoints[0]) : 0;
 shapeData->m_unscaledPointsDoublePtr = 0;
#endif

 if (numElem)
 {
  int sz = sizeof(btVector3Data);
  //	int sz2 = sizeof(btVector3DoubleData);
  //	int sz3 = sizeof(btVector3FloatData);
  btChunk* chunk = serializer->allocate(sz, numElem);
  btVector3Data* memPtr = (btVector3Data*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   m_unscaledPoints[i].serialize(*memPtr);
  }
  serializer->finalizeChunk(chunk, btVector3DataName, BT_ARRAY_CODE, (void*)&m_unscaledPoints[0]);
 }

 // Fill padding with zeros to appease msan.
 memset(shapeData->m_padding3, 0, sizeof(shapeData->m_padding3));

 return "btConvexHullShapeData";
}

void btConvexHullShape::project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
#if 1
 minProj = FLT_MAX;
 maxProj = -FLT_MAX;

 int numVerts = m_unscaledPoints.size();
 for (int i = 0; i<numVerts; i++)
 {
  btVector3 vtx = m_unscaledPoints[i] * m_localScaling;
  btVector3 pt = trans * vtx;
  btScalar dp = pt.dot(dir);
  if (dp < minProj)
  {
   minProj = dp;
   witnesPtMin = pt;
  }
  if (dp > maxProj)
  {
   maxProj = dp;
   witnesPtMax = pt;
  }
 }
#else
 btVector3 localAxis = dir*trans.getBasis();
 witnesPtMin = trans(localGetSupportingVertex(localAxis));
 witnesPtMax = trans(localGetSupportingVertex(-localAxis));

 minProj = witnesPtMin.dot(dir);
 maxProj = witnesPtMax.dot(dir);
#endif

 if (minProj>maxProj)
 {
  btSwap(minProj, maxProj);
  btSwap(witnesPtMin, witnesPtMax);
 }


}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"



btConvexInternalShape::btConvexInternalShape()
 : m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.)),
 m_collisionMargin(CONVEX_DISTANCE_MARGIN)
{
}


void	btConvexInternalShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling.absolute();
}



void	btConvexInternalShape::getAabbSlow(const btTransform& trans, btVector3&minAabb, btVector3&maxAabb) const
{
#ifndef __SPU__
 //use localGetSupportingVertexWithoutMargin?
 btScalar margin = getMargin();
 for (int i = 0; i<3; i++)
 {
  btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
  vec[i] = btScalar(1.);

  btVector3 sv = localGetSupportingVertex(vec*trans.getBasis());

  btVector3 tmp = trans(sv);
  maxAabb[i] = tmp[i] + margin;
  vec[i] = btScalar(-1.);
  tmp = trans(localGetSupportingVertex(vec*trans.getBasis()));
  minAabb[i] = tmp[i] - margin;
 }
#endif
}



btVector3	btConvexInternalShape::localGetSupportingVertex(const btVector3& vec)const
{
#ifndef __SPU__

 btVector3	supVertex = localGetSupportingVertexWithoutMargin(vec);

 if (getMargin() != btScalar(0.))
 {
  btVector3 vecnorm = vec;
  if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
  {
   vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
  }
  vecnorm.normalize();
  supVertex += getMargin() * vecnorm;
 }
 return supVertex;

#else
 btAssert(0);
 return btVector3(0, 0, 0);
#endif //__SPU__

}


btConvexInternalAabbCachingShape::btConvexInternalAabbCachingShape()
 : btConvexInternalShape(),
 m_localAabbMin(1, 1, 1),
 m_localAabbMax(-1, -1, -1),
 m_isLocalAabbValid(false)
{
}


void btConvexInternalAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
 getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void	btConvexInternalAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
 btConvexInternalShape::setLocalScaling(scaling);
 recalcLocalAabb();
}


void	btConvexInternalAabbCachingShape::recalcLocalAabb()
{
 m_isLocalAabbValid = true;

#if 1
 static const btVector3 _directions[] =
 {
  btVector3(1.,  0.,  0.),
  btVector3(0.,  1.,  0.),
  btVector3(0.,  0.,  1.),
  btVector3(-1., 0.,  0.),
  btVector3(0., -1.,  0.),
  btVector3(0.,  0., -1.)
 };

 btVector3 _supporting[] =
 {
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.)
 };

 batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

 for (int i = 0; i < 3; ++i)
 {
  m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
  m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
 }

#else

 for (int i = 0; i<3; i++)
 {
  btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
  vec[i] = btScalar(1.);
  btVector3 tmp = localGetSupportingVertex(vec);
  m_localAabbMax[i] = tmp[i] + m_collisionMargin;
  vec[i] = btScalar(-1.);
  tmp = localGetSupportingVertex(vec);
  m_localAabbMin[i] = tmp[i] - m_collisionMargin;
 }
#endif
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"

void btConvexPointCloudShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling;
 recalcLocalAabb();
}

#ifndef __SPU__
btVector3	btConvexPointCloudShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0)const
{
 btVector3 supVec(btScalar(0.), btScalar(0.), btScalar(0.));
 btScalar maxDot = btScalar(-BT_LARGE_FLOAT);

 btVector3 vec = vec0;
 btScalar lenSqr = vec.length2();
 if (lenSqr < btScalar(0.0001))
 {
  vec.setValue(1, 0, 0);
 }
 else
 {
  btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
  vec *= rlen;
 }

 if (m_numPoints > 0)
 {
  // Here we take advantage of dot(a*b, c) = dot( a, b*c) to do less work. Note this transformation is true mathematically, not numerically.
  //    btVector3 scaled = vec * m_localScaling;
  int index = (int)vec.maxDot(&m_unscaledPoints[0], m_numPoints, maxDot);   //FIXME: may violate encapsulation of m_unscaledPoints
  return getScaledPoint(index);
 }

 return supVec;
}

void	btConvexPointCloudShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 for (int j = 0; j < numVectors; j++)
 {
  const btVector3& vec = vectors[j] * m_localScaling;  // dot( a*c, b) = dot(a, b*c)
  btScalar maxDot;
  int index = (int)vec.maxDot(&m_unscaledPoints[0], m_numPoints, maxDot);
  supportVerticesOut[j][3] = btScalar(-BT_LARGE_FLOAT);
  if (0 <= index)
  {
   //WARNING: don't swap next lines, the w component would get overwritten!
   supportVerticesOut[j] = getScaledPoint(index);
   supportVerticesOut[j][3] = maxDot;
  }
 }

}



btVector3	btConvexPointCloudShape::localGetSupportingVertex(const btVector3& vec)const
{
 btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

 if (getMargin() != btScalar(0.))
 {
  btVector3 vecnorm = vec;
  if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
  {
   vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
  }
  vecnorm.normalize();
  supVertex += getMargin() * vecnorm;
 }
 return supVertex;
}


#endif






//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexHullShape with the Raytracer Demo
int	btConvexPointCloudShape::getNumVertices() const
{
 return m_numPoints;
}

int btConvexPointCloudShape::getNumEdges() const
{
 return 0;
}

void btConvexPointCloudShape::getEdge(int i, btVector3& pa, btVector3& pb) const
{
 btAssert(0);
}

void btConvexPointCloudShape::getVertex(int i, btVector3& vtx) const
{
 vtx = m_unscaledPoints[i] * m_localScaling;
}

int	btConvexPointCloudShape::getNumPlanes() const
{
 return 0;
}

void btConvexPointCloudShape::getPlane(btVector3&, btVector3&, int) const
{

 btAssert(0);
}

//not yet
bool btConvexPointCloudShape::isInside(const btVector3&, btScalar) const
{
 btAssert(0);
 return false;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs

#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btHashMap.h"


btConvexPolyhedron::btConvexPolyhedron()
{

}
btConvexPolyhedron::~btConvexPolyhedron()
{

}


inline bool IsAlmostZero(const btVector3& v)
{
 if (btFabs(v.x())>1e-6 || btFabs(v.y())>1e-6 || btFabs(v.z())>1e-6)	return false;
 return true;
}

struct btInternalVertexPair
{
 btInternalVertexPair(short int v0, short int v1)
  :m_v0(v0),
  m_v1(v1)
 {
  if (m_v1>m_v0)
   btSwap(m_v0, m_v1);
 }
 short int m_v0;
 short int m_v1;
 int getHash() const
 {
  return m_v0 + (m_v1 << 16);
 }
 bool equals(const btInternalVertexPair& other) const
 {
  return m_v0 == other.m_v0 && m_v1 == other.m_v1;
 }
};

struct btInternalEdge
{
 btInternalEdge()
  :m_face0(-1),
  m_face1(-1)
 {
 }
 short int m_face0;
 short int m_face1;
};

//

#ifdef TEST_INTERNAL_OBJECTS
bool btConvexPolyhedron::testContainment() const
{
 for (int p = 0; p<8; p++)
 {
  btVector3 LocalPt;
  if (p == 0)		LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], m_extents[2]);
  else if (p == 1)	LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], -m_extents[2]);
  else if (p == 2)	LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], m_extents[2]);
  else if (p == 3)	LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], -m_extents[2]);
  else if (p == 4)	LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], m_extents[2]);
  else if (p == 5)	LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], -m_extents[2]);
  else if (p == 6)	LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], m_extents[2]);
  else if (p == 7)	LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], -m_extents[2]);

  for (int i = 0; i<m_faces.size(); i++)
  {
   const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
   const btScalar d = LocalPt.dot(Normal) + m_faces[i].m_plane[3];
   if (d>0.0f)
    return false;
  }
 }
 return true;
}
#endif

void	btConvexPolyhedron::initialize()
{

 btHashMap<btInternalVertexPair, btInternalEdge> edges;

 btScalar TotalArea = 0.0f;

 m_localCenter.setValue(0, 0, 0);
 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  int NbTris = numVertices;
  for (int j = 0; j<NbTris; j++)
  {
   int k = (j + 1) % numVertices;
   btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
   btInternalEdge* edptr = edges.find(vp);
   btVector3 edge = m_vertices[vp.m_v1] - m_vertices[vp.m_v0];
   edge.normalize();

   bool found = false;

   for (int p = 0; p<m_uniqueEdges.size(); p++)
   {

    if (IsAlmostZero(m_uniqueEdges[p] - edge) ||
     IsAlmostZero(m_uniqueEdges[p] + edge))
    {
     found = true;
     break;
    }
   }

   if (!found)
   {
    m_uniqueEdges.push_back(edge);
   }

   if (edptr)
   {
    btAssert(edptr->m_face0 >= 0);
    btAssert(edptr->m_face1<0);
    edptr->m_face1 = i;
   }
   else
   {
    btInternalEdge ed;
    ed.m_face0 = i;
    edges.insert(vp, ed);
   }
  }
 }

#ifdef USE_CONNECTED_FACES
 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  m_faces[i].m_connectedFaces.resize(numVertices);

  for (int j = 0; j<numVertices; j++)
  {
   int k = (j + 1) % numVertices;
   btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
   btInternalEdge* edptr = edges.find(vp);
   btAssert(edptr);
   btAssert(edptr->m_face0 >= 0);
   btAssert(edptr->m_face1 >= 0);

   int connectedFace = (edptr->m_face0 == i) ? edptr->m_face1 : edptr->m_face0;
   m_faces[i].m_connectedFaces[j] = connectedFace;
  }
 }
#endif//USE_CONNECTED_FACES

 for (int i = 0; i<m_faces.size(); i++)
 {
  int numVertices = m_faces[i].m_indices.size();
  int NbTris = numVertices - 2;

  const btVector3& p0 = m_vertices[m_faces[i].m_indices[0]];
  for (int j = 1; j <= NbTris; j++)
  {
   int k = (j + 1) % numVertices;
   const btVector3& p1 = m_vertices[m_faces[i].m_indices[j]];
   const btVector3& p2 = m_vertices[m_faces[i].m_indices[k]];
   btScalar Area = ((p0 - p1).cross(p0 - p2)).length() * 0.5f;
   btVector3 Center = (p0 + p1 + p2) / 3.0f;
   m_localCenter += Area * Center;
   TotalArea += Area;
  }
 }
 m_localCenter /= TotalArea;




#ifdef TEST_INTERNAL_OBJECTS
 if (1)
 {
  m_radius = FLT_MAX;
  for (int i = 0; i<m_faces.size(); i++)
  {
   const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
   const btScalar dist = btFabs(m_localCenter.dot(Normal) + m_faces[i].m_plane[3]);
   if (dist<m_radius)
    m_radius = dist;
  }


  btScalar MinX = FLT_MAX;
  btScalar MinY = FLT_MAX;
  btScalar MinZ = FLT_MAX;
  btScalar MaxX = -FLT_MAX;
  btScalar MaxY = -FLT_MAX;
  btScalar MaxZ = -FLT_MAX;
  for (int i = 0; i<m_vertices.size(); i++)
  {
   const btVector3& pt = m_vertices[i];
   if (pt.x()<MinX)	MinX = pt.x();
   if (pt.x()>MaxX)	MaxX = pt.x();
   if (pt.y()<MinY)	MinY = pt.y();
   if (pt.y()>MaxY)	MaxY = pt.y();
   if (pt.z()<MinZ)	MinZ = pt.z();
   if (pt.z()>MaxZ)	MaxZ = pt.z();
  }
  mC.setValue(MaxX + MinX, MaxY + MinY, MaxZ + MinZ);
  mE.setValue(MaxX - MinX, MaxY - MinY, MaxZ - MinZ);



  //		const btScalar r = m_radius / sqrtf(2.0f);
  const btScalar r = m_radius / sqrtf(3.0f);
  const int LargestExtent = mE.maxAxis();
  const btScalar Step = (mE[LargestExtent] * 0.5f - r) / 1024.0f;
  m_extents[0] = m_extents[1] = m_extents[2] = r;
  m_extents[LargestExtent] = mE[LargestExtent] * 0.5f;
  bool FoundBox = false;
  for (int j = 0; j<1024; j++)
  {
   if (testContainment())
   {
    FoundBox = true;
    break;
   }

   m_extents[LargestExtent] -= Step;
  }
  if (!FoundBox)
  {
   m_extents[0] = m_extents[1] = m_extents[2] = r;
  }
  else
  {
   // Refine the box
   const btScalar Step = (m_radius - r) / 1024.0f;
   const int e0 = (1 << LargestExtent) & 3;
   const int e1 = (1 << e0) & 3;

   for (int j = 0; j<1024; j++)
   {
    const btScalar Saved0 = m_extents[e0];
    const btScalar Saved1 = m_extents[e1];
    m_extents[e0] += Step;
    m_extents[e1] += Step;

    if (!testContainment())
    {
     m_extents[e0] = Saved0;
     m_extents[e1] = Saved1;
     break;
    }
   }
  }
 }
#endif
}

void btConvexPolyhedron::project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
 minProj = FLT_MAX;
 maxProj = -FLT_MAX;
 int numVerts = m_vertices.size();
 for (int i = 0; i<numVerts; i++)
 {
  btVector3 pt = trans * m_vertices[i];
  btScalar dp = pt.dot(dir);
  if (dp < minProj)
  {
   minProj = dp;
   witnesPtMin = pt;
  }
  if (dp > maxProj)
  {
   maxProj = dp;
   witnesPtMax = pt;
  }
 }
 if (minProj>maxProj)
 {
  btSwap(minProj, maxProj);
  btSwap(witnesPtMin, witnesPtMax);
 }
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined (_WIN32) || defined (__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"

///not supported on IBM SDK, until we fix the alignment of btVector3
#if defined (__CELLOS_LV2__) && defined (__SPU__)
#include <spu_intrinsics.h>
static inline vec_float4 vec_dot3(vec_float4 vec0, vec_float4 vec1)
{
 vec_float4 result;
 result = spu_mul(vec0, vec1);
 result = spu_madd(spu_rlqwbyte(vec0, 4), spu_rlqwbyte(vec1, 4), result);
 return spu_madd(spu_rlqwbyte(vec0, 8), spu_rlqwbyte(vec1, 8), result);
}
#endif //__SPU__

btConvexShape::btConvexShape()
{
}

btConvexShape::~btConvexShape()
{

}


void btConvexShape::project(const btTransform& trans, const btVector3& dir, btScalar& min, btScalar& max, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
 btVector3 localAxis = dir*trans.getBasis();
 btVector3 vtx1 = trans(localGetSupportingVertex(localAxis));
 btVector3 vtx2 = trans(localGetSupportingVertex(-localAxis));

 min = vtx1.dot(dir);
 max = vtx2.dot(dir);
 witnesPtMax = vtx2;
 witnesPtMin = vtx1;

 if (min>max)
 {
  btScalar tmp = min;
  min = max;
  max = tmp;
  witnesPtMax = vtx1;
  witnesPtMin = vtx2;
 }
}


static btVector3 convexHullSupport(const btVector3& localDirOrg, const btVector3* points, int numPoints, const btVector3& localScaling)
{

 btVector3 vec = localDirOrg * localScaling;

#if defined (__CELLOS_LV2__) && defined (__SPU__)

 btVector3 localDir = vec;

 vec_float4 v_distMax = { -FLT_MAX,0,0,0 };
 vec_int4 v_idxMax = { -999,0,0,0 };
 int v = 0;
 int numverts = numPoints;

 for (; v<(int)numverts - 4; v += 4) {
  vec_float4 p0 = vec_dot3(points[v].get128(), localDir.get128());
  vec_float4 p1 = vec_dot3(points[v + 1].get128(), localDir.get128());
  vec_float4 p2 = vec_dot3(points[v + 2].get128(), localDir.get128());
  vec_float4 p3 = vec_dot3(points[v + 3].get128(), localDir.get128());
  const vec_int4 i0 = { v  ,0,0,0 };
  const vec_int4 i1 = { v + 1,0,0,0 };
  const vec_int4 i2 = { v + 2,0,0,0 };
  const vec_int4 i3 = { v + 3,0,0,0 };
  vec_uint4  retGt01 = spu_cmpgt(p0, p1);
  vec_float4 pmax01 = spu_sel(p1, p0, retGt01);
  vec_int4   imax01 = spu_sel(i1, i0, retGt01);
  vec_uint4  retGt23 = spu_cmpgt(p2, p3);
  vec_float4 pmax23 = spu_sel(p3, p2, retGt23);
  vec_int4   imax23 = spu_sel(i3, i2, retGt23);
  vec_uint4  retGt0123 = spu_cmpgt(pmax01, pmax23);
  vec_float4 pmax0123 = spu_sel(pmax23, pmax01, retGt0123);
  vec_int4   imax0123 = spu_sel(imax23, imax01, retGt0123);
  vec_uint4  retGtMax = spu_cmpgt(v_distMax, pmax0123);
  v_distMax = spu_sel(pmax0123, v_distMax, retGtMax);
  v_idxMax = spu_sel(imax0123, v_idxMax, retGtMax);
 }
 for (; v<(int)numverts; v++) {
  vec_float4 p = vec_dot3(points[v].get128(), localDir.get128());
  const vec_int4 i = { v,0,0,0 };
  vec_uint4  retGtMax = spu_cmpgt(v_distMax, p);
  v_distMax = spu_sel(p, v_distMax, retGtMax);
  v_idxMax = spu_sel(i, v_idxMax, retGtMax);
 }
 int ptIndex = spu_extract(v_idxMax, 0);
 const btVector3& supVec = points[ptIndex] * localScaling;
 return supVec;
#else

 btScalar maxDot;
 long ptIndex = vec.maxDot(points, numPoints, maxDot);
 btAssert(ptIndex >= 0);
 btVector3 supVec = points[ptIndex] * localScaling;
 return supVec;
#endif //__SPU__
}

btVector3 btConvexShape::localGetSupportVertexWithoutMarginNonVirtual(const btVector3& localDir) const
{
 switch (m_shapeType)
 {
 case SPHERE_SHAPE_PROXYTYPE:
 {
  return btVector3(0, 0, 0);
 }
 case BOX_SHAPE_PROXYTYPE:
 {
  btBoxShape* convexShape = (btBoxShape*)this;
  const btVector3& halfExtents = convexShape->getImplicitShapeDimensions();

#if defined( __APPLE__ ) && (defined( BT_USE_SSE )||defined( BT_USE_NEON ))
#if defined( BT_USE_SSE )
  return btVector3(_mm_xor_ps(_mm_and_ps(localDir.mVec128, (__m128) { -0.0f, -0.0f, -0.0f, -0.0f }), halfExtents.mVec128));
#elif defined( BT_USE_NEON )
  return btVector3((float32x4_t)(((uint32x4_t)localDir.mVec128 & (uint32x4_t) { 0x80000000, 0x80000000, 0x80000000, 0x80000000 }) ^ (uint32x4_t)halfExtents.mVec128));
#else
#error unknown vector arch
#endif
#else
  return btVector3(btFsels(localDir.x(), halfExtents.x(), -halfExtents.x()),
   btFsels(localDir.y(), halfExtents.y(), -halfExtents.y()),
   btFsels(localDir.z(), halfExtents.z(), -halfExtents.z()));
#endif
 }
 case TRIANGLE_SHAPE_PROXYTYPE:
 {
  btTriangleShape* triangleShape = (btTriangleShape*)this;
  btVector3 dir(localDir.getX(), localDir.getY(), localDir.getZ());
  btVector3* vertices = &triangleShape->m_vertices1[0];
  btVector3 dots = dir.dot3(vertices[0], vertices[1], vertices[2]);
  btVector3 sup = vertices[dots.maxAxis()];
  return btVector3(sup.getX(), sup.getY(), sup.getZ());
 }
 case CYLINDER_SHAPE_PROXYTYPE:
 {
  btCylinderShape* cylShape = (btCylinderShape*)this;
  //mapping of halfextents/dimension onto radius/height depends on how cylinder local orientation is (upAxis)

  btVector3 halfExtents = cylShape->getImplicitShapeDimensions();
  btVector3 v(localDir.getX(), localDir.getY(), localDir.getZ());
  int cylinderUpAxis = cylShape->getUpAxis();
  int XX(1), YY(0), ZZ(2);

  switch (cylinderUpAxis)
  {
  case 0:
  {
   XX = 1;
   YY = 0;
   ZZ = 2;
  }
  break;
  case 1:
  {
   XX = 0;
   YY = 1;
   ZZ = 2;
  }
  break;
  case 2:
  {
   XX = 0;
   YY = 2;
   ZZ = 1;

  }
  break;
  default:
   btAssert(0);
   break;
  };

  btScalar radius = halfExtents[XX];
  btScalar halfHeight = halfExtents[cylinderUpAxis];

  btVector3 tmp;
  btScalar d;

  btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
  if (s != btScalar(0.0))
  {
   d = radius / s;
   tmp[XX] = v[XX] * d;
   tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
   tmp[ZZ] = v[ZZ] * d;
   return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
  }
  else {
   tmp[XX] = radius;
   tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
   tmp[ZZ] = btScalar(0.0);
   return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
  }
 }
 case CAPSULE_SHAPE_PROXYTYPE:
 {
  btVector3 vec0(localDir.getX(), localDir.getY(), localDir.getZ());

  btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
  btScalar halfHeight = capsuleShape->getHalfHeight();
  int capsuleUpAxis = capsuleShape->getUpAxis();

  btVector3 supVec(0, 0, 0);

  btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

  btVector3 vec = vec0;
  btScalar lenSqr = vec.length2();
  if (lenSqr < SIMD_EPSILON*SIMD_EPSILON)
  {
   vec.setValue(1, 0, 0);
  }
  else
  {
   btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
   vec *= rlen;
  }
  btVector3 vtx;
  btScalar newDot;
  {
   btVector3 pos(0, 0, 0);
   pos[capsuleUpAxis] = halfHeight;

   vtx = pos;
   newDot = vec.dot(vtx);


   if (newDot > maxDot)
   {
    maxDot = newDot;
    supVec = vtx;
   }
  }
  {
   btVector3 pos(0, 0, 0);
   pos[capsuleUpAxis] = -halfHeight;

   vtx = pos;
   newDot = vec.dot(vtx);
   if (newDot > maxDot)
   {
    maxDot = newDot;
    supVec = vtx;
   }
  }
  return btVector3(supVec.getX(), supVec.getY(), supVec.getZ());
 }
 case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
 {
  btConvexPointCloudShape* convexPointCloudShape = (btConvexPointCloudShape*)this;
  btVector3* points = convexPointCloudShape->getUnscaledPoints();
  int numPoints = convexPointCloudShape->getNumPoints();
  return convexHullSupport(localDir, points, numPoints, convexPointCloudShape->getLocalScalingNV());
 }
 case CONVEX_HULL_SHAPE_PROXYTYPE:
 {
  btConvexHullShape* convexHullShape = (btConvexHullShape*)this;
  btVector3* points = convexHullShape->getUnscaledPoints();
  int numPoints = convexHullShape->getNumPoints();
  return convexHullSupport(localDir, points, numPoints, convexHullShape->getLocalScalingNV());
 }
 default:
#ifndef __SPU__
  return this->localGetSupportingVertexWithoutMargin(localDir);
#else
  btAssert(0);
#endif
 }

 // should never reach here
 btAssert(0);
 return btVector3(btScalar(0.0f), btScalar(0.0f), btScalar(0.0f));
}

btVector3 btConvexShape::localGetSupportVertexNonVirtual(const btVector3& localDir) const
{
 btVector3 localDirNorm = localDir;
 if (localDirNorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
 {
  localDirNorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
 }
 localDirNorm.normalize();

 return localGetSupportVertexWithoutMarginNonVirtual(localDirNorm) + getMarginNonVirtual() * localDirNorm;
}

/* TODO: This should be bumped up to btCollisionShape () */
btScalar btConvexShape::getMarginNonVirtual() const
{
 switch (m_shapeType)
 {
 case SPHERE_SHAPE_PROXYTYPE:
 {
  btSphereShape* sphereShape = (btSphereShape*)this;
  return sphereShape->getRadius();
 }
 case BOX_SHAPE_PROXYTYPE:
 {
  btBoxShape* convexShape = (btBoxShape*)this;
  return convexShape->getMarginNV();
 }
 case TRIANGLE_SHAPE_PROXYTYPE:
 {
  btTriangleShape* triangleShape = (btTriangleShape*)this;
  return triangleShape->getMarginNV();
 }
 case CYLINDER_SHAPE_PROXYTYPE:
 {
  btCylinderShape* cylShape = (btCylinderShape*)this;
  return cylShape->getMarginNV();
 }
 case CONE_SHAPE_PROXYTYPE:
 {
  btConeShape* conShape = (btConeShape*)this;
  return conShape->getMarginNV();
 }
 case CAPSULE_SHAPE_PROXYTYPE:
 {
  btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
  return capsuleShape->getMarginNV();
 }
 case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
  /* fall through */
 case CONVEX_HULL_SHAPE_PROXYTYPE:
 {
  btPolyhedralConvexShape* convexHullShape = (btPolyhedralConvexShape*)this;
  return convexHullShape->getMarginNV();
 }
 default:
#ifndef __SPU__
  return this->getMargin();
#else
  btAssert(0);
#endif
 }

 // should never reach here
 btAssert(0);
 return btScalar(0.0f);
}
#ifndef __SPU__
void btConvexShape::getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 switch (m_shapeType)
 {
 case SPHERE_SHAPE_PROXYTYPE:
 {
  btSphereShape* sphereShape = (btSphereShape*)this;
  btScalar radius = sphereShape->getImplicitShapeDimensions().getX();// * convexShape->getLocalScaling().getX();
  btScalar margin = radius + sphereShape->getMarginNonVirtual();
  const btVector3& center = t.getOrigin();
  btVector3 extent(margin, margin, margin);
  aabbMin = center - extent;
  aabbMax = center + extent;
 }
 break;
 case CYLINDER_SHAPE_PROXYTYPE:
  /* fall through */
 case BOX_SHAPE_PROXYTYPE:
 {
  btBoxShape* convexShape = (btBoxShape*)this;
  btScalar margin = convexShape->getMarginNonVirtual();
  btVector3 halfExtents = convexShape->getImplicitShapeDimensions();
  halfExtents += btVector3(margin, margin, margin);
  btMatrix3x3 abs_b = t.getBasis().absolute();
  btVector3 center = t.getOrigin();
  btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

  aabbMin = center - extent;
  aabbMax = center + extent;
  break;
 }
 case TRIANGLE_SHAPE_PROXYTYPE:
 {
  btTriangleShape* triangleShape = (btTriangleShape*)this;
  btScalar margin = triangleShape->getMarginNonVirtual();
  for (int i = 0; i<3; i++)
  {
   btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
   vec[i] = btScalar(1.);

   btVector3 sv = localGetSupportVertexWithoutMarginNonVirtual(vec*t.getBasis());

   btVector3 tmp = t(sv);
   aabbMax[i] = tmp[i] + margin;
   vec[i] = btScalar(-1.);
   tmp = t(localGetSupportVertexWithoutMarginNonVirtual(vec*t.getBasis()));
   aabbMin[i] = tmp[i] - margin;
  }
 }
 break;
 case CAPSULE_SHAPE_PROXYTYPE:
 {
  btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
  btVector3 halfExtents(capsuleShape->getRadius(), capsuleShape->getRadius(), capsuleShape->getRadius());
  int m_upAxis = capsuleShape->getUpAxis();
  halfExtents[m_upAxis] = capsuleShape->getRadius() + capsuleShape->getHalfHeight();
  btMatrix3x3 abs_b = t.getBasis().absolute();
  btVector3 center = t.getOrigin();
  btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
  aabbMin = center - extent;
  aabbMax = center + extent;
 }
 break;
 case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
 case CONVEX_HULL_SHAPE_PROXYTYPE:
 {
  btPolyhedralConvexAabbCachingShape* convexHullShape = (btPolyhedralConvexAabbCachingShape*)this;
  btScalar margin = convexHullShape->getMarginNonVirtual();
  convexHullShape->getNonvirtualAabb(t, aabbMin, aabbMax, margin);
 }
 break;
 default:
#ifndef __SPU__
  this->getAabb(t, aabbMin, aabbMax);
#else
  btAssert(0);
#endif
  break;
 }

 // should never reach here
 btAssert(0);
}

#endif //__SPU__
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"


btConvexTriangleMeshShape::btConvexTriangleMeshShape(btStridingMeshInterface* meshInterface, bool calcAabb)
 : btPolyhedralConvexAabbCachingShape(), m_stridingMesh(meshInterface)
{
 m_shapeType = CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE;
 if (calcAabb)
  recalcLocalAabb();
}




///It's not nice to have all this virtual function overhead, so perhaps we can also gather the points once
///but then we are duplicating
class LocalSupportVertexCallback : public btInternalTriangleIndexCallback
{

 btVector3 m_supportVertexLocal;
public:

 btScalar m_maxDot;
 btVector3 m_supportVecLocal;

 LocalSupportVertexCallback(const btVector3& supportVecLocal)
  : m_supportVertexLocal(btScalar(0.), btScalar(0.), btScalar(0.)),
  m_maxDot(btScalar(-BT_LARGE_FLOAT)),
  m_supportVecLocal(supportVecLocal)
 {
 }

 virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int  triangleIndex)
 {
  (void)triangleIndex;
  (void)partId;

  for (int i = 0; i<3; i++)
  {
   btScalar dot = m_supportVecLocal.dot(triangle[i]);
   if (dot > m_maxDot)
   {
    m_maxDot = dot;
    m_supportVertexLocal = triangle[i];
   }
  }
 }

 btVector3	GetSupportVertexLocal()
 {
  return m_supportVertexLocal;
 }

};





btVector3	btConvexTriangleMeshShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0)const
{
 btVector3 supVec(btScalar(0.), btScalar(0.), btScalar(0.));

 btVector3 vec = vec0;
 btScalar lenSqr = vec.length2();
 if (lenSqr < btScalar(0.0001))
 {
  vec.setValue(1, 0, 0);
 }
 else
 {
  btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
  vec *= rlen;
 }

 LocalSupportVertexCallback	supportCallback(vec);
 btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 m_stridingMesh->InternalProcessAllTriangles(&supportCallback, -aabbMax, aabbMax);
 supVec = supportCallback.GetSupportVertexLocal();

 return supVec;
}

void	btConvexTriangleMeshShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 //use 'w' component of supportVerticesOut?
 {
  for (int i = 0; i<numVectors; i++)
  {
   supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
  }
 }

 ///@todo: could do the batch inside the callback!


 for (int j = 0; j<numVectors; j++)
 {
  const btVector3& vec = vectors[j];
  LocalSupportVertexCallback	supportCallback(vec);
  btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
  m_stridingMesh->InternalProcessAllTriangles(&supportCallback, -aabbMax, aabbMax);
  supportVerticesOut[j] = supportCallback.GetSupportVertexLocal();
 }

}



btVector3	btConvexTriangleMeshShape::localGetSupportingVertex(const btVector3& vec)const
{
 btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

 if (getMargin() != btScalar(0.))
 {
  btVector3 vecnorm = vec;
  if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
  {
   vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
  }
  vecnorm.normalize();
  supVertex += getMargin() * vecnorm;
 }
 return supVertex;
}









//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexTriangleMeshShape with the Raytracer Demo
int	btConvexTriangleMeshShape::getNumVertices() const
{
 //cache this?
 return 0;

}

int btConvexTriangleMeshShape::getNumEdges() const
{
 return 0;
}

void btConvexTriangleMeshShape::getEdge(int, btVector3&, btVector3&) const
{
 btAssert(0);
}

void btConvexTriangleMeshShape::getVertex(int, btVector3&) const
{
 btAssert(0);
}

int	btConvexTriangleMeshShape::getNumPlanes() const
{
 return 0;
}

void btConvexTriangleMeshShape::getPlane(btVector3&, btVector3&, int) const
{
 btAssert(0);
}

//not yet
bool btConvexTriangleMeshShape::isInside(const btVector3&, btScalar) const
{
 btAssert(0);
 return false;
}



void	btConvexTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
 m_stridingMesh->setScaling(scaling);

 recalcLocalAabb();

}


const btVector3& btConvexTriangleMeshShape::getLocalScaling() const
{
 return m_stridingMesh->getScaling();
}

void btConvexTriangleMeshShape::calculatePrincipalAxisTransform(btTransform& principal, btVector3& inertia, btScalar& volume) const
{
 class CenterCallback : public btInternalTriangleIndexCallback
 {
  bool first;
  btVector3 ref;
  btVector3 sum;
  btScalar volume;

 public:

  CenterCallback() : first(true), ref(0, 0, 0), sum(0, 0, 0), volume(0)
  {
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
  {
   (void)triangleIndex;
   (void)partId;
   if (first)
   {
    ref = triangle[0];
    first = false;
   }
   else
   {
    btScalar vol = btFabs((triangle[0] - ref).triple(triangle[1] - ref, triangle[2] - ref));
    sum += (btScalar(0.25) * vol) * ((triangle[0] + triangle[1] + triangle[2] + ref));
    volume += vol;
   }
  }

  btVector3 getCenter()
  {
   return (volume > 0) ? sum / volume : ref;
  }

  btScalar getVolume()
  {
   return volume * btScalar(1. / 6);
  }

 };

 class InertiaCallback : public btInternalTriangleIndexCallback
 {
  btMatrix3x3 sum;
  btVector3 center;

 public:

  InertiaCallback(btVector3& center) : sum(0, 0, 0, 0, 0, 0, 0, 0, 0), center(center)
  {
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
  {
   (void)triangleIndex;
   (void)partId;
   btMatrix3x3 i;
   btVector3 a = triangle[0] - center;
   btVector3 b = triangle[1] - center;
   btVector3 c = triangle[2] - center;
   btScalar volNeg = -btFabs(a.triple(b, c)) * btScalar(1. / 6);
   for (int j = 0; j < 3; j++)
   {
    for (int k = 0; k <= j; k++)
    {
     i[j][k] = i[k][j] = volNeg * (btScalar(0.1) * (a[j] * a[k] + b[j] * b[k] + c[j] * c[k])
      + btScalar(0.05) * (a[j] * b[k] + a[k] * b[j] + a[j] * c[k] + a[k] * c[j] + b[j] * c[k] + b[k] * c[j]));
    }
   }
   btScalar i00 = -i[0][0];
   btScalar i11 = -i[1][1];
   btScalar i22 = -i[2][2];
   i[0][0] = i11 + i22;
   i[1][1] = i22 + i00;
   i[2][2] = i00 + i11;
   sum[0] += i[0];
   sum[1] += i[1];
   sum[2] += i[2];
  }

  btMatrix3x3& getInertia()
  {
   return sum;
  }

 };

 CenterCallback centerCallback;
 btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 m_stridingMesh->InternalProcessAllTriangles(&centerCallback, -aabbMax, aabbMax);
 btVector3 center = centerCallback.getCenter();
 principal.setOrigin(center);
 volume = centerCallback.getVolume();

 InertiaCallback inertiaCallback(center);
 m_stridingMesh->InternalProcessAllTriangles(&inertiaCallback, -aabbMax, aabbMax);

 btMatrix3x3& i = inertiaCallback.getInertia();
 i.diagonalize(principal.getBasis(), btScalar(0.00001), 20);
 inertia.setValue(i[0][0], i[1][1], i[2][2]);
 inertia /= volume;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btCylinderShape.h"

btCylinderShape::btCylinderShape(const btVector3& halfExtents)
 :btConvexInternalShape(),
 m_upAxis(1)
{
 btVector3 margin(getMargin(), getMargin(), getMargin());
 m_implicitShapeDimensions = (halfExtents * m_localScaling) - margin;

 setSafeMargin(halfExtents);

 m_shapeType = CYLINDER_SHAPE_PROXYTYPE;
}


btCylinderShapeX::btCylinderShapeX(const btVector3& halfExtents)
 :btCylinderShape(halfExtents)
{
 m_upAxis = 0;

}


btCylinderShapeZ::btCylinderShapeZ(const btVector3& halfExtents)
 :btCylinderShape(halfExtents)
{
 m_upAxis = 2;

}

void btCylinderShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}

void	btCylinderShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{

 //Until Bullet 2.77 a box approximation was used, so uncomment this if you need backwards compatibility
 //#define USE_BOX_INERTIA_APPROXIMATION 1
#ifndef USE_BOX_INERTIA_APPROXIMATION

 /*
 cylinder is defined as following:
 *
 * - principle axis aligned along y by default, radius in x, z-value not used
 * - for btCylinderShapeX: principle axis aligned along x, radius in y direction, z-value not used
 * - for btCylinderShapeZ: principle axis aligned along z, radius in x direction, y-value not used
 *
 */

 btScalar radius2;	// square of cylinder radius
 btScalar height2;	// square of cylinder height
 btVector3 halfExtents = getHalfExtentsWithMargin();	// get cylinder dimension
 btScalar div12 = mass / 12.f;
 btScalar div4 = mass / 4.f;
 btScalar div2 = mass / 2.f;
 int idxRadius, idxHeight;

 switch (m_upAxis)	// get indices of radius and height of cylinder
 {
 case 0:		// cylinder is aligned along x
  idxRadius = 1;
  idxHeight = 0;
  break;
 case 2:		// cylinder is aligned along z
  idxRadius = 0;
  idxHeight = 2;
  break;
 default:	// cylinder is aligned along y
  idxRadius = 0;
  idxHeight = 1;
 }

 // calculate squares
 radius2 = halfExtents[idxRadius] * halfExtents[idxRadius];
 height2 = btScalar(4.) * halfExtents[idxHeight] * halfExtents[idxHeight];

 // calculate tensor terms
 btScalar t1 = div12 * height2 + div4 * radius2;
 btScalar t2 = div2 * radius2;

 switch (m_upAxis)	// set diagonal elements of inertia tensor
 {
 case 0:		// cylinder is aligned along x
  inertia.setValue(t2, t1, t1);
  break;
 case 2:		// cylinder is aligned along z
  inertia.setValue(t1, t1, t2);
  break;
 default:	// cylinder is aligned along y
  inertia.setValue(t1, t2, t1);
 }
#else //USE_BOX_INERTIA_APPROXIMATION
 //approximation of box shape
 btVector3 halfExtents = getHalfExtentsWithMargin();

 btScalar lx = btScalar(2.)*(halfExtents.x());
 btScalar ly = btScalar(2.)*(halfExtents.y());
 btScalar lz = btScalar(2.)*(halfExtents.z());

 inertia.setValue(mass / (btScalar(12.0)) * (ly*ly + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + ly*ly));
#endif //USE_BOX_INERTIA_APPROXIMATION
}


SIMD_FORCE_INLINE btVector3 CylinderLocalSupportX(const btVector3& halfExtents, const btVector3& v)
{
 const int cylinderUpAxis = 0;
 const int XX = 1;
 const int YY = 0;
 const int ZZ = 2;

 //mapping depends on how cylinder local orientation is
 // extents of the cylinder is: X,Y is for radius, and Z for height


 btScalar radius = halfExtents[XX];
 btScalar halfHeight = halfExtents[cylinderUpAxis];


 btVector3 tmp;
 btScalar d;

 btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
 if (s != btScalar(0.0))
 {
  d = radius / s;
  tmp[XX] = v[XX] * d;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = v[ZZ] * d;
  return tmp;
 }
 else
 {
  tmp[XX] = radius;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = btScalar(0.0);
  return tmp;
 }


}






inline  btVector3 CylinderLocalSupportY(const btVector3& halfExtents, const btVector3& v)
{

 const int cylinderUpAxis = 1;
 const int XX = 0;
 const int YY = 1;
 const int ZZ = 2;


 btScalar radius = halfExtents[XX];
 btScalar halfHeight = halfExtents[cylinderUpAxis];


 btVector3 tmp;
 btScalar d;

 btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
 if (s != btScalar(0.0))
 {
  d = radius / s;
  tmp[XX] = v[XX] * d;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = v[ZZ] * d;
  return tmp;
 }
 else
 {
  tmp[XX] = radius;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = btScalar(0.0);
  return tmp;
 }

}

inline btVector3 CylinderLocalSupportZ(const btVector3& halfExtents, const btVector3& v)
{
 const int cylinderUpAxis = 2;
 const int XX = 0;
 const int YY = 2;
 const int ZZ = 1;

 //mapping depends on how cylinder local orientation is
 // extents of the cylinder is: X,Y is for radius, and Z for height


 btScalar radius = halfExtents[XX];
 btScalar halfHeight = halfExtents[cylinderUpAxis];


 btVector3 tmp;
 btScalar d;

 btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
 if (s != btScalar(0.0))
 {
  d = radius / s;
  tmp[XX] = v[XX] * d;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = v[ZZ] * d;
  return tmp;
 }
 else
 {
  tmp[XX] = radius;
  tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
  tmp[ZZ] = btScalar(0.0);
  return tmp;
 }


}

btVector3	btCylinderShapeX::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 return CylinderLocalSupportX(getHalfExtentsWithoutMargin(), vec);
}


btVector3	btCylinderShapeZ::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 return CylinderLocalSupportZ(getHalfExtentsWithoutMargin(), vec);
}
btVector3	btCylinderShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 return CylinderLocalSupportY(getHalfExtentsWithoutMargin(), vec);
}

void	btCylinderShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 for (int i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i] = CylinderLocalSupportY(getHalfExtentsWithoutMargin(), vectors[i]);
 }
}

void	btCylinderShapeZ::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 for (int i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i] = CylinderLocalSupportZ(getHalfExtentsWithoutMargin(), vectors[i]);
 }
}




void	btCylinderShapeX::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 for (int i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i] = CylinderLocalSupportX(getHalfExtentsWithoutMargin(), vectors[i]);
 }
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btEmptyShape.h"


#include "BulletCollision/CollisionShapes/btCollisionShape.h"


btEmptyShape::btEmptyShape() : btConcaveShape()
{
 m_shapeType = EMPTY_SHAPE_PROXYTYPE;
}


btEmptyShape::~btEmptyShape()
{
}


///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
void btEmptyShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 btVector3 margin(getMargin(), getMargin(), getMargin());

 aabbMin = t.getOrigin() - margin;

 aabbMax = t.getOrigin() + margin;

}

void	btEmptyShape::calculateLocalInertia(btScalar, btVector3&) const
{
 btAssert(0);
}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h"

#include "LinearMath/btTransformUtil.h"



btHeightfieldTerrainShape::btHeightfieldTerrainShape
(
 int heightStickWidth, int heightStickLength, const void* heightfieldData,
 btScalar heightScale, btScalar minHeight, btScalar maxHeight, int upAxis,
 PHY_ScalarType hdt, bool flipQuadEdges
)
{
 initialize(heightStickWidth, heightStickLength, heightfieldData,
  heightScale, minHeight, maxHeight, upAxis, hdt,
  flipQuadEdges);
}



btHeightfieldTerrainShape::btHeightfieldTerrainShape(int heightStickWidth, int heightStickLength, const void* heightfieldData, btScalar maxHeight, int upAxis, bool useFloatData, bool flipQuadEdges)
{
 // legacy constructor: support only float or unsigned char,
 // 	and min height is zero
 PHY_ScalarType hdt = (useFloatData) ? PHY_FLOAT : PHY_UCHAR;
 btScalar minHeight = 0.0f;

 // previously, height = uchar * maxHeight / 65535.
 // So to preserve legacy behavior, heightScale = maxHeight / 65535
 btScalar heightScale = maxHeight / 65535;

 initialize(heightStickWidth, heightStickLength, heightfieldData,
  heightScale, minHeight, maxHeight, upAxis, hdt,
  flipQuadEdges);
}



void btHeightfieldTerrainShape::initialize
(
 int heightStickWidth, int heightStickLength, const void* heightfieldData,
 btScalar heightScale, btScalar minHeight, btScalar maxHeight, int upAxis,
 PHY_ScalarType hdt, bool flipQuadEdges
)
{
 // validation
 btAssert(heightStickWidth > 1);// && "bad width");
 btAssert(heightStickLength > 1);// && "bad length");
 btAssert(heightfieldData);// && "null heightfield data");
                           // btAssert(heightScale) -- do we care?  Trust caller here
 btAssert(minHeight <= maxHeight);// && "bad min/max height");
 btAssert(upAxis >= 0 && upAxis < 3);// && "bad upAxis--should be in range [0,2]");
 btAssert(hdt != PHY_UCHAR || hdt != PHY_FLOAT || hdt != PHY_SHORT);// && "Bad height data type enum");

                                                                    // initialize member variables
 m_shapeType = TERRAIN_SHAPE_PROXYTYPE;
 m_heightStickWidth = heightStickWidth;
 m_heightStickLength = heightStickLength;
 m_minHeight = minHeight;
 m_maxHeight = maxHeight;
 m_width = (btScalar)(heightStickWidth - 1);
 m_length = (btScalar)(heightStickLength - 1);
 m_heightScale = heightScale;
 m_heightfieldDataUnknown = heightfieldData;
 m_heightDataType = hdt;
 m_flipQuadEdges = flipQuadEdges;
 m_useDiamondSubdivision = false;
 m_useZigzagSubdivision = false;
 m_upAxis = upAxis;
 m_localScaling.setValue(btScalar(1.), btScalar(1.), btScalar(1.));

 // determine min/max axis-aligned bounding box (aabb) values
 switch (m_upAxis)
 {
 case 0:
 {
  m_localAabbMin.setValue(m_minHeight, 0, 0);
  m_localAabbMax.setValue(m_maxHeight, m_width, m_length);
  break;
 }
 case 1:
 {
  m_localAabbMin.setValue(0, m_minHeight, 0);
  m_localAabbMax.setValue(m_width, m_maxHeight, m_length);
  break;
 };
 case 2:
 {
  m_localAabbMin.setValue(0, 0, m_minHeight);
  m_localAabbMax.setValue(m_width, m_length, m_maxHeight);
  break;
 }
 default:
 {
  //need to get valid m_upAxis
  btAssert(0);// && "Bad m_upAxis");
 }
 }

 // remember origin (defined as exact middle of aabb)
 m_localOrigin = btScalar(0.5) * (m_localAabbMin + m_localAabbMax);
}



btHeightfieldTerrainShape::~btHeightfieldTerrainShape()
{
}



void btHeightfieldTerrainShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 btVector3 halfExtents = (m_localAabbMax - m_localAabbMin)* m_localScaling * btScalar(0.5);

 btVector3 localOrigin(0, 0, 0);
 localOrigin[m_upAxis] = (m_minHeight + m_maxHeight) * btScalar(0.5);
 localOrigin *= m_localScaling;

 btMatrix3x3 abs_b = t.getBasis().absolute();
 btVector3 center = t.getOrigin();
 btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
 extent += btVector3(getMargin(), getMargin(), getMargin());

 aabbMin = center - extent;
 aabbMax = center + extent;
}


/// This returns the "raw" (user's initial) height, not the actual height.
/// The actual height needs to be adjusted to be relative to the center
///   of the heightfield's AABB.
btScalar
btHeightfieldTerrainShape::getRawHeightFieldValue(int x, int y) const
{
 btScalar val = 0.f;
 switch (m_heightDataType)
 {
 case PHY_FLOAT:
 {
  val = m_heightfieldDataFloat[(y*m_heightStickWidth) + x];
  break;
 }

 case PHY_UCHAR:
 {
  unsigned char heightFieldValue = m_heightfieldDataUnsignedChar[(y*m_heightStickWidth) + x];
  val = heightFieldValue * m_heightScale;
  break;
 }

 case PHY_SHORT:
 {
  short hfValue = m_heightfieldDataShort[(y * m_heightStickWidth) + x];
  val = hfValue * m_heightScale;
  break;
 }

 default:
 {
  btAssert(!"Bad m_heightDataType");
 }
 }

 return val;
}




/// this returns the vertex in bullet-local coordinates
void	btHeightfieldTerrainShape::getVertex(int x, int y, btVector3& vertex) const
{
 btAssert(x >= 0);
 btAssert(y >= 0);
 btAssert(x<m_heightStickWidth);
 btAssert(y<m_heightStickLength);

 btScalar	height = getRawHeightFieldValue(x, y);

 switch (m_upAxis)
 {
 case 0:
 {
  vertex.setValue(
   height - m_localOrigin.getX(),
   (-m_width / btScalar(2.0)) + x,
   (-m_length / btScalar(2.0)) + y
  );
  break;
 }
 case 1:
 {
  vertex.setValue(
   (-m_width / btScalar(2.0)) + x,
   height - m_localOrigin.getY(),
   (-m_length / btScalar(2.0)) + y
  );
  break;
 };
 case 2:
 {
  vertex.setValue(
   (-m_width / btScalar(2.0)) + x,
   (-m_length / btScalar(2.0)) + y,
   height - m_localOrigin.getZ()
  );
  break;
 }
 default:
 {
  //need to get valid m_upAxis
  btAssert(0);
 }
 }

 vertex *= m_localScaling;
}



static inline int
getQuantized
(
 btScalar x
)
{
 if (x < 0.0) {
  return (int)(x - 0.5);
 }
 return (int)(x + 0.5);
}



/// given input vector, return quantized version
/**
This routine is basically determining the gridpoint indices for a given
input vector, answering the question: "which gridpoint is closest to the
provided point?".

"with clamp" means that we restrict the point to be in the heightfield's
axis-aligned bounding box.
*/
void btHeightfieldTerrainShape::quantizeWithClamp(int* out, const btVector3& point, int /*isMax*/) const
{
 btVector3 clampedPoint(point);
 clampedPoint.setMax(m_localAabbMin);
 clampedPoint.setMin(m_localAabbMax);

 out[0] = getQuantized(clampedPoint.getX());
 out[1] = getQuantized(clampedPoint.getY());
 out[2] = getQuantized(clampedPoint.getZ());

}



/// process all triangles within the provided axis-aligned bounding box
/**
basic algorithm:
- convert input aabb to local coordinates (scale down and shift for local origin)
- convert input aabb to a range of heightfield grid points (quantize)
- iterate over all triangles in that subset of the grid
*/
void	btHeightfieldTerrainShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 // scale down the input aabb's so they are in local (non-scaled) coordinates
 btVector3	localAabbMin = aabbMin*btVector3(1.f / m_localScaling[0], 1.f / m_localScaling[1], 1.f / m_localScaling[2]);
 btVector3	localAabbMax = aabbMax*btVector3(1.f / m_localScaling[0], 1.f / m_localScaling[1], 1.f / m_localScaling[2]);

 // account for local origin
 localAabbMin += m_localOrigin;
 localAabbMax += m_localOrigin;

 //quantize the aabbMin and aabbMax, and adjust the start/end ranges
 int	quantizedAabbMin[3];
 int	quantizedAabbMax[3];
 quantizeWithClamp(quantizedAabbMin, localAabbMin, 0);
 quantizeWithClamp(quantizedAabbMax, localAabbMax, 1);

 // expand the min/max quantized values
 // this is to catch the case where the input aabb falls between grid points!
 for (int i = 0; i < 3; ++i) {
  quantizedAabbMin[i]--;
  quantizedAabbMax[i]++;
 }

 int startX = 0;
 int endX = m_heightStickWidth - 1;
 int startJ = 0;
 int endJ = m_heightStickLength - 1;

 switch (m_upAxis)
 {
 case 0:
 {
  if (quantizedAabbMin[1]>startX)
   startX = quantizedAabbMin[1];
  if (quantizedAabbMax[1]<endX)
   endX = quantizedAabbMax[1];
  if (quantizedAabbMin[2]>startJ)
   startJ = quantizedAabbMin[2];
  if (quantizedAabbMax[2]<endJ)
   endJ = quantizedAabbMax[2];
  break;
 }
 case 1:
 {
  if (quantizedAabbMin[0]>startX)
   startX = quantizedAabbMin[0];
  if (quantizedAabbMax[0]<endX)
   endX = quantizedAabbMax[0];
  if (quantizedAabbMin[2]>startJ)
   startJ = quantizedAabbMin[2];
  if (quantizedAabbMax[2]<endJ)
   endJ = quantizedAabbMax[2];
  break;
 };
 case 2:
 {
  if (quantizedAabbMin[0]>startX)
   startX = quantizedAabbMin[0];
  if (quantizedAabbMax[0]<endX)
   endX = quantizedAabbMax[0];
  if (quantizedAabbMin[1]>startJ)
   startJ = quantizedAabbMin[1];
  if (quantizedAabbMax[1]<endJ)
   endJ = quantizedAabbMax[1];
  break;
 }
 default:
 {
  //need to get valid m_upAxis
  btAssert(0);
 }
 }




 for (int j = startJ; j<endJ; j++)
 {
  for (int x = startX; x<endX; x++)
  {
   btVector3 vertices[3];
   if (m_flipQuadEdges || (m_useDiamondSubdivision && !((j + x) & 1)) || (m_useZigzagSubdivision && !(j & 1)))
   {
    //first triangle
    getVertex(x, j, vertices[0]);
    getVertex(x, j + 1, vertices[1]);
    getVertex(x + 1, j + 1, vertices[2]);
    callback->processTriangle(vertices, x, j);
    //second triangle
    //  getVertex(x,j,vertices[0]);//already got this vertex before, thanks to Danny Chapman
    getVertex(x + 1, j + 1, vertices[1]);
    getVertex(x + 1, j, vertices[2]);
    callback->processTriangle(vertices, x, j);

   }
   else
   {
    //first triangle
    getVertex(x, j, vertices[0]);
    getVertex(x, j + 1, vertices[1]);
    getVertex(x + 1, j, vertices[2]);
    callback->processTriangle(vertices, x, j);
    //second triangle
    getVertex(x + 1, j, vertices[0]);
    //getVertex(x,j+1,vertices[1]);
    getVertex(x + 1, j + 1, vertices[2]);
    callback->processTriangle(vertices, x, j);
   }
  }
 }



}

void	btHeightfieldTerrainShape::calculateLocalInertia(btScalar, btVector3& inertia) const
{
 //moving concave objects not supported

 inertia.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
}

void	btHeightfieldTerrainShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling;
}
const btVector3& btHeightfieldTerrainShape::getLocalScaling() const
{
 return m_localScaling;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btMinkowskiSumShape.h"


btMinkowskiSumShape::btMinkowskiSumShape(const btConvexShape* shapeA, const btConvexShape* shapeB)
 : btConvexInternalShape(),
 m_shapeA(shapeA),
 m_shapeB(shapeB)
{
 m_shapeType = MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE;
 m_transA.setIdentity();
 m_transB.setIdentity();
}

btVector3 btMinkowskiSumShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 btVector3 supVertexA = m_transA(m_shapeA->localGetSupportingVertexWithoutMargin(vec*m_transA.getBasis()));
 btVector3 supVertexB = m_transB(m_shapeB->localGetSupportingVertexWithoutMargin(-vec*m_transB.getBasis()));
 return  supVertexA - supVertexB;
}

void	btMinkowskiSumShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 ///@todo: could make recursive use of batching. probably this shape is not used frequently.
 for (int i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i] = localGetSupportingVertexWithoutMargin(vectors[i]);
 }

}



btScalar	btMinkowskiSumShape::getMargin() const
{
 return m_shapeA->getMargin() + m_shapeB->getMargin();
}


void	btMinkowskiSumShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 (void)mass;
 //inertia of the AABB of the Minkowski sum
 btTransform identity;
 identity.setIdentity();
 btVector3 aabbMin, aabbMax;
 getAabb(identity, aabbMin, aabbMax);

 btVector3 halfExtents = (aabbMax - aabbMin)*btScalar(0.5);

 btScalar margin = getMargin();

 btScalar lx = btScalar(2.)*(halfExtents.x() + margin);
 btScalar ly = btScalar(2.)*(halfExtents.y() + margin);
 btScalar lz = btScalar(2.)*(halfExtents.z() + margin);
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(0.08333333);

 inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/// This file was created by Alex Silverman

#include "BulletCollision/CollisionShapes/btMultimaterialTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btTriangleIndexVertexMaterialArray.h"
//#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"


///Obtains the material for a specific triangle
const btMaterial * btMultimaterialTriangleMeshShape::getMaterialProperties(int partID, int triIndex)
{
 const unsigned char * materialBase = 0;
 int numMaterials;
 PHY_ScalarType materialType;
 int materialStride;
 const unsigned char * triangleMaterialBase = 0;
 int numTriangles;
 int triangleMaterialStride;
 PHY_ScalarType triangleType;

 ((btTriangleIndexVertexMaterialArray*)m_meshInterface)->getLockedReadOnlyMaterialBase(&materialBase, numMaterials, materialType, materialStride,
  &triangleMaterialBase, numTriangles, triangleMaterialStride, triangleType, partID);

 // return the pointer to the place with the friction for the triangle
 // TODO: This depends on whether it's a moving mesh or not
 // BUG IN GIMPACT
 //return (btScalar*)(&materialBase[triangleMaterialBase[(triIndex-1) * triangleMaterialStride] * materialStride]);
 int * matInd = (int *)(&(triangleMaterialBase[(triIndex * triangleMaterialStride)]));
 btMaterial *matVal = (btMaterial *)(&(materialBase[*matInd * materialStride]));
 return (matVal);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined (_WIN32) || defined (__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "LinearMath/btQuaternion.h"
#include "LinearMath/btSerializer.h"

btMultiSphereShape::btMultiSphereShape(const btVector3* positions, const btScalar* radi, int numSpheres)
 :btConvexInternalAabbCachingShape()
{
 m_shapeType = MULTI_SPHERE_SHAPE_PROXYTYPE;
 //btScalar startMargin = btScalar(BT_LARGE_FLOAT);

 m_localPositionArray.resize(numSpheres);
 m_radiArray.resize(numSpheres);
 for (int i = 0; i<numSpheres; i++)
 {
  m_localPositionArray[i] = positions[i];
  m_radiArray[i] = radi[i];

 }

 recalcLocalAabb();

}

#ifndef MIN
#define MIN( _a, _b)    ((_a) < (_b) ? (_a) : (_b))
#endif
btVector3	btMultiSphereShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0)const
{
 btVector3 supVec(0, 0, 0);

 btScalar maxDot(btScalar(-BT_LARGE_FLOAT));


 btVector3 vec = vec0;
 btScalar lenSqr = vec.length2();
 if (lenSqr < (SIMD_EPSILON*SIMD_EPSILON))
 {
  vec.setValue(1, 0, 0);
 }
 else
 {
  btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
  vec *= rlen;
 }

 btVector3 vtx;
 btScalar newDot;

 const btVector3* pos = &m_localPositionArray[0];
 const btScalar* rad = &m_radiArray[0];
 int numSpheres = m_localPositionArray.size();

 for (int k = 0; k < numSpheres; k += 128)
 {
  btVector3 temp[128];
  int inner_count = MIN(numSpheres - k, 128);
  for (long i = 0; i < inner_count; i++)
  {
   temp[i] = (*pos)*m_localScaling + vec*m_localScaling*(*rad) - vec * getMargin();
   pos++;
   rad++;
  }
  long i = vec.maxDot(temp, inner_count, newDot);
  if (newDot > maxDot)
  {
   maxDot = newDot;
   supVec = temp[i];
  }
 }

 return supVec;

}

void	btMultiSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{

 for (int j = 0; j<numVectors; j++)
 {
  btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

  const btVector3& vec = vectors[j];

  btVector3 vtx;
  btScalar newDot;

  const btVector3* pos = &m_localPositionArray[0];
  const btScalar* rad = &m_radiArray[0];
  int numSpheres = m_localPositionArray.size();

  for (int k = 0; k < numSpheres; k += 128)
  {
   btVector3 temp[128];
   int inner_count = MIN(numSpheres - k, 128);
   for (long i = 0; i < inner_count; i++)
   {
    temp[i] = (*pos)*m_localScaling + vec*m_localScaling*(*rad) - vec * getMargin();
    pos++;
    rad++;
   }
   long i = vec.maxDot(temp, inner_count, newDot);
   if (newDot > maxDot)
   {
    maxDot = newDot;
    supportVerticesOut[j] = temp[i];
   }
  }

 }
}








void	btMultiSphereShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 //as an approximation, take the inertia of the box that bounds the spheres

 btVector3 localAabbMin, localAabbMax;
 getCachedLocalAabb(localAabbMin, localAabbMax);
 btVector3 halfExtents = (localAabbMax - localAabbMin)*btScalar(0.5);

 btScalar lx = btScalar(2.)*(halfExtents.x());
 btScalar ly = btScalar(2.)*(halfExtents.y());
 btScalar lz = btScalar(2.)*(halfExtents.z());

 inertia.setValue(mass / (btScalar(12.0)) * (ly*ly + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + lz*lz),
  mass / (btScalar(12.0)) * (lx*lx + ly*ly));

}


///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btMultiSphereShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btMultiSphereShapeData* shapeData = (btMultiSphereShapeData*)dataBuffer;
 btConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serializer);

 int numElem = m_localPositionArray.size();
 shapeData->m_localPositionArrayPtr = numElem ? (btPositionAndRadius*)serializer->getUniquePointer((void*)&m_localPositionArray[0]) : 0;

 shapeData->m_localPositionArraySize = numElem;
 if (numElem)
 {
  btChunk* chunk = serializer->allocate(sizeof(btPositionAndRadius), numElem);
  btPositionAndRadius* memPtr = (btPositionAndRadius*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   m_localPositionArray[i].serializeFloat(memPtr->m_pos);
   memPtr->m_radius = float(m_radiArray[i]);
  }
  serializer->finalizeChunk(chunk, "btPositionAndRadius", BT_ARRAY_CODE, (void*)&m_localPositionArray[0]);
 }

 // Fill padding with zeros to appease msan.
 memset(shapeData->m_padding, 0, sizeof(shapeData->m_padding));

 return "btMultiSphereShapeData";
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btIDebugDraw.h"


btOptimizedBvh::btOptimizedBvh()
{
}

btOptimizedBvh::~btOptimizedBvh()
{
}


void btOptimizedBvh::build(btStridingMeshInterface* triangles, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax)
{
 m_useQuantization = useQuantizedAabbCompression;


 // NodeArray	triangleNodes;

 struct	NodeTriangleCallback : public btInternalTriangleIndexCallback
 {

  NodeArray&	m_triangleNodes;

  NodeTriangleCallback& operator=(NodeTriangleCallback& other)
  {
   m_triangleNodes.copyFromArray(other.m_triangleNodes);
   return *this;
  }

  NodeTriangleCallback(NodeArray&	triangleNodes)
   :m_triangleNodes(triangleNodes)
  {
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int  triangleIndex)
  {
   btOptimizedBvhNode node;
   btVector3	aabbMin, aabbMax;
   aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
   aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
   aabbMin.setMin(triangle[0]);
   aabbMax.setMax(triangle[0]);
   aabbMin.setMin(triangle[1]);
   aabbMax.setMax(triangle[1]);
   aabbMin.setMin(triangle[2]);
   aabbMax.setMax(triangle[2]);

   //with quantization?
   node.m_aabbMinOrg = aabbMin;
   node.m_aabbMaxOrg = aabbMax;

   node.m_escapeIndex = -1;

   //for child nodes
   node.m_subPart = partId;
   node.m_triangleIndex = triangleIndex;
   m_triangleNodes.push_back(node);
  }
 };
 struct	QuantizedNodeTriangleCallback : public btInternalTriangleIndexCallback
 {
  QuantizedNodeArray&	m_triangleNodes;
  const btQuantizedBvh* m_optimizedTree; // for quantization

  QuantizedNodeTriangleCallback& operator=(QuantizedNodeTriangleCallback& other)
  {
   m_triangleNodes.copyFromArray(other.m_triangleNodes);
   m_optimizedTree = other.m_optimizedTree;
   return *this;
  }

  QuantizedNodeTriangleCallback(QuantizedNodeArray&	triangleNodes, const btQuantizedBvh* tree)
   :m_triangleNodes(triangleNodes), m_optimizedTree(tree)
  {
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int  triangleIndex)
  {
   // The partId and triangle index must fit in the same (positive) integer
   btAssert(partId < (1 << MAX_NUM_PARTS_IN_BITS));
   btAssert(triangleIndex < (1 << (31 - MAX_NUM_PARTS_IN_BITS)));
   //negative indices are reserved for escapeIndex
   btAssert(triangleIndex >= 0);

   btQuantizedBvhNode node;
   btVector3	aabbMin, aabbMax;
   aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
   aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
   aabbMin.setMin(triangle[0]);
   aabbMax.setMax(triangle[0]);
   aabbMin.setMin(triangle[1]);
   aabbMax.setMax(triangle[1]);
   aabbMin.setMin(triangle[2]);
   aabbMax.setMax(triangle[2]);

   //PCK: add these checks for zero dimensions of aabb
   const btScalar MIN_AABB_DIMENSION = btScalar(0.002);
   const btScalar MIN_AABB_HALF_DIMENSION = btScalar(0.001);
   if (aabbMax.x() - aabbMin.x() < MIN_AABB_DIMENSION)
   {
    aabbMax.setX(aabbMax.x() + MIN_AABB_HALF_DIMENSION);
    aabbMin.setX(aabbMin.x() - MIN_AABB_HALF_DIMENSION);
   }
   if (aabbMax.y() - aabbMin.y() < MIN_AABB_DIMENSION)
   {
    aabbMax.setY(aabbMax.y() + MIN_AABB_HALF_DIMENSION);
    aabbMin.setY(aabbMin.y() - MIN_AABB_HALF_DIMENSION);
   }
   if (aabbMax.z() - aabbMin.z() < MIN_AABB_DIMENSION)
   {
    aabbMax.setZ(aabbMax.z() + MIN_AABB_HALF_DIMENSION);
    aabbMin.setZ(aabbMin.z() - MIN_AABB_HALF_DIMENSION);
   }

   m_optimizedTree->quantize(&node.m_quantizedAabbMin[0], aabbMin, 0);
   m_optimizedTree->quantize(&node.m_quantizedAabbMax[0], aabbMax, 1);

   node.m_escapeIndexOrTriangleIndex = (partId << (31 - MAX_NUM_PARTS_IN_BITS)) | triangleIndex;

   m_triangleNodes.push_back(node);
  }
 };



 int numLeafNodes = 0;


 if (m_useQuantization)
 {

  //initialize quantization values
  setQuantizationValues(bvhAabbMin, bvhAabbMax);

  QuantizedNodeTriangleCallback	callback(m_quantizedLeafNodes, this);


  triangles->InternalProcessAllTriangles(&callback, m_bvhAabbMin, m_bvhAabbMax);

  //now we have an array of leafnodes in m_leafNodes
  numLeafNodes = m_quantizedLeafNodes.size();


  m_quantizedContiguousNodes.resize(2 * numLeafNodes);


 }
 else
 {
  NodeTriangleCallback	callback(m_leafNodes);

  btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
  btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));

  triangles->InternalProcessAllTriangles(&callback, aabbMin, aabbMax);

  //now we have an array of leafnodes in m_leafNodes
  numLeafNodes = m_leafNodes.size();

  m_contiguousNodes.resize(2 * numLeafNodes);
 }

 m_curNodeIndex = 0;

 buildTree(0, numLeafNodes);

 ///if the entire tree is small then subtree size, we need to create a header info for the tree
 if (m_useQuantization && !m_SubtreeHeaders.size())
 {
  btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
  subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[0]);
  subtree.m_rootNodeIndex = 0;
  subtree.m_subtreeSize = m_quantizedContiguousNodes[0].isLeafNode() ? 1 : m_quantizedContiguousNodes[0].getEscapeIndex();
 }

 //PCK: update the copy of the size
 m_subtreeHeaderCount = m_SubtreeHeaders.size();

 //PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
 m_quantizedLeafNodes.clear();
 m_leafNodes.clear();
}




void	btOptimizedBvh::refit(btStridingMeshInterface* meshInterface, const btVector3& aabbMin, const btVector3& aabbMax)
{
 if (m_useQuantization)
 {

  setQuantizationValues(aabbMin, aabbMax);

  updateBvhNodes(meshInterface, 0, m_curNodeIndex, 0);

  ///now update all subtree headers

  int i;
  for (i = 0; i<m_SubtreeHeaders.size(); i++)
  {
   btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];
   subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[subtree.m_rootNodeIndex]);
  }

 }
 else
 {

 }
}




void	btOptimizedBvh::refitPartial(btStridingMeshInterface* meshInterface, const btVector3& aabbMin, const btVector3& aabbMax)
{
 //incrementally initialize quantization values
 btAssert(m_useQuantization);

 btAssert(aabbMin.getX() > m_bvhAabbMin.getX());
 btAssert(aabbMin.getY() > m_bvhAabbMin.getY());
 btAssert(aabbMin.getZ() > m_bvhAabbMin.getZ());

 btAssert(aabbMax.getX() < m_bvhAabbMax.getX());
 btAssert(aabbMax.getY() < m_bvhAabbMax.getY());
 btAssert(aabbMax.getZ() < m_bvhAabbMax.getZ());

 ///we should update all quantization values, using updateBvhNodes(meshInterface);
 ///but we only update chunks that overlap the given aabb

 unsigned short	quantizedQueryAabbMin[3];
 unsigned short	quantizedQueryAabbMax[3];

 quantize(&quantizedQueryAabbMin[0], aabbMin, 0);
 quantize(&quantizedQueryAabbMax[0], aabbMax, 1);

 int i;
 for (i = 0; i<this->m_SubtreeHeaders.size(); i++)
 {
  btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];

  //PCK: unsigned instead of bool
  unsigned overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, subtree.m_quantizedAabbMin, subtree.m_quantizedAabbMax);
  if (overlap != 0)
  {
   updateBvhNodes(meshInterface, subtree.m_rootNodeIndex, subtree.m_rootNodeIndex + subtree.m_subtreeSize, i);

   subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[subtree.m_rootNodeIndex]);
  }
 }

}

void	btOptimizedBvh::updateBvhNodes(btStridingMeshInterface* meshInterface, int firstNode, int endNode, int index)
{
 (void)index;

 btAssert(m_useQuantization);

 int curNodeSubPart = -1;

 //get access info to trianglemesh data
 const unsigned char *vertexbase = 0;
 int numverts = 0;
 PHY_ScalarType type = PHY_INTEGER;
 int stride = 0;
 const unsigned char *indexbase = 0;
 int indexstride = 0;
 int numfaces = 0;
 PHY_ScalarType indicestype = PHY_INTEGER;

 btVector3	triangleVerts[3];
 btVector3	aabbMin, aabbMax;
 const btVector3& meshScaling = meshInterface->getScaling();

 int i;
 for (i = endNode - 1; i >= firstNode; i--)
 {


  btQuantizedBvhNode& curNode = m_quantizedContiguousNodes[i];
  if (curNode.isLeafNode())
  {
   //recalc aabb from triangle data
   int nodeSubPart = curNode.getPartId();
   int nodeTriangleIndex = curNode.getTriangleIndex();
   if (nodeSubPart != curNodeSubPart)
   {
    if (curNodeSubPart >= 0)
     meshInterface->unLockReadOnlyVertexBase(curNodeSubPart);
    meshInterface->getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numfaces, indicestype, nodeSubPart);

    curNodeSubPart = nodeSubPart;
    btAssert(indicestype == PHY_INTEGER || indicestype == PHY_SHORT);
   }
   //triangles->getLockedReadOnlyVertexIndexBase(vertexBase,numVerts,

   unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex*indexstride);


   for (int j = 2; j >= 0; j--)
   {

    int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : gfxbase[j];
    if (type == PHY_FLOAT)
    {
     float* graphicsbase = (float*)(vertexbase + graphicsindex*stride);
     triangleVerts[j] = btVector3(
      graphicsbase[0] * meshScaling.getX(),
      graphicsbase[1] * meshScaling.getY(),
      graphicsbase[2] * meshScaling.getZ());
    }
    else
    {
     double* graphicsbase = (double*)(vertexbase + graphicsindex*stride);
     triangleVerts[j] = btVector3(btScalar(graphicsbase[0] * meshScaling.getX()), btScalar(graphicsbase[1] * meshScaling.getY()), btScalar(graphicsbase[2] * meshScaling.getZ()));
    }
   }



   aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
   aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
   aabbMin.setMin(triangleVerts[0]);
   aabbMax.setMax(triangleVerts[0]);
   aabbMin.setMin(triangleVerts[1]);
   aabbMax.setMax(triangleVerts[1]);
   aabbMin.setMin(triangleVerts[2]);
   aabbMax.setMax(triangleVerts[2]);

   quantize(&curNode.m_quantizedAabbMin[0], aabbMin, 0);
   quantize(&curNode.m_quantizedAabbMax[0], aabbMax, 1);

  }
  else
  {
   //combine aabb from both children

   btQuantizedBvhNode* leftChildNode = &m_quantizedContiguousNodes[i + 1];

   btQuantizedBvhNode* rightChildNode = leftChildNode->isLeafNode() ? &m_quantizedContiguousNodes[i + 2] :
    &m_quantizedContiguousNodes[i + 1 + leftChildNode->getEscapeIndex()];


   {
    for (int i = 0; i<3; i++)
    {
     curNode.m_quantizedAabbMin[i] = leftChildNode->m_quantizedAabbMin[i];
     if (curNode.m_quantizedAabbMin[i]>rightChildNode->m_quantizedAabbMin[i])
      curNode.m_quantizedAabbMin[i] = rightChildNode->m_quantizedAabbMin[i];

     curNode.m_quantizedAabbMax[i] = leftChildNode->m_quantizedAabbMax[i];
     if (curNode.m_quantizedAabbMax[i] < rightChildNode->m_quantizedAabbMax[i])
      curNode.m_quantizedAabbMax[i] = rightChildNode->m_quantizedAabbMax[i];
    }
   }
  }

 }

 if (curNodeSubPart >= 0)
  meshInterface->unLockReadOnlyVertexBase(curNodeSubPart);


}

///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
btOptimizedBvh* btOptimizedBvh::deSerializeInPlace(void *i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian)
{
 btQuantizedBvh* bvh = btQuantizedBvh::deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian);

 //we don't add additional data so just do a static upcast
 return static_cast<btOptimizedBvh*>(bvh);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#if defined (_WIN32) || defined (__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btConvexHullComputer.h"
#include <new>
#include "LinearMath/btGeometryUtil.h"
#include "LinearMath/btGrahamScan2dConvexHull.h"


btPolyhedralConvexShape::btPolyhedralConvexShape() :btConvexInternalShape(),
m_polyhedron(0)
{

}

btPolyhedralConvexShape::~btPolyhedralConvexShape()
{
 if (m_polyhedron)
 {
  m_polyhedron->~btConvexPolyhedron();
  btAlignedFree(m_polyhedron);
 }
}


bool	btPolyhedralConvexShape::initializePolyhedralFeatures(int shiftVerticesByMargin)
{

 if (m_polyhedron)
 {
  m_polyhedron->~btConvexPolyhedron();
  btAlignedFree(m_polyhedron);
 }

 void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
 m_polyhedron = new (mem) btConvexPolyhedron;

 btAlignedObjectArray<btVector3> orgVertices;

 for (int i = 0; i<getNumVertices(); i++)
 {
  btVector3& newVertex = orgVertices.expand();
  getVertex(i, newVertex);
 }

 btConvexHullComputer conv;

 if (shiftVerticesByMargin)
 {
  btAlignedObjectArray<btVector3> planeEquations;
  btGeometryUtil::getPlaneEquationsFromVertices(orgVertices, planeEquations);

  btAlignedObjectArray<btVector3> shiftedPlaneEquations;
  for (int p = 0; p<planeEquations.size(); p++)
  {
   btVector3 plane = planeEquations[p];
   //	   btScalar margin = getMargin();
   plane[3] -= getMargin();
   shiftedPlaneEquations.push_back(plane);
  }

  btAlignedObjectArray<btVector3> tmpVertices;

  btGeometryUtil::getVerticesFromPlaneEquations(shiftedPlaneEquations, tmpVertices);

  conv.compute(&tmpVertices[0].getX(), sizeof(btVector3), tmpVertices.size(), 0.f, 0.f);
 }
 else
 {

  conv.compute(&orgVertices[0].getX(), sizeof(btVector3), orgVertices.size(), 0.f, 0.f);
 }



 btAlignedObjectArray<btVector3> faceNormals;
 int numFaces = conv.faces.size();
 faceNormals.resize(numFaces);
 btConvexHullComputer* convexUtil = &conv;


 btAlignedObjectArray<btFace>	tmpFaces;
 tmpFaces.resize(numFaces);

 int numVertices = convexUtil->vertices.size();
 m_polyhedron->m_vertices.resize(numVertices);
 for (int p = 0; p<numVertices; p++)
 {
  m_polyhedron->m_vertices[p] = convexUtil->vertices[p];
 }


 for (int i = 0; i<numFaces; i++)
 {
  int face = convexUtil->faces[i];
  //printf("face=%d\n",face);
  const btConvexHullComputer::Edge*  firstEdge = &convexUtil->edges[face];
  const btConvexHullComputer::Edge*  edge = firstEdge;

  btVector3 edges[3];
  int numEdges = 0;
  //compute face normals

  do
  {

   int src = edge->getSourceVertex();
   tmpFaces[i].m_indices.push_back(src);
   int targ = edge->getTargetVertex();
   btVector3 wa = convexUtil->vertices[src];

   btVector3 wb = convexUtil->vertices[targ];
   btVector3 newEdge = wb - wa;
   newEdge.normalize();
   if (numEdges<2)
    edges[numEdges++] = newEdge;

   edge = edge->getNextEdgeOfFace();
  } while (edge != firstEdge);

  btScalar planeEq = 1e30f;


  if (numEdges == 2)
  {
   faceNormals[i] = edges[0].cross(edges[1]);
   faceNormals[i].normalize();
   tmpFaces[i].m_plane[0] = faceNormals[i].getX();
   tmpFaces[i].m_plane[1] = faceNormals[i].getY();
   tmpFaces[i].m_plane[2] = faceNormals[i].getZ();
   tmpFaces[i].m_plane[3] = planeEq;

  }
  else
  {
   btAssert(0);//degenerate?
   faceNormals[i].setZero();
  }

  for (int v = 0; v<tmpFaces[i].m_indices.size(); v++)
  {
   btScalar eq = m_polyhedron->m_vertices[tmpFaces[i].m_indices[v]].dot(faceNormals[i]);
   if (planeEq>eq)
   {
    planeEq = eq;
   }
  }
  tmpFaces[i].m_plane[3] = -planeEq;
 }

 //merge coplanar faces and copy them to m_polyhedron

 btScalar faceWeldThreshold = 0.999f;
 btAlignedObjectArray<int> todoFaces;
 for (int i = 0; i<tmpFaces.size(); i++)
  todoFaces.push_back(i);

 while (todoFaces.size())
 {
  btAlignedObjectArray<int> coplanarFaceGroup;
  int refFace = todoFaces[todoFaces.size() - 1];

  coplanarFaceGroup.push_back(refFace);
  btFace& faceA = tmpFaces[refFace];
  todoFaces.pop_back();

  btVector3 faceNormalA(faceA.m_plane[0], faceA.m_plane[1], faceA.m_plane[2]);
  for (int j = todoFaces.size() - 1; j >= 0; j--)
  {
   int i = todoFaces[j];
   btFace& faceB = tmpFaces[i];
   btVector3 faceNormalB(faceB.m_plane[0], faceB.m_plane[1], faceB.m_plane[2]);
   if (faceNormalA.dot(faceNormalB)>faceWeldThreshold)
   {
    coplanarFaceGroup.push_back(i);
    todoFaces.remove(i);
   }
  }


  bool did_merge = false;
  if (coplanarFaceGroup.size()>1)
  {
   //do the merge: use Graham Scan 2d convex hull

   btAlignedObjectArray<GrahamVector3> orgpoints;
   btVector3 averageFaceNormal(0, 0, 0);

   for (int i = 0; i<coplanarFaceGroup.size(); i++)
   {
    //				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);

    btFace& face = tmpFaces[coplanarFaceGroup[i]];
    btVector3 faceNormal(face.m_plane[0], face.m_plane[1], face.m_plane[2]);
    averageFaceNormal += faceNormal;
    for (int f = 0; f<face.m_indices.size(); f++)
    {
     int orgIndex = face.m_indices[f];
     btVector3 pt = m_polyhedron->m_vertices[orgIndex];

     bool found = false;

     for (int i = 0; i<orgpoints.size(); i++)
     {
      //if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
      if (orgpoints[i].m_orgIndex == orgIndex)
      {
       found = true;
       break;
      }
     }
     if (!found)
      orgpoints.push_back(GrahamVector3(pt, orgIndex));
    }
   }



   btFace combinedFace;
   for (int i = 0; i<4; i++)
    combinedFace.m_plane[i] = tmpFaces[coplanarFaceGroup[0]].m_plane[i];

   btAlignedObjectArray<GrahamVector3> hull;

   averageFaceNormal.normalize();
   GrahamScanConvexHull2D(orgpoints, hull, averageFaceNormal);

   for (int i = 0; i<hull.size(); i++)
   {
    combinedFace.m_indices.push_back(hull[i].m_orgIndex);
    for (int k = 0; k < orgpoints.size(); k++)
    {
     if (orgpoints[k].m_orgIndex == hull[i].m_orgIndex)
     {
      orgpoints[k].m_orgIndex = -1; // invalidate...
      break;
     }
    }
   }

   // are there rejected vertices?
   bool reject_merge = false;



   for (int i = 0; i < orgpoints.size(); i++) {
    if (orgpoints[i].m_orgIndex == -1)
     continue; // this is in the hull...
               // this vertex is rejected -- is anybody else using this vertex?
    for (int j = 0; j < tmpFaces.size(); j++) {

     btFace& face = tmpFaces[j];
     // is this a face of the current coplanar group?
     bool is_in_current_group = false;
     for (int k = 0; k < coplanarFaceGroup.size(); k++) {
      if (coplanarFaceGroup[k] == j) {
       is_in_current_group = true;
       break;
      }
     }
     if (is_in_current_group) // ignore this face...
      continue;
     // does this face use this rejected vertex?
     for (int v = 0; v < face.m_indices.size(); v++) {
      if (face.m_indices[v] == orgpoints[i].m_orgIndex) {
       // this rejected vertex is used in another face -- reject merge
       reject_merge = true;
       break;
      }
     }
     if (reject_merge)
      break;
    }
    if (reject_merge)
     break;
   }

   if (!reject_merge)
   {
    // do this merge!
    did_merge = true;
    m_polyhedron->m_faces.push_back(combinedFace);
   }
  }
  if (!did_merge)
  {
   for (int i = 0; i<coplanarFaceGroup.size(); i++)
   {
    btFace face = tmpFaces[coplanarFaceGroup[i]];
    m_polyhedron->m_faces.push_back(face);
   }

  }



 }

 m_polyhedron->initialize();

 return true;
}

#ifndef MIN
#define MIN(_a, _b)     ((_a) < (_b) ? (_a) : (_b))
#endif

btVector3	btPolyhedralConvexShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0)const
{


 btVector3 supVec(0, 0, 0);
#ifndef __SPU__
 int i;
 btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

 btVector3 vec = vec0;
 btScalar lenSqr = vec.length2();
 if (lenSqr < btScalar(0.0001))
 {
  vec.setValue(1, 0, 0);
 }
 else
 {
  btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
  vec *= rlen;
 }

 btVector3 vtx;
 btScalar newDot;

 for (int k = 0; k < getNumVertices(); k += 128)
 {
  btVector3 temp[128];
  int inner_count = MIN(getNumVertices() - k, 128);
  for (i = 0; i < inner_count; i++)
   getVertex(i, temp[i]);
  i = (int)vec.maxDot(temp, inner_count, newDot);
  if (newDot > maxDot)
  {
   maxDot = newDot;
   supVec = temp[i];
  }
 }

#endif //__SPU__
 return supVec;
}



void	btPolyhedralConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
#ifndef __SPU__
 int i;

 btVector3 vtx;
 btScalar newDot;

 for (i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
 }

 for (int j = 0; j<numVectors; j++)
 {
  const btVector3& vec = vectors[j];

  for (int k = 0; k < getNumVertices(); k += 128)
  {
   btVector3 temp[128];
   int inner_count = MIN(getNumVertices() - k, 128);
   for (i = 0; i < inner_count; i++)
    getVertex(i, temp[i]);
   i = (int)vec.maxDot(temp, inner_count, newDot);
   if (newDot > supportVerticesOut[j][3])
   {
    supportVerticesOut[j] = temp[i];
    supportVerticesOut[j][3] = newDot;
   }
  }
 }

#endif //__SPU__
}



void	btPolyhedralConvexShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
#ifndef __SPU__
 //not yet, return box inertia

 btScalar margin = getMargin();

 btTransform ident;
 ident.setIdentity();
 btVector3 aabbMin, aabbMax;
 getAabb(ident, aabbMin, aabbMax);
 btVector3 halfExtents = (aabbMax - aabbMin)*btScalar(0.5);

 btScalar lx = btScalar(2.)*(halfExtents.x() + margin);
 btScalar ly = btScalar(2.)*(halfExtents.y() + margin);
 btScalar lz = btScalar(2.)*(halfExtents.z() + margin);
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(0.08333333);

 inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));
#endif //__SPU__
}



void	btPolyhedralConvexAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
 btConvexInternalShape::setLocalScaling(scaling);
 recalcLocalAabb();
}

btPolyhedralConvexAabbCachingShape::btPolyhedralConvexAabbCachingShape()
 :btPolyhedralConvexShape(),
 m_localAabbMin(1, 1, 1),
 m_localAabbMax(-1, -1, -1),
 m_isLocalAabbValid(false)
{
}

void btPolyhedralConvexAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
 getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void	btPolyhedralConvexAabbCachingShape::recalcLocalAabb()
{
 m_isLocalAabbValid = true;

#if 1
 static const btVector3 _directions[] =
 {
  btVector3(1.,  0.,  0.),
  btVector3(0.,  1.,  0.),
  btVector3(0.,  0.,  1.),
  btVector3(-1., 0.,  0.),
  btVector3(0., -1.,  0.),
  btVector3(0.,  0., -1.)
 };

 btVector3 _supporting[] =
 {
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.)
 };

 batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

 for (int i = 0; i < 3; ++i)
 {
  m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
  m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
 }

#else

 for (int i = 0; i<3; i++)
 {
  btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
  vec[i] = btScalar(1.);
  btVector3 tmp = localGetSupportingVertex(vec);
  m_localAabbMax[i] = tmp[i];
  vec[i] = btScalar(-1.);
  tmp = localGetSupportingVertex(vec);
  m_localAabbMin[i] = tmp[i];
 }
#endif
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h"

btScaledBvhTriangleMeshShape::btScaledBvhTriangleMeshShape(btBvhTriangleMeshShape* childShape, const btVector3& localScaling)
 :m_localScaling(localScaling), m_bvhTriMeshShape(childShape)
{
 m_shapeType = SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE;
}

btScaledBvhTriangleMeshShape::~btScaledBvhTriangleMeshShape()
{
}


class btScaledTriangleCallback : public btTriangleCallback
{
 btTriangleCallback* m_originalCallback;

 btVector3	m_localScaling;

public:

 btScaledTriangleCallback(btTriangleCallback* originalCallback, const btVector3& localScaling)
  :m_originalCallback(originalCallback),
  m_localScaling(localScaling)
 {
 }

 virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
 {
  btVector3 newTriangle[3];
  newTriangle[0] = triangle[0] * m_localScaling;
  newTriangle[1] = triangle[1] * m_localScaling;
  newTriangle[2] = triangle[2] * m_localScaling;
  m_originalCallback->processTriangle(&newTriangle[0], partId, triangleIndex);
 }
};

void	btScaledBvhTriangleMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 btScaledTriangleCallback scaledCallback(callback, m_localScaling);

 btVector3 invLocalScaling(1.f / m_localScaling.getX(), 1.f / m_localScaling.getY(), 1.f / m_localScaling.getZ());
 btVector3 scaledAabbMin, scaledAabbMax;

 ///support negative scaling
 scaledAabbMin[0] = m_localScaling.getX() >= 0. ? aabbMin[0] * invLocalScaling[0] : aabbMax[0] * invLocalScaling[0];
 scaledAabbMin[1] = m_localScaling.getY() >= 0. ? aabbMin[1] * invLocalScaling[1] : aabbMax[1] * invLocalScaling[1];
 scaledAabbMin[2] = m_localScaling.getZ() >= 0. ? aabbMin[2] * invLocalScaling[2] : aabbMax[2] * invLocalScaling[2];
 scaledAabbMin[3] = 0.f;

 scaledAabbMax[0] = m_localScaling.getX() <= 0. ? aabbMin[0] * invLocalScaling[0] : aabbMax[0] * invLocalScaling[0];
 scaledAabbMax[1] = m_localScaling.getY() <= 0. ? aabbMin[1] * invLocalScaling[1] : aabbMax[1] * invLocalScaling[1];
 scaledAabbMax[2] = m_localScaling.getZ() <= 0. ? aabbMin[2] * invLocalScaling[2] : aabbMax[2] * invLocalScaling[2];
 scaledAabbMax[3] = 0.f;


 m_bvhTriMeshShape->processAllTriangles(&scaledCallback, scaledAabbMin, scaledAabbMax);
}


void	btScaledBvhTriangleMeshShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
 btVector3 localAabbMin = m_bvhTriMeshShape->getLocalAabbMin();
 btVector3 localAabbMax = m_bvhTriMeshShape->getLocalAabbMax();

 btVector3 tmpLocalAabbMin = localAabbMin * m_localScaling;
 btVector3 tmpLocalAabbMax = localAabbMax * m_localScaling;

 localAabbMin[0] = (m_localScaling.getX() >= 0.) ? tmpLocalAabbMin[0] : tmpLocalAabbMax[0];
 localAabbMin[1] = (m_localScaling.getY() >= 0.) ? tmpLocalAabbMin[1] : tmpLocalAabbMax[1];
 localAabbMin[2] = (m_localScaling.getZ() >= 0.) ? tmpLocalAabbMin[2] : tmpLocalAabbMax[2];
 localAabbMax[0] = (m_localScaling.getX() <= 0.) ? tmpLocalAabbMin[0] : tmpLocalAabbMax[0];
 localAabbMax[1] = (m_localScaling.getY() <= 0.) ? tmpLocalAabbMin[1] : tmpLocalAabbMax[1];
 localAabbMax[2] = (m_localScaling.getZ() <= 0.) ? tmpLocalAabbMin[2] : tmpLocalAabbMax[2];

 btVector3 localHalfExtents = btScalar(0.5)*(localAabbMax - localAabbMin);
 btScalar margin = m_bvhTriMeshShape->getMargin();
 localHalfExtents += btVector3(margin, margin, margin);
 btVector3 localCenter = btScalar(0.5)*(localAabbMax + localAabbMin);

 btMatrix3x3 abs_b = trans.getBasis().absolute();

 btVector3 center = trans(localCenter);

 btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
 aabbMin = center - extent;
 aabbMax = center + extent;

}

void	btScaledBvhTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling;
}

const btVector3& btScaledBvhTriangleMeshShape::getLocalScaling() const
{
 return m_localScaling;
}

void	btScaledBvhTriangleMeshShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 ///don't make this a movable object!
 //	btAssert(0);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//btShapeHull was implemented by John McCutchan.


#include "BulletCollision/CollisionShapes/btShapeHull.h"
#include "LinearMath/btConvexHull.h"

#define NUM_UNITSPHERE_POINTS 42

btShapeHull::btShapeHull(const btConvexShape* shape)
{
 m_shape = shape;
 m_vertices.clear();
 m_indices.clear();
 m_numIndices = 0;
}

btShapeHull::~btShapeHull()
{
 m_indices.clear();
 m_vertices.clear();
}

bool
btShapeHull::buildHull(btScalar /*margin*/)
{
 int numSampleDirections = NUM_UNITSPHERE_POINTS;
 {
  int numPDA = m_shape->getNumPreferredPenetrationDirections();
  if (numPDA)
  {
   for (int i = 0; i<numPDA; i++)
   {
    btVector3 norm;
    m_shape->getPreferredPenetrationDirection(i, norm);
    getUnitSpherePoints()[numSampleDirections] = norm;
    numSampleDirections++;
   }
  }
 }

 btVector3 supportPoints[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2];
 int i;
 for (i = 0; i < numSampleDirections; i++)
 {
  supportPoints[i] = m_shape->localGetSupportingVertex(getUnitSpherePoints()[i]);
 }

 HullDesc hd;
 hd.mFlags = QF_TRIANGLES;
 hd.mVcount = static_cast<unsigned int>(numSampleDirections);

#ifdef BT_USE_DOUBLE_PRECISION
 hd.mVertices = &supportPoints[0];
 hd.mVertexStride = sizeof(btVector3);
#else
 hd.mVertices = &supportPoints[0];
 hd.mVertexStride = sizeof(btVector3);
#endif

 HullLibrary hl;
 HullResult hr;
 if (hl.CreateConvexHull(hd, hr) == QE_FAIL)
 {
  return false;
 }

 m_vertices.resize(static_cast<int>(hr.mNumOutputVertices));


 for (i = 0; i < static_cast<int>(hr.mNumOutputVertices); i++)
 {
  m_vertices[i] = hr.m_OutputVertices[i];
 }
 m_numIndices = hr.mNumIndices;
 m_indices.resize(static_cast<int>(m_numIndices));
 for (i = 0; i < static_cast<int>(m_numIndices); i++)
 {
  m_indices[i] = hr.m_Indices[i];
 }

 // free temporary hull result that we just copied
 hl.ReleaseResult(hr);

 return true;
}

int
btShapeHull::numTriangles() const
{
 return static_cast<int>(m_numIndices / 3);
}

int
btShapeHull::numVertices() const
{
 return m_vertices.size();
}

int
btShapeHull::numIndices() const
{
 return static_cast<int>(m_numIndices);
}


btVector3* btShapeHull::getUnitSpherePoints()
{
 static btVector3 sUnitSpherePoints[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2] =
 {
  btVector3(btScalar(0.000000) , btScalar(-0.000000),btScalar(-1.000000)),
  btVector3(btScalar(0.723608) , btScalar(-0.525725),btScalar(-0.447219)),
  btVector3(btScalar(-0.276388) , btScalar(-0.850649),btScalar(-0.447219)),
  btVector3(btScalar(-0.894426) , btScalar(-0.000000),btScalar(-0.447216)),
  btVector3(btScalar(-0.276388) , btScalar(0.850649),btScalar(-0.447220)),
  btVector3(btScalar(0.723608) , btScalar(0.525725),btScalar(-0.447219)),
  btVector3(btScalar(0.276388) , btScalar(-0.850649),btScalar(0.447220)),
  btVector3(btScalar(-0.723608) , btScalar(-0.525725),btScalar(0.447219)),
  btVector3(btScalar(-0.723608) , btScalar(0.525725),btScalar(0.447219)),
  btVector3(btScalar(0.276388) , btScalar(0.850649),btScalar(0.447219)),
  btVector3(btScalar(0.894426) , btScalar(0.000000),btScalar(0.447216)),
  btVector3(btScalar(-0.000000) , btScalar(0.000000),btScalar(1.000000)),
  btVector3(btScalar(0.425323) , btScalar(-0.309011),btScalar(-0.850654)),
  btVector3(btScalar(-0.162456) , btScalar(-0.499995),btScalar(-0.850654)),
  btVector3(btScalar(0.262869) , btScalar(-0.809012),btScalar(-0.525738)),
  btVector3(btScalar(0.425323) , btScalar(0.309011),btScalar(-0.850654)),
  btVector3(btScalar(0.850648) , btScalar(-0.000000),btScalar(-0.525736)),
  btVector3(btScalar(-0.525730) , btScalar(-0.000000),btScalar(-0.850652)),
  btVector3(btScalar(-0.688190) , btScalar(-0.499997),btScalar(-0.525736)),
  btVector3(btScalar(-0.162456) , btScalar(0.499995),btScalar(-0.850654)),
  btVector3(btScalar(-0.688190) , btScalar(0.499997),btScalar(-0.525736)),
  btVector3(btScalar(0.262869) , btScalar(0.809012),btScalar(-0.525738)),
  btVector3(btScalar(0.951058) , btScalar(0.309013),btScalar(0.000000)),
  btVector3(btScalar(0.951058) , btScalar(-0.309013),btScalar(0.000000)),
  btVector3(btScalar(0.587786) , btScalar(-0.809017),btScalar(0.000000)),
  btVector3(btScalar(0.000000) , btScalar(-1.000000),btScalar(0.000000)),
  btVector3(btScalar(-0.587786) , btScalar(-0.809017),btScalar(0.000000)),
  btVector3(btScalar(-0.951058) , btScalar(-0.309013),btScalar(-0.000000)),
  btVector3(btScalar(-0.951058) , btScalar(0.309013),btScalar(-0.000000)),
  btVector3(btScalar(-0.587786) , btScalar(0.809017),btScalar(-0.000000)),
  btVector3(btScalar(-0.000000) , btScalar(1.000000),btScalar(-0.000000)),
  btVector3(btScalar(0.587786) , btScalar(0.809017),btScalar(-0.000000)),
  btVector3(btScalar(0.688190) , btScalar(-0.499997),btScalar(0.525736)),
  btVector3(btScalar(-0.262869) , btScalar(-0.809012),btScalar(0.525738)),
  btVector3(btScalar(-0.850648) , btScalar(0.000000),btScalar(0.525736)),
  btVector3(btScalar(-0.262869) , btScalar(0.809012),btScalar(0.525738)),
  btVector3(btScalar(0.688190) , btScalar(0.499997),btScalar(0.525736)),
  btVector3(btScalar(0.525730) , btScalar(0.000000),btScalar(0.850652)),
  btVector3(btScalar(0.162456) , btScalar(-0.499995),btScalar(0.850654)),
  btVector3(btScalar(-0.425323) , btScalar(-0.309011),btScalar(0.850654)),
  btVector3(btScalar(-0.425323) , btScalar(0.309011),btScalar(0.850654)),
  btVector3(btScalar(0.162456) , btScalar(0.499995),btScalar(0.850654))
 };
 return sUnitSpherePoints;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"

btVector3	btSphereShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 (void)vec;
 return btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
}

void	btSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 (void)vectors;

 for (int i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i].setValue(btScalar(0.), btScalar(0.), btScalar(0.));
 }
}


btVector3	btSphereShape::localGetSupportingVertex(const btVector3& vec)const
{
 btVector3 supVertex;
 supVertex = localGetSupportingVertexWithoutMargin(vec);

 btVector3 vecnorm = vec;
 if (vecnorm.length2() < (SIMD_EPSILON*SIMD_EPSILON))
 {
  vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
 }
 vecnorm.normalize();
 supVertex += getMargin() * vecnorm;
 return supVertex;
}


//broken due to scaling
void btSphereShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 const btVector3& center = t.getOrigin();
 btVector3 extent(getMargin(), getMargin(), getMargin());
 aabbMin = center - extent;
 aabbMax = center + extent;
}



void	btSphereShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 btScalar elem = btScalar(0.4) * mass * getMargin()*getMargin();
 inertia.setValue(elem, elem, elem);

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"

#include "LinearMath/btTransformUtil.h"


btStaticPlaneShape::btStaticPlaneShape(const btVector3& planeNormal, btScalar planeConstant)
 : btConcaveShape(), m_planeNormal(planeNormal.normalized()),
 m_planeConstant(planeConstant),
 m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.))
{
 m_shapeType = STATIC_PLANE_PROXYTYPE;
 //	btAssert( btFuzzyZero(m_planeNormal.length() - btScalar(1.)) );
}


btStaticPlaneShape::~btStaticPlaneShape()
{
}



void btStaticPlaneShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
 (void)t;
 /*
 btVector3 infvec (btScalar(BT_LARGE_FLOAT),btScalar(BT_LARGE_FLOAT),btScalar(BT_LARGE_FLOAT));

 btVector3 center = m_planeNormal*m_planeConstant;
 aabbMin = center + infvec*m_planeNormal;
 aabbMax = aabbMin;
 aabbMin.setMin(center - infvec*m_planeNormal);
 aabbMax.setMax(center - infvec*m_planeNormal);
 */

 aabbMin.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
 aabbMax.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));

}




void	btStaticPlaneShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{

 btVector3 halfExtents = (aabbMax - aabbMin) * btScalar(0.5);
 btScalar radius = halfExtents.length();
 btVector3 center = (aabbMax + aabbMin) * btScalar(0.5);

 //this is where the triangles are generated, given AABB and plane equation (normal/constant)

 btVector3 tangentDir0, tangentDir1;

 //tangentDir0/tangentDir1 can be precalculated
 btPlaneSpace1(m_planeNormal, tangentDir0, tangentDir1);

 btVector3 supVertex0, supVertex1;

 btVector3 projectedCenter = center - (m_planeNormal.dot(center) - m_planeConstant)*m_planeNormal;

 btVector3 triangle[3];
 triangle[0] = projectedCenter + tangentDir0*radius + tangentDir1*radius;
 triangle[1] = projectedCenter + tangentDir0*radius - tangentDir1*radius;
 triangle[2] = projectedCenter - tangentDir0*radius - tangentDir1*radius;

 callback->processTriangle(triangle, 0, 0);

 triangle[0] = projectedCenter - tangentDir0*radius - tangentDir1*radius;
 triangle[1] = projectedCenter - tangentDir0*radius + tangentDir1*radius;
 triangle[2] = projectedCenter + tangentDir0*radius + tangentDir1*radius;

 callback->processTriangle(triangle, 0, 1);

}

void	btStaticPlaneShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 (void)mass;

 //moving concave objects not supported

 inertia.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
}

void	btStaticPlaneShape::setLocalScaling(const btVector3& scaling)
{
 m_localScaling = scaling;
}
const btVector3& btStaticPlaneShape::getLocalScaling() const
{
 return m_localScaling;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btSerializer.h"

btStridingMeshInterface::~btStridingMeshInterface()
{

}


void	btStridingMeshInterface::InternalProcessAllTriangles(btInternalTriangleIndexCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 (void)aabbMin;
 (void)aabbMax;
 int numtotalphysicsverts = 0;
 int part, graphicssubparts = getNumSubParts();
 const unsigned char * vertexbase;
 const unsigned char * indexbase;
 int indexstride;
 PHY_ScalarType type;
 PHY_ScalarType gfxindextype;
 int stride, numverts, numtriangles;
 int gfxindex;
 btVector3 triangle[3];

 btVector3 meshScaling = getScaling();

 ///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
 for (part = 0; part<graphicssubparts; part++)
 {
  getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numtriangles, gfxindextype, part);
  numtotalphysicsverts += numtriangles * 3; //upper bound

                                            ///unlike that developers want to pass in double-precision meshes in single-precision Bullet build
                                            ///so disable this feature by default
                                            ///see patch http://code.google.com/p/bullet/issues/detail?id=213

  switch (type)
  {
  case PHY_FLOAT:
  {

   float* graphicsbase;

   switch (gfxindextype)
   {
   case PHY_INTEGER:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex*indexstride);
     graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   case PHY_SHORT:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex*indexstride);
     graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   case PHY_UCHAR:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex*indexstride);
     graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   default:
    btAssert((gfxindextype == PHY_INTEGER) || (gfxindextype == PHY_SHORT));
   }
   break;
  }

  case PHY_DOUBLE:
  {
   double* graphicsbase;

   switch (gfxindextype)
   {
   case PHY_INTEGER:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex*indexstride);
     graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   case PHY_SHORT:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex*indexstride);
     graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   case PHY_UCHAR:
   {
    for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
    {
     unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex*indexstride);
     graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
     triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
     triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
     triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
     callback->internalProcessTriangleIndex(triangle, part, gfxindex);
    }
    break;
   }
   default:
    btAssert((gfxindextype == PHY_INTEGER) || (gfxindextype == PHY_SHORT));
   }
   break;
  }
  default:
   btAssert((type == PHY_FLOAT) || (type == PHY_DOUBLE));
  }

  unLockReadOnlyVertexBase(part);
 }
}

void	btStridingMeshInterface::calculateAabbBruteForce(btVector3& aabbMin, btVector3& aabbMax)
{

 struct	AabbCalculationCallback : public btInternalTriangleIndexCallback
 {
  btVector3	m_aabbMin;
  btVector3	m_aabbMax;

  AabbCalculationCallback()
  {
   m_aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
   m_aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int  triangleIndex)
  {
   (void)partId;
   (void)triangleIndex;

   m_aabbMin.setMin(triangle[0]);
   m_aabbMax.setMax(triangle[0]);
   m_aabbMin.setMin(triangle[1]);
   m_aabbMax.setMax(triangle[1]);
   m_aabbMin.setMin(triangle[2]);
   m_aabbMax.setMax(triangle[2]);
  }
 };

 //first calculate the total aabb for all triangles
 AabbCalculationCallback	aabbCallback;
 aabbMin.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
 aabbMax.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 InternalProcessAllTriangles(&aabbCallback, aabbMin, aabbMax);

 aabbMin = aabbCallback.m_aabbMin;
 aabbMax = aabbCallback.m_aabbMax;
}



///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btStridingMeshInterface::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btStridingMeshInterfaceData* trimeshData = (btStridingMeshInterfaceData*)dataBuffer;

 trimeshData->m_numMeshParts = getNumSubParts();

 //void* uniquePtr = 0;

 trimeshData->m_meshPartsPtr = 0;

 if (trimeshData->m_numMeshParts)
 {
  btChunk* chunk = serializer->allocate(sizeof(btMeshPartData), trimeshData->m_numMeshParts);
  btMeshPartData* memPtr = (btMeshPartData*)chunk->m_oldPtr;
  trimeshData->m_meshPartsPtr = (btMeshPartData *)serializer->getUniquePointer(memPtr);


  //	int numtotalphysicsverts = 0;
  int part, graphicssubparts = getNumSubParts();
  const unsigned char * vertexbase;
  const unsigned char * indexbase;
  int indexstride;
  PHY_ScalarType type;
  PHY_ScalarType gfxindextype;
  int stride, numverts, numtriangles;
  int gfxindex;
  //	btVector3 triangle[3];

  //	btVector3 meshScaling = getScaling();

  ///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
  for (part = 0; part<graphicssubparts; part++, memPtr++)
  {
   getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numtriangles, gfxindextype, part);
   memPtr->m_numTriangles = numtriangles;//indices = 3*numtriangles
   memPtr->m_numVertices = numverts;
   memPtr->m_indices16 = 0;
   memPtr->m_indices32 = 0;
   memPtr->m_3indices16 = 0;
   memPtr->m_3indices8 = 0;
   memPtr->m_vertices3f = 0;
   memPtr->m_vertices3d = 0;


   switch (gfxindextype)
   {
   case PHY_INTEGER:
   {
    int numindices = numtriangles * 3;

    if (numindices)
    {
     btChunk* chunk = serializer->allocate(sizeof(btIntIndexData), numindices);
     btIntIndexData* tmpIndices = (btIntIndexData*)chunk->m_oldPtr;
     memPtr->m_indices32 = (btIntIndexData*)serializer->getUniquePointer(tmpIndices);
     for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
     {
      unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex*indexstride);
      tmpIndices[gfxindex * 3].m_value = tri_indices[0];
      tmpIndices[gfxindex * 3 + 1].m_value = tri_indices[1];
      tmpIndices[gfxindex * 3 + 2].m_value = tri_indices[2];
     }
     serializer->finalizeChunk(chunk, "btIntIndexData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
    }
    break;
   }
   case PHY_SHORT:
   {
    if (numtriangles)
    {
     btChunk* chunk = serializer->allocate(sizeof(btShortIntIndexTripletData), numtriangles);
     btShortIntIndexTripletData* tmpIndices = (btShortIntIndexTripletData*)chunk->m_oldPtr;
     memPtr->m_3indices16 = (btShortIntIndexTripletData*)serializer->getUniquePointer(tmpIndices);
     for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
     {
      unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex*indexstride);
      tmpIndices[gfxindex].m_values[0] = tri_indices[0];
      tmpIndices[gfxindex].m_values[1] = tri_indices[1];
      tmpIndices[gfxindex].m_values[2] = tri_indices[2];
      // Fill padding with zeros to appease msan.
      tmpIndices[gfxindex].m_pad[0] = 0;
      tmpIndices[gfxindex].m_pad[1] = 0;
     }
     serializer->finalizeChunk(chunk, "btShortIntIndexTripletData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
    }
    break;
   }
   case PHY_UCHAR:
   {
    if (numtriangles)
    {
     btChunk* chunk = serializer->allocate(sizeof(btCharIndexTripletData), numtriangles);
     btCharIndexTripletData* tmpIndices = (btCharIndexTripletData*)chunk->m_oldPtr;
     memPtr->m_3indices8 = (btCharIndexTripletData*)serializer->getUniquePointer(tmpIndices);
     for (gfxindex = 0; gfxindex<numtriangles; gfxindex++)
     {
      unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex*indexstride);
      tmpIndices[gfxindex].m_values[0] = tri_indices[0];
      tmpIndices[gfxindex].m_values[1] = tri_indices[1];
      tmpIndices[gfxindex].m_values[2] = tri_indices[2];
      // Fill padding with zeros to appease msan.
      tmpIndices[gfxindex].m_pad = 0;
     }
     serializer->finalizeChunk(chunk, "btCharIndexTripletData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
    }
    break;
   }
   default:
   {
    btAssert(0);
    //unknown index type
   }
   }

   switch (type)
   {
   case PHY_FLOAT:
   {
    float* graphicsbase;

    if (numverts)
    {
     btChunk* chunk = serializer->allocate(sizeof(btVector3FloatData), numverts);
     btVector3FloatData* tmpVertices = (btVector3FloatData*)chunk->m_oldPtr;
     memPtr->m_vertices3f = (btVector3FloatData *)serializer->getUniquePointer(tmpVertices);
     for (int i = 0; i<numverts; i++)
     {
      graphicsbase = (float*)(vertexbase + i*stride);
      tmpVertices[i].m_floats[0] = graphicsbase[0];
      tmpVertices[i].m_floats[1] = graphicsbase[1];
      tmpVertices[i].m_floats[2] = graphicsbase[2];
     }
     serializer->finalizeChunk(chunk, "btVector3FloatData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
    }
    break;
   }

   case PHY_DOUBLE:
   {
    if (numverts)
    {
     btChunk* chunk = serializer->allocate(sizeof(btVector3DoubleData), numverts);
     btVector3DoubleData* tmpVertices = (btVector3DoubleData*)chunk->m_oldPtr;
     memPtr->m_vertices3d = (btVector3DoubleData *)serializer->getUniquePointer(tmpVertices);
     for (int i = 0; i<numverts; i++)
     {
      double* graphicsbase = (double*)(vertexbase + i*stride);//for now convert to float, might leave it at double
      tmpVertices[i].m_floats[0] = graphicsbase[0];
      tmpVertices[i].m_floats[1] = graphicsbase[1];
      tmpVertices[i].m_floats[2] = graphicsbase[2];
     }
     serializer->finalizeChunk(chunk, "btVector3DoubleData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
    }
    break;
   }

   default:
    btAssert((type == PHY_FLOAT) || (type == PHY_DOUBLE));
   }

   unLockReadOnlyVertexBase(part);
  }

  serializer->finalizeChunk(chunk, "btMeshPartData", BT_ARRAY_CODE, chunk->m_oldPtr);
 }

 // Fill padding with zeros to appease msan.
 memset(trimeshData->m_padding, 0, sizeof(trimeshData->m_padding));

 m_scaling.serializeFloat(trimeshData->m_scaling);
 return "btStridingMeshInterfaceData";
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTetrahedronShape.h"
#include "LinearMath/btMatrix3x3.h"

btBU_Simplex1to4::btBU_Simplex1to4() : btPolyhedralConvexAabbCachingShape(),
m_numVertices(0)
{
 m_shapeType = TETRAHEDRAL_SHAPE_PROXYTYPE;
}

btBU_Simplex1to4::btBU_Simplex1to4(const btVector3& pt0) : btPolyhedralConvexAabbCachingShape(),
m_numVertices(0)
{
 m_shapeType = TETRAHEDRAL_SHAPE_PROXYTYPE;
 addVertex(pt0);
}

btBU_Simplex1to4::btBU_Simplex1to4(const btVector3& pt0, const btVector3& pt1) : btPolyhedralConvexAabbCachingShape(),
m_numVertices(0)
{
 m_shapeType = TETRAHEDRAL_SHAPE_PROXYTYPE;
 addVertex(pt0);
 addVertex(pt1);
}

btBU_Simplex1to4::btBU_Simplex1to4(const btVector3& pt0, const btVector3& pt1, const btVector3& pt2) : btPolyhedralConvexAabbCachingShape(),
m_numVertices(0)
{
 m_shapeType = TETRAHEDRAL_SHAPE_PROXYTYPE;
 addVertex(pt0);
 addVertex(pt1);
 addVertex(pt2);
}

btBU_Simplex1to4::btBU_Simplex1to4(const btVector3& pt0, const btVector3& pt1, const btVector3& pt2, const btVector3& pt3) : btPolyhedralConvexAabbCachingShape(),
m_numVertices(0)
{
 m_shapeType = TETRAHEDRAL_SHAPE_PROXYTYPE;
 addVertex(pt0);
 addVertex(pt1);
 addVertex(pt2);
 addVertex(pt3);
}


void btBU_Simplex1to4::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
#if 1
 btPolyhedralConvexAabbCachingShape::getAabb(t, aabbMin, aabbMax);
#else
 aabbMin.setValue(BT_LARGE_FLOAT, BT_LARGE_FLOAT, BT_LARGE_FLOAT);
 aabbMax.setValue(-BT_LARGE_FLOAT, -BT_LARGE_FLOAT, -BT_LARGE_FLOAT);

 //just transform the vertices in worldspace, and take their AABB
 for (int i = 0; i<m_numVertices; i++)
 {
  btVector3 worldVertex = t(m_vertices[i]);
  aabbMin.setMin(worldVertex);
  aabbMax.setMax(worldVertex);
 }
#endif
}





void btBU_Simplex1to4::addVertex(const btVector3& pt)
{
 m_vertices[m_numVertices++] = pt;
 recalcLocalAabb();
}


int	btBU_Simplex1to4::getNumVertices() const
{
 return m_numVertices;
}

int btBU_Simplex1to4::getNumEdges() const
{
 //euler formula, F-E+V = 2, so E = F+V-2

 switch (m_numVertices)
 {
 case 0:
  return 0;
 case 1: return 0;
 case 2: return 1;
 case 3: return 3;
 case 4: return 6;


 }

 return 0;
}

void btBU_Simplex1to4::getEdge(int i, btVector3& pa, btVector3& pb) const
{

 switch (m_numVertices)
 {

 case 2:
  pa = m_vertices[0];
  pb = m_vertices[1];
  break;
 case 3:
  switch (i)
  {
  case 0:
   pa = m_vertices[0];
   pb = m_vertices[1];
   break;
  case 1:
   pa = m_vertices[1];
   pb = m_vertices[2];
   break;
  case 2:
   pa = m_vertices[2];
   pb = m_vertices[0];
   break;

  }
  break;
 case 4:
  switch (i)
  {
  case 0:
   pa = m_vertices[0];
   pb = m_vertices[1];
   break;
  case 1:
   pa = m_vertices[1];
   pb = m_vertices[2];
   break;
  case 2:
   pa = m_vertices[2];
   pb = m_vertices[0];
   break;
  case 3:
   pa = m_vertices[0];
   pb = m_vertices[3];
   break;
  case 4:
   pa = m_vertices[1];
   pb = m_vertices[3];
   break;
  case 5:
   pa = m_vertices[2];
   pb = m_vertices[3];
   break;
  }

 }




}

void btBU_Simplex1to4::getVertex(int i, btVector3& vtx) const
{
 vtx = m_vertices[i];
}

int	btBU_Simplex1to4::getNumPlanes() const
{
 switch (m_numVertices)
 {
 case 0:
  return 0;
 case 1:
  return 0;
 case 2:
  return 0;
 case 3:
  return 2;
 case 4:
  return 4;
 default:
 {
 }
 }
 return 0;
}


void btBU_Simplex1to4::getPlane(btVector3&, btVector3&, int) const
{

}

int btBU_Simplex1to4::getIndex(int) const
{
 return 0;
}

bool btBU_Simplex1to4::isInside(const btVector3&, btScalar) const
{
 return false;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleBuffer.h"







void btTriangleBuffer::processTriangle(btVector3* triangle, int partId, int  triangleIndex)
{
 btTriangle	tri;
 tri.m_vertex0 = triangle[0];
 tri.m_vertex1 = triangle[1];
 tri.m_vertex2 = triangle[2];
 tri.m_partId = partId;
 tri.m_triangleIndex = triangleIndex;

 m_triangleBuffer.push_back(tri);
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleCallback.h"

btTriangleCallback::~btTriangleCallback()
{

}


btInternalTriangleIndexCallback::~btInternalTriangleIndexCallback()
{

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h"

btTriangleIndexVertexArray::btTriangleIndexVertexArray(int numTriangles, int* triangleIndexBase, int triangleIndexStride, int numVertices, btScalar* vertexBase, int vertexStride)
 : m_hasAabb(0)
{
 btIndexedMesh mesh;

 mesh.m_numTriangles = numTriangles;
 mesh.m_triangleIndexBase = (const unsigned char *)triangleIndexBase;
 mesh.m_triangleIndexStride = triangleIndexStride;
 mesh.m_numVertices = numVertices;
 mesh.m_vertexBase = (const unsigned char *)vertexBase;
 mesh.m_vertexStride = vertexStride;

 addIndexedMesh(mesh);

}

btTriangleIndexVertexArray::~btTriangleIndexVertexArray()
{

}

void	btTriangleIndexVertexArray::getLockedVertexIndexBase(unsigned char **vertexbase, int& numverts, PHY_ScalarType& type, int& vertexStride, unsigned char **indexbase, int & indexstride, int& numfaces, PHY_ScalarType& indicestype, int subpart)
{
 btAssert(subpart< getNumSubParts());

 btIndexedMesh& mesh = m_indexedMeshes[subpart];

 numverts = mesh.m_numVertices;
 (*vertexbase) = (unsigned char *)mesh.m_vertexBase;

 type = mesh.m_vertexType;

 vertexStride = mesh.m_vertexStride;

 numfaces = mesh.m_numTriangles;

 (*indexbase) = (unsigned char *)mesh.m_triangleIndexBase;
 indexstride = mesh.m_triangleIndexStride;
 indicestype = mesh.m_indexType;
}

void	btTriangleIndexVertexArray::getLockedReadOnlyVertexIndexBase(const unsigned char **vertexbase, int& numverts, PHY_ScalarType& type, int& vertexStride, const unsigned char **indexbase, int & indexstride, int& numfaces, PHY_ScalarType& indicestype, int subpart) const
{
 const btIndexedMesh& mesh = m_indexedMeshes[subpart];

 numverts = mesh.m_numVertices;
 (*vertexbase) = (const unsigned char *)mesh.m_vertexBase;

 type = mesh.m_vertexType;

 vertexStride = mesh.m_vertexStride;

 numfaces = mesh.m_numTriangles;
 (*indexbase) = (const unsigned char *)mesh.m_triangleIndexBase;
 indexstride = mesh.m_triangleIndexStride;
 indicestype = mesh.m_indexType;
}

bool	btTriangleIndexVertexArray::hasPremadeAabb() const
{
 return (m_hasAabb == 1);
}


void	btTriangleIndexVertexArray::setPremadeAabb(const btVector3& aabbMin, const btVector3& aabbMax) const
{
 m_aabbMin = aabbMin;
 m_aabbMax = aabbMax;
 m_hasAabb = 1; // this is intentionally an int see notes in header
}

void	btTriangleIndexVertexArray::getPremadeAabb(btVector3* aabbMin, btVector3* aabbMax) const
{
 *aabbMin = m_aabbMin;
 *aabbMax = m_aabbMax;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was created by Alex Silverman

#include "BulletCollision/CollisionShapes/btTriangleIndexVertexMaterialArray.h"

btTriangleIndexVertexMaterialArray::btTriangleIndexVertexMaterialArray(int numTriangles, int* triangleIndexBase, int triangleIndexStride,
 int numVertices, btScalar* vertexBase, int vertexStride,
 int numMaterials, unsigned char* materialBase, int materialStride,
 int* triangleMaterialsBase, int materialIndexStride) :
 btTriangleIndexVertexArray(numTriangles, triangleIndexBase, triangleIndexStride, numVertices, vertexBase, vertexStride)
{
 btMaterialProperties mat;

 mat.m_numMaterials = numMaterials;
 mat.m_materialBase = materialBase;
 mat.m_materialStride = materialStride;
#ifdef BT_USE_DOUBLE_PRECISION
 mat.m_materialType = PHY_DOUBLE;
#else
 mat.m_materialType = PHY_FLOAT;
#endif

 mat.m_numTriangles = numTriangles;
 mat.m_triangleMaterialsBase = (unsigned char *)triangleMaterialsBase;
 mat.m_triangleMaterialStride = materialIndexStride;
 mat.m_triangleType = PHY_INTEGER;

 addMaterialProperties(mat);
}


void btTriangleIndexVertexMaterialArray::getLockedMaterialBase(unsigned char **materialBase, int& numMaterials, PHY_ScalarType& materialType, int& materialStride,
 unsigned char ** triangleMaterialBase, int& numTriangles, int& triangleMaterialStride, PHY_ScalarType& triangleType, int subpart)
{
 btAssert(subpart< getNumSubParts());

 btMaterialProperties& mats = m_materials[subpart];

 numMaterials = mats.m_numMaterials;
 (*materialBase) = (unsigned char *)mats.m_materialBase;
#ifdef BT_USE_DOUBLE_PRECISION
 materialType = PHY_DOUBLE;
#else
 materialType = PHY_FLOAT;
#endif
 materialStride = mats.m_materialStride;

 numTriangles = mats.m_numTriangles;
 (*triangleMaterialBase) = (unsigned char *)mats.m_triangleMaterialsBase;
 triangleMaterialStride = mats.m_triangleMaterialStride;
 triangleType = mats.m_triangleType;
}

void btTriangleIndexVertexMaterialArray::getLockedReadOnlyMaterialBase(const unsigned char **materialBase, int& numMaterials, PHY_ScalarType& materialType, int& materialStride,
 const unsigned char ** triangleMaterialBase, int& numTriangles, int& triangleMaterialStride, PHY_ScalarType& triangleType, int subpart)
{
 btMaterialProperties& mats = m_materials[subpart];

 numMaterials = mats.m_numMaterials;
 (*materialBase) = (const unsigned char *)mats.m_materialBase;
#ifdef BT_USE_DOUBLE_PRECISION
 materialType = PHY_DOUBLE;
#else
 materialType = PHY_FLOAT;
#endif
 materialStride = mats.m_materialStride;

 numTriangles = mats.m_numTriangles;
 (*triangleMaterialBase) = (const unsigned char *)mats.m_triangleMaterialsBase;
 triangleMaterialStride = mats.m_triangleMaterialStride;
 triangleType = mats.m_triangleType;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btTriangleMesh.h"



btTriangleMesh::btTriangleMesh(bool use32bitIndices, bool use4componentVertices)
 :m_use32bitIndices(use32bitIndices),
 m_use4componentVertices(use4componentVertices),
 m_weldingThreshold(0.0)
{
 btIndexedMesh meshIndex;
 meshIndex.m_numTriangles = 0;
 meshIndex.m_numVertices = 0;
 meshIndex.m_indexType = PHY_INTEGER;
 meshIndex.m_triangleIndexBase = 0;
 meshIndex.m_triangleIndexStride = 3 * sizeof(int);
 meshIndex.m_vertexBase = 0;
 meshIndex.m_vertexStride = sizeof(btVector3);
 m_indexedMeshes.push_back(meshIndex);

 if (m_use32bitIndices)
 {
  m_indexedMeshes[0].m_numTriangles = m_32bitIndices.size() / 3;
  m_indexedMeshes[0].m_triangleIndexBase = 0;
  m_indexedMeshes[0].m_indexType = PHY_INTEGER;
  m_indexedMeshes[0].m_triangleIndexStride = 3 * sizeof(int);
 }
 else
 {
  m_indexedMeshes[0].m_numTriangles = m_16bitIndices.size() / 3;
  m_indexedMeshes[0].m_triangleIndexBase = 0;
  m_indexedMeshes[0].m_indexType = PHY_SHORT;
  m_indexedMeshes[0].m_triangleIndexStride = 3 * sizeof(short int);
 }

 if (m_use4componentVertices)
 {
  m_indexedMeshes[0].m_numVertices = m_4componentVertices.size();
  m_indexedMeshes[0].m_vertexBase = 0;
  m_indexedMeshes[0].m_vertexStride = sizeof(btVector3);
 }
 else
 {
  m_indexedMeshes[0].m_numVertices = m_3componentVertices.size() / 3;
  m_indexedMeshes[0].m_vertexBase = 0;
  m_indexedMeshes[0].m_vertexStride = 3 * sizeof(btScalar);
 }


}

void	btTriangleMesh::addIndex(int index)
{
 if (m_use32bitIndices)
 {
  m_32bitIndices.push_back(index);
  m_indexedMeshes[0].m_triangleIndexBase = (unsigned char*)&m_32bitIndices[0];
 }
 else
 {
  m_16bitIndices.push_back(index);
  m_indexedMeshes[0].m_triangleIndexBase = (unsigned char*)&m_16bitIndices[0];
 }
}

void	btTriangleMesh::addTriangleIndices(int index1, int index2, int index3)
{
 m_indexedMeshes[0].m_numTriangles++;
 addIndex(index1);
 addIndex(index2);
 addIndex(index3);
}

int	btTriangleMesh::findOrAddVertex(const btVector3& vertex, bool removeDuplicateVertices)
{
 //return index of new/existing vertex
 ///@todo: could use acceleration structure for this
 if (m_use4componentVertices)
 {
  if (removeDuplicateVertices)
  {
   for (int i = 0; i< m_4componentVertices.size(); i++)
   {
    if ((m_4componentVertices[i] - vertex).length2() <= m_weldingThreshold)
    {
     return i;
    }
   }
  }
  m_indexedMeshes[0].m_numVertices++;
  m_4componentVertices.push_back(vertex);
  m_indexedMeshes[0].m_vertexBase = (unsigned char*)&m_4componentVertices[0];

  return m_4componentVertices.size() - 1;

 }
 else
 {

  if (removeDuplicateVertices)
  {
   for (int i = 0; i< m_3componentVertices.size(); i += 3)
   {
    btVector3 vtx(m_3componentVertices[i], m_3componentVertices[i + 1], m_3componentVertices[i + 2]);
    if ((vtx - vertex).length2() <= m_weldingThreshold)
    {
     return i / 3;
    }
   }
  }
  m_3componentVertices.push_back(vertex.getX());
  m_3componentVertices.push_back(vertex.getY());
  m_3componentVertices.push_back(vertex.getZ());
  m_indexedMeshes[0].m_numVertices++;
  m_indexedMeshes[0].m_vertexBase = (unsigned char*)&m_3componentVertices[0];
  return (m_3componentVertices.size() / 3) - 1;
 }

}

void	btTriangleMesh::addTriangle(const btVector3& vertex0, const btVector3& vertex1, const btVector3& vertex2, bool removeDuplicateVertices)
{
 m_indexedMeshes[0].m_numTriangles++;
 addIndex(findOrAddVertex(vertex0, removeDuplicateVertices));
 addIndex(findOrAddVertex(vertex1, removeDuplicateVertices));
 addIndex(findOrAddVertex(vertex2, removeDuplicateVertices));
}

int btTriangleMesh::getNumTriangles() const
{
 if (m_use32bitIndices)
 {
  return m_32bitIndices.size() / 3;
 }
 return m_16bitIndices.size() / 3;
}

void btTriangleMesh::preallocateVertices(int numverts)
{
 if (m_use4componentVertices)
 {
  m_4componentVertices.reserve(numverts);
 }
 else
 {
  m_3componentVertices.reserve(numverts);
 }
}

void btTriangleMesh::preallocateIndices(int numindices)
{
 if (m_use32bitIndices)
 {
  m_32bitIndices.reserve(numindices);
 }
 else
 {
  m_16bitIndices.reserve(numindices);
 }
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btQuaternion.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btAabbUtil2.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"


btTriangleMeshShape::btTriangleMeshShape(btStridingMeshInterface* meshInterface)
 : btConcaveShape(), m_meshInterface(meshInterface)
{
 m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
 if (meshInterface->hasPremadeAabb())
 {
  meshInterface->getPremadeAabb(&m_localAabbMin, &m_localAabbMax);
 }
 else
 {
  recalcLocalAabb();
 }
}


btTriangleMeshShape::~btTriangleMeshShape()
{

}




void btTriangleMeshShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{

 btVector3 localHalfExtents = btScalar(0.5)*(m_localAabbMax - m_localAabbMin);
 localHalfExtents += btVector3(getMargin(), getMargin(), getMargin());
 btVector3 localCenter = btScalar(0.5)*(m_localAabbMax + m_localAabbMin);

 btMatrix3x3 abs_b = trans.getBasis().absolute();

 btVector3 center = trans(localCenter);

 btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
 aabbMin = center - extent;
 aabbMax = center + extent;
}

void	btTriangleMeshShape::recalcLocalAabb()
{
 for (int i = 0; i<3; i++)
 {
  btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
  vec[i] = btScalar(1.);
  btVector3 tmp = localGetSupportingVertex(vec);
  m_localAabbMax[i] = tmp[i] + m_collisionMargin;
  vec[i] = btScalar(-1.);
  tmp = localGetSupportingVertex(vec);
  m_localAabbMin[i] = tmp[i] - m_collisionMargin;
 }
}



class SupportVertexCallback : public btTriangleCallback
{

 btVector3 m_supportVertexLocal;
public:

 btTransform	m_worldTrans;
 btScalar m_maxDot;
 btVector3 m_supportVecLocal;

 SupportVertexCallback(const btVector3& supportVecWorld, const btTransform& trans)
  : m_supportVertexLocal(btScalar(0.), btScalar(0.), btScalar(0.)), m_worldTrans(trans), m_maxDot(btScalar(-BT_LARGE_FLOAT))

 {
  m_supportVecLocal = supportVecWorld * m_worldTrans.getBasis();
 }

 virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
 {
  (void)partId;
  (void)triangleIndex;
  for (int i = 0; i<3; i++)
  {
   btScalar dot = m_supportVecLocal.dot(triangle[i]);
   if (dot > m_maxDot)
   {
    m_maxDot = dot;
    m_supportVertexLocal = triangle[i];
   }
  }
 }

 btVector3 GetSupportVertexWorldSpace()
 {
  return m_worldTrans(m_supportVertexLocal);
 }

 btVector3	GetSupportVertexLocal()
 {
  return m_supportVertexLocal;
 }

};


void btTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
 m_meshInterface->setScaling(scaling);
 recalcLocalAabb();
}

const btVector3& btTriangleMeshShape::getLocalScaling() const
{
 return m_meshInterface->getScaling();
}






//#define DEBUG_TRIANGLE_MESH



void	btTriangleMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 struct FilteredCallback : public btInternalTriangleIndexCallback
 {
  btTriangleCallback* m_callback;
  btVector3 m_aabbMin;
  btVector3 m_aabbMax;

  FilteredCallback(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax)
   :m_callback(callback),
   m_aabbMin(aabbMin),
   m_aabbMax(aabbMax)
  {
  }

  virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
  {
   if (TestTriangleAgainstAabb2(&triangle[0], m_aabbMin, m_aabbMax))
   {
    //check aabb in triangle-space, before doing this
    m_callback->processTriangle(triangle, partId, triangleIndex);
   }

  }

 };

 FilteredCallback filterCallback(callback, aabbMin, aabbMax);

 m_meshInterface->InternalProcessAllTriangles(&filterCallback, aabbMin, aabbMax);
}





void	btTriangleMeshShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 (void)mass;
 //moving concave objects not supported
 btAssert(0);
 inertia.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
}


btVector3 btTriangleMeshShape::localGetSupportingVertex(const btVector3& vec) const
{
 btVector3 supportVertex;

 btTransform ident;
 ident.setIdentity();

 SupportVertexCallback supportCallback(vec, ident);

 btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));

 processAllTriangles(&supportCallback, -aabbMax, aabbMax);

 supportVertex = supportCallback.GetSupportVertexLocal();

 return supportVertex;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btUniformScalingShape.h"

btUniformScalingShape::btUniformScalingShape(btConvexShape* convexChildShape, btScalar uniformScalingFactor) :
 btConvexShape(), m_childConvexShape(convexChildShape),
 m_uniformScalingFactor(uniformScalingFactor)
{
 m_shapeType = UNIFORM_SCALING_SHAPE_PROXYTYPE;
}

btUniformScalingShape::~btUniformScalingShape()
{
}


btVector3	btUniformScalingShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const
{
 btVector3 tmpVertex;
 tmpVertex = m_childConvexShape->localGetSupportingVertexWithoutMargin(vec);
 return tmpVertex*m_uniformScalingFactor;
}

void	btUniformScalingShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
 m_childConvexShape->batchedUnitVectorGetSupportingVertexWithoutMargin(vectors, supportVerticesOut, numVectors);
 int i;
 for (i = 0; i<numVectors; i++)
 {
  supportVerticesOut[i] = supportVerticesOut[i] * m_uniformScalingFactor;
 }
}


btVector3	btUniformScalingShape::localGetSupportingVertex(const btVector3& vec)const
{
 btVector3 tmpVertex;
 tmpVertex = m_childConvexShape->localGetSupportingVertex(vec);
 return tmpVertex*m_uniformScalingFactor;
}


void	btUniformScalingShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{

 ///this linear upscaling is not realistic, but we don't deal with large mass ratios...
 btVector3 tmpInertia;
 m_childConvexShape->calculateLocalInertia(mass, tmpInertia);
 inertia = tmpInertia * m_uniformScalingFactor;
}


///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
void btUniformScalingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
 getAabbSlow(trans, aabbMin, aabbMax);

}

void btUniformScalingShape::getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
#if 1
 btVector3 _directions[] =
 {
  btVector3(1.,  0.,  0.),
  btVector3(0.,  1.,  0.),
  btVector3(0.,  0.,  1.),
  btVector3(-1., 0.,  0.),
  btVector3(0., -1.,  0.),
  btVector3(0.,  0., -1.)
 };

 btVector3 _supporting[] =
 {
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.),
  btVector3(0., 0., 0.)
 };

 for (int i = 0; i<6; i++)
 {
  _directions[i] = _directions[i] * t.getBasis();
 }

 batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

 btVector3 aabbMin1(0, 0, 0), aabbMax1(0, 0, 0);

 for (int i = 0; i < 3; ++i)
 {
  aabbMax1[i] = t(_supporting[i])[i];
  aabbMin1[i] = t(_supporting[i + 3])[i];
 }
 btVector3 marginVec(getMargin(), getMargin(), getMargin());
 aabbMin = aabbMin1 - marginVec;
 aabbMax = aabbMax1 + marginVec;

#else

 btScalar margin = getMargin();
 for (int i = 0; i<3; i++)
 {
  btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
  vec[i] = btScalar(1.);
  btVector3 sv = localGetSupportingVertex(vec*t.getBasis());
  btVector3 tmp = t(sv);
  aabbMax[i] = tmp[i] + margin;
  vec[i] = btScalar(-1.);
  sv = localGetSupportingVertex(vec*t.getBasis());
  tmp = t(sv);
  aabbMin[i] = tmp[i] - margin;
 }

#endif
}

void	btUniformScalingShape::setLocalScaling(const btVector3& scaling)
{
 m_childConvexShape->setLocalScaling(scaling);
}

const btVector3& btUniformScalingShape::getLocalScaling() const
{
 return m_childConvexShape->getLocalScaling();
}

void	btUniformScalingShape::setMargin(btScalar margin)
{
 m_childConvexShape->setMargin(margin);
}
btScalar	btUniformScalingShape::getMargin() const
{
 return m_childConvexShape->getMargin() * m_uniformScalingFactor;
}

int		btUniformScalingShape::getNumPreferredPenetrationDirections() const
{
 return m_childConvexShape->getNumPreferredPenetrationDirections();
}

void	btUniformScalingShape::getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
{
 m_childConvexShape->getPreferredPenetrationDirection(index, penetrationVector);
}

/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/Gimpact/btContactProcessing.h"

#define MAX_COINCIDENT 8

struct CONTACT_KEY_TOKEN
{
 unsigned int m_key;
 int m_value;
 CONTACT_KEY_TOKEN()
 {
 }

 CONTACT_KEY_TOKEN(unsigned int key, int token)
 {
  m_key = key;
  m_value = token;
 }

 CONTACT_KEY_TOKEN(const CONTACT_KEY_TOKEN& rtoken)
 {
  m_key = rtoken.m_key;
  m_value = rtoken.m_value;
 }

 inline bool operator <(const CONTACT_KEY_TOKEN& other) const
 {
  return (m_key < other.m_key);
 }

 inline bool operator >(const CONTACT_KEY_TOKEN& other) const
 {
  return (m_key > other.m_key);
 }

};

class CONTACT_KEY_TOKEN_COMP
{
public:

 bool operator() (const CONTACT_KEY_TOKEN& a, const CONTACT_KEY_TOKEN& b) const
 {
  return (a < b);
 }
};


void btContactArray::merge_contacts(
 const btContactArray & contacts, bool normal_contact_average)
{
 clear();

 int i;
 if (contacts.size() == 0) return;


 if (contacts.size() == 1)
 {
  push_back(contacts[0]);
  return;
 }

 btAlignedObjectArray<CONTACT_KEY_TOKEN> keycontacts;

 keycontacts.reserve(contacts.size());

 //fill key contacts

 for (i = 0; i<contacts.size(); i++)
 {
  keycontacts.push_back(CONTACT_KEY_TOKEN(contacts[i].calc_key_contact(), i));
 }

 //sort keys
 keycontacts.quickSort(CONTACT_KEY_TOKEN_COMP());

 // Merge contacts
 int coincident_count = 0;
 btVector3 coincident_normals[MAX_COINCIDENT];

 unsigned int last_key = keycontacts[0].m_key;
 unsigned int key = 0;

 push_back(contacts[keycontacts[0].m_value]);

 GIM_CONTACT * pcontact = &(*this)[0];

 for (i = 1; i<keycontacts.size(); i++)
 {
  key = keycontacts[i].m_key;
  const GIM_CONTACT * scontact = &contacts[keycontacts[i].m_value];

  if (last_key == key)//same points
  {
   //merge contact
   if (pcontact->m_depth - CONTACT_DIFF_EPSILON > scontact->m_depth)//)
   {
    *pcontact = *scontact;
    coincident_count = 0;
   }
   else if (normal_contact_average)
   {
    if (btFabs(pcontact->m_depth - scontact->m_depth)<CONTACT_DIFF_EPSILON)
    {
     if (coincident_count<MAX_COINCIDENT)
     {
      coincident_normals[coincident_count] = scontact->m_normal;
      coincident_count++;
     }
    }
   }
  }
  else
  {//add new contact

   if (normal_contact_average && coincident_count>0)
   {
    pcontact->interpolate_normals(coincident_normals, coincident_count);
    coincident_count = 0;
   }

   push_back(*scontact);
   pcontact = &(*this)[this->size() - 1];
  }
  last_key = key;
 }
}

void btContactArray::merge_contacts_unique(const btContactArray & contacts)
{
 clear();

 if (contacts.size() == 0) return;

 if (contacts.size() == 1)
 {
  push_back(contacts[0]);
  return;
 }

 GIM_CONTACT average_contact = contacts[0];

 for (int i = 1; i<contacts.size(); i++)
 {
  average_contact.m_point += contacts[i].m_point;
  average_contact.m_normal += contacts[i].m_normal * contacts[i].m_depth;
 }

 //divide
 btScalar divide_average = 1.0f / ((btScalar)contacts.size());

 average_contact.m_point *= divide_average;

 average_contact.m_normal *= divide_average;

 average_contact.m_depth = average_contact.m_normal.length();

 average_contact.m_normal /= average_contact.m_depth;

}

/*! \file btGenericPoolAllocator.cpp
\author Francisco Leon Najera. email projectileman@yahoo.com

General purpose allocator class
*/
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/Gimpact/btGenericPoolAllocator.h"



/// *************** btGenericMemoryPool ******************///////////

size_t btGenericMemoryPool::allocate_from_free_nodes(size_t num_elements)
{
 size_t ptr = BT_UINT_MAX;

 if (m_free_nodes_count == 0) return BT_UINT_MAX;
 // find an avaliable free node with the correct size
 size_t revindex = m_free_nodes_count;

 while (revindex-- && ptr == BT_UINT_MAX)
 {
  if (m_allocated_sizes[m_free_nodes[revindex]] >= num_elements)
  {
   ptr = revindex;
  }
 }
 if (ptr == BT_UINT_MAX) return BT_UINT_MAX; // not found


 revindex = ptr;
 ptr = m_free_nodes[revindex];
 // post: ptr contains the node index, and revindex the index in m_free_nodes

 size_t  finalsize = m_allocated_sizes[ptr];
 finalsize -= num_elements;

 m_allocated_sizes[ptr] = num_elements;

 // post: finalsize>=0, m_allocated_sizes[ptr] has the requested size

 if (finalsize>0) // preserve free node, there are some free memory
 {
  m_free_nodes[revindex] = ptr + num_elements;
  m_allocated_sizes[ptr + num_elements] = finalsize;
 }
 else // delete free node
 {
  // swap with end
  m_free_nodes[revindex] = m_free_nodes[m_free_nodes_count - 1];
  m_free_nodes_count--;
 }

 return ptr;
}

size_t btGenericMemoryPool::allocate_from_pool(size_t num_elements)
{
 if (m_allocated_count + num_elements>m_max_element_count) return BT_UINT_MAX;

 size_t ptr = m_allocated_count;

 m_allocated_sizes[m_allocated_count] = num_elements;
 m_allocated_count += num_elements;

 return ptr;
}


void btGenericMemoryPool::init_pool(size_t element_size, size_t element_count)
{
 m_allocated_count = 0;
 m_free_nodes_count = 0;

 m_element_size = element_size;
 m_max_element_count = element_count;




 m_pool = (unsigned char *)btAlignedAlloc(m_element_size*m_max_element_count, 16);
 m_free_nodes = (size_t *)btAlignedAlloc(sizeof(size_t)*m_max_element_count, 16);
 m_allocated_sizes = (size_t *)btAlignedAlloc(sizeof(size_t)*m_max_element_count, 16);

 for (size_t i = 0; i< m_max_element_count; i++)
 {
  m_allocated_sizes[i] = 0;
 }
}

void btGenericMemoryPool::end_pool()
{
 btAlignedFree(m_pool);
 btAlignedFree(m_free_nodes);
 btAlignedFree(m_allocated_sizes);
 m_allocated_count = 0;
 m_free_nodes_count = 0;
}


//! Allocates memory in pool
/*!
\param size_bytes size in bytes of the buffer
*/
void * btGenericMemoryPool::allocate(size_t size_bytes)
{

 size_t module = size_bytes%m_element_size;
 size_t element_count = size_bytes / m_element_size;
 if (module>0) element_count++;

 size_t alloc_pos = allocate_from_free_nodes(element_count);
 // a free node is found
 if (alloc_pos != BT_UINT_MAX)
 {
  return get_element_data(alloc_pos);
 }
 // allocate directly on pool
 alloc_pos = allocate_from_pool(element_count);

 if (alloc_pos == BT_UINT_MAX) return NULL; // not space
 return get_element_data(alloc_pos);
}

bool btGenericMemoryPool::freeMemory(void * pointer)
{
 unsigned char * pointer_pos = (unsigned char *)pointer;
 unsigned char * pool_pos = (unsigned char *)m_pool;
 // calc offset
 if (pointer_pos<pool_pos) return false;//other pool
 size_t offset = size_t(pointer_pos - pool_pos);
 if (offset >= get_pool_capacity()) return false;// far away

                                                 // find free position
 m_free_nodes[m_free_nodes_count] = offset / m_element_size;
 m_free_nodes_count++;
 return true;
}


/// *******************! btGenericPoolAllocator *******************!///


btGenericPoolAllocator::~btGenericPoolAllocator()
{
 // destroy pools
 size_t i;
 for (i = 0; i<m_pool_count; i++)
 {
  m_pools[i]->end_pool();
  btAlignedFree(m_pools[i]);
 }
}


// creates a pool
btGenericMemoryPool * btGenericPoolAllocator::push_new_pool()
{
 if (m_pool_count >= BT_DEFAULT_MAX_POOLS) return NULL;

 btGenericMemoryPool * newptr = (btGenericMemoryPool *)btAlignedAlloc(sizeof(btGenericMemoryPool), 16);

 m_pools[m_pool_count] = newptr;

 m_pools[m_pool_count]->init_pool(m_pool_element_size, m_pool_element_count);

 m_pool_count++;
 return newptr;
}

void * btGenericPoolAllocator::failback_alloc(size_t size_bytes)
{

 btGenericMemoryPool * pool = NULL;


 if (size_bytes <= get_pool_capacity())
 {
  pool = push_new_pool();
 }

 if (pool == NULL) // failback
 {
  return btAlignedAlloc(size_bytes, 16);
 }

 return pool->allocate(size_bytes);
}

bool btGenericPoolAllocator::failback_free(void * pointer)
{
 btAlignedFree(pointer);
 return true;
}


//! Allocates memory in pool
/*!
\param size_bytes size in bytes of the buffer
*/
void * btGenericPoolAllocator::allocate(size_t size_bytes)
{
 void * ptr = NULL;

 size_t i = 0;
 while (i<m_pool_count && ptr == NULL)
 {
  ptr = m_pools[i]->allocate(size_bytes);
  ++i;
 }

 if (ptr) return ptr;

 return failback_alloc(size_bytes);
}

bool btGenericPoolAllocator::freeMemory(void * pointer)
{
 bool result = false;

 size_t i = 0;
 while (i<m_pool_count && result == false)
 {
  result = m_pools[i]->freeMemory(pointer);
  ++i;
 }

 if (result) return true;

 return failback_free(pointer);
}

/// ************** STANDARD ALLOCATOR ***************************///


#define BT_DEFAULT_POOL_SIZE 32768
#define BT_DEFAULT_POOL_ELEMENT_SIZE 8

// main allocator
class GIM_STANDARD_ALLOCATOR : public btGenericPoolAllocator
{
public:
 GIM_STANDARD_ALLOCATOR() :btGenericPoolAllocator(BT_DEFAULT_POOL_ELEMENT_SIZE, BT_DEFAULT_POOL_SIZE)
 {
 }
};

// global allocator
GIM_STANDARD_ALLOCATOR g_main_allocator;


void * btPoolAlloc(size_t size)
{
 return g_main_allocator.allocate(size);
}

void * btPoolRealloc(void *ptr, size_t oldsize, size_t newsize)
{
 void * newptr = btPoolAlloc(newsize);
 size_t copysize = oldsize<newsize ? oldsize : newsize;
 memcpy(newptr, ptr, copysize);
 btPoolFree(ptr);
 return newptr;
}

void btPoolFree(void *ptr)
{
 g_main_allocator.freeMemory(ptr);
}
/*! \file gim_box_set.h
\author Francisco Leon Najera
*/
/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/Gimpact/btGImpactBvh.h"
#include "LinearMath/btQuickprof.h"

#ifdef TRI_COLLISION_PROFILING

btClock g_tree_clock;

float g_accum_tree_collision_time = 0;
int g_count_traversing = 0;


void bt_begin_gim02_tree_time()
{
 g_tree_clock.reset();
}

void bt_end_gim02_tree_time()
{
 g_accum_tree_collision_time += g_tree_clock.getTimeMicroseconds();
 g_count_traversing++;
}

//! Gets the average time in miliseconds of tree collisions
float btGImpactBvh::getAverageTreeCollisionTime()
{
 if (g_count_traversing == 0) return 0;

 float avgtime = g_accum_tree_collision_time;
 avgtime /= (float)g_count_traversing;

 g_accum_tree_collision_time = 0;
 g_count_traversing = 0;
 return avgtime;

 //	float avgtime = g_count_traversing;
 //	g_count_traversing = 0;
 //	return avgtime;

}

#endif //TRI_COLLISION_PROFILING

/////////////////////// btBvhTree /////////////////////////////////

int btBvhTree::_calc_splitting_axis(
 GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex, int endIndex)
{

 int i;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 btVector3 variance(btScalar(0.), btScalar(0.), btScalar(0.));
 int numIndices = endIndex - startIndex;

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  btVector3 diff2 = center - means;
  diff2 = diff2 * diff2;
  variance += diff2;
 }
 variance *= (btScalar(1.) / ((btScalar)numIndices - 1));

 return variance.maxAxis();
}


int btBvhTree::_sort_and_calc_splitting_index(
 GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex,
 int endIndex, int splitAxis)
{
 int i;
 int splitIndex = startIndex;
 int numIndices = endIndex - startIndex;

 // average of centers
 btScalar splitValue = 0.0f;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 splitValue = means[splitAxis];


 //sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  if (center[splitAxis] > splitValue)
  {
   //swap
   primitive_boxes.swap(i, splitIndex);
   //swapLeafNodes(i,splitIndex);
   splitIndex++;
  }
 }

 //if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
 //otherwise the tree-building might fail due to stack-overflows in certain cases.
 //unbalanced1 is unsafe: it can cause stack overflows
 //bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));

 //unbalanced2 should work too: always use center (perfect balanced trees)
 //bool unbalanced2 = true;

 //this should be safe too:
 int rangeBalancedIndices = numIndices / 3;
 bool unbalanced = ((splitIndex <= (startIndex + rangeBalancedIndices)) || (splitIndex >= (endIndex - 1 - rangeBalancedIndices)));

 if (unbalanced)
 {
  splitIndex = startIndex + (numIndices >> 1);
 }

 btAssert(!((splitIndex == startIndex) || (splitIndex == (endIndex))));

 return splitIndex;

}


void btBvhTree::_build_sub_tree(GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex, int endIndex)
{
 int curIndex = m_num_nodes;
 m_num_nodes++;

 btAssert((endIndex - startIndex)>0);

 if ((endIndex - startIndex) == 1)
 {
  //We have a leaf node
  setNodeBound(curIndex, primitive_boxes[startIndex].m_bound);
  m_node_array[curIndex].setDataIndex(primitive_boxes[startIndex].m_data);

  return;
 }
 //calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.

 //split axis
 int splitIndex = _calc_splitting_axis(primitive_boxes, startIndex, endIndex);

 splitIndex = _sort_and_calc_splitting_index(
  primitive_boxes, startIndex, endIndex,
  splitIndex//split axis
 );


 //calc this node bounding box

 btAABB node_bound;
 node_bound.invalidate();

 for (int i = startIndex; i<endIndex; i++)
 {
  node_bound.merge(primitive_boxes[i].m_bound);
 }

 setNodeBound(curIndex, node_bound);


 //build left branch
 _build_sub_tree(primitive_boxes, startIndex, splitIndex);


 //build right branch
 _build_sub_tree(primitive_boxes, splitIndex, endIndex);

 m_node_array[curIndex].setEscapeIndex(m_num_nodes - curIndex);


}

//! stackless build tree
void btBvhTree::build_tree(
 GIM_BVH_DATA_ARRAY & primitive_boxes)
{
 // initialize node count to 0
 m_num_nodes = 0;
 // allocate nodes
 m_node_array.resize(primitive_boxes.size() * 2);

 _build_sub_tree(primitive_boxes, 0, primitive_boxes.size());
}

////////////////////////////////////class btGImpactBvh

void btGImpactBvh::refit()
{
 int nodecount = getNodeCount();
 while (nodecount--)
 {
  if (isLeafNode(nodecount))
  {
   btAABB leafbox;
   m_primitive_manager->get_primitive_box(getNodeData(nodecount), leafbox);
   setNodeBound(nodecount, leafbox);
  }
  else
  {
   //const GIM_BVH_TREE_NODE * nodepointer = get_node_pointer(nodecount);
   //get left bound
   btAABB bound;
   bound.invalidate();

   btAABB temp_box;

   int child_node = getLeftNode(nodecount);
   if (child_node)
   {
    getNodeBound(child_node, temp_box);
    bound.merge(temp_box);
   }

   child_node = getRightNode(nodecount);
   if (child_node)
   {
    getNodeBound(child_node, temp_box);
    bound.merge(temp_box);
   }

   setNodeBound(nodecount, bound);
  }
 }
}

//! this rebuild the entire set
void btGImpactBvh::buildSet()
{
 //obtain primitive boxes
 GIM_BVH_DATA_ARRAY primitive_boxes;
 primitive_boxes.resize(m_primitive_manager->get_primitive_count());

 for (int i = 0; i<primitive_boxes.size(); i++)
 {
  m_primitive_manager->get_primitive_box(i, primitive_boxes[i].m_bound);
  primitive_boxes[i].m_data = i;
 }

 m_box_tree.build_tree(primitive_boxes);
}

//! returns the indices of the primitives in the m_primitive_manager
bool btGImpactBvh::boxQuery(const btAABB & box, btAlignedObjectArray<int> & collided_results) const
{
 int curIndex = 0;
 int numNodes = getNodeCount();

 while (curIndex < numNodes)
 {
  btAABB bound;
  getNodeBound(curIndex, bound);

  //catch bugs in tree data

  bool aabbOverlap = bound.has_collision(box);
  bool isleafnode = isLeafNode(curIndex);

  if (isleafnode && aabbOverlap)
  {
   collided_results.push_back(getNodeData(curIndex));
  }

  if (aabbOverlap || isleafnode)
  {
   //next subnode
   curIndex++;
  }
  else
  {
   //skip node
   curIndex += getEscapeNodeIndex(curIndex);
  }
 }
 if (collided_results.size()>0) return true;
 return false;
}



//! returns the indices of the primitives in the m_primitive_manager
bool btGImpactBvh::rayQuery(
 const btVector3 & ray_dir, const btVector3 & ray_origin,
 btAlignedObjectArray<int> & collided_results) const
{
 int curIndex = 0;
 int numNodes = getNodeCount();

 while (curIndex < numNodes)
 {
  btAABB bound;
  getNodeBound(curIndex, bound);

  //catch bugs in tree data

  bool aabbOverlap = bound.collide_ray(ray_origin, ray_dir);
  bool isleafnode = isLeafNode(curIndex);

  if (isleafnode && aabbOverlap)
  {
   collided_results.push_back(getNodeData(curIndex));
  }

  if (aabbOverlap || isleafnode)
  {
   //next subnode
   curIndex++;
  }
  else
  {
   //skip node
   curIndex += getEscapeNodeIndex(curIndex);
  }
 }
 if (collided_results.size()>0) return true;
 return false;
}


SIMD_FORCE_INLINE bool _node_collision(
 btGImpactBvh * boxset0, btGImpactBvh * boxset1,
 const BT_BOX_BOX_TRANSFORM_CACHE & trans_cache_1to0,
 int node0, int node1, bool complete_primitive_tests)
{
 btAABB box0;
 boxset0->getNodeBound(node0, box0);
 btAABB box1;
 boxset1->getNodeBound(node1, box1);

 return box0.overlapping_trans_cache(box1, trans_cache_1to0, complete_primitive_tests);
 //	box1.appy_transform_trans_cache(trans_cache_1to0);
 //	return box0.has_collision(box1);

}


//stackless recursive collision routine
static void _find_collision_pairs_recursive(
 btGImpactBvh * boxset0, btGImpactBvh * boxset1,
 btPairSet * collision_pairs,
 const BT_BOX_BOX_TRANSFORM_CACHE & trans_cache_1to0,
 int node0, int node1, bool complete_primitive_tests)
{



 if (_node_collision(
  boxset0, boxset1, trans_cache_1to0,
  node0, node1, complete_primitive_tests) == false) return;//avoid colliding internal nodes

 if (boxset0->isLeafNode(node0))
 {
  if (boxset1->isLeafNode(node1))
  {
   // collision result
   collision_pairs->push_pair(
    boxset0->getNodeData(node0), boxset1->getNodeData(node1));
   return;
  }
  else
  {

   //collide left recursive

   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    node0, boxset1->getLeftNode(node1), false);

   //collide right recursive
   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    node0, boxset1->getRightNode(node1), false);


  }
 }
 else
 {
  if (boxset1->isLeafNode(node1))
  {

   //collide left recursive
   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), node1, false);


   //collide right recursive

   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), node1, false);


  }
  else
  {
   //collide left0 left1



   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), boxset1->getLeftNode(node1), false);

   //collide left0 right1

   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), boxset1->getRightNode(node1), false);


   //collide right0 left1

   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), boxset1->getLeftNode(node1), false);

   //collide right0 right1

   _find_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), boxset1->getRightNode(node1), false);

  }// else if node1 is not a leaf
 }// else if node0 is not a leaf
}


void btGImpactBvh::find_collision(btGImpactBvh * boxset0, const btTransform & trans0,
 btGImpactBvh * boxset1, const btTransform & trans1,
 btPairSet & collision_pairs)
{

 if (boxset0->getNodeCount() == 0 || boxset1->getNodeCount() == 0) return;

 BT_BOX_BOX_TRANSFORM_CACHE trans_cache_1to0;

 trans_cache_1to0.calc_from_homogenic(trans0, trans1);

#ifdef TRI_COLLISION_PROFILING
 bt_begin_gim02_tree_time();
#endif //TRI_COLLISION_PROFILING

 _find_collision_pairs_recursive(
  boxset0, boxset1,
  &collision_pairs, trans_cache_1to0, 0, 0, true);
#ifdef TRI_COLLISION_PROFILING
 bt_end_gim02_tree_time();
#endif //TRI_COLLISION_PROFILING

}

/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
/*
Author: Francisco Len Njera
Concave-Concave Collision

*/

#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h"
#include "BulletCollision/Gimpact/btContactProcessing.h"
#include "LinearMath/btQuickprof.h"


//! Class for accessing the plane equation
class btPlaneShape : public btStaticPlaneShape
{
public:

 btPlaneShape(const btVector3& v, float f)
  :btStaticPlaneShape(v, f)
 {
 }

 void get_plane_equation(btVector4 &equation)
 {
  equation[0] = m_planeNormal[0];
  equation[1] = m_planeNormal[1];
  equation[2] = m_planeNormal[2];
  equation[3] = m_planeConstant;
 }


 void get_plane_equation_transformed(const btTransform & trans, btVector4 &equation) const
 {
  equation[0] = trans.getBasis().getRow(0).dot(m_planeNormal);
  equation[1] = trans.getBasis().getRow(1).dot(m_planeNormal);
  equation[2] = trans.getBasis().getRow(2).dot(m_planeNormal);
  equation[3] = trans.getOrigin().dot(m_planeNormal) + m_planeConstant;
 }
};



//////////////////////////////////////////////////////////////////////////////////////////////
#ifdef TRI_COLLISION_PROFILING

btClock g_triangle_clock;

float g_accum_triangle_collision_time = 0;
int g_count_triangle_collision = 0;

void bt_begin_gim02_tri_time()
{
 g_triangle_clock.reset();
}

void bt_end_gim02_tri_time()
{
 g_accum_triangle_collision_time += g_triangle_clock.getTimeMicroseconds();
 g_count_triangle_collision++;
}
#endif //TRI_COLLISION_PROFILING
//! Retrieving shapes shapes
/*!
Declared here due of insuficent space on Pool allocators
*/
//!@{
class GIM_ShapeRetriever
{
public:
 const btGImpactShapeInterface * m_gim_shape;
 btTriangleShapeEx m_trishape;
 btTetrahedronShapeEx m_tetrashape;

public:
 class ChildShapeRetriever
 {
 public:
  GIM_ShapeRetriever * m_parent;
  virtual const btCollisionShape * getChildShape(int index)
  {
   return m_parent->m_gim_shape->getChildShape(index);
  }
  virtual ~ChildShapeRetriever() {}
 };

 class TriangleShapeRetriever :public ChildShapeRetriever
 {
 public:

  virtual btCollisionShape * getChildShape(int index)
  {
   m_parent->m_gim_shape->getBulletTriangle(index, m_parent->m_trishape);
   return &m_parent->m_trishape;
  }
  virtual ~TriangleShapeRetriever() {}
 };

 class TetraShapeRetriever :public ChildShapeRetriever
 {
 public:

  virtual btCollisionShape * getChildShape(int index)
  {
   m_parent->m_gim_shape->getBulletTetrahedron(index, m_parent->m_tetrashape);
   return &m_parent->m_tetrashape;
  }
 };
public:
 ChildShapeRetriever m_child_retriever;
 TriangleShapeRetriever m_tri_retriever;
 TetraShapeRetriever  m_tetra_retriever;
 ChildShapeRetriever * m_current_retriever;

 GIM_ShapeRetriever(const btGImpactShapeInterface * gim_shape)
 {
  m_gim_shape = gim_shape;
  //select retriever
  if (m_gim_shape->needsRetrieveTriangles())
  {
   m_current_retriever = &m_tri_retriever;
  }
  else if (m_gim_shape->needsRetrieveTetrahedrons())
  {
   m_current_retriever = &m_tetra_retriever;
  }
  else
  {
   m_current_retriever = &m_child_retriever;
  }

  m_current_retriever->m_parent = this;
 }

 const btCollisionShape * getChildShape(int index)
 {
  return m_current_retriever->getChildShape(index);
 }


};



//!@}


#ifdef TRI_COLLISION_PROFILING

//! Gets the average time in miliseconds of tree collisions
float btGImpactCollisionAlgorithm::getAverageTreeCollisionTime()
{
 return btGImpactBoxSet::getAverageTreeCollisionTime();

}

//! Gets the average time in miliseconds of triangle collisions
float btGImpactCollisionAlgorithm::getAverageTriangleCollisionTime()
{
 if (g_count_triangle_collision == 0) return 0;

 float avgtime = g_accum_triangle_collision_time;
 avgtime /= (float)g_count_triangle_collision;

 g_accum_triangle_collision_time = 0;
 g_count_triangle_collision = 0;

 return avgtime;
}

#endif //TRI_COLLISION_PROFILING



btGImpactCollisionAlgorithm::btGImpactCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
 : btActivatingCollisionAlgorithm(ci, body0Wrap, body1Wrap)
{
 m_manifoldPtr = NULL;
 m_convex_algorithm = NULL;
}

btGImpactCollisionAlgorithm::~btGImpactCollisionAlgorithm()
{
 clearCache();
}





void btGImpactCollisionAlgorithm::addContactPoint(const btCollisionObjectWrapper * body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btVector3 & point,
 const btVector3 & normal,
 btScalar distance)
{
 m_resultOut->setShapeIdentifiersA(m_part0, m_triface0);
 m_resultOut->setShapeIdentifiersB(m_part1, m_triface1);
 checkManifold(body0Wrap, body1Wrap);
 m_resultOut->addContactPoint(normal, point, distance);
}


void btGImpactCollisionAlgorithm::shape_vs_shape_collision(
 const btCollisionObjectWrapper * body0Wrap,
 const btCollisionObjectWrapper* body1Wrap,
 const btCollisionShape * shape0,
 const btCollisionShape * shape1)
{


 {

  btCollisionAlgorithm* algor = newAlgorithm(body0Wrap, body1Wrap);
  // post :	checkManifold is called

  m_resultOut->setShapeIdentifiersA(m_part0, m_triface0);
  m_resultOut->setShapeIdentifiersB(m_part1, m_triface1);

  algor->processCollision(body0Wrap, body1Wrap, *m_dispatchInfo, m_resultOut);

  algor->~btCollisionAlgorithm();
  m_dispatcher->freeCollisionAlgorithm(algor);
 }

}

void btGImpactCollisionAlgorithm::convex_vs_convex_collision(
 const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper* body1Wrap,
 const btCollisionShape* shape0,
 const btCollisionShape* shape1)
{

 m_resultOut->setShapeIdentifiersA(m_part0, m_triface0);
 m_resultOut->setShapeIdentifiersB(m_part1, m_triface1);

 btCollisionObjectWrapper ob0(body0Wrap, shape0, body0Wrap->getCollisionObject(), body0Wrap->getWorldTransform(), m_part0, m_triface0);
 btCollisionObjectWrapper ob1(body1Wrap, shape1, body1Wrap->getCollisionObject(), body1Wrap->getWorldTransform(), m_part1, m_triface1);
 checkConvexAlgorithm(&ob0, &ob1);
 m_convex_algorithm->processCollision(&ob0, &ob1, *m_dispatchInfo, m_resultOut);


}




void btGImpactCollisionAlgorithm::gimpact_vs_gimpact_find_pairs(
 const btTransform & trans0,
 const btTransform & trans1,
 const btGImpactShapeInterface * shape0,
 const btGImpactShapeInterface * shape1, btPairSet & pairset)
{
 if (shape0->hasBoxSet() && shape1->hasBoxSet())
 {
  btGImpactBoxSet::find_collision(shape0->getBoxSet(), trans0, shape1->getBoxSet(), trans1, pairset);
 }
 else
 {
  btAABB boxshape0;
  btAABB boxshape1;
  int i = shape0->getNumChildShapes();

  while (i--)
  {
   shape0->getChildAabb(i, trans0, boxshape0.m_min, boxshape0.m_max);

   int j = shape1->getNumChildShapes();
   while (j--)
   {
    shape1->getChildAabb(i, trans1, boxshape1.m_min, boxshape1.m_max);

    if (boxshape1.has_collision(boxshape0))
    {
     pairset.push_pair(i, j);
    }
   }
  }
 }


}


void btGImpactCollisionAlgorithm::gimpact_vs_shape_find_pairs(
 const btTransform & trans0,
 const btTransform & trans1,
 const btGImpactShapeInterface * shape0,
 const btCollisionShape * shape1,
 btAlignedObjectArray<int> & collided_primitives)
{

 btAABB boxshape;


 if (shape0->hasBoxSet())
 {
  btTransform trans1to0 = trans0.inverse();
  trans1to0 *= trans1;

  shape1->getAabb(trans1to0, boxshape.m_min, boxshape.m_max);

  shape0->getBoxSet()->boxQuery(boxshape, collided_primitives);
 }
 else
 {
  shape1->getAabb(trans1, boxshape.m_min, boxshape.m_max);

  btAABB boxshape0;
  int i = shape0->getNumChildShapes();

  while (i--)
  {
   shape0->getChildAabb(i, trans0, boxshape0.m_min, boxshape0.m_max);

   if (boxshape.has_collision(boxshape0))
   {
    collided_primitives.push_back(i);
   }
  }

 }

}


void btGImpactCollisionAlgorithm::collide_gjk_triangles(const btCollisionObjectWrapper * body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btGImpactMeshShapePart * shape0,
 const btGImpactMeshShapePart * shape1,
 const int * pairs, int pair_count)
{
 btTriangleShapeEx tri0;
 btTriangleShapeEx tri1;

 shape0->lockChildShapes();
 shape1->lockChildShapes();

 const int * pair_pointer = pairs;

 while (pair_count--)
 {

  m_triface0 = *(pair_pointer);
  m_triface1 = *(pair_pointer + 1);
  pair_pointer += 2;



  shape0->getBulletTriangle(m_triface0, tri0);
  shape1->getBulletTriangle(m_triface1, tri1);


  //collide two convex shapes
  if (tri0.overlap_test_conservative(tri1))
  {
   convex_vs_convex_collision(body0Wrap, body1Wrap, &tri0, &tri1);
  }

 }

 shape0->unlockChildShapes();
 shape1->unlockChildShapes();
}

void btGImpactCollisionAlgorithm::collide_sat_triangles(const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper* body1Wrap,
 const btGImpactMeshShapePart * shape0,
 const btGImpactMeshShapePart * shape1,
 const int * pairs, int pair_count)
{
 btTransform orgtrans0 = body0Wrap->getWorldTransform();
 btTransform orgtrans1 = body1Wrap->getWorldTransform();

 btPrimitiveTriangle ptri0;
 btPrimitiveTriangle ptri1;
 GIM_TRIANGLE_CONTACT contact_data;

 shape0->lockChildShapes();
 shape1->lockChildShapes();

 const int * pair_pointer = pairs;

 while (pair_count--)
 {

  m_triface0 = *(pair_pointer);
  m_triface1 = *(pair_pointer + 1);
  pair_pointer += 2;


  shape0->getPrimitiveTriangle(m_triface0, ptri0);
  shape1->getPrimitiveTriangle(m_triface1, ptri1);

#ifdef TRI_COLLISION_PROFILING
  bt_begin_gim02_tri_time();
#endif

  ptri0.applyTransform(orgtrans0);
  ptri1.applyTransform(orgtrans1);


  //build planes
  ptri0.buildTriPlane();
  ptri1.buildTriPlane();
  // test conservative



  if (ptri0.overlap_test_conservative(ptri1))
  {
   if (ptri0.find_triangle_collision_clip_method(ptri1, contact_data))
   {

    int j = contact_data.m_point_count;
    while (j--)
    {

     addContactPoint(body0Wrap, body1Wrap,
      contact_data.m_points[j],
      contact_data.m_separating_normal,
      -contact_data.m_penetration_depth);
    }
   }
  }

#ifdef TRI_COLLISION_PROFILING
  bt_end_gim02_tri_time();
#endif

 }

 shape0->unlockChildShapes();
 shape1->unlockChildShapes();

}


void btGImpactCollisionAlgorithm::gimpact_vs_gimpact(
 const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btGImpactShapeInterface * shape0,
 const btGImpactShapeInterface * shape1)
{

 if (shape0->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE)
 {
  const btGImpactMeshShape * meshshape0 = static_cast<const btGImpactMeshShape *>(shape0);
  m_part0 = meshshape0->getMeshPartCount();

  while (m_part0--)
  {
   gimpact_vs_gimpact(body0Wrap, body1Wrap, meshshape0->getMeshPart(m_part0), shape1);
  }

  return;
 }

 if (shape1->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE)
 {
  const btGImpactMeshShape * meshshape1 = static_cast<const btGImpactMeshShape *>(shape1);
  m_part1 = meshshape1->getMeshPartCount();

  while (m_part1--)
  {

   gimpact_vs_gimpact(body0Wrap, body1Wrap, shape0, meshshape1->getMeshPart(m_part1));

  }

  return;
 }


 btTransform orgtrans0 = body0Wrap->getWorldTransform();
 btTransform orgtrans1 = body1Wrap->getWorldTransform();

 btPairSet pairset;

 gimpact_vs_gimpact_find_pairs(orgtrans0, orgtrans1, shape0, shape1, pairset);

 if (pairset.size() == 0) return;

 if (shape0->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE_PART &&
  shape1->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE_PART)
 {
  const btGImpactMeshShapePart * shapepart0 = static_cast<const btGImpactMeshShapePart * >(shape0);
  const btGImpactMeshShapePart * shapepart1 = static_cast<const btGImpactMeshShapePart * >(shape1);
  //specialized function
#ifdef BULLET_TRIANGLE_COLLISION
  collide_gjk_triangles(body0Wrap, body1Wrap, shapepart0, shapepart1, &pairset[0].m_index1, pairset.size());
#else
  collide_sat_triangles(body0Wrap, body1Wrap, shapepart0, shapepart1, &pairset[0].m_index1, pairset.size());
#endif

  return;
 }

 //general function

 shape0->lockChildShapes();
 shape1->lockChildShapes();

 GIM_ShapeRetriever retriever0(shape0);
 GIM_ShapeRetriever retriever1(shape1);

 bool child_has_transform0 = shape0->childrenHasTransform();
 bool child_has_transform1 = shape1->childrenHasTransform();

 int i = pairset.size();
 while (i--)
 {
  GIM_PAIR * pair = &pairset[i];
  m_triface0 = pair->m_index1;
  m_triface1 = pair->m_index2;
  const btCollisionShape * colshape0 = retriever0.getChildShape(m_triface0);
  const btCollisionShape * colshape1 = retriever1.getChildShape(m_triface1);

  btTransform tr0 = body0Wrap->getWorldTransform();
  btTransform tr1 = body1Wrap->getWorldTransform();

  if (child_has_transform0)
  {
   tr0 = orgtrans0*shape0->getChildTransform(m_triface0);
  }

  if (child_has_transform1)
  {
   tr1 = orgtrans1*shape1->getChildTransform(m_triface1);
  }

  btCollisionObjectWrapper ob0(body0Wrap, colshape0, body0Wrap->getCollisionObject(), tr0, m_part0, m_triface0);
  btCollisionObjectWrapper ob1(body1Wrap, colshape1, body1Wrap->getCollisionObject(), tr1, m_part1, m_triface1);

  //collide two convex shapes
  convex_vs_convex_collision(&ob0, &ob1, colshape0, colshape1);
 }

 shape0->unlockChildShapes();
 shape1->unlockChildShapes();
}

void btGImpactCollisionAlgorithm::gimpact_vs_shape(const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btGImpactShapeInterface * shape0,
 const btCollisionShape * shape1, bool swapped)
{
 if (shape0->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE)
 {
  const btGImpactMeshShape * meshshape0 = static_cast<const btGImpactMeshShape *>(shape0);
  int& part = swapped ? m_part1 : m_part0;
  part = meshshape0->getMeshPartCount();

  while (part--)
  {

   gimpact_vs_shape(body0Wrap,
    body1Wrap,
    meshshape0->getMeshPart(part),
    shape1, swapped);

  }

  return;
 }

#ifdef GIMPACT_VS_PLANE_COLLISION
 if (shape0->getGImpactShapeType() == CONST_GIMPACT_TRIMESH_SHAPE_PART &&
  shape1->getShapeType() == STATIC_PLANE_PROXYTYPE)
 {
  const btGImpactMeshShapePart * shapepart = static_cast<const btGImpactMeshShapePart *>(shape0);
  const btStaticPlaneShape * planeshape = static_cast<const btStaticPlaneShape * >(shape1);
  gimpacttrimeshpart_vs_plane_collision(body0Wrap, body1Wrap, shapepart, planeshape, swapped);
  return;
 }

#endif



 if (shape1->isCompound())
 {
  const btCompoundShape * compoundshape = static_cast<const btCompoundShape *>(shape1);
  gimpact_vs_compoundshape(body0Wrap, body1Wrap, shape0, compoundshape, swapped);
  return;
 }
 else if (shape1->isConcave())
 {
  const btConcaveShape * concaveshape = static_cast<const btConcaveShape *>(shape1);
  gimpact_vs_concave(body0Wrap, body1Wrap, shape0, concaveshape, swapped);
  return;
 }


 btTransform orgtrans0 = body0Wrap->getWorldTransform();

 btTransform orgtrans1 = body1Wrap->getWorldTransform();

 btAlignedObjectArray<int> collided_results;

 gimpact_vs_shape_find_pairs(orgtrans0, orgtrans1, shape0, shape1, collided_results);

 if (collided_results.size() == 0) return;


 shape0->lockChildShapes();

 GIM_ShapeRetriever retriever0(shape0);


 bool child_has_transform0 = shape0->childrenHasTransform();


 int i = collided_results.size();

 while (i--)
 {
  int child_index = collided_results[i];
  if (swapped)
   m_triface1 = child_index;
  else
   m_triface0 = child_index;

  const btCollisionShape * colshape0 = retriever0.getChildShape(child_index);

  btTransform tr0 = body0Wrap->getWorldTransform();

  if (child_has_transform0)
  {
   tr0 = orgtrans0*shape0->getChildTransform(child_index);
  }

  btCollisionObjectWrapper ob0(body0Wrap, colshape0, body0Wrap->getCollisionObject(), body0Wrap->getWorldTransform(), m_part0, m_triface0);
  const btCollisionObjectWrapper* prevObj0 = m_resultOut->getBody0Wrap();

  if (m_resultOut->getBody0Wrap()->getCollisionObject() == ob0.getCollisionObject())
  {
   m_resultOut->setBody0Wrap(&ob0);
  }
  else
  {
   m_resultOut->setBody1Wrap(&ob0);
  }

  //collide two shapes
  if (swapped)
  {

   shape_vs_shape_collision(body1Wrap, &ob0, shape1, colshape0);
  }
  else
  {

   shape_vs_shape_collision(&ob0, body1Wrap, colshape0, shape1);
  }
  m_resultOut->setBody0Wrap(prevObj0);

 }

 shape0->unlockChildShapes();

}

void btGImpactCollisionAlgorithm::gimpact_vs_compoundshape(const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper* body1Wrap,
 const btGImpactShapeInterface * shape0,
 const btCompoundShape * shape1, bool swapped)
{
 btTransform orgtrans1 = body1Wrap->getWorldTransform();

 int i = shape1->getNumChildShapes();
 while (i--)
 {

  const btCollisionShape * colshape1 = shape1->getChildShape(i);
  btTransform childtrans1 = orgtrans1*shape1->getChildTransform(i);

  btCollisionObjectWrapper ob1(body1Wrap, colshape1, body1Wrap->getCollisionObject(), childtrans1, -1, i);

  const btCollisionObjectWrapper* tmp = 0;
  if (m_resultOut->getBody0Wrap()->getCollisionObject() == ob1.getCollisionObject())
  {
   tmp = m_resultOut->getBody0Wrap();
   m_resultOut->setBody0Wrap(&ob1);
  }
  else
  {
   tmp = m_resultOut->getBody1Wrap();
   m_resultOut->setBody1Wrap(&ob1);
  }
  //collide child shape
  gimpact_vs_shape(body0Wrap, &ob1,
   shape0, colshape1, swapped);

  if (m_resultOut->getBody0Wrap()->getCollisionObject() == ob1.getCollisionObject())
  {
   m_resultOut->setBody0Wrap(tmp);
  }
  else
  {
   m_resultOut->setBody1Wrap(tmp);
  }
 }
}

void btGImpactCollisionAlgorithm::gimpacttrimeshpart_vs_plane_collision(
 const btCollisionObjectWrapper * body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btGImpactMeshShapePart * shape0,
 const btStaticPlaneShape * shape1, bool swapped)
{


 btTransform orgtrans0 = body0Wrap->getWorldTransform();
 btTransform orgtrans1 = body1Wrap->getWorldTransform();

 const btPlaneShape * planeshape = static_cast<const btPlaneShape *>(shape1);
 btVector4 plane;
 planeshape->get_plane_equation_transformed(orgtrans1, plane);

 //test box against plane

 btAABB tribox;
 shape0->getAabb(orgtrans0, tribox.m_min, tribox.m_max);
 tribox.increment_margin(planeshape->getMargin());

 if (tribox.plane_classify(plane) != BT_CONST_COLLIDE_PLANE) return;

 shape0->lockChildShapes();

 btScalar margin = shape0->getMargin() + planeshape->getMargin();

 btVector3 vertex;
 int vi = shape0->getVertexCount();
 while (vi--)
 {
  shape0->getVertex(vi, vertex);
  vertex = orgtrans0(vertex);

  btScalar distance = vertex.dot(plane) - plane[3] - margin;

  if (distance<0.0)//add contact
  {
   if (swapped)
   {
    addContactPoint(body1Wrap, body0Wrap,
     vertex,
     -plane,
     distance);
   }
   else
   {
    addContactPoint(body0Wrap, body1Wrap,
     vertex,
     plane,
     distance);
   }
  }
 }

 shape0->unlockChildShapes();
}




class btGImpactTriangleCallback : public btTriangleCallback
{
public:
 btGImpactCollisionAlgorithm * algorithm;
 const btCollisionObjectWrapper * body0Wrap;
 const btCollisionObjectWrapper * body1Wrap;
 const btGImpactShapeInterface * gimpactshape0;
 bool swapped;
 btScalar margin;

 virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
 {
  btTriangleShapeEx tri1(triangle[0], triangle[1], triangle[2]);
  tri1.setMargin(margin);
  if (swapped)
  {
   algorithm->setPart0(partId);
   algorithm->setFace0(triangleIndex);
  }
  else
  {
   algorithm->setPart1(partId);
   algorithm->setFace1(triangleIndex);
  }

  btCollisionObjectWrapper ob1Wrap(body1Wrap, &tri1, body1Wrap->getCollisionObject(), body1Wrap->getWorldTransform(), partId, triangleIndex);
  const btCollisionObjectWrapper * tmp = 0;

  if (algorithm->internalGetResultOut()->getBody0Wrap()->getCollisionObject() == ob1Wrap.getCollisionObject())
  {
   tmp = algorithm->internalGetResultOut()->getBody0Wrap();
   algorithm->internalGetResultOut()->setBody0Wrap(&ob1Wrap);
  }
  else
  {
   tmp = algorithm->internalGetResultOut()->getBody1Wrap();
   algorithm->internalGetResultOut()->setBody1Wrap(&ob1Wrap);
  }

  algorithm->gimpact_vs_shape(
   body0Wrap, &ob1Wrap, gimpactshape0, &tri1, swapped);

  if (algorithm->internalGetResultOut()->getBody0Wrap()->getCollisionObject() == ob1Wrap.getCollisionObject())
  {
   algorithm->internalGetResultOut()->setBody0Wrap(tmp);
  }
  else
  {
   algorithm->internalGetResultOut()->setBody1Wrap(tmp);
  }

 }
};




void btGImpactCollisionAlgorithm::gimpact_vs_concave(
 const btCollisionObjectWrapper* body0Wrap,
 const btCollisionObjectWrapper * body1Wrap,
 const btGImpactShapeInterface * shape0,
 const btConcaveShape * shape1, bool swapped)
{
 //create the callback
 btGImpactTriangleCallback tricallback;
 tricallback.algorithm = this;
 tricallback.body0Wrap = body0Wrap;
 tricallback.body1Wrap = body1Wrap;
 tricallback.gimpactshape0 = shape0;
 tricallback.swapped = swapped;
 tricallback.margin = shape1->getMargin();

 //getting the trimesh AABB
 btTransform gimpactInConcaveSpace;

 gimpactInConcaveSpace = body1Wrap->getWorldTransform().inverse() * body0Wrap->getWorldTransform();

 btVector3 minAABB, maxAABB;
 shape0->getAabb(gimpactInConcaveSpace, minAABB, maxAABB);

 shape1->processAllTriangles(&tricallback, minAABB, maxAABB);

}



void btGImpactCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 clearCache();

 m_resultOut = resultOut;
 m_dispatchInfo = &dispatchInfo;
 const btGImpactShapeInterface * gimpactshape0;
 const btGImpactShapeInterface * gimpactshape1;

 if (body0Wrap->getCollisionShape()->getShapeType() == GIMPACT_SHAPE_PROXYTYPE)
 {
  gimpactshape0 = static_cast<const btGImpactShapeInterface *>(body0Wrap->getCollisionShape());

  if (body1Wrap->getCollisionShape()->getShapeType() == GIMPACT_SHAPE_PROXYTYPE)
  {
   gimpactshape1 = static_cast<const btGImpactShapeInterface *>(body1Wrap->getCollisionShape());

   gimpact_vs_gimpact(body0Wrap, body1Wrap, gimpactshape0, gimpactshape1);
  }
  else
  {
   gimpact_vs_shape(body0Wrap, body1Wrap, gimpactshape0, body1Wrap->getCollisionShape(), false);
  }

 }
 else if (body1Wrap->getCollisionShape()->getShapeType() == GIMPACT_SHAPE_PROXYTYPE)
 {
  gimpactshape1 = static_cast<const btGImpactShapeInterface *>(body1Wrap->getCollisionShape());

  gimpact_vs_shape(body1Wrap, body0Wrap, gimpactshape1, body0Wrap->getCollisionShape(), true);
 }
}


btScalar btGImpactCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 return 1.f;

}

///////////////////////////////////// REGISTERING ALGORITHM //////////////////////////////////////////////



//! Use this function for register the algorithm externally
void btGImpactCollisionAlgorithm::registerAlgorithm(btCollisionDispatcher * dispatcher)
{

 static btGImpactCollisionAlgorithm::CreateFunc s_gimpact_cf;

 int i;

 for (i = 0; i < MAX_BROADPHASE_COLLISION_TYPES; i++)
 {
  dispatcher->registerCollisionCreateFunc(GIMPACT_SHAPE_PROXYTYPE, i, &s_gimpact_cf);
 }

 for (i = 0; i < MAX_BROADPHASE_COLLISION_TYPES; i++)
 {
  dispatcher->registerCollisionCreateFunc(i, GIMPACT_SHAPE_PROXYTYPE, &s_gimpact_cf);
 }

}
/*! \file gim_box_set.h
\author Francisco Leon Najera
*/
/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/Gimpact/btGImpactQuantizedBvh.h"
#include "LinearMath/btQuickprof.h"

#ifdef TRI_COLLISION_PROFILING
btClock g_q_tree_clock;


float g_q_accum_tree_collision_time = 0;
int g_q_count_traversing = 0;


void bt_begin_gim02_q_tree_time()
{
 g_q_tree_clock.reset();
}

void bt_end_gim02_q_tree_time()
{
 g_q_accum_tree_collision_time += g_q_tree_clock.getTimeMicroseconds();
 g_q_count_traversing++;
}


//! Gets the average time in miliseconds of tree collisions
float btGImpactQuantizedBvh::getAverageTreeCollisionTime()
{
 if (g_q_count_traversing == 0) return 0;

 float avgtime = g_q_accum_tree_collision_time;
 avgtime /= (float)g_q_count_traversing;

 g_q_accum_tree_collision_time = 0;
 g_q_count_traversing = 0;
 return avgtime;

 //	float avgtime = g_q_count_traversing;
 //	g_q_count_traversing = 0;
 //	return avgtime;

}

#endif //TRI_COLLISION_PROFILING

/////////////////////// btQuantizedBvhTree /////////////////////////////////

void btQuantizedBvhTree::calc_quantization(
 GIM_BVH_DATA_ARRAY & primitive_boxes, btScalar boundMargin)
{
 //calc globa box
 btAABB global_bound;
 global_bound.invalidate();

 for (int i = 0; i<primitive_boxes.size(); i++)
 {
  global_bound.merge(primitive_boxes[i].m_bound);
 }

 bt_calc_quantization_parameters(
  m_global_bound.m_min, m_global_bound.m_max, m_bvhQuantization, global_bound.m_min, global_bound.m_max, boundMargin);

}



int btQuantizedBvhTree::_calc_splitting_axis(
 GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex, int endIndex)
{

 int i;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 btVector3 variance(btScalar(0.), btScalar(0.), btScalar(0.));
 int numIndices = endIndex - startIndex;

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  btVector3 diff2 = center - means;
  diff2 = diff2 * diff2;
  variance += diff2;
 }
 variance *= (btScalar(1.) / ((btScalar)numIndices - 1));

 return variance.maxAxis();
}


int btQuantizedBvhTree::_sort_and_calc_splitting_index(
 GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex,
 int endIndex, int splitAxis)
{
 int i;
 int splitIndex = startIndex;
 int numIndices = endIndex - startIndex;

 // average of centers
 btScalar splitValue = 0.0f;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 splitValue = means[splitAxis];


 //sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  if (center[splitAxis] > splitValue)
  {
   //swap
   primitive_boxes.swap(i, splitIndex);
   //swapLeafNodes(i,splitIndex);
   splitIndex++;
  }
 }

 //if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
 //otherwise the tree-building might fail due to stack-overflows in certain cases.
 //unbalanced1 is unsafe: it can cause stack overflows
 //bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));

 //unbalanced2 should work too: always use center (perfect balanced trees)
 //bool unbalanced2 = true;

 //this should be safe too:
 int rangeBalancedIndices = numIndices / 3;
 bool unbalanced = ((splitIndex <= (startIndex + rangeBalancedIndices)) || (splitIndex >= (endIndex - 1 - rangeBalancedIndices)));

 if (unbalanced)
 {
  splitIndex = startIndex + (numIndices >> 1);
 }

 btAssert(!((splitIndex == startIndex) || (splitIndex == (endIndex))));

 return splitIndex;

}


void btQuantizedBvhTree::_build_sub_tree(GIM_BVH_DATA_ARRAY & primitive_boxes, int startIndex, int endIndex)
{
 int curIndex = m_num_nodes;
 m_num_nodes++;

 btAssert((endIndex - startIndex)>0);

 if ((endIndex - startIndex) == 1)
 {
  //We have a leaf node
  setNodeBound(curIndex, primitive_boxes[startIndex].m_bound);
  m_node_array[curIndex].setDataIndex(primitive_boxes[startIndex].m_data);

  return;
 }
 //calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.

 //split axis
 int splitIndex = _calc_splitting_axis(primitive_boxes, startIndex, endIndex);

 splitIndex = _sort_and_calc_splitting_index(
  primitive_boxes, startIndex, endIndex,
  splitIndex//split axis
 );


 //calc this node bounding box

 btAABB node_bound;
 node_bound.invalidate();

 for (int i = startIndex; i<endIndex; i++)
 {
  node_bound.merge(primitive_boxes[i].m_bound);
 }

 setNodeBound(curIndex, node_bound);


 //build left branch
 _build_sub_tree(primitive_boxes, startIndex, splitIndex);


 //build right branch
 _build_sub_tree(primitive_boxes, splitIndex, endIndex);

 m_node_array[curIndex].setEscapeIndex(m_num_nodes - curIndex);


}

//! stackless build tree
void btQuantizedBvhTree::build_tree(
 GIM_BVH_DATA_ARRAY & primitive_boxes)
{
 calc_quantization(primitive_boxes);
 // initialize node count to 0
 m_num_nodes = 0;
 // allocate nodes
 m_node_array.resize(primitive_boxes.size() * 2);

 _build_sub_tree(primitive_boxes, 0, primitive_boxes.size());
}

////////////////////////////////////class btGImpactQuantizedBvh

void btGImpactQuantizedBvh::refit()
{
 int nodecount = getNodeCount();
 while (nodecount--)
 {
  if (isLeafNode(nodecount))
  {
   btAABB leafbox;
   m_primitive_manager->get_primitive_box(getNodeData(nodecount), leafbox);
   setNodeBound(nodecount, leafbox);
  }
  else
  {
   //const GIM_BVH_TREE_NODE * nodepointer = get_node_pointer(nodecount);
   //get left bound
   btAABB bound;
   bound.invalidate();

   btAABB temp_box;

   int child_node = getLeftNode(nodecount);
   if (child_node)
   {
    getNodeBound(child_node, temp_box);
    bound.merge(temp_box);
   }

   child_node = getRightNode(nodecount);
   if (child_node)
   {
    getNodeBound(child_node, temp_box);
    bound.merge(temp_box);
   }

   setNodeBound(nodecount, bound);
  }
 }
}

//! this rebuild the entire set
void btGImpactQuantizedBvh::buildSet()
{
 //obtain primitive boxes
 GIM_BVH_DATA_ARRAY primitive_boxes;
 primitive_boxes.resize(m_primitive_manager->get_primitive_count());

 for (int i = 0; i<primitive_boxes.size(); i++)
 {
  m_primitive_manager->get_primitive_box(i, primitive_boxes[i].m_bound);
  primitive_boxes[i].m_data = i;
 }

 m_box_tree.build_tree(primitive_boxes);
}

//! returns the indices of the primitives in the m_primitive_manager
bool btGImpactQuantizedBvh::boxQuery(const btAABB & box, btAlignedObjectArray<int> & collided_results) const
{
 int curIndex = 0;
 int numNodes = getNodeCount();

 //quantize box

 unsigned short quantizedMin[3];
 unsigned short quantizedMax[3];

 m_box_tree.quantizePoint(quantizedMin, box.m_min);
 m_box_tree.quantizePoint(quantizedMax, box.m_max);


 while (curIndex < numNodes)
 {

  //catch bugs in tree data

  bool aabbOverlap = m_box_tree.testQuantizedBoxOverlapp(curIndex, quantizedMin, quantizedMax);
  bool isleafnode = isLeafNode(curIndex);

  if (isleafnode && aabbOverlap)
  {
   collided_results.push_back(getNodeData(curIndex));
  }

  if (aabbOverlap || isleafnode)
  {
   //next subnode
   curIndex++;
  }
  else
  {
   //skip node
   curIndex += getEscapeNodeIndex(curIndex);
  }
 }
 if (collided_results.size()>0) return true;
 return false;
}



//! returns the indices of the primitives in the m_primitive_manager
bool btGImpactQuantizedBvh::rayQuery(
 const btVector3 & ray_dir, const btVector3 & ray_origin,
 btAlignedObjectArray<int> & collided_results) const
{
 int curIndex = 0;
 int numNodes = getNodeCount();

 while (curIndex < numNodes)
 {
  btAABB bound;
  getNodeBound(curIndex, bound);

  //catch bugs in tree data

  bool aabbOverlap = bound.collide_ray(ray_origin, ray_dir);
  bool isleafnode = isLeafNode(curIndex);

  if (isleafnode && aabbOverlap)
  {
   collided_results.push_back(getNodeData(curIndex));
  }

  if (aabbOverlap || isleafnode)
  {
   //next subnode
   curIndex++;
  }
  else
  {
   //skip node
   curIndex += getEscapeNodeIndex(curIndex);
  }
 }
 if (collided_results.size()>0) return true;
 return false;
}


SIMD_FORCE_INLINE bool _quantized_node_collision(
 const btGImpactQuantizedBvh * boxset0, const btGImpactQuantizedBvh * boxset1,
 const BT_BOX_BOX_TRANSFORM_CACHE & trans_cache_1to0,
 int node0, int node1, bool complete_primitive_tests)
{
 btAABB box0;
 boxset0->getNodeBound(node0, box0);
 btAABB box1;
 boxset1->getNodeBound(node1, box1);

 return box0.overlapping_trans_cache(box1, trans_cache_1to0, complete_primitive_tests);
 //	box1.appy_transform_trans_cache(trans_cache_1to0);
 //	return box0.has_collision(box1);

}


//stackless recursive collision routine
static void _find_quantized_collision_pairs_recursive(
 const btGImpactQuantizedBvh * boxset0, const btGImpactQuantizedBvh * boxset1,
 btPairSet * collision_pairs,
 const BT_BOX_BOX_TRANSFORM_CACHE & trans_cache_1to0,
 int node0, int node1, bool complete_primitive_tests)
{



 if (_quantized_node_collision(
  boxset0, boxset1, trans_cache_1to0,
  node0, node1, complete_primitive_tests) == false) return;//avoid colliding internal nodes

 if (boxset0->isLeafNode(node0))
 {
  if (boxset1->isLeafNode(node1))
  {
   // collision result
   collision_pairs->push_pair(
    boxset0->getNodeData(node0), boxset1->getNodeData(node1));
   return;
  }
  else
  {

   //collide left recursive

   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    node0, boxset1->getLeftNode(node1), false);

   //collide right recursive
   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    node0, boxset1->getRightNode(node1), false);


  }
 }
 else
 {
  if (boxset1->isLeafNode(node1))
  {

   //collide left recursive
   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), node1, false);


   //collide right recursive

   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), node1, false);


  }
  else
  {
   //collide left0 left1



   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), boxset1->getLeftNode(node1), false);

   //collide left0 right1

   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getLeftNode(node0), boxset1->getRightNode(node1), false);


   //collide right0 left1

   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), boxset1->getLeftNode(node1), false);

   //collide right0 right1

   _find_quantized_collision_pairs_recursive(
    boxset0, boxset1,
    collision_pairs, trans_cache_1to0,
    boxset0->getRightNode(node0), boxset1->getRightNode(node1), false);

  }// else if node1 is not a leaf
 }// else if node0 is not a leaf
}


void btGImpactQuantizedBvh::find_collision(const btGImpactQuantizedBvh * boxset0, const btTransform & trans0,
 const btGImpactQuantizedBvh * boxset1, const btTransform & trans1,
 btPairSet & collision_pairs)
{

 if (boxset0->getNodeCount() == 0 || boxset1->getNodeCount() == 0) return;

 BT_BOX_BOX_TRANSFORM_CACHE trans_cache_1to0;

 trans_cache_1to0.calc_from_homogenic(trans0, trans1);

#ifdef TRI_COLLISION_PROFILING
 bt_begin_gim02_q_tree_time();
#endif //TRI_COLLISION_PROFILING

 _find_quantized_collision_pairs_recursive(
  boxset0, boxset1,
  &collision_pairs, trans_cache_1to0, 0, 0, true);
#ifdef TRI_COLLISION_PROFILING
 bt_end_gim02_q_tree_time();
#endif //TRI_COLLISION_PROFILING

}


/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/Gimpact/btGImpactShape.h"
#include "BulletCollision/Gimpact/btGImpactMassUtil.h"


btGImpactMeshShapePart::btGImpactMeshShapePart(btStridingMeshInterface * meshInterface, int part)
{
 // moved from .h to .cpp because of conditional compilation
 // (The setting of BT_THREADSAFE may differ between various cpp files, so it is best to
 // avoid using it in h files)
 m_primitive_manager.m_meshInterface = meshInterface;
 m_primitive_manager.m_part = part;
 m_box_set.setPrimitiveManager(&m_primitive_manager);
#if BT_THREADSAFE
 // If threadsafe is requested, this object uses a different lock/unlock
 //  model with the btStridingMeshInterface -- lock once when the object is constructed
 //  and unlock once in the destructor.
 // The other way of locking and unlocking for each collision check in the narrowphase
 // is not threadsafe.  Note these are not thread-locks, they are calls to the meshInterface's
 // getLockedReadOnlyVertexIndexBase virtual function, which by default just returns a couple of
 // pointers.  In theory a client could override the lock function to do all sorts of
 // things like reading data from GPU memory, or decompressing data on the fly, but such things
 // do not seem all that likely or useful, given the performance cost.
 m_primitive_manager.lock();
#endif
}

btGImpactMeshShapePart::~btGImpactMeshShapePart()
{
 // moved from .h to .cpp because of conditional compilation
#if BT_THREADSAFE
 m_primitive_manager.unlock();
#endif
}

void btGImpactMeshShapePart::lockChildShapes() const
{
 // moved from .h to .cpp because of conditional compilation
#if ! BT_THREADSAFE
 // called in the narrowphase -- not threadsafe!
 void * dummy = (void*)(m_box_set.getPrimitiveManager());
 TrimeshPrimitiveManager * dummymanager = static_cast<TrimeshPrimitiveManager *>(dummy);
 dummymanager->lock();
#endif
}

void btGImpactMeshShapePart::unlockChildShapes()  const
{
 // moved from .h to .cpp because of conditional compilation
#if ! BT_THREADSAFE
 // called in the narrowphase -- not threadsafe!
 void * dummy = (void*)(m_box_set.getPrimitiveManager());
 TrimeshPrimitiveManager * dummymanager = static_cast<TrimeshPrimitiveManager *>(dummy);
 dummymanager->unlock();
#endif
}


#define CALC_EXACT_INERTIA 1


void btGImpactCompoundShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 lockChildShapes();
#ifdef CALC_EXACT_INERTIA
 inertia.setValue(0.f, 0.f, 0.f);

 int i = this->getNumChildShapes();
 btScalar shapemass = mass / btScalar(i);

 while (i--)
 {
  btVector3 temp_inertia;
  m_childShapes[i]->calculateLocalInertia(shapemass, temp_inertia);
  if (childrenHasTransform())
  {
   inertia = gim_inertia_add_transformed(inertia, temp_inertia, m_childTransforms[i]);
  }
  else
  {
   inertia = gim_inertia_add_transformed(inertia, temp_inertia, btTransform::getIdentity());
  }

 }

#else

 // Calc box inertia

 btScalar lx = m_localAABB.m_max[0] - m_localAABB.m_min[0];
 btScalar ly = m_localAABB.m_max[1] - m_localAABB.m_min[1];
 btScalar lz = m_localAABB.m_max[2] - m_localAABB.m_min[2];
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(0.08333333);

 inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));

#endif
 unlockChildShapes();
}



void btGImpactMeshShapePart::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
 lockChildShapes();


#ifdef CALC_EXACT_INERTIA
 inertia.setValue(0.f, 0.f, 0.f);

 int i = this->getVertexCount();
 btScalar pointmass = mass / btScalar(i);

 while (i--)
 {
  btVector3 pointintertia;
  this->getVertex(i, pointintertia);
  pointintertia = gim_get_point_inertia(pointintertia, pointmass);
  inertia += pointintertia;
 }

#else

 // Calc box inertia

 btScalar lx = m_localAABB.m_max[0] - m_localAABB.m_min[0];
 btScalar ly = m_localAABB.m_max[1] - m_localAABB.m_min[1];
 btScalar lz = m_localAABB.m_max[2] - m_localAABB.m_min[2];
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(0.08333333);

 inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));

#endif

 unlockChildShapes();
}

void btGImpactMeshShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{

#ifdef CALC_EXACT_INERTIA
 inertia.setValue(0.f, 0.f, 0.f);

 int i = this->getMeshPartCount();
 btScalar partmass = mass / btScalar(i);

 while (i--)
 {
  btVector3 partinertia;
  getMeshPart(i)->calculateLocalInertia(partmass, partinertia);
  inertia += partinertia;
 }

#else

 // Calc box inertia

 btScalar lx = m_localAABB.m_max[0] - m_localAABB.m_min[0];
 btScalar ly = m_localAABB.m_max[1] - m_localAABB.m_min[1];
 btScalar lz = m_localAABB.m_max[2] - m_localAABB.m_min[2];
 const btScalar x2 = lx*lx;
 const btScalar y2 = ly*ly;
 const btScalar z2 = lz*lz;
 const btScalar scaledmass = mass * btScalar(0.08333333);

 inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));

#endif
}

void btGImpactMeshShape::rayTest(const btVector3& rayFrom, const btVector3& rayTo, btCollisionWorld::RayResultCallback& resultCallback) const
{
}

void btGImpactMeshShapePart::processAllTrianglesRay(btTriangleCallback* callback, const btVector3& rayFrom, const btVector3& rayTo) const
{
 lockChildShapes();

 btAlignedObjectArray<int> collided;
 btVector3 rayDir(rayTo - rayFrom);
 rayDir.normalize();
 m_box_set.rayQuery(rayDir, rayFrom, collided);

 if (collided.size() == 0)
 {
  unlockChildShapes();
  return;
 }

 int part = (int)getPart();
 btPrimitiveTriangle triangle;
 int i = collided.size();
 while (i--)
 {
  getPrimitiveTriangle(collided[i], triangle);
  callback->processTriangle(triangle.m_vertices, part, collided[i]);
 }
 unlockChildShapes();
}

void btGImpactMeshShapePart::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 lockChildShapes();
 btAABB box;
 box.m_min = aabbMin;
 box.m_max = aabbMax;

 btAlignedObjectArray<int> collided;
 m_box_set.boxQuery(box, collided);

 if (collided.size() == 0)
 {
  unlockChildShapes();
  return;
 }

 int part = (int)getPart();
 btPrimitiveTriangle triangle;
 int i = collided.size();
 while (i--)
 {
  this->getPrimitiveTriangle(collided[i], triangle);
  callback->processTriangle(triangle.m_vertices, part, collided[i]);
 }
 unlockChildShapes();

}

void btGImpactMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
 int i = m_mesh_parts.size();
 while (i--)
 {
  m_mesh_parts[i]->processAllTriangles(callback, aabbMin, aabbMax);
 }
}

void btGImpactMeshShape::processAllTrianglesRay(btTriangleCallback* callback, const btVector3& rayFrom, const btVector3& rayTo) const
{
 int i = m_mesh_parts.size();
 while (i--)
 {
  m_mesh_parts[i]->processAllTrianglesRay(callback, rayFrom, rayTo);
 }
}


///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btGImpactMeshShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btGImpactMeshShapeData* trimeshData = (btGImpactMeshShapeData*)dataBuffer;

 btCollisionShape::serialize(&trimeshData->m_collisionShapeData, serializer);

 m_meshInterface->serialize(&trimeshData->m_meshInterface, serializer);

 trimeshData->m_collisionMargin = float(m_collisionMargin);

 localScaling.serializeFloat(trimeshData->m_localScaling);

 trimeshData->m_gimpactSubType = int(getGImpactShapeType());

 return "btGImpactMeshShapeData";
}

/*! \file btGImpactTriangleShape.h
\author Francisco Leon Najera
*/
/*
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com


This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/Gimpact/btTriangleShapeEx.h"



void GIM_TRIANGLE_CONTACT::merge_points(const btVector4 & plane,
 btScalar margin, const btVector3 * points, int point_count)
{
 m_point_count = 0;
 m_penetration_depth = -1000.0f;

 int point_indices[MAX_TRI_CLIPPING];

 int _k;

 for (_k = 0; _k<point_count; _k++)
 {
  btScalar _dist = -bt_distance_point_plane(plane, points[_k]) + margin;

  if (_dist >= 0.0f)
  {
   if (_dist>m_penetration_depth)
   {
    m_penetration_depth = _dist;
    point_indices[0] = _k;
    m_point_count = 1;
   }
   else if ((_dist + SIMD_EPSILON) >= m_penetration_depth)
   {
    point_indices[m_point_count] = _k;
    m_point_count++;
   }
  }
 }

 for (_k = 0; _k<m_point_count; _k++)
 {
  m_points[_k] = points[point_indices[_k]];
 }
}

///class btPrimitiveTriangle
bool btPrimitiveTriangle::overlap_test_conservative(const btPrimitiveTriangle& other)
{
 btScalar total_margin = m_margin + other.m_margin;
 // classify points on other triangle
 btScalar dis0 = bt_distance_point_plane(m_plane, other.m_vertices[0]) - total_margin;

 btScalar dis1 = bt_distance_point_plane(m_plane, other.m_vertices[1]) - total_margin;

 btScalar dis2 = bt_distance_point_plane(m_plane, other.m_vertices[2]) - total_margin;

 if (dis0>0.0f&&dis1>0.0f&&dis2>0.0f) return false;

 // classify points on this triangle
 dis0 = bt_distance_point_plane(other.m_plane, m_vertices[0]) - total_margin;

 dis1 = bt_distance_point_plane(other.m_plane, m_vertices[1]) - total_margin;

 dis2 = bt_distance_point_plane(other.m_plane, m_vertices[2]) - total_margin;

 if (dis0>0.0f&&dis1>0.0f&&dis2>0.0f) return false;

 return true;
}

int btPrimitiveTriangle::clip_triangle(btPrimitiveTriangle & other, btVector3 * clipped_points)
{
 // edge 0

 btVector3 temp_points[MAX_TRI_CLIPPING];


 btVector4 edgeplane;

 get_edge_plane(0, edgeplane);


 int clipped_count = bt_plane_clip_triangle(
  edgeplane, other.m_vertices[0], other.m_vertices[1], other.m_vertices[2], temp_points);

 if (clipped_count == 0) return 0;

 btVector3 temp_points1[MAX_TRI_CLIPPING];


 // edge 1
 get_edge_plane(1, edgeplane);


 clipped_count = bt_plane_clip_polygon(edgeplane, temp_points, clipped_count, temp_points1);

 if (clipped_count == 0) return 0;

 // edge 2
 get_edge_plane(2, edgeplane);

 clipped_count = bt_plane_clip_polygon(
  edgeplane, temp_points1, clipped_count, clipped_points);

 return clipped_count;
}

bool btPrimitiveTriangle::find_triangle_collision_clip_method(btPrimitiveTriangle & other, GIM_TRIANGLE_CONTACT & contacts)
{
 btScalar margin = m_margin + other.m_margin;

 btVector3 clipped_points[MAX_TRI_CLIPPING];
 int clipped_count;
 //create planes
 // plane v vs U points

 GIM_TRIANGLE_CONTACT contacts1;

 contacts1.m_separating_normal = m_plane;


 clipped_count = clip_triangle(other, clipped_points);

 if (clipped_count == 0)
 {
  return false;//Reject
 }

 //find most deep interval face1
 contacts1.merge_points(contacts1.m_separating_normal, margin, clipped_points, clipped_count);
 if (contacts1.m_point_count == 0) return false; // too far
                                                 //Normal pointing to this triangle
 contacts1.m_separating_normal *= -1.f;


 //Clip tri1 by tri2 edges
 GIM_TRIANGLE_CONTACT contacts2;
 contacts2.m_separating_normal = other.m_plane;

 clipped_count = other.clip_triangle(*this, clipped_points);

 if (clipped_count == 0)
 {
  return false;//Reject
 }

 //find most deep interval face1
 contacts2.merge_points(contacts2.m_separating_normal, margin, clipped_points, clipped_count);
 if (contacts2.m_point_count == 0) return false; // too far




                                                 ////check most dir for contacts
 if (contacts2.m_penetration_depth<contacts1.m_penetration_depth)
 {
  contacts.copy_from(contacts2);
 }
 else
 {
  contacts.copy_from(contacts1);
 }
 return true;
}



///class btTriangleShapeEx: public btTriangleShape

bool btTriangleShapeEx::overlap_test_conservative(const btTriangleShapeEx& other)
{
 btScalar total_margin = getMargin() + other.getMargin();

 btVector4 plane0;
 buildTriPlane(plane0);
 btVector4 plane1;
 other.buildTriPlane(plane1);

 // classify points on other triangle
 btScalar dis0 = bt_distance_point_plane(plane0, other.m_vertices1[0]) - total_margin;

 btScalar dis1 = bt_distance_point_plane(plane0, other.m_vertices1[1]) - total_margin;

 btScalar dis2 = bt_distance_point_plane(plane0, other.m_vertices1[2]) - total_margin;

 if (dis0>0.0f&&dis1>0.0f&&dis2>0.0f) return false;

 // classify points on this triangle
 dis0 = bt_distance_point_plane(plane1, m_vertices1[0]) - total_margin;

 dis1 = bt_distance_point_plane(plane1, m_vertices1[1]) - total_margin;

 dis2 = bt_distance_point_plane(plane1, m_vertices1[2]) - total_margin;

 if (dis0>0.0f&&dis1>0.0f&&dis2>0.0f) return false;

 return true;
}



/*
-----------------------------------------------------------------------------
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
(1) The GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at
your option) any later version. The text of the GNU Lesser
General Public License is included with this library in the
file GIMPACT-LICENSE-LGPL.TXT.
(2) The BSD-style license that is included with this library in
the file GIMPACT-LICENSE-BSD.TXT.
(3) The zlib/libpng license that is included with this library in
the file GIMPACT-LICENSE-ZLIB.TXT.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.

-----------------------------------------------------------------------------
*/


//#define GUINT unsigned int

//#ifndef GIM_BOX_SET_H_INCLUDED
#define GIM_BOX_SET_H_INCLUDED

/*! \file gim_box_set.h
\author Francisco Leon Najera
*/
/*
-----------------------------------------------------------------------------
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
(1) The GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at
your option) any later version. The text of the GNU Lesser
General Public License is included with this library in the
file GIMPACT-LICENSE-LGPL.TXT.
(2) The BSD-style license that is included with this library in
the file GIMPACT-LICENSE-BSD.TXT.
(3) The zlib/libpng license that is included with this library in
the file GIMPACT-LICENSE-ZLIB.TXT.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.

-----------------------------------------------------------------------------
*/


#include "BulletCollision/Gimpact/gim_array.h"
#include "BulletCollision/Gimpact/gim_radixsort.h"
#include "BulletCollision/Gimpact/gim_box_collision.h"
#include "BulletCollision/Gimpact/gim_tri_collision.h"



//! Overlapping pair
struct GIM_PAIR2
{
 GUINT m_index1;
 GUINT m_index2;
 GIM_PAIR2()
 {}

 GIM_PAIR2(const GIM_PAIR2 & p)
 {
  m_index1 = p.m_index1;
  m_index2 = p.m_index2;
 }

 GIM_PAIR2(GUINT index1, GUINT index2)
 {
  m_index1 = index1;
  m_index2 = index2;
 }
};

//! A pairset array
class gim_pair_set : public gim_array<GIM_PAIR>
{
public:
 gim_pair_set() :gim_array<GIM_PAIR>(32)
 {
 }
 inline void push_pair(GUINT index1, GUINT index2)
 {
  push_back(GIM_PAIR(index1, index2));
 }

 inline void push_pair_inv(GUINT index1, GUINT index2)
 {
  push_back(GIM_PAIR(index2, index1));
 }
};


//! Prototype Base class for primitive classification
/*!
This class is a wrapper for primitive collections.
This tells relevant info for the Bounding Box set classes, which take care of space classification.
This class can manage Compound shapes and trimeshes, and if it is managing trimesh then the  Hierarchy Bounding Box classes will take advantage of primitive Vs Box overlapping tests for getting optimal results and less Per Box compairisons.
*/
class GIM_PRIMITIVE_MANAGER_PROTOTYPE
{
public:

 virtual ~GIM_PRIMITIVE_MANAGER_PROTOTYPE() {}
 //! determines if this manager consist on only triangles, which special case will be optimized
 virtual bool is_trimesh() = 0;
 virtual GUINT get_primitive_count() = 0;
 virtual void get_primitive_box(GUINT prim_index, GIM_AABB & primbox) = 0;
 virtual void get_primitive_triangle(GUINT prim_index, GIM_TRIANGLE & triangle) = 0;
};


struct GIM_AABB_DATA
{
 GIM_AABB m_bound;
 GUINT m_data;
};

//! Node Structure for trees
struct GIM_BOX_TREE_NODE
{
 GIM_AABB m_bound;
 GUINT m_left;//!< Left subtree
 GUINT m_right;//!< Right subtree
 GUINT m_escapeIndex;//!< Scape index for traversing
 GUINT m_data;//!< primitive index if apply

 GIM_BOX_TREE_NODE()
 {
  m_left = 0;
  m_right = 0;
  m_escapeIndex = 0;
  m_data = 0;
 }

 SIMD_FORCE_INLINE bool is_leaf_node() const
 {
  return  (!m_left && !m_right);
 }
};

//! Basic Box tree structure
class GIM_BOX_TREE
{
protected:
 GUINT m_num_nodes;
 gim_array<GIM_BOX_TREE_NODE> m_node_array;
protected:
 GUINT _sort_and_calc_splitting_index(
  gim_array<GIM_AABB_DATA> & primitive_boxes,
  GUINT startIndex, GUINT endIndex, GUINT splitAxis);

 GUINT _calc_splitting_axis(gim_array<GIM_AABB_DATA> & primitive_boxes, GUINT startIndex, GUINT endIndex);

 void _build_sub_tree(gim_array<GIM_AABB_DATA> & primitive_boxes, GUINT startIndex, GUINT endIndex);
public:
 GIM_BOX_TREE()
 {
  m_num_nodes = 0;
 }

 //! prototype functions for box tree management
 //!@{
 void build_tree(gim_array<GIM_AABB_DATA> & primitive_boxes);

 SIMD_FORCE_INLINE void clearNodes()
 {
  m_node_array.clear();
  m_num_nodes = 0;
 }

 //! node count
 SIMD_FORCE_INLINE GUINT getNodeCount() const
 {
  return m_num_nodes;
 }

 //! tells if the node is a leaf
 SIMD_FORCE_INLINE bool isLeafNode(GUINT nodeindex) const
 {
  return m_node_array[nodeindex].is_leaf_node();
 }

 SIMD_FORCE_INLINE GUINT getNodeData(GUINT nodeindex) const
 {
  return m_node_array[nodeindex].m_data;
 }

 SIMD_FORCE_INLINE void getNodeBound(GUINT nodeindex, GIM_AABB & bound) const
 {
  bound = m_node_array[nodeindex].m_bound;
 }

 SIMD_FORCE_INLINE void setNodeBound(GUINT nodeindex, const GIM_AABB & bound)
 {
  m_node_array[nodeindex].m_bound = bound;
 }

 SIMD_FORCE_INLINE GUINT getLeftNodeIndex(GUINT nodeindex)  const
 {
  return m_node_array[nodeindex].m_left;
 }

 SIMD_FORCE_INLINE GUINT getRightNodeIndex(GUINT nodeindex)  const
 {
  return m_node_array[nodeindex].m_right;
 }

 SIMD_FORCE_INLINE GUINT getScapeNodeIndex(GUINT nodeindex) const
 {
  return m_node_array[nodeindex].m_escapeIndex;
 }

 //!@}
};


//! Generic Box Tree Template
/*!
This class offers an structure for managing a box tree of primitives.
Requires a Primitive prototype (like GIM_PRIMITIVE_MANAGER_PROTOTYPE ) and
a Box tree structure ( like GIM_BOX_TREE).
*/
template<typename _GIM_PRIMITIVE_MANAGER_PROTOTYPE, typename _GIM_BOX_TREE_PROTOTYPE>
class GIM_BOX_TREE_TEMPLATE_SET
{
protected:
 _GIM_PRIMITIVE_MANAGER_PROTOTYPE m_primitive_manager;
 _GIM_BOX_TREE_PROTOTYPE m_box_tree;
protected:
 //stackless refit
 SIMD_FORCE_INLINE void refit()
 {
  GUINT nodecount = getNodeCount();
  while (nodecount--)
  {
   if (isLeafNode(nodecount))
   {
    GIM_AABB leafbox;
    m_primitive_manager.get_primitive_box(getNodeData(nodecount), leafbox);
    setNodeBound(nodecount, leafbox);
   }
   else
   {
    //get left bound
    GUINT childindex = getLeftNodeIndex(nodecount);
    GIM_AABB bound;
    getNodeBound(childindex, bound);
    //get right bound
    childindex = getRightNodeIndex(nodecount);
    GIM_AABB bound2;
    getNodeBound(childindex, bound2);
    bound.merge(bound2);

    setNodeBound(nodecount, bound);
   }
  }
 }
public:

 GIM_BOX_TREE_TEMPLATE_SET()
 {
 }

 SIMD_FORCE_INLINE GIM_AABB getGlobalBox()  const
 {
  GIM_AABB totalbox;
  getNodeBound(0, totalbox);
  return totalbox;
 }

 SIMD_FORCE_INLINE void setPrimitiveManager(const _GIM_PRIMITIVE_MANAGER_PROTOTYPE & primitive_manager)
 {
  m_primitive_manager = primitive_manager;
 }

 const _GIM_PRIMITIVE_MANAGER_PROTOTYPE & getPrimitiveManager() const
 {
  return m_primitive_manager;
 }

 _GIM_PRIMITIVE_MANAGER_PROTOTYPE & getPrimitiveManager()
 {
  return m_primitive_manager;
 }

 //! node manager prototype functions
 ///@{

 //! this attemps to refit the box set.
 SIMD_FORCE_INLINE void update()
 {
  refit();
 }

 //! this rebuild the entire set
 SIMD_FORCE_INLINE void buildSet()
 {
  //obtain primitive boxes
  gim_array<GIM_AABB_DATA> primitive_boxes;
  primitive_boxes.resize(m_primitive_manager.get_primitive_count(), false);

  for (GUINT i = 0; i<primitive_boxes.size(); i++)
  {
   m_primitive_manager.get_primitive_box(i, primitive_boxes[i].m_bound);
   primitive_boxes[i].m_data = i;
  }

  m_box_tree.build_tree(primitive_boxes);
 }

 //! returns the indices of the primitives in the m_primitive_manager
 SIMD_FORCE_INLINE bool boxQuery(const GIM_AABB & box, gim_array<GUINT> & collided_results) const
 {
  GUINT curIndex = 0;
  GUINT numNodes = getNodeCount();

  while (curIndex < numNodes)
  {
   GIM_AABB bound;
   getNodeBound(curIndex, bound);

   //catch bugs in tree data

   bool aabbOverlap = bound.has_collision(box);
   bool isleafnode = isLeafNode(curIndex);

   if (isleafnode && aabbOverlap)
   {
    collided_results.push_back(getNodeData(curIndex));
   }

   if (aabbOverlap || isleafnode)
   {
    //next subnode
    curIndex++;
   }
   else
   {
    //skip node
    curIndex += getScapeNodeIndex(curIndex);
   }
  }
  if (collided_results.size()>0) return true;
  return false;
 }

 //! returns the indices of the primitives in the m_primitive_manager
 SIMD_FORCE_INLINE bool boxQueryTrans(const GIM_AABB & box,
  const btTransform & transform, gim_array<GUINT> & collided_results) const
 {
  GIM_AABB transbox = box;
  transbox.appy_transform(transform);
  return boxQuery(transbox, collided_results);
 }

 //! returns the indices of the primitives in the m_primitive_manager
 SIMD_FORCE_INLINE bool rayQuery(
  const btVector3 & ray_dir, const btVector3 & ray_origin,
  gim_array<GUINT> & collided_results) const
 {
  GUINT curIndex = 0;
  GUINT numNodes = getNodeCount();

  while (curIndex < numNodes)
  {
   GIM_AABB bound;
   getNodeBound(curIndex, bound);

   //catch bugs in tree data

   bool aabbOverlap = bound.collide_ray(ray_origin, ray_dir);
   bool isleafnode = isLeafNode(curIndex);

   if (isleafnode && aabbOverlap)
   {
    collided_results.push_back(getNodeData(curIndex));
   }

   if (aabbOverlap || isleafnode)
   {
    //next subnode
    curIndex++;
   }
   else
   {
    //skip node
    curIndex += getScapeNodeIndex(curIndex);
   }
  }
  if (collided_results.size()>0) return true;
  return false;
 }

 //! tells if this set has hierarcht
 SIMD_FORCE_INLINE bool hasHierarchy() const
 {
  return true;
 }

 //! tells if this set is a trimesh
 SIMD_FORCE_INLINE bool isTrimesh()  const
 {
  return m_primitive_manager.is_trimesh();
 }

 //! node count
 SIMD_FORCE_INLINE GUINT getNodeCount() const
 {
  return m_box_tree.getNodeCount();
 }

 //! tells if the node is a leaf
 SIMD_FORCE_INLINE bool isLeafNode(GUINT nodeindex) const
 {
  return m_box_tree.isLeafNode(nodeindex);
 }

 SIMD_FORCE_INLINE GUINT getNodeData(GUINT nodeindex) const
 {
  return m_box_tree.getNodeData(nodeindex);
 }

 SIMD_FORCE_INLINE void getNodeBound(GUINT nodeindex, GIM_AABB & bound)  const
 {
  m_box_tree.getNodeBound(nodeindex, bound);
 }

 SIMD_FORCE_INLINE void setNodeBound(GUINT nodeindex, const GIM_AABB & bound)
 {
  m_box_tree.setNodeBound(nodeindex, bound);
 }

 SIMD_FORCE_INLINE GUINT getLeftNodeIndex(GUINT nodeindex) const
 {
  return m_box_tree.getLeftNodeIndex(nodeindex);
 }

 SIMD_FORCE_INLINE GUINT getRightNodeIndex(GUINT nodeindex) const
 {
  return m_box_tree.getRightNodeIndex(nodeindex);
 }

 SIMD_FORCE_INLINE GUINT getScapeNodeIndex(GUINT nodeindex) const
 {
  return m_box_tree.getScapeNodeIndex(nodeindex);
 }

 SIMD_FORCE_INLINE void getNodeTriangle(GUINT nodeindex, GIM_TRIANGLE & triangle) const
 {
  m_primitive_manager.get_primitive_triangle(getNodeData(nodeindex), triangle);
 }

};

//! Class for Box Tree Sets
/*!
this has the GIM_BOX_TREE implementation for bounding boxes.
*/
template<typename _GIM_PRIMITIVE_MANAGER_PROTOTYPE>
class GIM_BOX_TREE_SET : public GIM_BOX_TREE_TEMPLATE_SET< _GIM_PRIMITIVE_MANAGER_PROTOTYPE, GIM_BOX_TREE>
{
public:

};





/// GIM_BOX_SET collision methods
template<typename BOX_SET_CLASS0, typename BOX_SET_CLASS1>
class GIM_TREE_TREE_COLLIDER
{
public:
 gim_pair_set * m_collision_pairs;
 BOX_SET_CLASS0 * m_boxset0;
 BOX_SET_CLASS1 * m_boxset1;
 GUINT current_node0;
 GUINT current_node1;
 bool node0_is_leaf;
 bool node1_is_leaf;
 bool t0_is_trimesh;
 bool t1_is_trimesh;
 bool node0_has_triangle;
 bool node1_has_triangle;
 GIM_AABB m_box0;
 GIM_AABB m_box1;
 GIM_BOX_BOX_TRANSFORM_CACHE trans_cache_1to0;
 btTransform trans_cache_0to1;
 GIM_TRIANGLE m_tri0;
 btVector4 m_tri0_plane;
 GIM_TRIANGLE m_tri1;
 btVector4 m_tri1_plane;


public:
 GIM_TREE_TREE_COLLIDER()
 {
  current_node0 = G_UINT_INFINITY;
  current_node1 = G_UINT_INFINITY;
 }
protected:
 SIMD_FORCE_INLINE void retrieve_node0_triangle(GUINT node0)
 {
  if (node0_has_triangle) return;
  m_boxset0->getNodeTriangle(node0, m_tri0);
  //transform triangle
  m_tri0.m_vertices[0] = trans_cache_0to1(m_tri0.m_vertices[0]);
  m_tri0.m_vertices[1] = trans_cache_0to1(m_tri0.m_vertices[1]);
  m_tri0.m_vertices[2] = trans_cache_0to1(m_tri0.m_vertices[2]);
  m_tri0.get_plane(m_tri0_plane);

  node0_has_triangle = true;
 }

 SIMD_FORCE_INLINE void retrieve_node1_triangle(GUINT node1)
 {
  if (node1_has_triangle) return;
  m_boxset1->getNodeTriangle(node1, m_tri1);
  //transform triangle
  m_tri1.m_vertices[0] = trans_cache_1to0.transform(m_tri1.m_vertices[0]);
  m_tri1.m_vertices[1] = trans_cache_1to0.transform(m_tri1.m_vertices[1]);
  m_tri1.m_vertices[2] = trans_cache_1to0.transform(m_tri1.m_vertices[2]);
  m_tri1.get_plane(m_tri1_plane);

  node1_has_triangle = true;
 }

 SIMD_FORCE_INLINE void retrieve_node0_info(GUINT node0)
 {
  if (node0 == current_node0) return;
  m_boxset0->getNodeBound(node0, m_box0);
  node0_is_leaf = m_boxset0->isLeafNode(node0);
  node0_has_triangle = false;
  current_node0 = node0;
 }

 SIMD_FORCE_INLINE void retrieve_node1_info(GUINT node1)
 {
  if (node1 == current_node1) return;
  m_boxset1->getNodeBound(node1, m_box1);
  node1_is_leaf = m_boxset1->isLeafNode(node1);
  node1_has_triangle = false;
  current_node1 = node1;
 }

 SIMD_FORCE_INLINE bool node_collision(GUINT node0, GUINT node1)
 {
  retrieve_node0_info(node0);
  retrieve_node1_info(node1);
  bool result = m_box0.overlapping_trans_cache(m_box1, trans_cache_1to0, true);
  if (!result) return false;

  if (t0_is_trimesh && node0_is_leaf)
  {
   //perform primitive vs box collision
   retrieve_node0_triangle(node0);
   //do triangle vs box collision
   m_box1.increment_margin(m_tri0.m_margin);

   result = m_box1.collide_triangle_exact(
    m_tri0.m_vertices[0], m_tri0.m_vertices[1], m_tri0.m_vertices[2], m_tri0_plane);

   m_box1.increment_margin(-m_tri0.m_margin);

   if (!result) return false;
   return true;
  }
  else if (t1_is_trimesh && node1_is_leaf)
  {
   //perform primitive vs box collision
   retrieve_node1_triangle(node1);
   //do triangle vs box collision
   m_box0.increment_margin(m_tri1.m_margin);

   result = m_box0.collide_triangle_exact(
    m_tri1.m_vertices[0], m_tri1.m_vertices[1], m_tri1.m_vertices[2], m_tri1_plane);

   m_box0.increment_margin(-m_tri1.m_margin);

   if (!result) return false;
   return true;
  }
  return true;
 }

 //stackless collision routine
 void find_collision_pairs()
 {
  gim_pair_set stack_collisions;
  stack_collisions.reserve(32);

  //add the first pair
  stack_collisions.push_pair(0, 0);


  while (stack_collisions.size())
  {
   //retrieve the last pair and pop
   GUINT node0 = stack_collisions.back().m_index1;
   GUINT node1 = stack_collisions.back().m_index2;
   stack_collisions.pop_back();
   if (node_collision(node0, node1)) // a collision is found
   {
    if (node0_is_leaf)
    {
     if (node1_is_leaf)
     {
      m_collision_pairs->push_pair(m_boxset0->getNodeData(node0), m_boxset1->getNodeData(node1));
     }
     else
     {
      //collide left
      stack_collisions.push_pair(node0, m_boxset1->getLeftNodeIndex(node1));

      //collide right
      stack_collisions.push_pair(node0, m_boxset1->getRightNodeIndex(node1));
     }
    }
    else
    {
     if (node1_is_leaf)
     {
      //collide left
      stack_collisions.push_pair(m_boxset0->getLeftNodeIndex(node0), node1);
      //collide right
      stack_collisions.push_pair(m_boxset0->getRightNodeIndex(node0), node1);
     }
     else
     {
      GUINT left0 = m_boxset0->getLeftNodeIndex(node0);
      GUINT right0 = m_boxset0->getRightNodeIndex(node0);
      GUINT left1 = m_boxset1->getLeftNodeIndex(node1);
      GUINT right1 = m_boxset1->getRightNodeIndex(node1);
      //collide left
      stack_collisions.push_pair(left0, left1);
      //collide right
      stack_collisions.push_pair(left0, right1);
      //collide left
      stack_collisions.push_pair(right0, left1);
      //collide right
      stack_collisions.push_pair(right0, right1);

     }// else if node1 is not a leaf
    }// else if node0 is not a leaf

   }// if(node_collision(node0,node1))
  }//while(stack_collisions.size())
 }
public:
 void find_collision(BOX_SET_CLASS0 * boxset1, const btTransform & trans1,
  BOX_SET_CLASS1 * boxset2, const btTransform & trans2,
  gim_pair_set & collision_pairs, bool complete_primitive_tests = true)
 {
  m_collision_pairs = &collision_pairs;
  m_boxset0 = boxset1;
  m_boxset1 = boxset2;

  trans_cache_1to0.calc_from_homogenic(trans1, trans2);

  trans_cache_0to1 = trans2.inverse();
  trans_cache_0to1 *= trans1;


  if (complete_primitive_tests)
  {
   t0_is_trimesh = boxset1->getPrimitiveManager().is_trimesh();
   t1_is_trimesh = boxset2->getPrimitiveManager().is_trimesh();
  }
  else
  {
   t0_is_trimesh = false;
   t1_is_trimesh = false;
  }

  find_collision_pairs();
 }
};


//#endif // GIM_BOXPRUNING_H_INCLUDED




GUINT GIM_BOX_TREE::_calc_splitting_axis(
 gim_array<GIM_AABB_DATA> & primitive_boxes, GUINT startIndex, GUINT endIndex)
{
 GUINT i;

 btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
 btVector3 variance(btScalar(0.), btScalar(0.), btScalar(0.));
 GUINT numIndices = endIndex - startIndex;

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  means += center;
 }
 means *= (btScalar(1.) / (btScalar)numIndices);

 for (i = startIndex; i<endIndex; i++)
 {
  btVector3 center = btScalar(0.5)*(primitive_boxes[i].m_bound.m_max +
   primitive_boxes[i].m_bound.m_min);
  btVector3 diff2 = center - means;
  diff2 = diff2 * diff2;
  variance += diff2;
 }
 variance *= (btScalar(1.) / ((btScalar)numIndices - 1));

 return variance.maxAxis();
}


GUINT GIM_BOX_TREE::_sort_and_calc_splitting_index(
 gim_array<GIM_AABB_DATA> & primitive_boxes, GUINT startIndex,
 GUINT endIndex, GUINT splitAxis)
{
 GUINT i;
 GUINT splitIndex = startIndex;
 GUINT numIndices = endIndex - startIndex;

 // average of centers
 btScalar splitValue = 0.0f;
 for (i = startIndex; i<endIndex; i++)
 {
  splitValue += 0.5f*(primitive_boxes[i].m_bound.m_max[splitAxis] +
   primitive_boxes[i].m_bound.m_min[splitAxis]);
 }
 splitValue /= (btScalar)numIndices;

 //sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
 for (i = startIndex; i<endIndex; i++)
 {
  btScalar center = 0.5f*(primitive_boxes[i].m_bound.m_max[splitAxis] +
   primitive_boxes[i].m_bound.m_min[splitAxis]);
  if (center > splitValue)
  {
   //swap
   primitive_boxes.swap(i, splitIndex);
   splitIndex++;
  }
 }

 //if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
 //otherwise the tree-building might fail due to stack-overflows in certain cases.
 //unbalanced1 is unsafe: it can cause stack overflows
 //bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));

 //unbalanced2 should work too: always use center (perfect balanced trees)
 //bool unbalanced2 = true;

 //this should be safe too:
 GUINT rangeBalancedIndices = numIndices / 3;
 bool unbalanced = ((splitIndex <= (startIndex + rangeBalancedIndices)) || (splitIndex >= (endIndex - 1 - rangeBalancedIndices)));

 if (unbalanced)
 {
  splitIndex = startIndex + (numIndices >> 1);
 }

 btAssert(!((splitIndex == startIndex) || (splitIndex == (endIndex))));

 return splitIndex;
}


void GIM_BOX_TREE::_build_sub_tree(gim_array<GIM_AABB_DATA> & primitive_boxes, GUINT startIndex, GUINT endIndex)
{
 GUINT current_index = m_num_nodes++;

 btAssert((endIndex - startIndex)>0);

 if ((endIndex - startIndex) == 1) //we got a leaf
 {
  m_node_array[current_index].m_left = 0;
  m_node_array[current_index].m_right = 0;
  m_node_array[current_index].m_escapeIndex = 0;

  m_node_array[current_index].m_bound = primitive_boxes[startIndex].m_bound;
  m_node_array[current_index].m_data = primitive_boxes[startIndex].m_data;
  return;
 }

 //configure inner node

 GUINT splitIndex;

 //calc this node bounding box
 m_node_array[current_index].m_bound.invalidate();
 for (splitIndex = startIndex; splitIndex<endIndex; splitIndex++)
 {
  m_node_array[current_index].m_bound.merge(primitive_boxes[splitIndex].m_bound);
 }

 //calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.

 //split axis
 splitIndex = _calc_splitting_axis(primitive_boxes, startIndex, endIndex);

 splitIndex = _sort_and_calc_splitting_index(
  primitive_boxes, startIndex, endIndex, splitIndex);

 //configure this inner node : the left node index
 m_node_array[current_index].m_left = m_num_nodes;
 //build left child tree
 _build_sub_tree(primitive_boxes, startIndex, splitIndex);

 //configure this inner node : the right node index
 m_node_array[current_index].m_right = m_num_nodes;

 //build right child tree
 _build_sub_tree(primitive_boxes, splitIndex, endIndex);

 //configure this inner node : the escape index
 m_node_array[current_index].m_escapeIndex = m_num_nodes - current_index;
}

//! stackless build tree
void GIM_BOX_TREE::build_tree(
 gim_array<GIM_AABB_DATA> & primitive_boxes)
{
 // initialize node count to 0
 m_num_nodes = 0;
 // allocate nodes
 m_node_array.resize(primitive_boxes.size() * 2);

 _build_sub_tree(primitive_boxes, 0, primitive_boxes.size());
}



/*
-----------------------------------------------------------------------------
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
(1) The GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at
your option) any later version. The text of the GNU Lesser
General Public License is included with this library in the
file GIMPACT-LICENSE-LGPL.TXT.
(2) The BSD-style license that is included with this library in
the file GIMPACT-LICENSE-BSD.TXT.
(3) The zlib/libpng license that is included with this library in
the file GIMPACT-LICENSE-ZLIB.TXT.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.

-----------------------------------------------------------------------------
*/

#include "BulletCollision/Gimpact/gim_contact.h"

#define MAX_COINCIDENT 8

void gim_contact_array::merge_contacts(
 const gim_contact_array & contacts, bool normal_contact_average)
{
 clear();

 if (contacts.size() == 1)
 {
  push_back(contacts.back());
  return;
 }

 gim_array<GIM_RSORT_TOKEN> keycontacts(contacts.size());
 keycontacts.resize(contacts.size(), false);

 //fill key contacts

 GUINT i;

 for (i = 0; i<contacts.size(); i++)
 {
  keycontacts[i].m_key = contacts[i].calc_key_contact();
  keycontacts[i].m_value = i;
 }

 //sort keys
 gim_heap_sort(keycontacts.pointer(), keycontacts.size(), GIM_RSORT_TOKEN_COMPARATOR());

 // Merge contacts

 GUINT coincident_count = 0;
 btVector3 coincident_normals[MAX_COINCIDENT];

 GUINT last_key = keycontacts[0].m_key;
 GUINT key = 0;

 push_back(contacts[keycontacts[0].m_value]);
 GIM_CONTACT * pcontact = &back();



 for (i = 1; i<keycontacts.size(); i++)
 {
  key = keycontacts[i].m_key;
  const GIM_CONTACT * scontact = &contacts[keycontacts[i].m_value];

  if (last_key == key)//same points
  {
   //merge contact
   if (pcontact->m_depth - CONTACT_DIFF_EPSILON > scontact->m_depth)//)
   {
    *pcontact = *scontact;
    coincident_count = 0;
   }
   else if (normal_contact_average)
   {
    if (btFabs(pcontact->m_depth - scontact->m_depth)<CONTACT_DIFF_EPSILON)
    {
     if (coincident_count<MAX_COINCIDENT)
     {
      coincident_normals[coincident_count] = scontact->m_normal;
      coincident_count++;
     }
    }
   }
  }
  else
  {//add new contact

   if (normal_contact_average && coincident_count>0)
   {
    pcontact->interpolate_normals(coincident_normals, coincident_count);
    coincident_count = 0;
   }

   push_back(*scontact);
   pcontact = &back();
  }
  last_key = key;
 }
}

void gim_contact_array::merge_contacts_unique(const gim_contact_array & contacts)
{
 clear();

 if (contacts.size() == 1)
 {
  push_back(contacts.back());
  return;
 }

 GIM_CONTACT average_contact = contacts.back();

 for (GUINT i = 1; i<contacts.size(); i++)
 {
  average_contact.m_point += contacts[i].m_point;
  average_contact.m_normal += contacts[i].m_normal * contacts[i].m_depth;
 }

 //divide
 GREAL divide_average = 1.0f / ((GREAL)contacts.size());

 average_contact.m_point *= divide_average;

 average_contact.m_normal *= divide_average;

 average_contact.m_depth = average_contact.m_normal.length();

 average_contact.m_normal /= average_contact.m_depth;

}

/*
-----------------------------------------------------------------------------
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
(1) The GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at
your option) any later version. The text of the GNU Lesser
General Public License is included with this library in the
file GIMPACT-LICENSE-LGPL.TXT.
(2) The BSD-style license that is included with this library in
the file GIMPACT-LICENSE-BSD.TXT.
(3) The zlib/libpng license that is included with this library in
the file GIMPACT-LICENSE-ZLIB.TXT.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.

-----------------------------------------------------------------------------
*/


#include "BulletCollision/Gimpact/gim_memory.h"
#include "stdlib.h"

#ifdef GIM_SIMD_MEMORY
#include "LinearMath/btAlignedAllocator.h"
#endif

static gim_alloc_function *g_allocfn = 0;
static gim_alloca_function *g_allocafn = 0;
static gim_realloc_function *g_reallocfn = 0;
static gim_free_function *g_freefn = 0;

void gim_set_alloc_handler(gim_alloc_function *fn)
{
 g_allocfn = fn;
}

void gim_set_alloca_handler(gim_alloca_function *fn)
{
 g_allocafn = fn;
}

void gim_set_realloc_handler(gim_realloc_function *fn)
{
 g_reallocfn = fn;
}

void gim_set_free_handler(gim_free_function *fn)
{
 g_freefn = fn;
}

gim_alloc_function *gim_get_alloc_handler()
{
 return g_allocfn;
}

gim_alloca_function *gim_get_alloca_handler()
{
 return g_allocafn;
}


gim_realloc_function *gim_get_realloc_handler()
{
 return g_reallocfn;
}


gim_free_function  *gim_get_free_handler()
{
 return g_freefn;
}


void * gim_alloc(size_t size)
{
 void * ptr;
 if (g_allocfn)
 {
  ptr = g_allocfn(size);
 }
 else
 {
#ifdef GIM_SIMD_MEMORY
  ptr = btAlignedAlloc(size, 16);
#else
  ptr = malloc(size);
#endif
 }
 return ptr;
}

void * gim_alloca(size_t size)
{
 if (g_allocafn) return g_allocafn(size); else return gim_alloc(size);
}


void * gim_realloc(void *ptr, size_t oldsize, size_t newsize)
{
 void * newptr = gim_alloc(newsize);
 size_t copysize = oldsize<newsize ? oldsize : newsize;
 gim_simd_memcpy(newptr, ptr, copysize);
 gim_free(ptr);
 return newptr;
}

void gim_free(void *ptr)
{
 if (!ptr) return;
 if (g_freefn)
 {
  g_freefn(ptr);
 }
 else
 {
#ifdef GIM_SIMD_MEMORY
  btAlignedFree(ptr);
#else
  free(ptr);
#endif
 }
}


/*! \file gim_tri_collision.h
\author Francisco Leon Najera
*/
/*
-----------------------------------------------------------------------------
This source file is part of GIMPACT Library.

For the latest info, see http://gimpact.sourceforge.net/

Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371.
email: projectileman@yahoo.com

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
(1) The GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at
your option) any later version. The text of the GNU Lesser
General Public License is included with this library in the
file GIMPACT-LICENSE-LGPL.TXT.
(2) The BSD-style license that is included with this library in
the file GIMPACT-LICENSE-BSD.TXT.
(3) The zlib/libpng license that is included with this library in
the file GIMPACT-LICENSE-ZLIB.TXT.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.

-----------------------------------------------------------------------------
*/

#include "BulletCollision/Gimpact/gim_tri_collision.h"


#define TRI_LOCAL_EPSILON 0.000001f
#define MIN_EDGE_EDGE_DIS 0.00001f


class GIM_TRIANGLE_CALCULATION_CACHE
{
public:
 GREAL margin;
 btVector3 tu_vertices[3];
 btVector3 tv_vertices[3];
 btVector4 tu_plane;
 btVector4 tv_plane;
 btVector3 closest_point_u;
 btVector3 closest_point_v;
 btVector3 edge_edge_dir;
 btVector3 distances;
 GREAL du[4];
 GREAL du0du1;
 GREAL du0du2;
 GREAL dv[4];
 GREAL dv0dv1;
 GREAL dv0dv2;
 btVector3 temp_points[MAX_TRI_CLIPPING];
 btVector3 temp_points1[MAX_TRI_CLIPPING];
 btVector3 contact_points[MAX_TRI_CLIPPING];



 //! if returns false, the faces are paralele
 SIMD_FORCE_INLINE bool compute_intervals(
  const GREAL &D0,
  const GREAL &D1,
  const GREAL &D2,
  const GREAL &D0D1,
  const GREAL &D0D2,
  GREAL & scale_edge0,
  GREAL & scale_edge1,
  GUINT &edge_index0,
  GUINT &edge_index1)
 {
  if (D0D1>0.0f)
  {
   /* here we know that D0D2<=0.0 */
   /* that is D0, D1 are on the same side, D2 on the other or on the plane */
   scale_edge0 = -D2 / (D0 - D2);
   scale_edge1 = -D1 / (D2 - D1);
   edge_index0 = 2; edge_index1 = 1;
  }
  else if (D0D2>0.0f)
  {
   /* here we know that d0d1<=0.0 */
   scale_edge0 = -D0 / (D1 - D0);
   scale_edge1 = -D1 / (D2 - D1);
   edge_index0 = 0; edge_index1 = 1;
  }
  else if (D1*D2>0.0f || D0 != 0.0f)
  {
   /* here we know that d0d1<=0.0 or that D0!=0.0 */
   scale_edge0 = -D0 / (D1 - D0);
   scale_edge1 = -D2 / (D0 - D2);
   edge_index0 = 0; edge_index1 = 2;
  }
  else
  {
   return false;
  }
  return true;
 }


 //! clip triangle
 /*!
 */
 SIMD_FORCE_INLINE GUINT clip_triangle(
  const btVector4 & tri_plane,
  const btVector3 * tripoints,
  const btVector3 * srcpoints,
  btVector3 * clip_points)
 {
  // edge 0

  btVector4 edgeplane;

  EDGE_PLANE(tripoints[0], tripoints[1], tri_plane, edgeplane);

  GUINT clipped_count = PLANE_CLIP_TRIANGLE3D(
   edgeplane, srcpoints[0], srcpoints[1], srcpoints[2], temp_points);

  if (clipped_count == 0) return 0;

  // edge 1

  EDGE_PLANE(tripoints[1], tripoints[2], tri_plane, edgeplane);

  clipped_count = PLANE_CLIP_POLYGON3D(
   edgeplane, temp_points, clipped_count, temp_points1);

  if (clipped_count == 0) return 0;

  // edge 2

  EDGE_PLANE(tripoints[2], tripoints[0], tri_plane, edgeplane);

  clipped_count = PLANE_CLIP_POLYGON3D(
   edgeplane, temp_points1, clipped_count, clip_points);

  return clipped_count;


  /*GUINT i0 = (tri_plane.closestAxis()+1)%3;
  GUINT i1 = (i0+1)%3;
  // edge 0
  btVector3 temp_points[MAX_TRI_CLIPPING];
  btVector3 temp_points1[MAX_TRI_CLIPPING];

  GUINT clipped_count= PLANE_CLIP_TRIANGLE_GENERIC(
  0,srcpoints[0],srcpoints[1],srcpoints[2],temp_points,
  DISTANCE_EDGE(tripoints[0],tripoints[1],i0,i1));


  if(clipped_count == 0) return 0;

  // edge 1
  clipped_count = PLANE_CLIP_POLYGON_GENERIC(
  0,temp_points,clipped_count,temp_points1,
  DISTANCE_EDGE(tripoints[1],tripoints[2],i0,i1));

  if(clipped_count == 0) return 0;

  // edge 2
  clipped_count = PLANE_CLIP_POLYGON_GENERIC(
  0,temp_points1,clipped_count,clipped_points,
  DISTANCE_EDGE(tripoints[2],tripoints[0],i0,i1));

  return clipped_count;*/
 }

 SIMD_FORCE_INLINE void sort_isect(
  GREAL & isect0, GREAL & isect1, GUINT &e0, GUINT &e1, btVector3 & vec0, btVector3 & vec1)
 {
  if (isect1<isect0)
  {
   //swap
   GIM_SWAP_NUMBERS(isect0, isect1);
   GIM_SWAP_NUMBERS(e0, e1);
   btVector3 tmp = vec0;
   vec0 = vec1;
   vec1 = tmp;
  }
 }

 //! Test verifying interval intersection with the direction between planes
 /*!
 \pre tv_plane and tu_plane must be set
 \post
 distances[2] is set with the distance
 closest_point_u, closest_point_v, edge_edge_dir are set too
 \return
 - 0: faces are paralele
 - 1: face U casts face V
 - 2: face V casts face U
 - 3: nearest edges
 */
 SIMD_FORCE_INLINE GUINT cross_line_intersection_test()
 {
  // Compute direction of intersection line
  edge_edge_dir = tu_plane.cross(tv_plane);
  GREAL Dlen;
  VEC_LENGTH(edge_edge_dir, Dlen);

  if (Dlen<0.0001)
  {
   return 0; //faces near paralele
  }

  edge_edge_dir *= 1 / Dlen;//normalize


                            // Compute interval for triangle 1
  GUINT tu_e0, tu_e1;//edge indices
  GREAL tu_scale_e0, tu_scale_e1;//edge scale
  if (!compute_intervals(du[0], du[1], du[2],
   du0du1, du0du2, tu_scale_e0, tu_scale_e1, tu_e0, tu_e1)) return 0;

  // Compute interval for triangle 2
  GUINT tv_e0, tv_e1;//edge indices
  GREAL tv_scale_e0, tv_scale_e1;//edge scale

  if (!compute_intervals(dv[0], dv[1], dv[2],
   dv0dv1, dv0dv2, tv_scale_e0, tv_scale_e1, tv_e0, tv_e1)) return 0;

  //proyected vertices
  btVector3 up_e0 = tu_vertices[tu_e0].lerp(tu_vertices[(tu_e0 + 1) % 3], tu_scale_e0);
  btVector3 up_e1 = tu_vertices[tu_e1].lerp(tu_vertices[(tu_e1 + 1) % 3], tu_scale_e1);

  btVector3 vp_e0 = tv_vertices[tv_e0].lerp(tv_vertices[(tv_e0 + 1) % 3], tv_scale_e0);
  btVector3 vp_e1 = tv_vertices[tv_e1].lerp(tv_vertices[(tv_e1 + 1) % 3], tv_scale_e1);

  //proyected intervals
  GREAL isect_u[] = { up_e0.dot(edge_edge_dir),up_e1.dot(edge_edge_dir) };
  GREAL isect_v[] = { vp_e0.dot(edge_edge_dir),vp_e1.dot(edge_edge_dir) };

  sort_isect(isect_u[0], isect_u[1], tu_e0, tu_e1, up_e0, up_e1);
  sort_isect(isect_v[0], isect_v[1], tv_e0, tv_e1, vp_e0, vp_e1);

  const GREAL midpoint_u = 0.5f*(isect_u[0] + isect_u[1]); // midpoint
  const GREAL midpoint_v = 0.5f*(isect_v[0] + isect_v[1]); // midpoint

  if (midpoint_u<midpoint_v)
  {
   if (isect_u[1] >= isect_v[1]) // face U casts face V
   {
    return 1;
   }
   else if (isect_v[0] <= isect_u[0]) // face V casts face U
   {
    return 2;
   }
   // closest points
   closest_point_u = up_e1;
   closest_point_v = vp_e0;
   // calc edges and separation

   if (isect_u[1] + MIN_EDGE_EDGE_DIS<isect_v[0]) //calc distance between two lines instead
   {
    SEGMENT_COLLISION(
     tu_vertices[tu_e1], tu_vertices[(tu_e1 + 1) % 3],
     tv_vertices[tv_e0], tv_vertices[(tv_e0 + 1) % 3],
     closest_point_u,
     closest_point_v);

    edge_edge_dir = closest_point_u - closest_point_v;
    VEC_LENGTH(edge_edge_dir, distances[2]);
    edge_edge_dir *= 1.0f / distances[2];// normalize
   }
   else
   {
    distances[2] = isect_v[0] - isect_u[1];//distance negative
                                           //edge_edge_dir *= -1.0f; //normal pointing from V to U
   }

  }
  else
  {
   if (isect_v[1] >= isect_u[1]) // face V casts face U
   {
    return 2;
   }
   else if (isect_u[0] <= isect_v[0]) // face U casts face V
   {
    return 1;
   }
   // closest points
   closest_point_u = up_e0;
   closest_point_v = vp_e1;
   // calc edges and separation

   if (isect_v[1] + MIN_EDGE_EDGE_DIS<isect_u[0]) //calc distance between two lines instead
   {
    SEGMENT_COLLISION(
     tu_vertices[tu_e0], tu_vertices[(tu_e0 + 1) % 3],
     tv_vertices[tv_e1], tv_vertices[(tv_e1 + 1) % 3],
     closest_point_u,
     closest_point_v);

    edge_edge_dir = closest_point_u - closest_point_v;
    VEC_LENGTH(edge_edge_dir, distances[2]);
    edge_edge_dir *= 1.0f / distances[2];// normalize
   }
   else
   {
    distances[2] = isect_u[0] - isect_v[1];//distance negative
                                           //edge_edge_dir *= -1.0f; //normal pointing from V to U
   }
  }
  return 3;
 }


 //! collides by two sides
 SIMD_FORCE_INLINE bool triangle_collision(
  const btVector3 & u0,
  const btVector3 & u1,
  const btVector3 & u2,
  GREAL margin_u,
  const btVector3 & v0,
  const btVector3 & v1,
  const btVector3 & v2,
  GREAL margin_v,
  GIM_TRIANGLE_CONTACT_DATA & contacts)
 {

  margin = margin_u + margin_v;

  tu_vertices[0] = u0;
  tu_vertices[1] = u1;
  tu_vertices[2] = u2;

  tv_vertices[0] = v0;
  tv_vertices[1] = v1;
  tv_vertices[2] = v2;

  //create planes
  // plane v vs U points

  TRIANGLE_PLANE(tv_vertices[0], tv_vertices[1], tv_vertices[2], tv_plane);

  du[0] = DISTANCE_PLANE_POINT(tv_plane, tu_vertices[0]);
  du[1] = DISTANCE_PLANE_POINT(tv_plane, tu_vertices[1]);
  du[2] = DISTANCE_PLANE_POINT(tv_plane, tu_vertices[2]);


  du0du1 = du[0] * du[1];
  du0du2 = du[0] * du[2];


  if (du0du1>0.0f && du0du2>0.0f)	// same sign on all of them + not equal 0 ?
  {
   if (du[0]<0) //we need test behind the triangle plane
   {
    distances[0] = GIM_MAX3(du[0], du[1], du[2]);
    distances[0] = -distances[0];
    if (distances[0]>margin) return false; //never intersect

                                           //reorder triangle v
    VEC_SWAP(tv_vertices[0], tv_vertices[1]);
    VEC_SCALE_4(tv_plane, -1.0f, tv_plane);
   }
   else
   {
    distances[0] = GIM_MIN3(du[0], du[1], du[2]);
    if (distances[0]>margin) return false; //never intersect
   }
  }
  else
  {
   //Look if we need to invert the triangle
   distances[0] = (du[0] + du[1] + du[2]) / 3.0f; //centroid

   if (distances[0]<0.0f)
   {
    //reorder triangle v
    VEC_SWAP(tv_vertices[0], tv_vertices[1]);
    VEC_SCALE_4(tv_plane, -1.0f, tv_plane);

    distances[0] = GIM_MAX3(du[0], du[1], du[2]);
    distances[0] = -distances[0];
   }
   else
   {
    distances[0] = GIM_MIN3(du[0], du[1], du[2]);
   }
  }


  // plane U vs V points

  TRIANGLE_PLANE(tu_vertices[0], tu_vertices[1], tu_vertices[2], tu_plane);

  dv[0] = DISTANCE_PLANE_POINT(tu_plane, tv_vertices[0]);
  dv[1] = DISTANCE_PLANE_POINT(tu_plane, tv_vertices[1]);
  dv[2] = DISTANCE_PLANE_POINT(tu_plane, tv_vertices[2]);

  dv0dv1 = dv[0] * dv[1];
  dv0dv2 = dv[0] * dv[2];


  if (dv0dv1>0.0f && dv0dv2>0.0f)	// same sign on all of them + not equal 0 ?
  {
   if (dv[0]<0) //we need test behind the triangle plane
   {
    distances[1] = GIM_MAX3(dv[0], dv[1], dv[2]);
    distances[1] = -distances[1];
    if (distances[1]>margin) return false; //never intersect

                                           //reorder triangle u
    VEC_SWAP(tu_vertices[0], tu_vertices[1]);
    VEC_SCALE_4(tu_plane, -1.0f, tu_plane);
   }
   else
   {
    distances[1] = GIM_MIN3(dv[0], dv[1], dv[2]);
    if (distances[1]>margin) return false; //never intersect
   }
  }
  else
  {
   //Look if we need to invert the triangle
   distances[1] = (dv[0] + dv[1] + dv[2]) / 3.0f; //centroid

   if (distances[1]<0.0f)
   {
    //reorder triangle v
    VEC_SWAP(tu_vertices[0], tu_vertices[1]);
    VEC_SCALE_4(tu_plane, -1.0f, tu_plane);

    distances[1] = GIM_MAX3(dv[0], dv[1], dv[2]);
    distances[1] = -distances[1];
   }
   else
   {
    distances[1] = GIM_MIN3(dv[0], dv[1], dv[2]);
   }
  }

  GUINT bl;
  /* bl = cross_line_intersection_test();
  if(bl==3)
  {
  //take edge direction too
  bl = distances.maxAxis();
  }
  else
  {*/
  bl = 0;
  if (distances[0]<distances[1]) bl = 1;
  //}

  if (bl == 2) //edge edge separation
  {
   if (distances[2]>margin) return false;

   contacts.m_penetration_depth = -distances[2] + margin;
   contacts.m_points[0] = closest_point_v;
   contacts.m_point_count = 1;
   VEC_COPY(contacts.m_separating_normal, edge_edge_dir);

   return true;
  }

  //clip face against other


  GUINT point_count;
  //TODO
  if (bl == 0) //clip U points against V
  {
   point_count = clip_triangle(tv_plane, tv_vertices, tu_vertices, contact_points);
   if (point_count == 0) return false;
   contacts.merge_points(tv_plane, margin, contact_points, point_count);
  }
  else //clip V points against U
  {
   point_count = clip_triangle(tu_plane, tu_vertices, tv_vertices, contact_points);
   if (point_count == 0) return false;
   contacts.merge_points(tu_plane, margin, contact_points, point_count);
   contacts.m_separating_normal *= -1.f;
  }
  if (contacts.m_point_count == 0) return false;
  return true;
 }

};


/*class GIM_TRIANGLE_CALCULATION_CACHE
{
public:
GREAL margin;
GUINT clipped_count;
btVector3 tu_vertices[3];
btVector3 tv_vertices[3];
btVector3 temp_points[MAX_TRI_CLIPPING];
btVector3 temp_points1[MAX_TRI_CLIPPING];
btVector3 clipped_points[MAX_TRI_CLIPPING];
GIM_TRIANGLE_CONTACT_DATA contacts1;
GIM_TRIANGLE_CONTACT_DATA contacts2;


//! clip triangle
GUINT clip_triangle(
const btVector4 & tri_plane,
const btVector3 * tripoints,
const btVector3 * srcpoints,
btVector3 * clipped_points)
{
// edge 0

btVector4 edgeplane;

EDGE_PLANE(tripoints[0],tripoints[1],tri_plane,edgeplane);

GUINT clipped_count = PLANE_CLIP_TRIANGLE3D(
edgeplane,srcpoints[0],srcpoints[1],srcpoints[2],temp_points);

if(clipped_count == 0) return 0;

// edge 1

EDGE_PLANE(tripoints[1],tripoints[2],tri_plane,edgeplane);

clipped_count = PLANE_CLIP_POLYGON3D(
edgeplane,temp_points,clipped_count,temp_points1);

if(clipped_count == 0) return 0;

// edge 2

EDGE_PLANE(tripoints[2],tripoints[0],tri_plane,edgeplane);

clipped_count = PLANE_CLIP_POLYGON3D(
edgeplane,temp_points1,clipped_count,clipped_points);

return clipped_count;
}




//! collides only on one side
bool triangle_collision(
const btVector3 & u0,
const btVector3 & u1,
const btVector3 & u2,
GREAL margin_u,
const btVector3 & v0,
const btVector3 & v1,
const btVector3 & v2,
GREAL margin_v,
GIM_TRIANGLE_CONTACT_DATA & contacts)
{

margin = margin_u + margin_v;


tu_vertices[0] = u0;
tu_vertices[1] = u1;
tu_vertices[2] = u2;

tv_vertices[0] = v0;
tv_vertices[1] = v1;
tv_vertices[2] = v2;

//create planes
// plane v vs U points


TRIANGLE_PLANE(tv_vertices[0],tv_vertices[1],tv_vertices[2],contacts1.m_separating_normal);

clipped_count = clip_triangle(
contacts1.m_separating_normal,tv_vertices,tu_vertices,clipped_points);

if(clipped_count == 0 )
{
return false;//Reject
}

//find most deep interval face1
contacts1.merge_points(contacts1.m_separating_normal,margin,clipped_points,clipped_count);
if(contacts1.m_point_count == 0) return false; // too far

//Normal pointing to triangle1
//contacts1.m_separating_normal *= -1.f;

//Clip tri1 by tri2 edges

TRIANGLE_PLANE(tu_vertices[0],tu_vertices[1],tu_vertices[2],contacts2.m_separating_normal);

clipped_count = clip_triangle(
contacts2.m_separating_normal,tu_vertices,tv_vertices,clipped_points);

if(clipped_count == 0 )
{
return false;//Reject
}

//find most deep interval face1
contacts2.merge_points(contacts2.m_separating_normal,margin,clipped_points,clipped_count);
if(contacts2.m_point_count == 0) return false; // too far

contacts2.m_separating_normal *= -1.f;

////check most dir for contacts
if(contacts2.m_penetration_depth<contacts1.m_penetration_depth)
{
contacts.copy_from(contacts2);
}
else
{
contacts.copy_from(contacts1);
}
return true;
}


};*/



bool GIM_TRIANGLE::collide_triangle_hard_test(
 const GIM_TRIANGLE & other,
 GIM_TRIANGLE_CONTACT_DATA & contact_data) const
{
 GIM_TRIANGLE_CALCULATION_CACHE calc_cache;
 return calc_cache.triangle_collision(
  m_vertices[0], m_vertices[1], m_vertices[2], m_margin,
  other.m_vertices[0], other.m_vertices[1], other.m_vertices[2], other.m_margin,
  contact_data);

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "LinearMath/btTransformUtil.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"



btContinuousConvexCollision::btContinuousConvexCollision(const btConvexShape*	convexA, const btConvexShape*	convexB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver)
 :m_simplexSolver(simplexSolver),
 m_penetrationDepthSolver(penetrationDepthSolver),
 m_convexA(convexA), m_convexB1(convexB), m_planeShape(0)
{
}


btContinuousConvexCollision::btContinuousConvexCollision(const btConvexShape*	convexA, const btStaticPlaneShape*	plane)
 :m_simplexSolver(0),
 m_penetrationDepthSolver(0),
 m_convexA(convexA), m_convexB1(0), m_planeShape(plane)
{
}


/// This maximum should not be necessary. It allows for untested/degenerate cases in production code.
/// You don't want your game ever to lock-up.
#define MAX_ITERATIONS 64

void btContinuousConvexCollision::computeClosestPoints(const btTransform& transA, const btTransform& transB, btPointCollector& pointCollector)
{
 if (m_convexB1)
 {
  m_simplexSolver->reset();
  btGjkPairDetector gjk(m_convexA, m_convexB1, m_convexA->getShapeType(), m_convexB1->getShapeType(), m_convexA->getMargin(), m_convexB1->getMargin(), m_simplexSolver, m_penetrationDepthSolver);
  btGjkPairDetector::ClosestPointInput input;
  input.m_transformA = transA;
  input.m_transformB = transB;
  gjk.getClosestPoints(input, pointCollector, 0);
 }
 else
 {
  //convex versus plane
  const btConvexShape* convexShape = m_convexA;
  const btStaticPlaneShape* planeShape = m_planeShape;

  const btVector3& planeNormal = planeShape->getPlaneNormal();
  const btScalar& planeConstant = planeShape->getPlaneConstant();

  btTransform convexWorldTransform = transA;
  btTransform convexInPlaneTrans;
  convexInPlaneTrans = transB.inverse() * convexWorldTransform;
  btTransform planeInConvex;
  planeInConvex = convexWorldTransform.inverse() * transB;

  btVector3 vtx = convexShape->localGetSupportingVertex(planeInConvex.getBasis()*-planeNormal);

  btVector3 vtxInPlane = convexInPlaneTrans(vtx);
  btScalar distance = (planeNormal.dot(vtxInPlane) - planeConstant);

  btVector3 vtxInPlaneProjected = vtxInPlane - distance*planeNormal;
  btVector3 vtxInPlaneWorld = transB * vtxInPlaneProjected;
  btVector3 normalOnSurfaceB = transB.getBasis() * planeNormal;

  pointCollector.addContactPoint(
   normalOnSurfaceB,
   vtxInPlaneWorld,
   distance);
 }
}

bool	btContinuousConvexCollision::calcTimeOfImpact(
 const btTransform& fromA,
 const btTransform& toA,
 const btTransform& fromB,
 const btTransform& toB,
 CastResult& result)
{


 /// compute linear and angular velocity for this interval, to interpolate
 btVector3 linVelA, angVelA, linVelB, angVelB;
 btTransformUtil::calculateVelocity(fromA, toA, btScalar(1.), linVelA, angVelA);
 btTransformUtil::calculateVelocity(fromB, toB, btScalar(1.), linVelB, angVelB);


 btScalar boundingRadiusA = m_convexA->getAngularMotionDisc();
 btScalar boundingRadiusB = m_convexB1 ? m_convexB1->getAngularMotionDisc() : 0.f;

 btScalar maxAngularProjectedVelocity = angVelA.length() * boundingRadiusA + angVelB.length() * boundingRadiusB;
 btVector3 relLinVel = (linVelB - linVelA);

 btScalar relLinVelocLength = (linVelB - linVelA).length();

 if ((relLinVelocLength + maxAngularProjectedVelocity) == 0.f)
  return false;



 btScalar lambda = btScalar(0.);
 btVector3 v(1, 0, 0);

 int maxIter = MAX_ITERATIONS;

 btVector3 n;
 n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
 bool hasResult = false;
 btVector3 c;

 btScalar lastLambda = lambda;
 //btScalar epsilon = btScalar(0.001);

 int numIter = 0;
 //first solution, using GJK


 btScalar radius = 0.001f;
 //	result.drawCoordSystem(sphereTr);

 btPointCollector	pointCollector1;

 {

  computeClosestPoints(fromA, fromB, pointCollector1);

  hasResult = pointCollector1.m_hasResult;
  c = pointCollector1.m_pointInWorld;
 }

 if (hasResult)
 {
  btScalar dist;
  dist = pointCollector1.m_distance + result.m_allowedPenetration;
  n = pointCollector1.m_normalOnBInWorld;
  btScalar projectedLinearVelocity = relLinVel.dot(n);
  if ((projectedLinearVelocity + maxAngularProjectedVelocity) <= SIMD_EPSILON)
   return false;

  //not close enough
  while (dist > radius)
  {
   if (result.m_debugDrawer)
   {
    result.m_debugDrawer->drawSphere(c, 0.2f, btVector3(1, 1, 1));
   }
   btScalar dLambda = btScalar(0.);

   projectedLinearVelocity = relLinVel.dot(n);


   //don't report time of impact for motion away from the contact normal (or causes minor penetration)
   if ((projectedLinearVelocity + maxAngularProjectedVelocity) <= SIMD_EPSILON)
    return false;

   dLambda = dist / (projectedLinearVelocity + maxAngularProjectedVelocity);



   lambda = lambda + dLambda;

   if (lambda > btScalar(1.))
    return false;

   if (lambda < btScalar(0.))
    return false;


   //todo: next check with relative epsilon
   if (lambda <= lastLambda)
   {
    return false;
    //n.setValue(0,0,0);
    break;
   }
   lastLambda = lambda;



   //interpolate to next lambda
   btTransform interpolatedTransA, interpolatedTransB, relativeTrans;

   btTransformUtil::integrateTransform(fromA, linVelA, angVelA, lambda, interpolatedTransA);
   btTransformUtil::integrateTransform(fromB, linVelB, angVelB, lambda, interpolatedTransB);
   relativeTrans = interpolatedTransB.inverseTimes(interpolatedTransA);

   if (result.m_debugDrawer)
   {
    result.m_debugDrawer->drawSphere(interpolatedTransA.getOrigin(), 0.2f, btVector3(1, 0, 0));
   }

   result.DebugDraw(lambda);

   btPointCollector	pointCollector;
   computeClosestPoints(interpolatedTransA, interpolatedTransB, pointCollector);

   if (pointCollector.m_hasResult)
   {
    dist = pointCollector.m_distance + result.m_allowedPenetration;
    c = pointCollector.m_pointInWorld;
    n = pointCollector.m_normalOnBInWorld;
   }
   else
   {
    result.reportFailure(-1, numIter);
    return false;
   }

   numIter++;
   if (numIter > maxIter)
   {
    result.reportFailure(-2, numIter);
    return false;
   }
  }

  result.m_fraction = lambda;
  result.m_normal = n;
  result.m_hitPoint = c;
  return true;
 }

 return false;

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"

btConvexCast::~btConvexCast()
{
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "LinearMath/btTransformUtil.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define MAX_ITERATIONS 64
#else
#define MAX_ITERATIONS2 32
#endif

btGjkConvexCast::btGjkConvexCast(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver)
 :m_simplexSolver(simplexSolver),
 m_convexA(convexA),
 m_convexB(convexB)
{
}

bool	btGjkConvexCast::calcTimeOfImpact(
 const btTransform& fromA,
 const btTransform& toA,
 const btTransform& fromB,
 const btTransform& toB,
 CastResult& result)
{


 m_simplexSolver->reset();

 /// compute linear velocity for this interval, to interpolate
 //assume no rotation/angular velocity, assert here?
 btVector3 linVelA, linVelB;
 linVelA = toA.getOrigin() - fromA.getOrigin();
 linVelB = toB.getOrigin() - fromB.getOrigin();

 btScalar radius = btScalar(0.001);
 btScalar lambda = btScalar(0.);
 btVector3 v(1, 0, 0);

 int maxIter = MAX_ITERATIONS2;

 btVector3 n;
 n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
 bool hasResult = false;
 btVector3 c;
 btVector3 r = (linVelA - linVelB);

 btScalar lastLambda = lambda;
 //btScalar epsilon = btScalar(0.001);

 int numIter = 0;
 //first solution, using GJK


 btTransform identityTrans;
 identityTrans.setIdentity();


 //	result.drawCoordSystem(sphereTr);

 btPointCollector	pointCollector;


 btGjkPairDetector gjk(m_convexA, m_convexB, m_simplexSolver, 0);//m_penetrationDepthSolver);		
 btGjkPairDetector::ClosestPointInput input;

 //we don't use margins during CCD
 //	gjk.setIgnoreMargin(true);

 input.m_transformA = fromA;
 input.m_transformB = fromB;
 gjk.getClosestPoints(input, pointCollector, 0);

 hasResult = pointCollector.m_hasResult;
 c = pointCollector.m_pointInWorld;

 if (hasResult)
 {
  btScalar dist;
  dist = pointCollector.m_distance;
  n = pointCollector.m_normalOnBInWorld;



  //not close enough
  while (dist > radius)
  {
   numIter++;
   if (numIter > maxIter)
   {
    return false; //todo: report a failure
   }
   btScalar dLambda = btScalar(0.);

   btScalar projectedLinearVelocity = r.dot(n);

   dLambda = dist / (projectedLinearVelocity);

   lambda = lambda - dLambda;

   if (lambda > btScalar(1.))
    return false;

   if (lambda < btScalar(0.))
    return false;

   //todo: next check with relative epsilon
   if (lambda <= lastLambda)
   {
    return false;
    //n.setValue(0,0,0);
    break;
   }
   lastLambda = lambda;

   //interpolate to next lambda
   result.DebugDraw(lambda);
   input.m_transformA.getOrigin().setInterpolate3(fromA.getOrigin(), toA.getOrigin(), lambda);
   input.m_transformB.getOrigin().setInterpolate3(fromB.getOrigin(), toB.getOrigin(), lambda);

   gjk.getClosestPoints(input, pointCollector, 0);
   if (pointCollector.m_hasResult)
   {
    if (pointCollector.m_distance < btScalar(0.))
    {
     result.m_fraction = lastLambda;
     n = pointCollector.m_normalOnBInWorld;
     result.m_normal = n;
     result.m_hitPoint = pointCollector.m_pointInWorld;
     return true;
    }
    c = pointCollector.m_pointInWorld;
    n = pointCollector.m_normalOnBInWorld;
    dist = pointCollector.m_distance;
   }
   else
   {
    //??
    return false;
   }

  }

  //is n normalized?
  //don't report time of impact for motion away from the contact normal (or causes minor penetration)
  if (n.dot(r) >= -result.m_allowedPenetration)
   return false;

  result.m_fraction = lambda;
  result.m_normal = n;
  result.m_hitPoint = c;
  return true;
 }

 return false;


}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software in a
product, an acknowledgment in the product documentation would be appreciated
but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
GJK-EPA collision solver by Nathanael Presson, 2008
*/
#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"

#if defined(DEBUG) || defined (_DEBUG)
#include <stdio.h> //for debug printf
#ifdef __SPU__
#include <spu_printf.h>
#define printf spu_printf
#endif //__SPU__
#endif

namespace gjkepa2_impl
{

 // Config

 /* GJK	*/
#define GJK_MAX_ITERATIONS	128

#ifdef BT_USE_DOUBLE_PRECISION
#define GJK_ACCURACY		((btScalar)1e-12)
#define GJK_MIN_DISTANCE	((btScalar)1e-12)
#define GJK_DUPLICATED_EPS	((btScalar)1e-12)
#else
#define GJK_ACCURACY		((btScalar)0.0001)
#define GJK_MIN_DISTANCE	((btScalar)0.0001)
#define GJK_DUPLICATED_EPS	((btScalar)0.0001)
#endif //BT_USE_DOUBLE_PRECISION


#define GJK_SIMPLEX2_EPS	((btScalar)0.0)
#define GJK_SIMPLEX3_EPS	((btScalar)0.0)
#define GJK_SIMPLEX4_EPS	((btScalar)0.0)

 /* EPA	*/
#define EPA_MAX_VERTICES	128
#define EPA_MAX_ITERATIONS	255

#ifdef BT_USE_DOUBLE_PRECISION
#define EPA_ACCURACY		((btScalar)1e-12)
#define EPA_PLANE_EPS		((btScalar)1e-14)
#define EPA_INSIDE_EPS		((btScalar)1e-9)
#else
#define EPA_ACCURACY		((btScalar)0.0001)
#define EPA_PLANE_EPS		((btScalar)0.00001)
#define EPA_INSIDE_EPS		((btScalar)0.01)
#endif

#define EPA_FALLBACK            (10*EPA_ACCURACY)
#define EPA_MAX_FACES           (EPA_MAX_VERTICES*2)


 // Shorthands
 typedef unsigned int	U;
 typedef unsigned char	U1;

 // MinkowskiDiff
 struct	MinkowskiDiff
 {
  const btConvexShape*	m_shapes[2];
  btMatrix3x3				m_toshape1;
  btTransform				m_toshape0;
#ifdef __SPU__
  bool					m_enableMargin;
#else
  btVector3(btConvexShape::*Ls)(const btVector3&) const;
#endif//__SPU__


  MinkowskiDiff()
  {

  }
#ifdef __SPU__
  void					EnableMargin(bool enable)
  {
   m_enableMargin = enable;
  }
  inline btVector3		Support0(const btVector3& d) const
  {
   if (m_enableMargin)
   {
    return m_shapes[0]->localGetSupportVertexNonVirtual(d);
   }
   else
   {
    return m_shapes[0]->localGetSupportVertexWithoutMarginNonVirtual(d);
   }
  }
  inline btVector3		Support1(const btVector3& d) const
  {
   if (m_enableMargin)
   {
    return m_toshape0*(m_shapes[1]->localGetSupportVertexNonVirtual(m_toshape1*d));
   }
   else
   {
    return m_toshape0*(m_shapes[1]->localGetSupportVertexWithoutMarginNonVirtual(m_toshape1*d));
   }
  }
#else
  void					EnableMargin(bool enable)
  {
   if (enable)
    Ls = &btConvexShape::localGetSupportVertexNonVirtual;
   else
    Ls = &btConvexShape::localGetSupportVertexWithoutMarginNonVirtual;
  }
  inline btVector3		Support0(const btVector3& d) const
  {
   return(((m_shapes[0])->*(Ls))(d));
  }
  inline btVector3		Support1(const btVector3& d) const
  {
   return(m_toshape0*((m_shapes[1])->*(Ls))(m_toshape1*d));
  }
#endif //__SPU__

  inline btVector3		Support(const btVector3& d) const
  {
   return(Support0(d) - Support1(-d));
  }
  btVector3				Support(const btVector3& d, U index) const
  {
   if (index)
    return(Support1(d));
   else
    return(Support0(d));
  }
 };

 typedef	MinkowskiDiff	tShape;


 // GJK
 struct	GJK
 {
  /* Types		*/
  struct	sSV
  {
   btVector3	d, w;
  };
  struct	sSimplex
  {
   sSV*		c[4];
   btScalar	p[4];
   U			rank;
  };
  struct	eStatus {
   enum _ {
    Valid,
    Inside,
    Failed
   };
  };
  /* Fields		*/
  tShape			m_shape;
  btVector3		m_ray;
  btScalar		m_distance;
  sSimplex		m_simplices[2];
  sSV				m_store[4];
  sSV*			m_free[4];
  U				m_nfree;
  U				m_current;
  sSimplex*		m_simplex;
  eStatus::_		m_status;
  /* Methods		*/
  GJK()
  {
   Initialize();
  }
  void				Initialize()
  {
   m_ray = btVector3(0, 0, 0);
   m_nfree = 0;
   m_status = eStatus::Failed;
   m_current = 0;
   m_distance = 0;
  }
  eStatus::_			Evaluate(const tShape& shapearg, const btVector3& guess)
  {
   U			iterations = 0;
   btScalar	sqdist = 0;
   btScalar	alpha = 0;
   btVector3	lastw[4];
   U			clastw = 0;
   /* Initialize solver		*/
   m_free[0] = &m_store[0];
   m_free[1] = &m_store[1];
   m_free[2] = &m_store[2];
   m_free[3] = &m_store[3];
   m_nfree = 4;
   m_current = 0;
   m_status = eStatus::Valid;
   m_shape = shapearg;
   m_distance = 0;
   /* Initialize simplex		*/
   m_simplices[0].rank = 0;
   m_ray = guess;
   const btScalar	sqrl = m_ray.length2();
   appendvertice(m_simplices[0], sqrl>0 ? -m_ray : btVector3(1, 0, 0));
   m_simplices[0].p[0] = 1;
   m_ray = m_simplices[0].c[0]->w;
   sqdist = sqrl;
   lastw[0] =
    lastw[1] =
    lastw[2] =
    lastw[3] = m_ray;
   /* Loop						*/
   do {
    const U		next = 1 - m_current;
    sSimplex&	cs = m_simplices[m_current];
    sSimplex&	ns = m_simplices[next];
    /* Check zero							*/
    const btScalar	rl = m_ray.length();
    if (rl<GJK_MIN_DISTANCE)
    {/* Touching or inside				*/
     m_status = eStatus::Inside;
     break;
    }
    /* Append new vertice in -'v' direction	*/
    appendvertice(cs, -m_ray);
    const btVector3&	w = cs.c[cs.rank - 1]->w;
    bool				found = false;
    for (U i = 0; i<4; ++i)
    {
     if ((w - lastw[i]).length2()<GJK_DUPLICATED_EPS)
     {
      found = true; break;
     }
    }
    if (found)
    {/* Return old simplex				*/
     removevertice(m_simplices[m_current]);
     break;
    }
    else
    {/* Update lastw					*/
     lastw[clastw = (clastw + 1) & 3] = w;
    }
    /* Check for termination				*/
    const btScalar	omega = btDot(m_ray, w) / rl;
    alpha = btMax(omega, alpha);
    if (((rl - alpha) - (GJK_ACCURACY*rl)) <= 0)
    {/* Return old simplex				*/
     removevertice(m_simplices[m_current]);
     break;
    }
    /* Reduce simplex						*/
    btScalar	weights[4];
    U			mask = 0;
    switch (cs.rank)
    {
    case	2:	sqdist = projectorigin(cs.c[0]->w,
     cs.c[1]->w,
     weights, mask); break;
    case	3:	sqdist = projectorigin(cs.c[0]->w,
     cs.c[1]->w,
     cs.c[2]->w,
     weights, mask); break;
    case	4:	sqdist = projectorigin(cs.c[0]->w,
     cs.c[1]->w,
     cs.c[2]->w,
     cs.c[3]->w,
     weights, mask); break;
    }
    if (sqdist >= 0)
    {/* Valid	*/
     ns.rank = 0;
     m_ray = btVector3(0, 0, 0);
     m_current = next;
     for (U i = 0, ni = cs.rank; i<ni; ++i)
     {
      if (mask&(1 << i))
      {
       ns.c[ns.rank] = cs.c[i];
       ns.p[ns.rank++] = weights[i];
       m_ray += cs.c[i]->w*weights[i];
      }
      else
      {
       m_free[m_nfree++] = cs.c[i];
      }
     }
     if (mask == 15) m_status = eStatus::Inside;
    }
    else
    {/* Return old simplex				*/
     removevertice(m_simplices[m_current]);
     break;
    }
    m_status = ((++iterations)<GJK_MAX_ITERATIONS) ? m_status : eStatus::Failed;
   } while (m_status == eStatus::Valid);
   m_simplex = &m_simplices[m_current];
   switch (m_status)
   {
   case	eStatus::Valid:		m_distance = m_ray.length(); break;
   case	eStatus::Inside:	m_distance = 0; break;
   default:
   {
   }
   }
   return(m_status);
  }
  bool					EncloseOrigin()
  {
   switch (m_simplex->rank)
   {
   case	1:
   {
    for (U i = 0; i<3; ++i)
    {
     btVector3		axis = btVector3(0, 0, 0);
     axis[i] = 1;
     appendvertice(*m_simplex, axis);
     if (EncloseOrigin())	return(true);
     removevertice(*m_simplex);
     appendvertice(*m_simplex, -axis);
     if (EncloseOrigin())	return(true);
     removevertice(*m_simplex);
    }
   }
   break;
   case	2:
   {
    const btVector3	d = m_simplex->c[1]->w - m_simplex->c[0]->w;
    for (U i = 0; i<3; ++i)
    {
     btVector3		axis = btVector3(0, 0, 0);
     axis[i] = 1;
     const btVector3	p = btCross(d, axis);
     if (p.length2()>0)
     {
      appendvertice(*m_simplex, p);
      if (EncloseOrigin())	return(true);
      removevertice(*m_simplex);
      appendvertice(*m_simplex, -p);
      if (EncloseOrigin())	return(true);
      removevertice(*m_simplex);
     }
    }
   }
   break;
   case	3:
   {
    const btVector3	n = btCross(m_simplex->c[1]->w - m_simplex->c[0]->w,
     m_simplex->c[2]->w - m_simplex->c[0]->w);
    if (n.length2()>0)
    {
     appendvertice(*m_simplex, n);
     if (EncloseOrigin())	return(true);
     removevertice(*m_simplex);
     appendvertice(*m_simplex, -n);
     if (EncloseOrigin())	return(true);
     removevertice(*m_simplex);
    }
   }
   break;
   case	4:
   {
    if (btFabs(det(m_simplex->c[0]->w - m_simplex->c[3]->w,
     m_simplex->c[1]->w - m_simplex->c[3]->w,
     m_simplex->c[2]->w - m_simplex->c[3]->w))>0)
     return(true);
   }
   break;
   }
   return(false);
  }
  /* Internals	*/
  void				getsupport(const btVector3& d, sSV& sv) const
  {
   sv.d = d / d.length();
   sv.w = m_shape.Support(sv.d);
  }
  void				removevertice(sSimplex& simplex)
  {
   m_free[m_nfree++] = simplex.c[--simplex.rank];
  }
  void				appendvertice(sSimplex& simplex, const btVector3& v)
  {
   simplex.p[simplex.rank] = 0;
   simplex.c[simplex.rank] = m_free[--m_nfree];
   getsupport(v, *simplex.c[simplex.rank++]);
  }
  static btScalar		det(const btVector3& a, const btVector3& b, const btVector3& c)
  {
   return(a.y()*b.z()*c.x() + a.z()*b.x()*c.y() -
    a.x()*b.z()*c.y() - a.y()*b.x()*c.z() +
    a.x()*b.y()*c.z() - a.z()*b.y()*c.x());
  }
  static btScalar		projectorigin(const btVector3& a,
   const btVector3& b,
   btScalar* w, U& m)
  {
   const btVector3	d = b - a;
   const btScalar	l = d.length2();
   if (l>GJK_SIMPLEX2_EPS)
   {
    const btScalar	t(l>0 ? -btDot(a, d) / l : 0);
    if (t >= 1) { w[0] = 0; w[1] = 1; m = 2; return(b.length2()); }
    else if (t <= 0) { w[0] = 1; w[1] = 0; m = 1; return(a.length2()); }
    else { w[0] = 1 - (w[1] = t); m = 3; return((a + d*t).length2()); }
   }
   return(-1);
  }
  static btScalar		projectorigin(const btVector3& a,
   const btVector3& b,
   const btVector3& c,
   btScalar* w, U& m)
  {
   static const U		imd3[] = { 1,2,0 };
   const btVector3*	vt[] = { &a,&b,&c };
   const btVector3		dl[] = { a - b,b - c,c - a };
   const btVector3		n = btCross(dl[0], dl[1]);
   const btScalar		l = n.length2();
   if (l>GJK_SIMPLEX3_EPS)
   {
    btScalar	mindist = -1;
    btScalar	subw[2] = { 0.f,0.f };
    U			subm(0);
    for (U i = 0; i<3; ++i)
    {
     if (btDot(*vt[i], btCross(dl[i], n))>0)
     {
      const U			j = imd3[i];
      const btScalar	subd(projectorigin(*vt[i], *vt[j], subw, subm));
      if ((mindist<0) || (subd<mindist))
      {
       mindist = subd;
       m = static_cast<U>(((subm & 1) ? 1 << i : 0) + ((subm & 2) ? 1 << j : 0));
       w[i] = subw[0];
       w[j] = subw[1];
       w[imd3[j]] = 0;
      }
     }
    }
    if (mindist<0)
    {
     const btScalar	d = btDot(a, n);
     const btScalar	s = btSqrt(l);
     const btVector3	p = n*(d / l);
     mindist = p.length2();
     m = 7;
     w[0] = (btCross(dl[1], b - p)).length() / s;
     w[1] = (btCross(dl[2], c - p)).length() / s;
     w[2] = 1 - (w[0] + w[1]);
    }
    return(mindist);
   }
   return(-1);
  }
  static btScalar		projectorigin(const btVector3& a,
   const btVector3& b,
   const btVector3& c,
   const btVector3& d,
   btScalar* w, U& m)
  {
   static const U		imd3[] = { 1,2,0 };
   const btVector3*	vt[] = { &a,&b,&c,&d };
   const btVector3		dl[] = { a - d,b - d,c - d };
   const btScalar		vl = det(dl[0], dl[1], dl[2]);
   const bool			ng = (vl*btDot(a, btCross(b - c, a - b))) <= 0;
   if (ng && (btFabs(vl)>GJK_SIMPLEX4_EPS))
   {
    btScalar	mindist = -1;
    btScalar	subw[3] = { 0.f,0.f,0.f };
    U			subm(0);
    for (U i = 0; i<3; ++i)
    {
     const U			j = imd3[i];
     const btScalar	s = vl*btDot(d, btCross(dl[i], dl[j]));
     if (s>0)
     {
      const btScalar	subd = projectorigin(*vt[i], *vt[j], d, subw, subm);
      if ((mindist<0) || (subd<mindist))
      {
       mindist = subd;
       m = static_cast<U>((subm & 1 ? 1 << i : 0) +
        (subm & 2 ? 1 << j : 0) +
        (subm & 4 ? 8 : 0));
       w[i] = subw[0];
       w[j] = subw[1];
       w[imd3[j]] = 0;
       w[3] = subw[2];
      }
     }
    }
    if (mindist<0)
    {
     mindist = 0;
     m = 15;
     w[0] = det(c, b, d) / vl;
     w[1] = det(a, c, d) / vl;
     w[2] = det(b, a, d) / vl;
     w[3] = 1 - (w[0] + w[1] + w[2]);
    }
    return(mindist);
   }
   return(-1);
  }
 };

 // EPA
 struct	EPA
 {
  /* Types		*/
  typedef	GJK::sSV	sSV;
  struct	sFace
  {
   btVector3	n;
   btScalar	d;
   sSV*		c[3];
   sFace*		f[3];
   sFace*		l[2];
   U1			e[3];
   U1			pass;
  };
  struct	sList
  {
   sFace*		root;
   U			count;
   sList() : root(0), count(0) {}
  };
  struct	sHorizon
  {
   sFace*		cf;
   sFace*		ff;
   U			nf;
   sHorizon() : cf(0), ff(0), nf(0) {}
  };
  struct	eStatus {
   enum _ {
    Valid,
    Touching,
    Degenerated,
    NonConvex,
    InvalidHull,
    OutOfFaces,
    OutOfVertices,
    AccuraryReached,
    FallBack,
    Failed
   };
  };
  /* Fields		*/
  eStatus::_		m_status;
  GJK::sSimplex	m_result;
  btVector3		m_normal;
  btScalar		m_depth;
  sSV				m_sv_store[EPA_MAX_VERTICES];
  sFace			m_fc_store[EPA_MAX_FACES];
  U				m_nextsv;
  sList			m_hull;
  sList			m_stock;
  /* Methods		*/
  EPA()
  {
   Initialize();
  }


  static inline void		bind(sFace* fa, U ea, sFace* fb, U eb)
  {
   fa->e[ea] = (U1)eb; fa->f[ea] = fb;
   fb->e[eb] = (U1)ea; fb->f[eb] = fa;
  }
  static inline void		append(sList& list, sFace* face)
  {
   face->l[0] = 0;
   face->l[1] = list.root;
   if (list.root) list.root->l[0] = face;
   list.root = face;
   ++list.count;
  }
  static inline void		remove(sList& list, sFace* face)
  {
   if (face->l[1]) face->l[1]->l[0] = face->l[0];
   if (face->l[0]) face->l[0]->l[1] = face->l[1];
   if (face == list.root) list.root = face->l[1];
   --list.count;
  }


  void				Initialize()
  {
   m_status = eStatus::Failed;
   m_normal = btVector3(0, 0, 0);
   m_depth = 0;
   m_nextsv = 0;
   for (U i = 0; i<EPA_MAX_FACES; ++i)
   {
    append(m_stock, &m_fc_store[EPA_MAX_FACES - i - 1]);
   }
  }
  eStatus::_			Evaluate(GJK& gjk, const btVector3& guess)
  {
   GJK::sSimplex&	simplex = *gjk.m_simplex;
   if ((simplex.rank>1) && gjk.EncloseOrigin())
   {

    /* Clean up				*/
    while (m_hull.root)
    {
     sFace*	f = m_hull.root;
     remove(m_hull, f);
     append(m_stock, f);
    }
    m_status = eStatus::Valid;
    m_nextsv = 0;
    /* Orient simplex		*/
    if (gjk.det(simplex.c[0]->w - simplex.c[3]->w,
     simplex.c[1]->w - simplex.c[3]->w,
     simplex.c[2]->w - simplex.c[3]->w)<0)
    {
     btSwap(simplex.c[0], simplex.c[1]);
     btSwap(simplex.p[0], simplex.p[1]);
    }
    /* Build initial hull	*/
    sFace*	tetra[] = { newface(simplex.c[0],simplex.c[1],simplex.c[2],true),
     newface(simplex.c[1],simplex.c[0],simplex.c[3],true),
     newface(simplex.c[2],simplex.c[1],simplex.c[3],true),
     newface(simplex.c[0],simplex.c[2],simplex.c[3],true) };
    if (m_hull.count == 4)
    {
     sFace*		best = findbest();
     sFace		outer = *best;
     U			pass = 0;
     U			iterations = 0;
     bind(tetra[0], 0, tetra[1], 0);
     bind(tetra[0], 1, tetra[2], 0);
     bind(tetra[0], 2, tetra[3], 0);
     bind(tetra[1], 1, tetra[3], 2);
     bind(tetra[1], 2, tetra[2], 1);
     bind(tetra[2], 2, tetra[3], 1);
     m_status = eStatus::Valid;
     for (; iterations<EPA_MAX_ITERATIONS; ++iterations)
     {
      if (m_nextsv<EPA_MAX_VERTICES)
      {
       sHorizon		horizon;
       sSV*			w = &m_sv_store[m_nextsv++];
       bool			valid = true;
       best->pass = (U1)(++pass);
       gjk.getsupport(best->n, *w);
       const btScalar	wdist = btDot(best->n, w->w) - best->d;
       if (wdist>EPA_ACCURACY)
       {
        for (U j = 0; (j<3) && valid; ++j)
        {
         valid &= expand(pass, w,
          best->f[j], best->e[j],
          horizon);
        }
        if (valid && (horizon.nf >= 3))
        {
         bind(horizon.cf, 1, horizon.ff, 2);
         remove(m_hull, best);
         append(m_stock, best);
         best = findbest();
         outer = *best;
        }
        else { m_status = eStatus::InvalidHull; break; }
       }
       else { m_status = eStatus::AccuraryReached; break; }
      }
      else { m_status = eStatus::OutOfVertices; break; }
     }
     const btVector3	projection = outer.n*outer.d;
     m_normal = outer.n;
     m_depth = outer.d;
     m_result.rank = 3;
     m_result.c[0] = outer.c[0];
     m_result.c[1] = outer.c[1];
     m_result.c[2] = outer.c[2];
     m_result.p[0] = btCross(outer.c[1]->w - projection,
      outer.c[2]->w - projection).length();
     m_result.p[1] = btCross(outer.c[2]->w - projection,
      outer.c[0]->w - projection).length();
     m_result.p[2] = btCross(outer.c[0]->w - projection,
      outer.c[1]->w - projection).length();
     const btScalar	sum = m_result.p[0] + m_result.p[1] + m_result.p[2];
     m_result.p[0] /= sum;
     m_result.p[1] /= sum;
     m_result.p[2] /= sum;
     return(m_status);
    }
   }
   /* Fallback		*/
   m_status = eStatus::FallBack;
   m_normal = -guess;
   const btScalar	nl = m_normal.length();
   if (nl>0)
    m_normal = m_normal / nl;
   else
    m_normal = btVector3(1, 0, 0);
   m_depth = 0;
   m_result.rank = 1;
   m_result.c[0] = simplex.c[0];
   m_result.p[0] = 1;
   return(m_status);
  }
  bool getedgedist(sFace* face, sSV* a, sSV* b, btScalar& dist)
  {
   const btVector3 ba = b->w - a->w;
   const btVector3 n_ab = btCross(ba, face->n); // Outward facing edge normal direction, on triangle plane
   const btScalar a_dot_nab = btDot(a->w, n_ab); // Only care about the sign to determine inside/outside, so not normalization required

   if (a_dot_nab < 0)
   {
    // Outside of edge a->b

    const btScalar ba_l2 = ba.length2();
    const btScalar a_dot_ba = btDot(a->w, ba);
    const btScalar b_dot_ba = btDot(b->w, ba);

    if (a_dot_ba > 0)
    {
     // Pick distance vertex a
     dist = a->w.length();
    }
    else if (b_dot_ba < 0)
    {
     // Pick distance vertex b
     dist = b->w.length();
    }
    else
    {
     // Pick distance to edge a->b
     const btScalar a_dot_b = btDot(a->w, b->w);
     dist = btSqrt(btMax((a->w.length2() * b->w.length2() - a_dot_b * a_dot_b) / ba_l2, (btScalar)0));
    }

    return true;
   }

   return false;
  }
  sFace*				newface(sSV* a, sSV* b, sSV* c, bool forced)
  {
   if (m_stock.root)
   {
    sFace*	face = m_stock.root;
    remove(m_stock, face);
    append(m_hull, face);
    face->pass = 0;
    face->c[0] = a;
    face->c[1] = b;
    face->c[2] = c;
    face->n = btCross(b->w - a->w, c->w - a->w);
    const btScalar	l = face->n.length();
    const bool		v = l>EPA_ACCURACY;

    if (v)
    {
     if (!(getedgedist(face, a, b, face->d) ||
      getedgedist(face, b, c, face->d) ||
      getedgedist(face, c, a, face->d)))
     {
      // Origin projects to the interior of the triangle
      // Use distance to triangle plane
      face->d = btDot(a->w, face->n) / l;
     }

     face->n /= l;
     if (forced || (face->d >= -EPA_PLANE_EPS))
     {
      return face;
     }
     else
      m_status = eStatus::NonConvex;
    }
    else
     m_status = eStatus::Degenerated;

    remove(m_hull, face);
    append(m_stock, face);
    return 0;

   }
   m_status = m_stock.root ? eStatus::OutOfVertices : eStatus::OutOfFaces;
   return 0;
  }
  sFace*				findbest()
  {
   sFace*		minf = m_hull.root;
   btScalar	mind = minf->d*minf->d;
   for (sFace* f = minf->l[1]; f; f = f->l[1])
   {
    const btScalar	sqd = f->d*f->d;
    if (sqd<mind)
    {
     minf = f;
     mind = sqd;
    }
   }
   return(minf);
  }
  bool				expand(U pass, sSV* w, sFace* f, U e, sHorizon& horizon)
  {
   static const U	i1m3[] = { 1,2,0 };
   static const U	i2m3[] = { 2,0,1 };
   if (f->pass != pass)
   {
    const U	e1 = i1m3[e];
    if ((btDot(f->n, w->w) - f->d)<-EPA_PLANE_EPS)
    {
     sFace*	nf = newface(f->c[e1], f->c[e], w, false);
     if (nf)
     {
      bind(nf, 0, f, e);
      if (horizon.cf) bind(horizon.cf, 1, nf, 2); else horizon.ff = nf;
      horizon.cf = nf;
      ++horizon.nf;
      return(true);
     }
    }
    else
    {
     const U	e2 = i2m3[e];
     f->pass = (U1)pass;
     if (expand(pass, w, f->f[e1], f->e[e1], horizon) &&
      expand(pass, w, f->f[e2], f->e[e2], horizon))
     {
      remove(m_hull, f);
      append(m_stock, f);
      return(true);
     }
    }
   }
   return(false);
  }

 };

 //
 static void	Initialize(const btConvexShape* shape0, const btTransform& wtrs0,
  const btConvexShape* shape1, const btTransform& wtrs1,
  btGjkEpaSolver2::sResults& results,
  tShape& shape,
  bool withmargins)
 {
  /* Results		*/
  results.witnesses[0] =
   results.witnesses[1] = btVector3(0, 0, 0);
  results.status = btGjkEpaSolver2::sResults::Separated;
  /* Shape		*/
  shape.m_shapes[0] = shape0;
  shape.m_shapes[1] = shape1;
  shape.m_toshape1 = wtrs1.getBasis().transposeTimes(wtrs0.getBasis());
  shape.m_toshape0 = wtrs0.inverseTimes(wtrs1);
  shape.EnableMargin(withmargins);
 }

}

//
// Api
//

using namespace	gjkepa2_impl;

//
int			btGjkEpaSolver2::StackSizeRequirement()
{
 return(sizeof(GJK) + sizeof(EPA));
}

//
bool		btGjkEpaSolver2::Distance(const btConvexShape*	shape0,
 const btTransform&		wtrs0,
 const btConvexShape*	shape1,
 const btTransform&		wtrs1,
 const btVector3&		guess,
 sResults&				results)
{
 tShape			shape;
 Initialize(shape0, wtrs0, shape1, wtrs1, results, shape, false);
 GJK				gjk;
 GJK::eStatus::_	gjk_status = gjk.Evaluate(shape, guess);
 if (gjk_status == GJK::eStatus::Valid)
 {
  btVector3	w0 = btVector3(0, 0, 0);
  btVector3	w1 = btVector3(0, 0, 0);
  for (U i = 0; i<gjk.m_simplex->rank; ++i)
  {
   const btScalar	p = gjk.m_simplex->p[i];
   w0 += shape.Support(gjk.m_simplex->c[i]->d, 0)*p;
   w1 += shape.Support(-gjk.m_simplex->c[i]->d, 1)*p;
  }
  results.witnesses[0] = wtrs0*w0;
  results.witnesses[1] = wtrs0*w1;
  results.normal = w0 - w1;
  results.distance = results.normal.length();
  results.normal /= results.distance>GJK_MIN_DISTANCE ? results.distance : 1;
  return(true);
 }
 else
 {
  results.status = gjk_status == GJK::eStatus::Inside ?
   sResults::Penetrating :
   sResults::GJK_Failed;
  return(false);
 }
}

//
bool	btGjkEpaSolver2::Penetration(const btConvexShape*	shape0,
 const btTransform&		wtrs0,
 const btConvexShape*	shape1,
 const btTransform&		wtrs1,
 const btVector3&		guess,
 sResults&				results,
 bool					usemargins)
{
 tShape			shape;
 Initialize(shape0, wtrs0, shape1, wtrs1, results, shape, usemargins);
 GJK				gjk;
 GJK::eStatus::_	gjk_status = gjk.Evaluate(shape, -guess);
 switch (gjk_status)
 {
 case	GJK::eStatus::Inside:
 {
  EPA				epa;
  EPA::eStatus::_	epa_status = epa.Evaluate(gjk, -guess);
  if (epa_status != EPA::eStatus::Failed)
  {
   btVector3	w0 = btVector3(0, 0, 0);
   for (U i = 0; i<epa.m_result.rank; ++i)
   {
    w0 += shape.Support(epa.m_result.c[i]->d, 0)*epa.m_result.p[i];
   }
   results.status = sResults::Penetrating;
   results.witnesses[0] = wtrs0*w0;
   results.witnesses[1] = wtrs0*(w0 - epa.m_normal*epa.m_depth);
   results.normal = -epa.m_normal;
   results.distance = -epa.m_depth;
   return(true);
  }
  else results.status = sResults::EPA_Failed;
 }
 break;
 case	GJK::eStatus::Failed:
  results.status = sResults::GJK_Failed;
  break;
 default:
 {
 }
 }
 return(false);
}

#ifndef __SPU__
//
btScalar	btGjkEpaSolver2::SignedDistance(const btVector3& position,
 btScalar margin,
 const btConvexShape* shape0,
 const btTransform& wtrs0,
 sResults& results)
{
 tShape			shape;
 btSphereShape	shape1(margin);
 btTransform		wtrs1(btQuaternion(0, 0, 0, 1), position);
 Initialize(shape0, wtrs0, &shape1, wtrs1, results, shape, false);
 GJK				gjk;
 GJK::eStatus::_	gjk_status = gjk.Evaluate(shape, btVector3(1, 1, 1));
 if (gjk_status == GJK::eStatus::Valid)
 {
  btVector3	w0 = btVector3(0, 0, 0);
  btVector3	w1 = btVector3(0, 0, 0);
  for (U i = 0; i<gjk.m_simplex->rank; ++i)
  {
   const btScalar	p = gjk.m_simplex->p[i];
   w0 += shape.Support(gjk.m_simplex->c[i]->d, 0)*p;
   w1 += shape.Support(-gjk.m_simplex->c[i]->d, 1)*p;
  }
  results.witnesses[0] = wtrs0*w0;
  results.witnesses[1] = wtrs0*w1;
  const btVector3	delta = results.witnesses[1] -
   results.witnesses[0];
  const btScalar	margin = shape0->getMarginNonVirtual() +
   shape1.getMarginNonVirtual();
  const btScalar	length = delta.length();
  results.normal = delta / length;
  results.witnesses[0] += results.normal*margin;
  return(length - margin);
 }
 else
 {
  if (gjk_status == GJK::eStatus::Inside)
  {
   if (Penetration(shape0, wtrs0, &shape1, wtrs1, gjk.m_ray, results))
   {
    const btVector3	delta = results.witnesses[0] -
     results.witnesses[1];
    const btScalar	length = delta.length();
    if (length >= SIMD_EPSILON)
     results.normal = delta / length;
    return(-length);
   }
  }
 }
 return(SIMD_INFINITY);
}

//
bool	btGjkEpaSolver2::SignedDistance(const btConvexShape*	shape0,
 const btTransform&		wtrs0,
 const btConvexShape*	shape1,
 const btTransform&		wtrs1,
 const btVector3&		guess,
 sResults&				results)
{
 if (!Distance(shape0, wtrs0, shape1, wtrs1, guess, results))
  return(Penetration(shape0, wtrs0, shape1, wtrs1, guess, results, false));
 else
  return(true);
}
#endif //__SPU__

/* Symbols cleanup		*/

#undef GJK_MAX_ITERATIONS
#undef GJK_ACCURACY
#undef GJK_MIN_DISTANCE
#undef GJK_DUPLICATED_EPS
#undef GJK_SIMPLEX2_EPS
#undef GJK_SIMPLEX3_EPS
#undef GJK_SIMPLEX4_EPS

#undef EPA_MAX_VERTICES
#undef EPA_MAX_FACES
#undef EPA_MAX_ITERATIONS
#undef EPA_ACCURACY
#undef EPA_FALLBACK
#undef EPA_PLANE_EPS
#undef EPA_INSIDE_EPS
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

EPA Copyright (c) Ricardo Padrela 2006

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"


#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"

bool btGjkEpaPenetrationDepthSolver::calcPenDepth(btSimplexSolverInterface& simplexSolver,
 const btConvexShape* pConvexA, const btConvexShape* pConvexB,
 const btTransform& transformA, const btTransform& transformB,
 btVector3& v, btVector3& wWitnessOnA, btVector3& wWitnessOnB,
 class btIDebugDraw* debugDraw)
{

 (void)debugDraw;
 (void)v;
 (void)simplexSolver;

 //	const btScalar				radialmargin(btScalar(0.));

 btVector3	guessVector(transformB.getOrigin() - transformA.getOrigin());
 btGjkEpaSolver2::sResults	results;


 if (btGjkEpaSolver2::Penetration(pConvexA, transformA,
  pConvexB, transformB,
  guessVector, results))

 {
  //	debugDraw->drawLine(results.witnesses[1],results.witnesses[1]+results.normal,btVector3(255,0,0));
  //resultOut->addContactPoint(results.normal,results.witnesses[1],-results.depth);
  wWitnessOnA = results.witnesses[0];
  wWitnessOnB = results.witnesses[1];
  v = results.normal;
  return true;
 }
 else
 {
  if (btGjkEpaSolver2::Distance(pConvexA, transformA, pConvexB, transformB, guessVector, results))
  {
   wWitnessOnA = results.witnesses[0];
   wWitnessOnB = results.witnesses[1];
   v = results.normal;
   return false;
  }
 }

 return false;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"



#if defined(DEBUG) || defined (_DEBUG)
//#define TEST_NON_VIRTUAL 1
#include <stdio.h> //for debug printf
#ifdef __SPU__
#include <spu_printf.h>
#define printf spu_printf
#endif //__SPU__
#endif

//must be above the machine epsilon
#ifdef  BT_USE_DOUBLE_PRECISION
#define REL_ERROR2 btScalar(1.0e-12)
btScalar gGjkEpaPenetrationTolerance = 1e-7;
#else
#define REL_ERROR2 btScalar(1.0e-6)
btScalar gGjkEpaPenetrationTolerance = (btScalar)0.001;
#endif

//temp globals, to improve GJK/EPA/penetration calculations
int gNumDeepPenetrationChecks = 0;
int gNumGjkChecks = 0;


btGjkPairDetector::btGjkPairDetector(const btConvexShape* objectA, const btConvexShape* objectB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver*	penetrationDepthSolver)
 :m_cachedSeparatingAxis(btScalar(0.), btScalar(1.), btScalar(0.)),
 m_penetrationDepthSolver(penetrationDepthSolver),
 m_simplexSolver(simplexSolver),
 m_minkowskiA(objectA),
 m_minkowskiB(objectB),
 m_shapeTypeA(objectA->getShapeType()),
 m_shapeTypeB(objectB->getShapeType()),
 m_marginA(objectA->getMargin()),
 m_marginB(objectB->getMargin()),
 m_ignoreMargin(false),
 m_lastUsedMethod(-1),
 m_catchDegeneracies(1),
 m_fixContactNormalDirection(1)
{
}
btGjkPairDetector::btGjkPairDetector(const btConvexShape* objectA, const btConvexShape* objectB, int shapeTypeA, int shapeTypeB, btScalar marginA, btScalar marginB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver*	penetrationDepthSolver)
 :m_cachedSeparatingAxis(btScalar(0.), btScalar(1.), btScalar(0.)),
 m_penetrationDepthSolver(penetrationDepthSolver),
 m_simplexSolver(simplexSolver),
 m_minkowskiA(objectA),
 m_minkowskiB(objectB),
 m_shapeTypeA(shapeTypeA),
 m_shapeTypeB(shapeTypeB),
 m_marginA(marginA),
 m_marginB(marginB),
 m_ignoreMargin(false),
 m_lastUsedMethod(-1),
 m_catchDegeneracies(1),
 m_fixContactNormalDirection(1)
{
}

void	btGjkPairDetector::getClosestPoints(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw, bool swapResults)
{
 (void)swapResults;

 getClosestPointsNonVirtual(input, output, debugDraw);
}

#ifdef __SPU__
void btGjkPairDetector::getClosestPointsNonVirtual(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw)
#else
void btGjkPairDetector::getClosestPointsNonVirtual(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw)
#endif
{
 m_cachedSeparatingDistance = 0.f;

 btScalar distance = btScalar(0.);
 btVector3	normalInB(btScalar(0.), btScalar(0.), btScalar(0.));

 btVector3 pointOnA, pointOnB;
 btTransform	localTransA = input.m_transformA;
 btTransform localTransB = input.m_transformB;
 btVector3 positionOffset = (localTransA.getOrigin() + localTransB.getOrigin()) * btScalar(0.5);
 localTransA.getOrigin() -= positionOffset;
 localTransB.getOrigin() -= positionOffset;

 bool check2d = m_minkowskiA->isConvex2d() && m_minkowskiB->isConvex2d();

 btScalar marginA = m_marginA;
 btScalar marginB = m_marginB;

 gNumGjkChecks++;

 //for CCD we don't use margins
 if (m_ignoreMargin)
 {
  marginA = btScalar(0.);
  marginB = btScalar(0.);
 }

 m_curIter = 0;
 int gGjkMaxIter = 1000;//this is to catch invalid input, perhaps check for #NaN?
 m_cachedSeparatingAxis.setValue(0, 1, 0);

 bool isValid = false;
 bool checkSimplex = false;
 bool checkPenetration = true;
 m_degenerateSimplex = 0;

 m_lastUsedMethod = -1;

 {
  btScalar squaredDistance = BT_LARGE_FLOAT;
  btScalar delta = btScalar(0.);

  btScalar margin = marginA + marginB;



  m_simplexSolver->reset();

  for (; ; )
   //while (true)
  {

   btVector3 seperatingAxisInA = (-m_cachedSeparatingAxis)* input.m_transformA.getBasis();
   btVector3 seperatingAxisInB = m_cachedSeparatingAxis* input.m_transformB.getBasis();


   btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
   btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);

   btVector3  pWorld = localTransA(pInA);
   btVector3  qWorld = localTransB(qInB);


   if (check2d)
   {
    pWorld[2] = 0.f;
    qWorld[2] = 0.f;
   }

   btVector3 w = pWorld - qWorld;
   delta = m_cachedSeparatingAxis.dot(w);

   // potential exit, they don't overlap
   if ((delta > btScalar(0.0)) && (delta * delta > squaredDistance * input.m_maximumDistanceSquared))
   {
    m_degenerateSimplex = 10;
    checkSimplex = true;
    //checkPenetration = false;
    break;
   }

   //exit 0: the new point is already in the simplex, or we didn't come any closer
   if (m_simplexSolver->inSimplex(w))
   {
    m_degenerateSimplex = 1;
    checkSimplex = true;
    break;
   }
   // are we getting any closer ?
   btScalar f0 = squaredDistance - delta;
   btScalar f1 = squaredDistance * REL_ERROR2;

   if (f0 <= f1)
   {
    if (f0 <= btScalar(0.))
    {
     m_degenerateSimplex = 2;
    }
    else
    {
     m_degenerateSimplex = 11;
    }
    checkSimplex = true;
    break;
   }

   //add current vertex to simplex
   m_simplexSolver->addVertex(w, pWorld, qWorld);
   btVector3 newCachedSeparatingAxis;

   //calculate the closest point to the origin (update vector v)
   if (!m_simplexSolver->closest(newCachedSeparatingAxis))
   {
    m_degenerateSimplex = 3;
    checkSimplex = true;
    break;
   }

   if (newCachedSeparatingAxis.length2()<REL_ERROR2)
   {
    m_cachedSeparatingAxis = newCachedSeparatingAxis;
    m_degenerateSimplex = 6;
    checkSimplex = true;
    break;
   }

   btScalar previousSquaredDistance = squaredDistance;
   squaredDistance = newCachedSeparatingAxis.length2();
#if 0
   ///warning: this termination condition leads to some problems in 2d test case see Bullet/Demos/Box2dDemo
   if (squaredDistance>previousSquaredDistance)
   {
    m_degenerateSimplex = 7;
    squaredDistance = previousSquaredDistance;
    checkSimplex = false;
    break;
   }
#endif //


   //redundant m_simplexSolver->compute_points(pointOnA, pointOnB);

   //are we getting any closer ?
   if (previousSquaredDistance - squaredDistance <= SIMD_EPSILON * previousSquaredDistance)
   {
    //				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
    checkSimplex = true;
    m_degenerateSimplex = 12;

    break;
   }

   m_cachedSeparatingAxis = newCachedSeparatingAxis;

   //degeneracy, this is typically due to invalid/uninitialized worldtransforms for a btCollisionObject   
   if (m_curIter++ > gGjkMaxIter)
   {
#if defined(DEBUG) || defined (_DEBUG)

    printf("btGjkPairDetector maxIter exceeded:%i\n", m_curIter);
    printf("sepAxis=(%f,%f,%f), squaredDistance = %f, shapeTypeA=%i,shapeTypeB=%i\n",
     m_cachedSeparatingAxis.getX(),
     m_cachedSeparatingAxis.getY(),
     m_cachedSeparatingAxis.getZ(),
     squaredDistance,
     m_minkowskiA->getShapeType(),
     m_minkowskiB->getShapeType());

#endif   
    break;

   }


   bool check = (!m_simplexSolver->fullSimplex());
   //bool check = (!m_simplexSolver->fullSimplex() && squaredDistance > SIMD_EPSILON * m_simplexSolver->maxVertex());

   if (!check)
   {
    //do we need this backup_closest here ?
    //				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
    m_degenerateSimplex = 13;
    break;
   }
  }

  if (checkSimplex)
  {
   m_simplexSolver->compute_points(pointOnA, pointOnB);
   normalInB = m_cachedSeparatingAxis;

   btScalar lenSqr = m_cachedSeparatingAxis.length2();

   //valid normal
   if (lenSqr < REL_ERROR2)
   {
    m_degenerateSimplex = 5;
   }
   if (lenSqr > SIMD_EPSILON*SIMD_EPSILON)
   {
    btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
    normalInB *= rlen; //normalize

    btScalar s = btSqrt(squaredDistance);

    btAssert(s > btScalar(0.0));
    pointOnA -= m_cachedSeparatingAxis * (marginA / s);
    pointOnB += m_cachedSeparatingAxis * (marginB / s);
    distance = ((btScalar(1.) / rlen) - margin);
    isValid = true;

    m_lastUsedMethod = 1;
   }
   else
   {
    m_lastUsedMethod = 2;
   }
  }

  bool catchDegeneratePenetrationCase =
   (m_catchDegeneracies && m_penetrationDepthSolver && m_degenerateSimplex && ((distance + margin) < gGjkEpaPenetrationTolerance));

  //if (checkPenetration && !isValid)
  if (checkPenetration && (!isValid || catchDegeneratePenetrationCase))
  {
   //penetration case

   //if there is no way to handle penetrations, bail out
   if (m_penetrationDepthSolver)
   {
    // Penetration depth case.
    btVector3 tmpPointOnA, tmpPointOnB;

    gNumDeepPenetrationChecks++;
    m_cachedSeparatingAxis.setZero();

    bool isValid2 = m_penetrationDepthSolver->calcPenDepth(
     *m_simplexSolver,
     m_minkowskiA, m_minkowskiB,
     localTransA, localTransB,
     m_cachedSeparatingAxis, tmpPointOnA, tmpPointOnB,
     debugDraw
    );


    if (isValid2)
    {
     btVector3 tmpNormalInB = tmpPointOnB - tmpPointOnA;
     btScalar lenSqr = tmpNormalInB.length2();
     if (lenSqr <= (SIMD_EPSILON*SIMD_EPSILON))
     {
      tmpNormalInB = m_cachedSeparatingAxis;
      lenSqr = m_cachedSeparatingAxis.length2();
     }

     if (lenSqr > (SIMD_EPSILON*SIMD_EPSILON))
     {
      tmpNormalInB /= btSqrt(lenSqr);
      btScalar distance2 = -(tmpPointOnA - tmpPointOnB).length();
      m_lastUsedMethod = 3;
      //only replace valid penetrations when the result is deeper (check)
      if (!isValid || (distance2 < distance))
      {
       distance = distance2;
       pointOnA = tmpPointOnA;
       pointOnB = tmpPointOnB;
       normalInB = tmpNormalInB;

       isValid = true;

      }
      else
      {
       m_lastUsedMethod = 8;
      }
     }
     else
     {
      m_lastUsedMethod = 9;
     }
    }
    else

    {
     ///this is another degenerate case, where the initial GJK calculation reports a degenerate case
     ///EPA reports no penetration, and the second GJK (using the supporting vector without margin)
     ///reports a valid positive distance. Use the results of the second GJK instead of failing.
     ///thanks to Jacob.Langford for the reproduction case
     ///http://code.google.com/p/bullet/issues/detail?id=250


     if (m_cachedSeparatingAxis.length2() > btScalar(0.))
     {
      btScalar distance2 = (tmpPointOnA - tmpPointOnB).length() - margin;
      //only replace valid distances when the distance is less
      if (!isValid || (distance2 < distance))
      {
       distance = distance2;
       pointOnA = tmpPointOnA;
       pointOnB = tmpPointOnB;
       pointOnA -= m_cachedSeparatingAxis * marginA;
       pointOnB += m_cachedSeparatingAxis * marginB;
       normalInB = m_cachedSeparatingAxis;
       normalInB.normalize();

       isValid = true;
       m_lastUsedMethod = 6;
      }
      else
      {
       m_lastUsedMethod = 5;
      }
     }
    }

   }

  }
 }



 if (isValid && ((distance < 0) || (distance*distance < input.m_maximumDistanceSquared)))
 {

  m_cachedSeparatingAxis = normalInB;
  m_cachedSeparatingDistance = distance;

  {
   ///todo: need to track down this EPA penetration solver degeneracy
   ///the penetration solver reports penetration but the contact normal
   ///connecting the contact points is pointing in the opposite direction
   ///until then, detect the issue and revert the normal

   btScalar d1 = 0;
   {
    btVector3 seperatingAxisInA = (normalInB)* input.m_transformA.getBasis();
    btVector3 seperatingAxisInB = -normalInB* input.m_transformB.getBasis();


    btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
    btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);

    btVector3  pWorld = localTransA(pInA);
    btVector3  qWorld = localTransB(qInB);
    btVector3 w = pWorld - qWorld;
    d1 = (-normalInB).dot(w);
   }
   btScalar d0 = 0.f;
   {
    btVector3 seperatingAxisInA = (-normalInB)* input.m_transformA.getBasis();
    btVector3 seperatingAxisInB = normalInB* input.m_transformB.getBasis();


    btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
    btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);

    btVector3  pWorld = localTransA(pInA);
    btVector3  qWorld = localTransB(qInB);
    btVector3 w = pWorld - qWorld;
    d0 = normalInB.dot(w);
   }
   if (d1>d0)
   {
    m_lastUsedMethod = 10;
    normalInB *= -1;
   }

  }
  output.addContactPoint(
   normalInB,
   pointOnB + positionOffset,
   distance);

 }


}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"

#define NUM_UNITSPHERE_POINTS 42


bool btMinkowskiPenetrationDepthSolver::calcPenDepth(btSimplexSolverInterface& simplexSolver,
 const btConvexShape* convexA, const btConvexShape* convexB,
 const btTransform& transA, const btTransform& transB,
 btVector3& v, btVector3& pa, btVector3& pb,
 class btIDebugDraw* debugDraw
)
{

 (void)v;

 bool check2d = convexA->isConvex2d() && convexB->isConvex2d();

 struct btIntermediateResult : public btDiscreteCollisionDetectorInterface::Result
 {

  btIntermediateResult() :m_hasResult(false)
  {
  }

  btVector3 m_normalOnBInWorld;
  btVector3 m_pointInWorld;
  btScalar m_depth;
  bool	m_hasResult;

  virtual void setShapeIdentifiersA(int partId0, int index0)
  {
   (void)partId0;
   (void)index0;
  }
  virtual void setShapeIdentifiersB(int partId1, int index1)
  {
   (void)partId1;
   (void)index1;
  }
  void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
  {
   m_normalOnBInWorld = normalOnBInWorld;
   m_pointInWorld = pointInWorld;
   m_depth = depth;
   m_hasResult = true;
  }
 };

 //just take fixed number of orientation, and sample the penetration depth in that direction
 btScalar minProj = btScalar(BT_LARGE_FLOAT);
 btVector3 minNorm(btScalar(0.), btScalar(0.), btScalar(0.));
 btVector3 minA, minB;
 btVector3 seperatingAxisInA, seperatingAxisInB;
 btVector3 pInA, qInB, pWorld, qWorld, w;

#ifndef __SPU__
#define USE_BATCHED_SUPPORT 1
#endif
#ifdef USE_BATCHED_SUPPORT

 btVector3	supportVerticesABatch[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2];
 btVector3	supportVerticesBBatch[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2];
 btVector3	seperatingAxisInABatch[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2];
 btVector3	seperatingAxisInBBatch[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2];
 int i;

 int numSampleDirections = NUM_UNITSPHERE_POINTS;

 for (i = 0; i<numSampleDirections; i++)
 {
  btVector3 norm = getPenetrationDirections()[i];
  seperatingAxisInABatch[i] = (-norm) * transA.getBasis();
  seperatingAxisInBBatch[i] = norm   * transB.getBasis();
 }

 {
  int numPDA = convexA->getNumPreferredPenetrationDirections();
  if (numPDA)
  {
   for (int i = 0; i<numPDA; i++)
   {
    btVector3 norm;
    convexA->getPreferredPenetrationDirection(i, norm);
    norm = transA.getBasis() * norm;
    getPenetrationDirections()[numSampleDirections] = norm;
    seperatingAxisInABatch[numSampleDirections] = (-norm) * transA.getBasis();
    seperatingAxisInBBatch[numSampleDirections] = norm * transB.getBasis();
    numSampleDirections++;
   }
  }
 }

 {
  int numPDB = convexB->getNumPreferredPenetrationDirections();
  if (numPDB)
  {
   for (int i = 0; i<numPDB; i++)
   {
    btVector3 norm;
    convexB->getPreferredPenetrationDirection(i, norm);
    norm = transB.getBasis() * norm;
    getPenetrationDirections()[numSampleDirections] = norm;
    seperatingAxisInABatch[numSampleDirections] = (-norm) * transA.getBasis();
    seperatingAxisInBBatch[numSampleDirections] = norm * transB.getBasis();
    numSampleDirections++;
   }
  }
 }




 convexA->batchedUnitVectorGetSupportingVertexWithoutMargin(seperatingAxisInABatch, supportVerticesABatch, numSampleDirections);
 convexB->batchedUnitVectorGetSupportingVertexWithoutMargin(seperatingAxisInBBatch, supportVerticesBBatch, numSampleDirections);

 for (i = 0; i<numSampleDirections; i++)
 {
  btVector3 norm = getPenetrationDirections()[i];
  if (check2d)
  {
   norm[2] = 0.f;
  }
  if (norm.length2()>0.01)
  {

   seperatingAxisInA = seperatingAxisInABatch[i];
   seperatingAxisInB = seperatingAxisInBBatch[i];

   pInA = supportVerticesABatch[i];
   qInB = supportVerticesBBatch[i];

   pWorld = transA(pInA);
   qWorld = transB(qInB);
   if (check2d)
   {
    pWorld[2] = 0.f;
    qWorld[2] = 0.f;
   }

   w = qWorld - pWorld;
   btScalar delta = norm.dot(w);
   //find smallest delta
   if (delta < minProj)
   {
    minProj = delta;
    minNorm = norm;
    minA = pWorld;
    minB = qWorld;
   }
  }
 }
#else

 int numSampleDirections = NUM_UNITSPHERE_POINTS;

#ifndef __SPU__
 {
  int numPDA = convexA->getNumPreferredPenetrationDirections();
  if (numPDA)
  {
   for (int i = 0; i<numPDA; i++)
   {
    btVector3 norm;
    convexA->getPreferredPenetrationDirection(i, norm);
    norm = transA.getBasis() * norm;
    getPenetrationDirections()[numSampleDirections] = norm;
    numSampleDirections++;
   }
  }
 }

 {
  int numPDB = convexB->getNumPreferredPenetrationDirections();
  if (numPDB)
  {
   for (int i = 0; i<numPDB; i++)
   {
    btVector3 norm;
    convexB->getPreferredPenetrationDirection(i, norm);
    norm = transB.getBasis() * norm;
    getPenetrationDirections()[numSampleDirections] = norm;
    numSampleDirections++;
   }
  }
 }
#endif // __SPU__

 for (int i = 0; i<numSampleDirections; i++)
 {
  const btVector3& norm = getPenetrationDirections()[i];
  seperatingAxisInA = (-norm)* transA.getBasis();
  seperatingAxisInB = norm* transB.getBasis();
  pInA = convexA->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
  qInB = convexB->localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);
  pWorld = transA(pInA);
  qWorld = transB(qInB);
  w = qWorld - pWorld;
  btScalar delta = norm.dot(w);
  //find smallest delta
  if (delta < minProj)
  {
   minProj = delta;
   minNorm = norm;
   minA = pWorld;
   minB = qWorld;
  }
 }
#endif //USE_BATCHED_SUPPORT

 //add the margins

 minA += minNorm*convexA->getMarginNonVirtual();
 minB -= minNorm*convexB->getMarginNonVirtual();
 //no penetration
 if (minProj < btScalar(0.))
  return false;

 btScalar extraSeparation = 0.5f;///scale dependent
 minProj += extraSeparation + (convexA->getMarginNonVirtual() + convexB->getMarginNonVirtual());





 //#define DEBUG_DRAW 1
#ifdef DEBUG_DRAW
 if (debugDraw)
 {
  btVector3 color(0, 1, 0);
  debugDraw->drawLine(minA, minB, color);
  color = btVector3(1, 1, 1);
  btVector3 vec = minB - minA;
  btScalar prj2 = minNorm.dot(vec);
  debugDraw->drawLine(minA, minA + (minNorm*minProj), color);

 }
#endif //DEBUG_DRAW



 btGjkPairDetector gjkdet(convexA, convexB, &simplexSolver, 0);

 btScalar offsetDist = minProj;
 btVector3 offset = minNorm * offsetDist;



 btGjkPairDetector::ClosestPointInput input;

 btVector3 newOrg = transA.getOrigin() + offset;

 btTransform displacedTrans = transA;
 displacedTrans.setOrigin(newOrg);

 input.m_transformA = displacedTrans;
 input.m_transformB = transB;
 input.m_maximumDistanceSquared = btScalar(BT_LARGE_FLOAT);//minProj;

 btIntermediateResult res;
 gjkdet.setCachedSeperatingAxis(-minNorm);
 gjkdet.getClosestPoints(input, res, debugDraw);

 btScalar correctedMinNorm = minProj - res.m_depth;


 //the penetration depth is over-estimated, relax it
 btScalar penetration_relaxation = btScalar(1.);
 minNorm *= penetration_relaxation;


 if (res.m_hasResult)
 {

  pa = res.m_pointInWorld - minNorm * correctedMinNorm;
  pb = res.m_pointInWorld;
  v = minNorm;

#ifdef DEBUG_DRAW
  if (debugDraw)
  {
   btVector3 color(1, 0, 0);
   debugDraw->drawLine(pa, pb, color);
  }
#endif//DEBUG_DRAW


 }
 return res.m_hasResult;
}

btVector3*	btMinkowskiPenetrationDepthSolver::getPenetrationDirections()
{
 static btVector3	sPenetrationDirections[NUM_UNITSPHERE_POINTS + MAX_PREFERRED_PENETRATION_DIRECTIONS * 2] =
 {
  btVector3(btScalar(0.000000) , btScalar(-0.000000),btScalar(-1.000000)),
  btVector3(btScalar(0.723608) , btScalar(-0.525725),btScalar(-0.447219)),
  btVector3(btScalar(-0.276388) , btScalar(-0.850649),btScalar(-0.447219)),
  btVector3(btScalar(-0.894426) , btScalar(-0.000000),btScalar(-0.447216)),
  btVector3(btScalar(-0.276388) , btScalar(0.850649),btScalar(-0.447220)),
  btVector3(btScalar(0.723608) , btScalar(0.525725),btScalar(-0.447219)),
  btVector3(btScalar(0.276388) , btScalar(-0.850649),btScalar(0.447220)),
  btVector3(btScalar(-0.723608) , btScalar(-0.525725),btScalar(0.447219)),
  btVector3(btScalar(-0.723608) , btScalar(0.525725),btScalar(0.447219)),
  btVector3(btScalar(0.276388) , btScalar(0.850649),btScalar(0.447219)),
  btVector3(btScalar(0.894426) , btScalar(0.000000),btScalar(0.447216)),
  btVector3(btScalar(-0.000000) , btScalar(0.000000),btScalar(1.000000)),
  btVector3(btScalar(0.425323) , btScalar(-0.309011),btScalar(-0.850654)),
  btVector3(btScalar(-0.162456) , btScalar(-0.499995),btScalar(-0.850654)),
  btVector3(btScalar(0.262869) , btScalar(-0.809012),btScalar(-0.525738)),
  btVector3(btScalar(0.425323) , btScalar(0.309011),btScalar(-0.850654)),
  btVector3(btScalar(0.850648) , btScalar(-0.000000),btScalar(-0.525736)),
  btVector3(btScalar(-0.525730) , btScalar(-0.000000),btScalar(-0.850652)),
  btVector3(btScalar(-0.688190) , btScalar(-0.499997),btScalar(-0.525736)),
  btVector3(btScalar(-0.162456) , btScalar(0.499995),btScalar(-0.850654)),
  btVector3(btScalar(-0.688190) , btScalar(0.499997),btScalar(-0.525736)),
  btVector3(btScalar(0.262869) , btScalar(0.809012),btScalar(-0.525738)),
  btVector3(btScalar(0.951058) , btScalar(0.309013),btScalar(0.000000)),
  btVector3(btScalar(0.951058) , btScalar(-0.309013),btScalar(0.000000)),
  btVector3(btScalar(0.587786) , btScalar(-0.809017),btScalar(0.000000)),
  btVector3(btScalar(0.000000) , btScalar(-1.000000),btScalar(0.000000)),
  btVector3(btScalar(-0.587786) , btScalar(-0.809017),btScalar(0.000000)),
  btVector3(btScalar(-0.951058) , btScalar(-0.309013),btScalar(-0.000000)),
  btVector3(btScalar(-0.951058) , btScalar(0.309013),btScalar(-0.000000)),
  btVector3(btScalar(-0.587786) , btScalar(0.809017),btScalar(-0.000000)),
  btVector3(btScalar(-0.000000) , btScalar(1.000000),btScalar(-0.000000)),
  btVector3(btScalar(0.587786) , btScalar(0.809017),btScalar(-0.000000)),
  btVector3(btScalar(0.688190) , btScalar(-0.499997),btScalar(0.525736)),
  btVector3(btScalar(-0.262869) , btScalar(-0.809012),btScalar(0.525738)),
  btVector3(btScalar(-0.850648) , btScalar(0.000000),btScalar(0.525736)),
  btVector3(btScalar(-0.262869) , btScalar(0.809012),btScalar(0.525738)),
  btVector3(btScalar(0.688190) , btScalar(0.499997),btScalar(0.525736)),
  btVector3(btScalar(0.525730) , btScalar(0.000000),btScalar(0.850652)),
  btVector3(btScalar(0.162456) , btScalar(-0.499995),btScalar(0.850654)),
  btVector3(btScalar(-0.425323) , btScalar(-0.309011),btScalar(0.850654)),
  btVector3(btScalar(-0.425323) , btScalar(0.309011),btScalar(0.850654)),
  btVector3(btScalar(0.162456) , btScalar(0.499995),btScalar(0.850654))
 };

 return sPenetrationDirections;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "LinearMath/btTransform.h"


btScalar					gContactBreakingThreshold = btScalar(0.02);
ContactDestroyedCallback	gContactDestroyedCallback = 0;
ContactProcessedCallback	gContactProcessedCallback = 0;
ContactStartedCallback		gContactStartedCallback = 0;
ContactEndedCallback		gContactEndedCallback = 0;
///gContactCalcArea3Points will approximate the convex hull area using 3 points
///when setting it to false, it will use 4 points to compute the area: it is more accurate but slower
bool						gContactCalcArea3Points = true;


btPersistentManifold::btPersistentManifold()
 :btTypedObject(BT_PERSISTENT_MANIFOLD_TYPE),
 m_body0(0),
 m_body1(0),
 m_cachedPoints(0),
 m_index1a(0)
{
}




#ifdef DEBUG_PERSISTENCY
#include <stdio.h>
void	btPersistentManifold::DebugPersistency()
{
 int i;
 printf("DebugPersistency : numPoints %d\n", m_cachedPoints);
 for (i = 0; i<m_cachedPoints; i++)
 {
  printf("m_pointCache[%d].m_userPersistentData = %x\n", i, m_pointCache[i].m_userPersistentData);
 }
}
#endif //DEBUG_PERSISTENCY

void btPersistentManifold::clearUserCache(btManifoldPoint& pt)
{

 void* oldPtr = pt.m_userPersistentData;
 if (oldPtr)
 {
#ifdef DEBUG_PERSISTENCY
  int i;
  int occurance = 0;
  for (i = 0; i<m_cachedPoints; i++)
  {
   if (m_pointCache[i].m_userPersistentData == oldPtr)
   {
    occurance++;
    if (occurance>1)
     printf("error in clearUserCache\n");
   }
  }
  btAssert(occurance <= 0);
#endif //DEBUG_PERSISTENCY

  if (pt.m_userPersistentData && gContactDestroyedCallback)
  {
   (*gContactDestroyedCallback)(pt.m_userPersistentData);
   pt.m_userPersistentData = 0;
  }

#ifdef DEBUG_PERSISTENCY
  DebugPersistency();
#endif
 }


}

static inline btScalar calcArea4Points(const btVector3 &p0, const btVector3 &p1, const btVector3 &p2, const btVector3 &p3)
{
 // It calculates possible 3 area constructed from random 4 points and returns the biggest one.

 btVector3 a[3], b[3];
 a[0] = p0 - p1;
 a[1] = p0 - p2;
 a[2] = p0 - p3;
 b[0] = p2 - p3;
 b[1] = p1 - p3;
 b[2] = p1 - p2;

 //todo: Following 3 cross production can be easily optimized by SIMD.
 btVector3 tmp0 = a[0].cross(b[0]);
 btVector3 tmp1 = a[1].cross(b[1]);
 btVector3 tmp2 = a[2].cross(b[2]);

 return btMax(btMax(tmp0.length2(), tmp1.length2()), tmp2.length2());
}

int btPersistentManifold::sortCachedPoints(const btManifoldPoint& pt)
{
 //calculate 4 possible cases areas, and take biggest area
 //also need to keep 'deepest'

 int maxPenetrationIndex = -1;
#define KEEP_DEEPEST_POINT 1
#ifdef KEEP_DEEPEST_POINT
 btScalar maxPenetration = pt.getDistance();
 for (int i = 0; i<4; i++)
 {
  if (m_pointCache[i].getDistance() < maxPenetration)
  {
   maxPenetrationIndex = i;
   maxPenetration = m_pointCache[i].getDistance();
  }
 }
#endif //KEEP_DEEPEST_POINT

 btScalar res0(btScalar(0.)), res1(btScalar(0.)), res2(btScalar(0.)), res3(btScalar(0.));

 if (gContactCalcArea3Points)
 {
  if (maxPenetrationIndex != 0)
  {
   btVector3 a0 = pt.m_localPointA - m_pointCache[1].m_localPointA;
   btVector3 b0 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
   btVector3 cross = a0.cross(b0);
   res0 = cross.length2();
  }
  if (maxPenetrationIndex != 1)
  {
   btVector3 a1 = pt.m_localPointA - m_pointCache[0].m_localPointA;
   btVector3 b1 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
   btVector3 cross = a1.cross(b1);
   res1 = cross.length2();
  }

  if (maxPenetrationIndex != 2)
  {
   btVector3 a2 = pt.m_localPointA - m_pointCache[0].m_localPointA;
   btVector3 b2 = m_pointCache[3].m_localPointA - m_pointCache[1].m_localPointA;
   btVector3 cross = a2.cross(b2);
   res2 = cross.length2();
  }

  if (maxPenetrationIndex != 3)
  {
   btVector3 a3 = pt.m_localPointA - m_pointCache[0].m_localPointA;
   btVector3 b3 = m_pointCache[2].m_localPointA - m_pointCache[1].m_localPointA;
   btVector3 cross = a3.cross(b3);
   res3 = cross.length2();
  }
 }
 else
 {
  if (maxPenetrationIndex != 0) {
   res0 = calcArea4Points(pt.m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
  }

  if (maxPenetrationIndex != 1) {
   res1 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
  }

  if (maxPenetrationIndex != 2) {
   res2 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[3].m_localPointA);
  }

  if (maxPenetrationIndex != 3) {
   res3 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA);
  }
 }
 btVector4 maxvec(res0, res1, res2, res3);
 int biggestarea = maxvec.closestAxis4();
 return biggestarea;

}


int btPersistentManifold::getCacheEntry(const btManifoldPoint& newPoint) const
{
 btScalar shortestDist = getContactBreakingThreshold() * getContactBreakingThreshold();
 int size = getNumContacts();
 int nearestPoint = -1;
 for (int i = 0; i < size; i++)
 {
  const btManifoldPoint &mp = m_pointCache[i];

  btVector3 diffA = mp.m_localPointA - newPoint.m_localPointA;
  const btScalar distToManiPoint = diffA.dot(diffA);
  if (distToManiPoint < shortestDist)
  {
   shortestDist = distToManiPoint;
   nearestPoint = i;
  }
 }
 return nearestPoint;
}

int btPersistentManifold::addManifoldPoint(const btManifoldPoint& newPoint, bool isPredictive)
{
 if (!isPredictive)
 {
  btAssert(validContactDistance(newPoint));
 }

 int insertIndex = getNumContacts();
 if (insertIndex == MANIFOLD_CACHE_SIZE)
 {
#if MANIFOLD_CACHE_SIZE >= 4
  //sort cache so best points come first, based on area
  insertIndex = sortCachedPoints(newPoint);
#else
  insertIndex = 0;
#endif
  clearUserCache(m_pointCache[insertIndex]);

 }
 else
 {
  m_cachedPoints++;


 }
 if (insertIndex<0)
  insertIndex = 0;

 btAssert(m_pointCache[insertIndex].m_userPersistentData == 0);
 m_pointCache[insertIndex] = newPoint;
 return insertIndex;
}

btScalar	btPersistentManifold::getContactBreakingThreshold() const
{
 return m_contactBreakingThreshold;
}



void btPersistentManifold::refreshContactPoints(const btTransform& trA, const btTransform& trB)
{
 int i;
#ifdef DEBUG_PERSISTENCY
 printf("refreshContactPoints posA = (%f,%f,%f) posB = (%f,%f,%f)\n",
  trA.getOrigin().getX(),
  trA.getOrigin().getY(),
  trA.getOrigin().getZ(),
  trB.getOrigin().getX(),
  trB.getOrigin().getY(),
  trB.getOrigin().getZ());
#endif //DEBUG_PERSISTENCY
 /// first refresh worldspace positions and distance
 for (i = getNumContacts() - 1; i >= 0; i--)
 {
  btManifoldPoint &manifoldPoint = m_pointCache[i];
  manifoldPoint.m_positionWorldOnA = trA(manifoldPoint.m_localPointA);
  manifoldPoint.m_positionWorldOnB = trB(manifoldPoint.m_localPointB);
  manifoldPoint.m_distance1 = (manifoldPoint.m_positionWorldOnA - manifoldPoint.m_positionWorldOnB).dot(manifoldPoint.m_normalWorldOnB);
  manifoldPoint.m_lifeTime++;
 }

 /// then 
 btScalar distance2d;
 btVector3 projectedDifference, projectedPoint;
 for (i = getNumContacts() - 1; i >= 0; i--)
 {

  btManifoldPoint &manifoldPoint = m_pointCache[i];
  //contact becomes invalid when signed distance exceeds margin (projected on contactnormal direction)
  if (!validContactDistance(manifoldPoint))
  {
   removeContactPoint(i);
  }
  else
  {
   //todo: friction anchor may require the contact to be around a bit longer
   //contact also becomes invalid when relative movement orthogonal to normal exceeds margin
   projectedPoint = manifoldPoint.m_positionWorldOnA - manifoldPoint.m_normalWorldOnB * manifoldPoint.m_distance1;
   projectedDifference = manifoldPoint.m_positionWorldOnB - projectedPoint;
   distance2d = projectedDifference.dot(projectedDifference);
   if (distance2d  > getContactBreakingThreshold()*getContactBreakingThreshold())
   {
    removeContactPoint(i);
   }
   else
   {
    //contact point processed callback
    if (gContactProcessedCallback)
     (*gContactProcessedCallback)(manifoldPoint, (void*)m_body0, (void*)m_body1);
   }
  }
 }
#ifdef DEBUG_PERSISTENCY
 DebugPersistency();
#endif //
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs


#include "BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"

#include <float.h> //for FLT_MAX

int gExpectedNbTests = 0;
int gActualNbTests = 0;
bool gUseInternalObject = true;

// Clips a face to the back of a plane
void btPolyhedralContactClipping::clipFace(const btVertexArray& pVtxIn, btVertexArray& ppVtxOut, const btVector3& planeNormalWS, btScalar planeEqWS)
{

 int ve;
 btScalar ds, de;
 int numVerts = pVtxIn.size();
 if (numVerts < 2)
  return;

 btVector3 firstVertex = pVtxIn[pVtxIn.size() - 1];
 btVector3 endVertex = pVtxIn[0];

 ds = planeNormalWS.dot(firstVertex) + planeEqWS;

 for (ve = 0; ve < numVerts; ve++)
 {
  endVertex = pVtxIn[ve];

  de = planeNormalWS.dot(endVertex) + planeEqWS;

  if (ds<0)
  {
   if (de<0)
   {
    // Start < 0, end < 0, so output endVertex
    ppVtxOut.push_back(endVertex);
   }
   else
   {
    // Start < 0, end >= 0, so output intersection
    ppVtxOut.push_back(firstVertex.lerp(endVertex, btScalar(ds * 1.f / (ds - de))));
   }
  }
  else
  {
   if (de<0)
   {
    // Start >= 0, end < 0 so output intersection and end
    ppVtxOut.push_back(firstVertex.lerp(endVertex, btScalar(ds * 1.f / (ds - de))));
    ppVtxOut.push_back(endVertex);
   }
  }
  firstVertex = endVertex;
  ds = de;
 }
}


static bool TestSepAxis(const btConvexPolyhedron& hullA, const btConvexPolyhedron& hullB, const btTransform& transA, const btTransform& transB, const btVector3& sep_axis, btScalar& depth, btVector3& witnessPointA, btVector3& witnessPointB)
{
 btScalar Min0, Max0;
 btScalar Min1, Max1;
 btVector3 witnesPtMinA, witnesPtMaxA;
 btVector3 witnesPtMinB, witnesPtMaxB;

 hullA.project(transA, sep_axis, Min0, Max0, witnesPtMinA, witnesPtMaxA);
 hullB.project(transB, sep_axis, Min1, Max1, witnesPtMinB, witnesPtMaxB);

 if (Max0<Min1 || Max1<Min0)
  return false;

 btScalar d0 = Max0 - Min1;
 btAssert(d0 >= 0.0f);
 btScalar d1 = Max1 - Min0;
 btAssert(d1 >= 0.0f);
 if (d0<d1)
 {
  depth = d0;
  witnessPointA = witnesPtMaxA;
  witnessPointB = witnesPtMinB;

 }
 else
 {
  depth = d1;
  witnessPointA = witnesPtMinA;
  witnessPointB = witnesPtMaxB;
 }

 return true;
}



static int gActualSATPairTests = 0;

#ifdef TEST_INTERNAL_OBJECTS

inline void BoxSupport(const btScalar extents[3], const btScalar sv[3], btScalar p[3])
{
 // This version is ~11.000 cycles (4%) faster overall in one of the tests.
 //	IR(p[0]) = IR(extents[0])|(IR(sv[0])&SIGN_BITMASK);
 //	IR(p[1]) = IR(extents[1])|(IR(sv[1])&SIGN_BITMASK);
 //	IR(p[2]) = IR(extents[2])|(IR(sv[2])&SIGN_BITMASK);
 p[0] = sv[0] < 0.0f ? -extents[0] : extents[0];
 p[1] = sv[1] < 0.0f ? -extents[1] : extents[1];
 p[2] = sv[2] < 0.0f ? -extents[2] : extents[2];
}

void InverseTransformPoint3x3(btVector3& out, const btVector3& in, const btTransform& tr)
{
 const btMatrix3x3& rot = tr.getBasis();
 const btVector3& r0 = rot[0];
 const btVector3& r1 = rot[1];
 const btVector3& r2 = rot[2];

 const btScalar x = r0.x()*in.x() + r1.x()*in.y() + r2.x()*in.z();
 const btScalar y = r0.y()*in.x() + r1.y()*in.y() + r2.y()*in.z();
 const btScalar z = r0.z()*in.x() + r1.z()*in.y() + r2.z()*in.z();

 out.setValue(x, y, z);
}

bool TestInternalObjects(const btTransform& trans0, const btTransform& trans1, const btVector3& delta_c, const btVector3& axis, const btConvexPolyhedron& convex0, const btConvexPolyhedron& convex1, btScalar dmin)
{
 const btScalar dp = delta_c.dot(axis);

 btVector3 localAxis0;
 InverseTransformPoint3x3(localAxis0, axis, trans0);
 btVector3 localAxis1;
 InverseTransformPoint3x3(localAxis1, axis, trans1);

 btScalar p0[3];
 BoxSupport(convex0.m_extents, localAxis0, p0);
 btScalar p1[3];
 BoxSupport(convex1.m_extents, localAxis1, p1);

 const btScalar Radius0 = p0[0] * localAxis0.x() + p0[1] * localAxis0.y() + p0[2] * localAxis0.z();
 const btScalar Radius1 = p1[0] * localAxis1.x() + p1[1] * localAxis1.y() + p1[2] * localAxis1.z();

 const btScalar MinRadius = Radius0>convex0.m_radius ? Radius0 : convex0.m_radius;
 const btScalar MaxRadius = Radius1>convex1.m_radius ? Radius1 : convex1.m_radius;

 const btScalar MinMaxRadius = MaxRadius + MinRadius;
 const btScalar d0 = MinMaxRadius + dp;
 const btScalar d1 = MinMaxRadius - dp;

 const btScalar depth = d0<d1 ? d0 : d1;
 if (depth>dmin)
  return false;
 return true;
}
#endif //TEST_INTERNAL_OBJECTS



SIMD_FORCE_INLINE void btSegmentsClosestPoints(
 btVector3& ptsVector,
 btVector3& offsetA,
 btVector3& offsetB,
 btScalar& tA, btScalar& tB,
 const btVector3& translation,
 const btVector3& dirA, btScalar hlenA,
 const btVector3& dirB, btScalar hlenB)
{
 // compute the parameters of the closest points on each line segment

 btScalar dirA_dot_dirB = btDot(dirA, dirB);
 btScalar dirA_dot_trans = btDot(dirA, translation);
 btScalar dirB_dot_trans = btDot(dirB, translation);

 btScalar denom = 1.0f - dirA_dot_dirB * dirA_dot_dirB;

 if (denom == 0.0f) {
  tA = 0.0f;
 }
 else {
  tA = (dirA_dot_trans - dirB_dot_trans * dirA_dot_dirB) / denom;
  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }

 tB = tA * dirA_dot_dirB - dirB_dot_trans;

 if (tB < -hlenB) {
  tB = -hlenB;
  tA = tB * dirA_dot_dirB + dirA_dot_trans;

  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }
 else if (tB > hlenB) {
  tB = hlenB;
  tA = tB * dirA_dot_dirB + dirA_dot_trans;

  if (tA < -hlenA)
   tA = -hlenA;
  else if (tA > hlenA)
   tA = hlenA;
 }

 // compute the closest points relative to segment centers.

 offsetA = dirA * tA;
 offsetB = dirB * tB;

 ptsVector = translation - offsetA + offsetB;
}



bool btPolyhedralContactClipping::findSeparatingAxis(const btConvexPolyhedron& hullA, const btConvexPolyhedron& hullB, const btTransform& transA, const btTransform& transB, btVector3& sep, btDiscreteCollisionDetectorInterface::Result& resultOut)
{
 gActualSATPairTests++;

 //#ifdef TEST_INTERNAL_OBJECTS
 const btVector3 c0 = transA * hullA.m_localCenter;
 const btVector3 c1 = transB * hullB.m_localCenter;
 const btVector3 DeltaC2 = c0 - c1;
 //#endif

 btScalar dmin = FLT_MAX;
 int curPlaneTests = 0;

 int numFacesA = hullA.m_faces.size();
 // Test normals from hullA
 for (int i = 0; i<numFacesA; i++)
 {
  const btVector3 Normal(hullA.m_faces[i].m_plane[0], hullA.m_faces[i].m_plane[1], hullA.m_faces[i].m_plane[2]);
  btVector3 faceANormalWS = transA.getBasis() * Normal;
  if (DeltaC2.dot(faceANormalWS)<0)
   faceANormalWS *= -1.f;

  curPlaneTests++;
#ifdef TEST_INTERNAL_OBJECTS
  gExpectedNbTests++;
  if (gUseInternalObject && !TestInternalObjects(transA, transB, DeltaC2, faceANormalWS, hullA, hullB, dmin))
   continue;
  gActualNbTests++;
#endif

  btScalar d;
  btVector3 wA, wB;
  if (!TestSepAxis(hullA, hullB, transA, transB, faceANormalWS, d, wA, wB))
   return false;

  if (d<dmin)
  {
   dmin = d;
   sep = faceANormalWS;
  }
 }

 int numFacesB = hullB.m_faces.size();
 // Test normals from hullB
 for (int i = 0; i<numFacesB; i++)
 {
  const btVector3 Normal(hullB.m_faces[i].m_plane[0], hullB.m_faces[i].m_plane[1], hullB.m_faces[i].m_plane[2]);
  btVector3 WorldNormal = transB.getBasis() * Normal;
  if (DeltaC2.dot(WorldNormal)<0)
   WorldNormal *= -1.f;

  curPlaneTests++;
#ifdef TEST_INTERNAL_OBJECTS
  gExpectedNbTests++;
  if (gUseInternalObject && !TestInternalObjects(transA, transB, DeltaC2, WorldNormal, hullA, hullB, dmin))
   continue;
  gActualNbTests++;
#endif

  btScalar d;
  btVector3 wA, wB;
  if (!TestSepAxis(hullA, hullB, transA, transB, WorldNormal, d, wA, wB))
   return false;

  if (d<dmin)
  {
   dmin = d;
   sep = WorldNormal;
  }
 }

 btVector3 edgeAstart, edgeAend, edgeBstart, edgeBend;
 int edgeA = -1;
 int edgeB = -1;
 btVector3 worldEdgeA;
 btVector3 worldEdgeB;
 btVector3 witnessPointA(0, 0, 0), witnessPointB(0, 0, 0);


 int curEdgeEdge = 0;
 // Test edges
 for (int e0 = 0; e0<hullA.m_uniqueEdges.size(); e0++)
 {
  const btVector3 edge0 = hullA.m_uniqueEdges[e0];
  const btVector3 WorldEdge0 = transA.getBasis() * edge0;
  for (int e1 = 0; e1<hullB.m_uniqueEdges.size(); e1++)
  {
   const btVector3 edge1 = hullB.m_uniqueEdges[e1];
   const btVector3 WorldEdge1 = transB.getBasis() * edge1;

   btVector3 Cross = WorldEdge0.cross(WorldEdge1);
   curEdgeEdge++;
   if (!IsAlmostZero(Cross))
   {
    Cross = Cross.normalize();
    if (DeltaC2.dot(Cross)<0)
     Cross *= -1.f;


#ifdef TEST_INTERNAL_OBJECTS
    gExpectedNbTests++;
    if (gUseInternalObject && !TestInternalObjects(transA, transB, DeltaC2, Cross, hullA, hullB, dmin))
     continue;
    gActualNbTests++;
#endif

    btScalar dist;
    btVector3 wA, wB;
    if (!TestSepAxis(hullA, hullB, transA, transB, Cross, dist, wA, wB))
     return false;

    if (dist<dmin)
    {
     dmin = dist;
     sep = Cross;
     edgeA = e0;
     edgeB = e1;
     worldEdgeA = WorldEdge0;
     worldEdgeB = WorldEdge1;
     witnessPointA = wA;
     witnessPointB = wB;
    }
   }
  }

 }

 if (edgeA >= 0 && edgeB >= 0)
 {
  //		printf("edge-edge\n");
  //add an edge-edge contact

  btVector3 ptsVector;
  btVector3 offsetA;
  btVector3 offsetB;
  btScalar tA;
  btScalar tB;

  btVector3 translation = witnessPointB - witnessPointA;

  btVector3 dirA = worldEdgeA;
  btVector3 dirB = worldEdgeB;

  btScalar hlenB = 1e30f;
  btScalar hlenA = 1e30f;

  btSegmentsClosestPoints(ptsVector, offsetA, offsetB, tA, tB,
   translation,
   dirA, hlenA,
   dirB, hlenB);

  btScalar nlSqrt = ptsVector.length2();
  if (nlSqrt>SIMD_EPSILON)
  {
   btScalar nl = btSqrt(nlSqrt);
   ptsVector *= 1.f / nl;
   if (ptsVector.dot(DeltaC2)<0.f)
   {
    ptsVector *= -1.f;
   }
   btVector3 ptOnB = witnessPointB + offsetB;
   btScalar distance = nl;
   resultOut.addContactPoint(ptsVector, ptOnB, -distance);
  }

 }


 if ((DeltaC2.dot(sep))<0.0f)
  sep = -sep;

 return true;
}

void	btPolyhedralContactClipping::clipFaceAgainstHull(const btVector3& separatingNormal, const btConvexPolyhedron& hullA, const btTransform& transA, btVertexArray& worldVertsB1, btVertexArray& worldVertsB2, const btScalar minDist, btScalar maxDist, btDiscreteCollisionDetectorInterface::Result& resultOut)
{
 worldVertsB2.resize(0);
 btVertexArray* pVtxIn = &worldVertsB1;
 btVertexArray* pVtxOut = &worldVertsB2;
 pVtxOut->reserve(pVtxIn->size());

 int closestFaceA = -1;
 {
  btScalar dmin = FLT_MAX;
  for (int face = 0; face<hullA.m_faces.size(); face++)
  {
   const btVector3 Normal(hullA.m_faces[face].m_plane[0], hullA.m_faces[face].m_plane[1], hullA.m_faces[face].m_plane[2]);
   const btVector3 faceANormalWS = transA.getBasis() * Normal;

   btScalar d = faceANormalWS.dot(separatingNormal);
   if (d < dmin)
   {
    dmin = d;
    closestFaceA = face;
   }
  }
 }
 if (closestFaceA<0)
  return;

 const btFace& polyA = hullA.m_faces[closestFaceA];

 // clip polygon to back of planes of all faces of hull A that are adjacent to witness face
 int numVerticesA = polyA.m_indices.size();
 for (int e0 = 0; e0<numVerticesA; e0++)
 {
  const btVector3& a = hullA.m_vertices[polyA.m_indices[e0]];
  const btVector3& b = hullA.m_vertices[polyA.m_indices[(e0 + 1) % numVerticesA]];
  const btVector3 edge0 = a - b;
  const btVector3 WorldEdge0 = transA.getBasis() * edge0;
  btVector3 worldPlaneAnormal1 = transA.getBasis()* btVector3(polyA.m_plane[0], polyA.m_plane[1], polyA.m_plane[2]);

  btVector3 planeNormalWS1 = -WorldEdge0.cross(worldPlaneAnormal1);//.cross(WorldEdge0);
  btVector3 worldA1 = transA*a;
  btScalar planeEqWS1 = -worldA1.dot(planeNormalWS1);

  //int otherFace=0;
#ifdef BLA1
  int otherFace = polyA.m_connectedFaces[e0];
  btVector3 localPlaneNormal(hullA.m_faces[otherFace].m_plane[0], hullA.m_faces[otherFace].m_plane[1], hullA.m_faces[otherFace].m_plane[2]);
  btScalar localPlaneEq = hullA.m_faces[otherFace].m_plane[3];

  btVector3 planeNormalWS = transA.getBasis()*localPlaneNormal;
  btScalar planeEqWS = localPlaneEq - planeNormalWS.dot(transA.getOrigin());
#else 
  btVector3 planeNormalWS = planeNormalWS1;
  btScalar planeEqWS = planeEqWS1;

#endif
  //clip face

  clipFace(*pVtxIn, *pVtxOut, planeNormalWS, planeEqWS);
  btSwap(pVtxIn, pVtxOut);
  pVtxOut->resize(0);
 }



 //#define ONLY_REPORT_DEEPEST_POINT

 btVector3 point;


 // only keep points that are behind the witness face
 {
  btVector3 localPlaneNormal(polyA.m_plane[0], polyA.m_plane[1], polyA.m_plane[2]);
  btScalar localPlaneEq = polyA.m_plane[3];
  btVector3 planeNormalWS = transA.getBasis()*localPlaneNormal;
  btScalar planeEqWS = localPlaneEq - planeNormalWS.dot(transA.getOrigin());
  for (int i = 0; i<pVtxIn->size(); i++)
  {
   btVector3 vtx = pVtxIn->at(i);
   btScalar depth = planeNormalWS.dot(vtx) + planeEqWS;
   if (depth <= minDist)
   {
    //				printf("clamped: depth=%f to minDist=%f\n",depth,minDist);
    depth = minDist;
   }

   if (depth <= maxDist)
   {
    btVector3 point = pVtxIn->at(i);
#ifdef ONLY_REPORT_DEEPEST_POINT
    curMaxDist = depth;
#else
#if 0
    if (depth<-3)
    {
     printf("error in btPolyhedralContactClipping depth = %f\n", depth);
     printf("likely wrong separatingNormal passed in\n");
    }
#endif				
    resultOut.addContactPoint(separatingNormal, point, depth);
#endif
   }
  }
 }
#ifdef ONLY_REPORT_DEEPEST_POINT
 if (curMaxDist<maxDist)
 {
  resultOut.addContactPoint(separatingNormal, point, curMaxDist);
 }
#endif //ONLY_REPORT_DEEPEST_POINT

}





void	btPolyhedralContactClipping::clipHullAgainstHull(const btVector3& separatingNormal1, const btConvexPolyhedron& hullA, const btConvexPolyhedron& hullB, const btTransform& transA, const btTransform& transB, const btScalar minDist, btScalar maxDist, btVertexArray& worldVertsB1, btVertexArray& worldVertsB2, btDiscreteCollisionDetectorInterface::Result& resultOut)
{

 btVector3 separatingNormal = separatingNormal1.normalized();
 //	const btVector3 c0 = transA * hullA.m_localCenter;
 //	const btVector3 c1 = transB * hullB.m_localCenter;
 //const btVector3 DeltaC2 = c0 - c1;



 int closestFaceB = -1;
 btScalar dmax = -FLT_MAX;
 {
  for (int face = 0; face<hullB.m_faces.size(); face++)
  {
   const btVector3 Normal(hullB.m_faces[face].m_plane[0], hullB.m_faces[face].m_plane[1], hullB.m_faces[face].m_plane[2]);
   const btVector3 WorldNormal = transB.getBasis() * Normal;
   btScalar d = WorldNormal.dot(separatingNormal);
   if (d > dmax)
   {
    dmax = d;
    closestFaceB = face;
   }
  }
 }
 worldVertsB1.resize(0);
 {
  const btFace& polyB = hullB.m_faces[closestFaceB];
  const int numVertices = polyB.m_indices.size();
  for (int e0 = 0; e0<numVertices; e0++)
  {
   const btVector3& b = hullB.m_vertices[polyB.m_indices[e0]];
   worldVertsB1.push_back(transB*b);
  }
 }


 if (closestFaceB >= 0)
  clipFaceAgainstHull(separatingNormal, hullA, transA, worldVertsB1, worldVertsB2, minDist, maxDist, resultOut);

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//#include <stdio.h>

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"

btTriangleRaycastCallback::btTriangleRaycastCallback(const btVector3& from, const btVector3& to, unsigned int flags)
 :
 m_from(from),
 m_to(to),
 //@BP Mod
 m_flags(flags),
 m_hitFraction(btScalar(1.))
{

}



void btTriangleRaycastCallback::processTriangle(btVector3* triangle, int partId, int triangleIndex)
{
 const btVector3 &vert0 = triangle[0];
 const btVector3 &vert1 = triangle[1];
 const btVector3 &vert2 = triangle[2];

 btVector3 v10; v10 = vert1 - vert0;
 btVector3 v20; v20 = vert2 - vert0;

 btVector3 triangleNormal; triangleNormal = v10.cross(v20);

 const btScalar dist = vert0.dot(triangleNormal);
 btScalar dist_a = triangleNormal.dot(m_from);
 dist_a -= dist;
 btScalar dist_b = triangleNormal.dot(m_to);
 dist_b -= dist;

 if (dist_a * dist_b >= btScalar(0.0))
 {
  return; // same sign
 }

 if (((m_flags & kF_FilterBackfaces) != 0) && (dist_a <= btScalar(0.0)))
 {
  // Backface, skip check
  return;
 }


 const btScalar proj_length = dist_a - dist_b;
 const btScalar distance = (dist_a) / (proj_length);
 // Now we have the intersection point on the plane, we'll see if it's inside the triangle
 // Add an epsilon as a tolerance for the raycast,
 // in case the ray hits exacly on the edge of the triangle.
 // It must be scaled for the triangle size.

 if (distance < m_hitFraction)
 {


  btScalar edge_tolerance = triangleNormal.length2();
  edge_tolerance *= btScalar(-0.0001);
  btVector3 point; point.setInterpolate3(m_from, m_to, distance);
  {
   btVector3 v0p; v0p = vert0 - point;
   btVector3 v1p; v1p = vert1 - point;
   btVector3 cp0; cp0 = v0p.cross(v1p);

   if ((btScalar)(cp0.dot(triangleNormal)) >= edge_tolerance)
   {


    btVector3 v2p; v2p = vert2 - point;
    btVector3 cp1;
    cp1 = v1p.cross(v2p);
    if ((btScalar)(cp1.dot(triangleNormal)) >= edge_tolerance)
    {
     btVector3 cp2;
     cp2 = v2p.cross(v0p);

     if ((btScalar)(cp2.dot(triangleNormal)) >= edge_tolerance)
     {
      //@BP Mod
      // Triangle normal isn't normalized
      triangleNormal.normalize();

      //@BP Mod - Allow for unflipped normal when raycasting against backfaces
      if (((m_flags & kF_KeepUnflippedNormal) == 0) && (dist_a <= btScalar(0.0)))
      {
       m_hitFraction = reportHit(-triangleNormal, distance, partId, triangleIndex);
      }
      else
      {
       m_hitFraction = reportHit(triangleNormal, distance, partId, triangleIndex);
      }
     }
    }
   }
  }
 }
}


btTriangleConvexcastCallback::btTriangleConvexcastCallback(const btConvexShape* convexShape, const btTransform& convexShapeFrom, const btTransform& convexShapeTo, const btTransform& triangleToWorld, const btScalar triangleCollisionMargin)
{
 m_convexShape = convexShape;
 m_convexShapeFrom = convexShapeFrom;
 m_convexShapeTo = convexShapeTo;
 m_triangleToWorld = triangleToWorld;
 m_hitFraction = 1.0f;
 m_triangleCollisionMargin = triangleCollisionMargin;
 m_allowedPenetration = 0.f;
}

void
btTriangleConvexcastCallback::processTriangle(btVector3* triangle, int partId, int triangleIndex)
{
 btTriangleShape triangleShape(triangle[0], triangle[1], triangle[2]);
 triangleShape.setMargin(m_triangleCollisionMargin);

 btVoronoiSimplexSolver	simplexSolver;
 btGjkEpaPenetrationDepthSolver	gjkEpaPenetrationSolver;

 //#define  USE_SUBSIMPLEX_CONVEX_CAST 1
 //if you reenable USE_SUBSIMPLEX_CONVEX_CAST see commented out code below
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
 btSubsimplexConvexCast convexCaster(m_convexShape, &triangleShape, &simplexSolver);
#else
 //btGjkConvexCast	convexCaster(m_convexShape,&triangleShape,&simplexSolver);
 btContinuousConvexCollision convexCaster(m_convexShape, &triangleShape, &simplexSolver, &gjkEpaPenetrationSolver);
#endif //#USE_SUBSIMPLEX_CONVEX_CAST

 btConvexCast::CastResult castResult;
 castResult.m_fraction = btScalar(1.);
 castResult.m_allowedPenetration = m_allowedPenetration;
 if (convexCaster.calcTimeOfImpact(m_convexShapeFrom, m_convexShapeTo, m_triangleToWorld, m_triangleToWorld, castResult))
 {
  //add hit
  if (castResult.m_normal.length2() > btScalar(0.0001))
  {
   if (castResult.m_fraction < m_hitFraction)
   {
    /* btContinuousConvexCast's normal is already in world space */
    /*
    #ifdef USE_SUBSIMPLEX_CONVEX_CAST
    //rotate normal into worldspace
    castResult.m_normal = m_convexShapeFrom.getBasis() * castResult.m_normal;
    #endif //USE_SUBSIMPLEX_CONVEX_CAST
    */
    castResult.m_normal.normalize();

    reportHit(castResult.m_normal,
     castResult.m_hitPoint,
     castResult.m_fraction,
     partId,
     triangleIndex);
   }
  }
 }
}

#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "LinearMath/btMinMax.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"



//response  between two dynamic objects without friction and no restitution, assuming 0 penetration depth
btScalar resolveSingleCollision(
 btRigidBody* body1,
 btCollisionObject* colObj2,
 const btVector3& contactPositionWorld,
 const btVector3& contactNormalOnB,
 const btContactSolverInfo& solverInfo,
 btScalar distance)
{
 btRigidBody* body2 = btRigidBody::upcast(colObj2);


 const btVector3& normal = contactNormalOnB;

 btVector3 rel_pos1 = contactPositionWorld - body1->getWorldTransform().getOrigin();
 btVector3 rel_pos2 = contactPositionWorld - colObj2->getWorldTransform().getOrigin();

 btVector3 vel1 = body1->getVelocityInLocalPoint(rel_pos1);
 btVector3 vel2 = body2 ? body2->getVelocityInLocalPoint(rel_pos2) : btVector3(0, 0, 0);
 btVector3 vel = vel1 - vel2;
 btScalar rel_vel;
 rel_vel = normal.dot(vel);

 btScalar combinedRestitution = 0.f;
 btScalar restitution = combinedRestitution* -rel_vel;

 btScalar positionalError = solverInfo.m_erp *-distance / solverInfo.m_timeStep;
 btScalar velocityError = -(1.0f + restitution) * rel_vel;// * damping;
 btScalar denom0 = body1->computeImpulseDenominator(contactPositionWorld, normal);
 btScalar denom1 = body2 ? body2->computeImpulseDenominator(contactPositionWorld, normal) : 0.f;
 btScalar relaxation = 1.f;
 btScalar jacDiagABInv = relaxation / (denom0 + denom1);

 btScalar penetrationImpulse = positionalError * jacDiagABInv;
 btScalar velocityImpulse = velocityError * jacDiagABInv;

 btScalar normalImpulse = penetrationImpulse + velocityImpulse;
 normalImpulse = 0.f > normalImpulse ? 0.f : normalImpulse;

 body1->applyImpulse(normal*(normalImpulse), rel_pos1);
 if (body2)
  body2->applyImpulse(-normal*(normalImpulse), rel_pos2);

 return normalImpulse;
}


//bilateral constraint between two dynamic objects
void resolveSingleBilateral(btRigidBody& body1, const btVector3& pos1,
 btRigidBody& body2, const btVector3& pos2,
 btScalar distance, const btVector3& normal, btScalar& impulse, btScalar timeStep)
{
 (void)timeStep;
 (void)distance;


 btScalar normalLenSqr = normal.length2();
 btAssert(btFabs(normalLenSqr) < btScalar(1.1));
 if (normalLenSqr > btScalar(1.1))
 {
  impulse = btScalar(0.);
  return;
 }
 btVector3 rel_pos1 = pos1 - body1.getCenterOfMassPosition();
 btVector3 rel_pos2 = pos2 - body2.getCenterOfMassPosition();
 //this jacobian entry could be re-used for all iterations

 btVector3 vel1 = body1.getVelocityInLocalPoint(rel_pos1);
 btVector3 vel2 = body2.getVelocityInLocalPoint(rel_pos2);
 btVector3 vel = vel1 - vel2;


 btJacobianEntry jac(body1.getCenterOfMassTransform().getBasis().transpose(),
  body2.getCenterOfMassTransform().getBasis().transpose(),
  rel_pos1, rel_pos2, normal, body1.getInvInertiaDiagLocal(), body1.getInvMass(),
  body2.getInvInertiaDiagLocal(), body2.getInvMass());

 btScalar jacDiagAB = jac.getDiagonal();
 btScalar jacDiagABInv = btScalar(1.) / jacDiagAB;

 btScalar rel_vel = jac.getRelativeVelocity(
  body1.getLinearVelocity(),
  body1.getCenterOfMassTransform().getBasis().transpose() * body1.getAngularVelocity(),
  body2.getLinearVelocity(),
  body2.getCenterOfMassTransform().getBasis().transpose() * body2.getAngularVelocity());



 rel_vel = normal.dot(vel);

 //todo: move this into proper structure
 btScalar contactDamping = btScalar(0.2);

#ifdef ONLY_USE_LINEAR_MASS
 btScalar massTerm = btScalar(1.) / (body1.getInvMass() + body2.getInvMass());
 impulse = -contactDamping * rel_vel * massTerm;
#else	
 btScalar velocityImpulse = -contactDamping * rel_vel * jacDiagABInv;
 impulse = velocityImpulse;
#endif
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/ConstraintSolver/btFixedConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include <new>


btFixedConstraint::btFixedConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB)
 :btGeneric6DofSpring2Constraint(rbA, rbB, frameInA, frameInB)
{
 setAngularLowerLimit(btVector3(0, 0, 0));
 setAngularUpperLimit(btVector3(0, 0, 0));
 setLinearLowerLimit(btVector3(0, 0, 0));
 setLinearUpperLimit(btVector3(0, 0, 0));
}




btFixedConstraint::~btFixedConstraint()
{
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2012 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/// Implemented by Erwin Coumans. The idea for the constraint comes from Dimitris Papavasiliou.

#include "BulletDynamics/ConstraintSolver/btGearConstraint.h"

btGearConstraint::btGearConstraint(btRigidBody& rbA, btRigidBody& rbB, const btVector3& axisInA, const btVector3& axisInB, btScalar ratio)
 :btTypedConstraint(GEAR_CONSTRAINT_TYPE, rbA, rbB),
 m_axisInA(axisInA),
 m_axisInB(axisInB),
 m_ratio(ratio)
{
}

btGearConstraint::~btGearConstraint()
{
}

void btGearConstraint::getInfo1(btConstraintInfo1* info)
{
 info->m_numConstraintRows = 1;
 info->nub = 1;
}

void btGearConstraint::getInfo2(btConstraintInfo2* info)
{
 btVector3 globalAxisA, globalAxisB;

 globalAxisA = m_rbA.getWorldTransform().getBasis()*this->m_axisInA;
 globalAxisB = m_rbB.getWorldTransform().getBasis()*this->m_axisInB;

 info->m_J1angularAxis[0] = globalAxisA[0];
 info->m_J1angularAxis[1] = globalAxisA[1];
 info->m_J1angularAxis[2] = globalAxisA[2];

 info->m_J2angularAxis[0] = m_ratio*globalAxisB[0];
 info->m_J2angularAxis[1] = m_ratio*globalAxisB[1];
 info->m_J2angularAxis[2] = m_ratio*globalAxisB[2];

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
/*
2007-09-09
Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btTransformUtil.h"
#include <new>



#define D6_USE_OBSOLETE_METHOD false
#define D6_USE_FRAME_OFFSET true






btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA)
 : btTypedConstraint(D6_CONSTRAINT_TYPE, rbA, rbB)
 , m_frameInA(frameInA)
 , m_frameInB(frameInB),
 m_useLinearReferenceFrameA(useLinearReferenceFrameA),
 m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET),
 m_flags(0),
 m_useSolveConstraintObsolete(D6_USE_OBSOLETE_METHOD)
{
 calculateTransforms();
}



btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbB, const btTransform& frameInB, bool useLinearReferenceFrameB)
 : btTypedConstraint(D6_CONSTRAINT_TYPE, getFixedBody(), rbB),
 m_frameInB(frameInB),
 m_useLinearReferenceFrameA(useLinearReferenceFrameB),
 m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET),
 m_flags(0),
 m_useSolveConstraintObsolete(false)
{
 ///not providing rigidbody A means implicitly using worldspace for body A
 m_frameInA = rbB.getCenterOfMassTransform() * m_frameInB;
 calculateTransforms();
}




#define GENERIC_D6_DISABLE_WARMSTARTING 1



btScalar btGetMatrixElem(const btMatrix3x3& mat, int index);
btScalar btGetMatrixElem(const btMatrix3x3& mat, int index)
{
 int i = index % 3;
 int j = index / 3;
 return mat[i][j];
}



///MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
bool	matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz);
bool	matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz)
{
 //	// rot =  cy*cz          -cy*sz           sy
 //	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
 //	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
 //

 btScalar fi = btGetMatrixElem(mat, 2);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAtan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 8));
   xyz[1] = btAsin(btGetMatrixElem(mat, 2));
   xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
   return true;
  }
  else
  {
   // WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
   xyz[0] = -btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
   xyz[1] = -SIMD_HALF_PI;
   xyz[2] = btScalar(0.0);
   return false;
  }
 }
 else
 {
  // WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
  xyz[0] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
  xyz[1] = SIMD_HALF_PI;
  xyz[2] = 0.0;
 }
 return false;
}

//////////////////////////// btRotationalLimitMotor ////////////////////////////////////

int btRotationalLimitMotor::testLimitValue(btScalar test_value)
{
 if (m_loLimit>m_hiLimit)
 {
  m_currentLimit = 0;//Free from violation
  return 0;
 }
 if (test_value < m_loLimit)
 {
  m_currentLimit = 1;//low limit violation
  m_currentLimitError = test_value - m_loLimit;
  if (m_currentLimitError>SIMD_PI)
   m_currentLimitError -= SIMD_2_PI;
  else if (m_currentLimitError<-SIMD_PI)
   m_currentLimitError += SIMD_2_PI;
  return 1;
 }
 else if (test_value> m_hiLimit)
 {
  m_currentLimit = 2;//High limit violation
  m_currentLimitError = test_value - m_hiLimit;
  if (m_currentLimitError>SIMD_PI)
   m_currentLimitError -= SIMD_2_PI;
  else if (m_currentLimitError<-SIMD_PI)
   m_currentLimitError += SIMD_2_PI;
  return 2;
 };

 m_currentLimit = 0;//Free from violation
 return 0;

}



btScalar btRotationalLimitMotor::solveAngularLimits(
 btScalar timeStep, btVector3& axis, btScalar jacDiagABInv,
 btRigidBody * body0, btRigidBody * body1)
{
 if (needApplyTorques() == false) return 0.0f;

 btScalar target_velocity = m_targetVelocity;
 btScalar maxMotorForce = m_maxMotorForce;

 //current error correction
 if (m_currentLimit != 0)
 {
  target_velocity = -m_stopERP*m_currentLimitError / (timeStep);
  maxMotorForce = m_maxLimitForce;
 }

 maxMotorForce *= timeStep;

 // current velocity difference

 btVector3 angVelA = body0->getAngularVelocity();
 btVector3 angVelB = body1->getAngularVelocity();

 btVector3 vel_diff;
 vel_diff = angVelA - angVelB;



 btScalar rel_vel = axis.dot(vel_diff);

 // correction velocity
 btScalar motor_relvel = m_limitSoftness*(target_velocity - m_damping*rel_vel);


 if (motor_relvel < SIMD_EPSILON && motor_relvel > -SIMD_EPSILON)
 {
  return 0.0f;//no need for applying force
 }


 // correction impulse
 btScalar unclippedMotorImpulse = (1 + m_bounce)*motor_relvel*jacDiagABInv;

 // clip correction impulse
 btScalar clippedMotorImpulse;

 ///@todo: should clip against accumulated impulse
 if (unclippedMotorImpulse>0.0f)
 {
  clippedMotorImpulse = unclippedMotorImpulse > maxMotorForce ? maxMotorForce : unclippedMotorImpulse;
 }
 else
 {
  clippedMotorImpulse = unclippedMotorImpulse < -maxMotorForce ? -maxMotorForce : unclippedMotorImpulse;
 }


 // sort with accumulated impulses
 btScalar	lo = btScalar(-BT_LARGE_FLOAT);
 btScalar	hi = btScalar(BT_LARGE_FLOAT);

 btScalar oldaccumImpulse = m_accumulatedImpulse;
 btScalar sum = oldaccumImpulse + clippedMotorImpulse;
 m_accumulatedImpulse = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;

 clippedMotorImpulse = m_accumulatedImpulse - oldaccumImpulse;

 btVector3 motorImp = clippedMotorImpulse * axis;

 body0->applyTorqueImpulse(motorImp);
 body1->applyTorqueImpulse(-motorImp);

 return clippedMotorImpulse;


}

//////////////////////////// End btRotationalLimitMotor ////////////////////////////////////




//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////


int btTranslationalLimitMotor::testLimitValue(int limitIndex, btScalar test_value)
{
 btScalar loLimit = m_lowerLimit[limitIndex];
 btScalar hiLimit = m_upperLimit[limitIndex];
 if (loLimit > hiLimit)
 {
  m_currentLimit[limitIndex] = 0;//Free from violation
  m_currentLimitError[limitIndex] = btScalar(0.f);
  return 0;
 }

 if (test_value < loLimit)
 {
  m_currentLimit[limitIndex] = 2;//low limit violation
  m_currentLimitError[limitIndex] = test_value - loLimit;
  return 2;
 }
 else if (test_value> hiLimit)
 {
  m_currentLimit[limitIndex] = 1;//High limit violation
  m_currentLimitError[limitIndex] = test_value - hiLimit;
  return 1;
 };

 m_currentLimit[limitIndex] = 0;//Free from violation
 m_currentLimitError[limitIndex] = btScalar(0.f);
 return 0;
}



btScalar btTranslationalLimitMotor::solveLinearAxis(
 btScalar timeStep,
 btScalar jacDiagABInv,
 btRigidBody& body1, const btVector3 &pointInA,
 btRigidBody& body2, const btVector3 &pointInB,
 int limit_index,
 const btVector3 & axis_normal_on_a,
 const btVector3 & anchorPos)
{

 ///find relative velocity
 //    btVector3 rel_pos1 = pointInA - body1.getCenterOfMassPosition();
 //    btVector3 rel_pos2 = pointInB - body2.getCenterOfMassPosition();
 btVector3 rel_pos1 = anchorPos - body1.getCenterOfMassPosition();
 btVector3 rel_pos2 = anchorPos - body2.getCenterOfMassPosition();

 btVector3 vel1 = body1.getVelocityInLocalPoint(rel_pos1);
 btVector3 vel2 = body2.getVelocityInLocalPoint(rel_pos2);
 btVector3 vel = vel1 - vel2;

 btScalar rel_vel = axis_normal_on_a.dot(vel);



 /// apply displacement correction

 //positional error (zeroth order error)
 btScalar depth = -(pointInA - pointInB).dot(axis_normal_on_a);
 btScalar	lo = btScalar(-BT_LARGE_FLOAT);
 btScalar	hi = btScalar(BT_LARGE_FLOAT);

 btScalar minLimit = m_lowerLimit[limit_index];
 btScalar maxLimit = m_upperLimit[limit_index];

 //handle the limits
 if (minLimit < maxLimit)
 {
  {
   if (depth > maxLimit)
   {
    depth -= maxLimit;
    lo = btScalar(0.);

   }
   else
   {
    if (depth < minLimit)
    {
     depth -= minLimit;
     hi = btScalar(0.);
    }
    else
    {
     return 0.0f;
    }
   }
  }
 }

 btScalar normalImpulse = m_limitSoftness*(m_restitution*depth / timeStep - m_damping*rel_vel) * jacDiagABInv;




 btScalar oldNormalImpulse = m_accumulatedImpulse[limit_index];
 btScalar sum = oldNormalImpulse + normalImpulse;
 m_accumulatedImpulse[limit_index] = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;
 normalImpulse = m_accumulatedImpulse[limit_index] - oldNormalImpulse;

 btVector3 impulse_vector = axis_normal_on_a * normalImpulse;
 body1.applyImpulse(impulse_vector, rel_pos1);
 body2.applyImpulse(-impulse_vector, rel_pos2);



 return normalImpulse;
}

//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////

void btGeneric6DofConstraint::calculateAngleInfo()
{
 btMatrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse()*m_calculatedTransformB.getBasis();
 matrixToEulerXYZ(relative_frame, m_calculatedAxisAngleDiff);
 // in euler angle mode we do not actually constrain the angular velocity
 // along the axes axis[0] and axis[2] (although we do use axis[1]) :
 //
 //    to get			constrain w2-w1 along		...not
 //    ------			---------------------		------
 //    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
 //    d(angle[1])/dt = 0	ax[1]
 //    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
 //
 // constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
 // to prove the result for angle[0], write the expression for angle[0] from
 // GetInfo1 then take the derivative. to prove this for angle[2] it is
 // easier to take the euler rate expression for d(angle[2])/dt with respect
 // to the components of w and set that to 0.
 btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
 btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);

 m_calculatedAxis[1] = axis2.cross(axis0);
 m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
 m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);

 m_calculatedAxis[0].normalize();
 m_calculatedAxis[1].normalize();
 m_calculatedAxis[2].normalize();

}

void btGeneric6DofConstraint::calculateTransforms()
{
 calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

void btGeneric6DofConstraint::calculateTransforms(const btTransform& transA, const btTransform& transB)
{
 m_calculatedTransformA = transA * m_frameInA;
 m_calculatedTransformB = transB * m_frameInB;
 calculateLinearInfo();
 calculateAngleInfo();
 if (m_useOffsetForConstraintFrame)
 {	//  get weight factors depending on masses
  btScalar miA = getRigidBodyA().getInvMass();
  btScalar miB = getRigidBodyB().getInvMass();
  m_hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
  btScalar miS = miA + miB;
  if (miS > btScalar(0.f))
  {
   m_factA = miB / miS;
  }
  else
  {
   m_factA = btScalar(0.5f);
  }
  m_factB = btScalar(1.0f) - m_factA;
 }
}



void btGeneric6DofConstraint::buildLinearJacobian(
 btJacobianEntry & jacLinear, const btVector3 & normalWorld,
 const btVector3 & pivotAInW, const btVector3 & pivotBInW)
{
 new (&jacLinear) btJacobianEntry(
  m_rbA.getCenterOfMassTransform().getBasis().transpose(),
  m_rbB.getCenterOfMassTransform().getBasis().transpose(),
  pivotAInW - m_rbA.getCenterOfMassPosition(),
  pivotBInW - m_rbB.getCenterOfMassPosition(),
  normalWorld,
  m_rbA.getInvInertiaDiagLocal(),
  m_rbA.getInvMass(),
  m_rbB.getInvInertiaDiagLocal(),
  m_rbB.getInvMass());
}



void btGeneric6DofConstraint::buildAngularJacobian(
 btJacobianEntry & jacAngular, const btVector3 & jointAxisW)
{
 new (&jacAngular)	btJacobianEntry(jointAxisW,
  m_rbA.getCenterOfMassTransform().getBasis().transpose(),
  m_rbB.getCenterOfMassTransform().getBasis().transpose(),
  m_rbA.getInvInertiaDiagLocal(),
  m_rbB.getInvInertiaDiagLocal());

}



bool btGeneric6DofConstraint::testAngularLimitMotor(int axis_index)
{
 btScalar angle = m_calculatedAxisAngleDiff[axis_index];
 angle = btAdjustAngleToLimits(angle, m_angularLimits[axis_index].m_loLimit, m_angularLimits[axis_index].m_hiLimit);
 m_angularLimits[axis_index].m_currentPosition = angle;
 //test limits
 m_angularLimits[axis_index].testLimitValue(angle);
 return m_angularLimits[axis_index].needApplyTorques();
}



void btGeneric6DofConstraint::buildJacobian()
{
#ifndef __SPU__
 if (m_useSolveConstraintObsolete)
 {

  // Clear accumulated impulses for the next simulation step
  m_linearLimits.m_accumulatedImpulse.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
  int i;
  for (i = 0; i < 3; i++)
  {
   m_angularLimits[i].m_accumulatedImpulse = btScalar(0.);
  }
  //calculates transform
  calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());

  //  const btVector3& pivotAInW = m_calculatedTransformA.getOrigin();
  //  const btVector3& pivotBInW = m_calculatedTransformB.getOrigin();
  calcAnchorPos();
  btVector3 pivotAInW = m_AnchorPos;
  btVector3 pivotBInW = m_AnchorPos;

  // not used here
  //    btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
  //    btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

  btVector3 normalWorld;
  //linear part
  for (i = 0; i<3; i++)
  {
   if (m_linearLimits.isLimited(i))
   {
    if (m_useLinearReferenceFrameA)
     normalWorld = m_calculatedTransformA.getBasis().getColumn(i);
    else
     normalWorld = m_calculatedTransformB.getBasis().getColumn(i);

    buildLinearJacobian(
     m_jacLinear[i], normalWorld,
     pivotAInW, pivotBInW);

   }
  }

  // angular part
  for (i = 0; i<3; i++)
  {
   //calculates error angle
   if (testAngularLimitMotor(i))
   {
    normalWorld = this->getAxis(i);
    // Create angular atom
    buildAngularJacobian(m_jacAng[i], normalWorld);
   }
  }

 }
#endif //__SPU__

}


void btGeneric6DofConstraint::getInfo1(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  //prepare constraint
  calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
  info->m_numConstraintRows = 0;
  info->nub = 6;
  int i;
  //test linear limits
  for (i = 0; i < 3; i++)
  {
   if (m_linearLimits.needApplyForce(i))
   {
    info->m_numConstraintRows++;
    info->nub--;
   }
  }
  //test angular limits
  for (i = 0; i<3; i++)
  {
   if (testAngularLimitMotor(i))
   {
    info->m_numConstraintRows++;
    info->nub--;
   }
  }
 }
}

void btGeneric6DofConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  //pre-allocate all 6
  info->m_numConstraintRows = 6;
  info->nub = 0;
 }
}


void btGeneric6DofConstraint::getInfo2(btConstraintInfo2* info)
{
 btAssert(!m_useSolveConstraintObsolete);

 const btTransform& transA = m_rbA.getCenterOfMassTransform();
 const btTransform& transB = m_rbB.getCenterOfMassTransform();
 const btVector3& linVelA = m_rbA.getLinearVelocity();
 const btVector3& linVelB = m_rbB.getLinearVelocity();
 const btVector3& angVelA = m_rbA.getAngularVelocity();
 const btVector3& angVelB = m_rbB.getAngularVelocity();

 if (m_useOffsetForConstraintFrame)
 { // for stability better to solve angular limits first
  int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
 else
 { // leave old version for compatibility
  int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }

}


void btGeneric6DofConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{

 btAssert(!m_useSolveConstraintObsolete);
 //prepare constraint
 calculateTransforms(transA, transB);

 int i;
 for (i = 0; i<3; i++)
 {
  testAngularLimitMotor(i);
 }

 if (m_useOffsetForConstraintFrame)
 { // for stability better to solve angular limits first
  int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
 else
 { // leave old version for compatibility
  int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
  setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
 }
}



int btGeneric6DofConstraint::setLinearLimits(btConstraintInfo2* info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
 //	int row = 0;
 //solve linear limits
 btRotationalLimitMotor limot;
 for (int i = 0; i<3; i++)
 {
  if (m_linearLimits.needApplyForce(i))
  { // re-use rotational motor code
   limot.m_bounce = btScalar(0.f);
   limot.m_currentLimit = m_linearLimits.m_currentLimit[i];
   limot.m_currentPosition = m_linearLimits.m_currentLinearDiff[i];
   limot.m_currentLimitError = m_linearLimits.m_currentLimitError[i];
   limot.m_damping = m_linearLimits.m_damping;
   limot.m_enableMotor = m_linearLimits.m_enableMotor[i];
   limot.m_hiLimit = m_linearLimits.m_upperLimit[i];
   limot.m_limitSoftness = m_linearLimits.m_limitSoftness;
   limot.m_loLimit = m_linearLimits.m_lowerLimit[i];
   limot.m_maxLimitForce = btScalar(0.f);
   limot.m_maxMotorForce = m_linearLimits.m_maxMotorForce[i];
   limot.m_targetVelocity = m_linearLimits.m_targetVelocity[i];
   btVector3 axis = m_calculatedTransformA.getBasis().getColumn(i);
   int flags = m_flags >> (i * BT_6DOF_FLAGS_AXIS_SHIFT);
   limot.m_normalCFM = (flags & BT_6DOF_FLAGS_CFM_NORM) ? m_linearLimits.m_normalCFM[i] : info->cfm[0];
   limot.m_stopCFM = (flags & BT_6DOF_FLAGS_CFM_STOP) ? m_linearLimits.m_stopCFM[i] : info->cfm[0];
   limot.m_stopERP = (flags & BT_6DOF_FLAGS_ERP_STOP) ? m_linearLimits.m_stopERP[i] : info->erp;
   if (m_useOffsetForConstraintFrame)
   {
    int indx1 = (i + 1) % 3;
    int indx2 = (i + 2) % 3;
    int rotAllowed = 1; // rotations around orthos to current axis
    if (m_angularLimits[indx1].m_currentLimit && m_angularLimits[indx2].m_currentLimit)
    {
     rotAllowed = 0;
    }
    row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0, rotAllowed);
   }
   else
   {
    row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0);
   }
  }
 }
 return row;
}



int btGeneric6DofConstraint::setAngularLimits(btConstraintInfo2 *info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
 btGeneric6DofConstraint * d6constraint = this;
 int row = row_offset;
 //solve angular limits
 for (int i = 0; i<3; i++)
 {
  if (d6constraint->getRotationalLimitMotor(i)->needApplyTorques())
  {
   btVector3 axis = d6constraint->getAxis(i);
   int flags = m_flags >> ((i + 3) * BT_6DOF_FLAGS_AXIS_SHIFT);
   if (!(flags & BT_6DOF_FLAGS_CFM_NORM))
   {
    m_angularLimits[i].m_normalCFM = info->cfm[0];
   }
   if (!(flags & BT_6DOF_FLAGS_CFM_STOP))
   {
    m_angularLimits[i].m_stopCFM = info->cfm[0];
   }
   if (!(flags & BT_6DOF_FLAGS_ERP_STOP))
   {
    m_angularLimits[i].m_stopERP = info->erp;
   }
   row += get_limit_motor_info2(d6constraint->getRotationalLimitMotor(i),
    transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 1);
  }
 }

 return row;
}




void	btGeneric6DofConstraint::updateRHS(btScalar	timeStep)
{
 (void)timeStep;

}


void btGeneric6DofConstraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
 m_frameInA = frameA;
 m_frameInB = frameB;
 buildJacobian();
 calculateTransforms();
}



btVector3 btGeneric6DofConstraint::getAxis(int axis_index) const
{
 return m_calculatedAxis[axis_index];
}


btScalar	btGeneric6DofConstraint::getRelativePivotPosition(int axisIndex) const
{
 return m_calculatedLinearDiff[axisIndex];
}


btScalar btGeneric6DofConstraint::getAngle(int axisIndex) const
{
 return m_calculatedAxisAngleDiff[axisIndex];
}



void btGeneric6DofConstraint::calcAnchorPos(void)
{
 btScalar imA = m_rbA.getInvMass();
 btScalar imB = m_rbB.getInvMass();
 btScalar weight;
 if (imB == btScalar(0.0))
 {
  weight = btScalar(1.0);
 }
 else
 {
  weight = imA / (imA + imB);
 }
 const btVector3& pA = m_calculatedTransformA.getOrigin();
 const btVector3& pB = m_calculatedTransformB.getOrigin();
 m_AnchorPos = pA * weight + pB * (btScalar(1.0) - weight);
 return;
}



void btGeneric6DofConstraint::calculateLinearInfo()
{
 m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
 m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
 for (int i = 0; i < 3; i++)
 {
  m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
  m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
 }
}



int btGeneric6DofConstraint::get_limit_motor_info2(
 btRotationalLimitMotor * limot,
 const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
 btConstraintInfo2 *info, int row, btVector3& ax1, int rotational, int rotAllowed)
{
 int srow = row * info->rowskip;
 bool powered = limot->m_enableMotor;
 int limit = limot->m_currentLimit;
 if (powered || limit)
 {   // if the joint is powered, or has joint limits, add in the extra row
  btScalar *J1 = rotational ? info->m_J1angularAxis : info->m_J1linearAxis;
  btScalar *J2 = rotational ? info->m_J2angularAxis : info->m_J2linearAxis;
  J1[srow + 0] = ax1[0];
  J1[srow + 1] = ax1[1];
  J1[srow + 2] = ax1[2];

  J2[srow + 0] = -ax1[0];
  J2[srow + 1] = -ax1[1];
  J2[srow + 2] = -ax1[2];

  if ((!rotational))
  {
   if (m_useOffsetForConstraintFrame)
   {
    btVector3 tmpA, tmpB, relA, relB;
    // get vector from bodyB to frameB in WCS
    relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
    // get its projection to constraint axis
    btVector3 projB = ax1 * relB.dot(ax1);
    // get vector directed from bodyB to constraint axis (and orthogonal to it)
    btVector3 orthoB = relB - projB;
    // same for bodyA
    relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
    btVector3 projA = ax1 * relA.dot(ax1);
    btVector3 orthoA = relA - projA;
    // get desired offset between frames A and B along constraint axis
    btScalar desiredOffs = limot->m_currentPosition - limot->m_currentLimitError;
    // desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis
    btVector3 totalDist = projA + ax1 * desiredOffs - projB;
    // get offset vectors relA and relB
    relA = orthoA + totalDist * m_factA;
    relB = orthoB - totalDist * m_factB;
    tmpA = relA.cross(ax1);
    tmpB = relB.cross(ax1);
    if (m_hasStaticBody && (!rotAllowed))
    {
     tmpA *= m_factA;
     tmpB *= m_factB;
    }
    int i;
    for (i = 0; i<3; i++) info->m_J1angularAxis[srow + i] = tmpA[i];
    for (i = 0; i<3; i++) info->m_J2angularAxis[srow + i] = -tmpB[i];
   }
   else
   {
    btVector3 ltd;	// Linear Torque Decoupling vector
    btVector3 c = m_calculatedTransformB.getOrigin() - transA.getOrigin();
    ltd = c.cross(ax1);
    info->m_J1angularAxis[srow + 0] = ltd[0];
    info->m_J1angularAxis[srow + 1] = ltd[1];
    info->m_J1angularAxis[srow + 2] = ltd[2];

    c = m_calculatedTransformB.getOrigin() - transB.getOrigin();
    ltd = -c.cross(ax1);
    info->m_J2angularAxis[srow + 0] = ltd[0];
    info->m_J2angularAxis[srow + 1] = ltd[1];
    info->m_J2angularAxis[srow + 2] = ltd[2];
   }
  }
  // if we're limited low and high simultaneously, the joint motor is
  // ineffective
  if (limit && (limot->m_loLimit == limot->m_hiLimit)) powered = false;
  info->m_constraintError[srow] = btScalar(0.f);
  if (powered)
  {
   info->cfm[srow] = limot->m_normalCFM;
   if (!limit)
   {
    btScalar tag_vel = rotational ? limot->m_targetVelocity : -limot->m_targetVelocity;

    btScalar mot_fact = getMotorFactor(limot->m_currentPosition,
     limot->m_loLimit,
     limot->m_hiLimit,
     tag_vel,
     info->fps * limot->m_stopERP);
    info->m_constraintError[srow] += mot_fact * limot->m_targetVelocity;
    info->m_lowerLimit[srow] = -limot->m_maxMotorForce;
    info->m_upperLimit[srow] = limot->m_maxMotorForce;
   }
  }
  if (limit)
  {
   btScalar k = info->fps * limot->m_stopERP;
   if (!rotational)
   {
    info->m_constraintError[srow] += k * limot->m_currentLimitError;
   }
   else
   {
    info->m_constraintError[srow] += -k * limot->m_currentLimitError;
   }
   info->cfm[srow] = limot->m_stopCFM;
   if (limot->m_loLimit == limot->m_hiLimit)
   {   // limited low and high simultaneously
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else
   {
    if (limit == 1)
    {
     info->m_lowerLimit[srow] = 0;
     info->m_upperLimit[srow] = SIMD_INFINITY;
    }
    else
    {
     info->m_lowerLimit[srow] = -SIMD_INFINITY;
     info->m_upperLimit[srow] = 0;
    }
    // deal with bounce
    if (limot->m_bounce > 0)
    {
     // calculate joint velocity
     btScalar vel;
     if (rotational)
     {
      vel = angVelA.dot(ax1);
      //make sure that if no body -> angVelB == zero vec
      //                        if (body1)
      vel -= angVelB.dot(ax1);
     }
     else
     {
      vel = linVelA.dot(ax1);
      //make sure that if no body -> angVelB == zero vec
      //                        if (body1)
      vel -= linVelB.dot(ax1);
     }
     // only apply bounce if the velocity is incoming, and if the
     // resulting c[] exceeds what we already have.
     if (limit == 1)
     {
      if (vel < 0)
      {
       btScalar newc = -limot->m_bounce* vel;
       if (newc > info->m_constraintError[srow])
        info->m_constraintError[srow] = newc;
      }
     }
     else
     {
      if (vel > 0)
      {
       btScalar newc = -limot->m_bounce * vel;
       if (newc < info->m_constraintError[srow])
        info->m_constraintError[srow] = newc;
      }
     }
    }
   }
  }
  return 1;
 }
 else return 0;
}






///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void btGeneric6DofConstraint::setParam(int num, btScalar value, int axis)
{
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   m_linearLimits.m_stopERP[axis] = value;
   m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case BT_CONSTRAINT_STOP_CFM:
   m_linearLimits.m_stopCFM[axis] = value;
   m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case BT_CONSTRAINT_CFM:
   m_linearLimits.m_normalCFM[axis] = value;
   m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   m_angularLimits[axis - 3].m_stopERP = value;
   m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case BT_CONSTRAINT_STOP_CFM:
   m_angularLimits[axis - 3].m_stopCFM = value;
   m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  case BT_CONSTRAINT_CFM:
   m_angularLimits[axis - 3].m_normalCFM = value;
   m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
}

///return the local value of parameter
btScalar btGeneric6DofConstraint::getParam(int num, int axis) const
{
 btScalar retVal = 0;
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_stopERP[axis];
   break;
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_stopCFM[axis];
   break;
  case BT_CONSTRAINT_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_linearLimits.m_normalCFM[axis];
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_stopERP;
   break;
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_stopCFM;
   break;
  case BT_CONSTRAINT_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
   retVal = m_angularLimits[axis - 3].m_normalCFM;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
 return retVal;
}



void btGeneric6DofConstraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
 btVector3 zAxis = axis1.normalized();
 btVector3 yAxis = axis2.normalized();
 btVector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system

 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);

 // now get constraint frame in local coordinate systems
 m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

 calculateTransforms();
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
2014 May: btGeneric6DofSpring2Constraint is created from the original (2.82.2712) btGeneric6DofConstraint by Gabor Puhr and Tamas Umenhoffer
Pros:
- Much more accurate and stable in a lot of situation. (Especially when a sleeping chain of RBs connected with 6dof2 is pulled)
- Stable and accurate spring with minimal energy loss that works with all of the solvers. (latter is not true for the original 6dof spring)
- Servo motor functionality
- Much more accurate bouncing. 0 really means zero bouncing (not true for the original 6odf) and there is only a minimal energy loss when the value is 1 (because of the solvers' precision)
- Rotation order for the Euler system can be set. (One axis' freedom is still limited to pi/2)

Cons:
- It is slower than the original 6dof. There is no exact ratio, but half speed is a good estimation. (with PGS)
- At bouncing the correct velocity is calculated, but not the correct position. (it is because of the solver can correct position or velocity, but not both.)
*/

/// 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/// Added support for generic constraint solver through getInfo1/getInfo2 methods

/*
2007-09-09
btGeneric6DofConstraint Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/



#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include <new>



btGeneric6DofSpring2Constraint::btGeneric6DofSpring2Constraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, RotateOrder rotOrder)
 : btTypedConstraint(D6_SPRING_2_CONSTRAINT_TYPE, rbA, rbB)
 , m_frameInA(frameInA)
 , m_frameInB(frameInB)
 , m_rotateOrder(rotOrder)
 , m_flags(0)
{
 calculateTransforms();
}


btGeneric6DofSpring2Constraint::btGeneric6DofSpring2Constraint(btRigidBody& rbB, const btTransform& frameInB, RotateOrder rotOrder)
 : btTypedConstraint(D6_SPRING_2_CONSTRAINT_TYPE, getFixedBody(), rbB)
 , m_frameInB(frameInB)
 , m_rotateOrder(rotOrder)
 , m_flags(0)
{
 ///not providing rigidbody A means implicitly using worldspace for body A
 m_frameInA = rbB.getCenterOfMassTransform() * m_frameInB;
 calculateTransforms();
}


btScalar btGeneric6DofSpring2Constraint::btGetMatrixElem(const btMatrix3x3& mat, int index)
{
 int i = index % 3;
 int j = index / 3;
 return mat[i][j];
}

// MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html

bool btGeneric6DofSpring2Constraint::matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cy*cz          -cy*sz           sy
 //        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
 //       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy

 btScalar fi = btGetMatrixElem(mat, 2);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAtan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 8));
   xyz[1] = btAsin(btGetMatrixElem(mat, 2));
   xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
   return true;
  }
  else
  {
   // WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
   xyz[0] = -btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
   xyz[1] = -SIMD_HALF_PI;
   xyz[2] = btScalar(0.0);
   return false;
  }
 }
 else
 {
  // WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
  xyz[0] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
  xyz[1] = SIMD_HALF_PI;
  xyz[2] = 0.0;
 }
 return false;
}

bool btGeneric6DofSpring2Constraint::matrixToEulerXZY(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cy*cz          -sz           sy*cz
 //        cy*cx*sz+sx*sy  cx*cz        sy*cx*sz-cy*sx
 //        cy*sx*sz-cx*sy  sx*cz        sy*sx*sz+cx*cy

 btScalar fi = btGetMatrixElem(mat, 1);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAtan2(btGetMatrixElem(mat, 7), btGetMatrixElem(mat, 4));
   xyz[1] = btAtan2(btGetMatrixElem(mat, 2), btGetMatrixElem(mat, 0));
   xyz[2] = btAsin(-btGetMatrixElem(mat, 1));
   return true;
  }
  else
  {
   xyz[0] = -btAtan2(-btGetMatrixElem(mat, 6), btGetMatrixElem(mat, 8));
   xyz[1] = btScalar(0.0);
   xyz[2] = SIMD_HALF_PI;
   return false;
  }
 }
 else
 {
  xyz[0] = btAtan2(-btGetMatrixElem(mat, 6), btGetMatrixElem(mat, 8));
  xyz[1] = 0.0;
  xyz[2] = -SIMD_HALF_PI;
 }
 return false;
}

bool btGeneric6DofSpring2Constraint::matrixToEulerYXZ(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cy*cz+sy*sx*sz  cz*sy*sx-cy*sz  cx*sy
 //        cx*sz           cx*cz           -sx
 //        cy*sx*sz-cz*sy  sy*sz+cy*cz*sx  cy*cx

 btScalar fi = btGetMatrixElem(mat, 5);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAsin(-btGetMatrixElem(mat, 5));
   xyz[1] = btAtan2(btGetMatrixElem(mat, 2), btGetMatrixElem(mat, 8));
   xyz[2] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
   return true;
  }
  else
  {
   xyz[0] = SIMD_HALF_PI;
   xyz[1] = -btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
   xyz[2] = btScalar(0.0);
   return false;
  }
 }
 else
 {
  xyz[0] = -SIMD_HALF_PI;
  xyz[1] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
  xyz[2] = 0.0;
 }
 return false;
}

bool btGeneric6DofSpring2Constraint::matrixToEulerYZX(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cy*cz   sy*sx-cy*cx*sz   cx*sy+cy*sz*sx
 //        sz           cz*cx           -cz*sx
 //        -cz*sy  cy*sx+cx*sy*sz   cy*cx-sy*sz*sx

 btScalar fi = btGetMatrixElem(mat, 3);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAtan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 4));
   xyz[1] = btAtan2(-btGetMatrixElem(mat, 6), btGetMatrixElem(mat, 0));
   xyz[2] = btAsin(btGetMatrixElem(mat, 3));
   return true;
  }
  else
  {
   xyz[0] = btScalar(0.0);
   xyz[1] = -btAtan2(btGetMatrixElem(mat, 7), btGetMatrixElem(mat, 8));
   xyz[2] = -SIMD_HALF_PI;
   return false;
  }
 }
 else
 {
  xyz[0] = btScalar(0.0);
  xyz[1] = btAtan2(btGetMatrixElem(mat, 7), btGetMatrixElem(mat, 8));
  xyz[2] = SIMD_HALF_PI;
 }
 return false;
}

bool btGeneric6DofSpring2Constraint::matrixToEulerZXY(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cz*cy-sz*sx*sy    -cx*sz   cz*sy+cy*sz*sx
 //        cy*sz+cz*sx*sy     cz*cx   sz*sy-cz*xy*sx
 //        -cx*sy              sx     cx*cy

 btScalar fi = btGetMatrixElem(mat, 7);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAsin(btGetMatrixElem(mat, 7));
   xyz[1] = btAtan2(-btGetMatrixElem(mat, 6), btGetMatrixElem(mat, 8));
   xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 4));
   return true;
  }
  else
  {
   xyz[0] = -SIMD_HALF_PI;
   xyz[1] = btScalar(0.0);
   xyz[2] = -btAtan2(btGetMatrixElem(mat, 2), btGetMatrixElem(mat, 0));
   return false;
  }
 }
 else
 {
  xyz[0] = SIMD_HALF_PI;
  xyz[1] = btScalar(0.0);
  xyz[2] = btAtan2(btGetMatrixElem(mat, 2), btGetMatrixElem(mat, 0));
 }
 return false;
}

bool btGeneric6DofSpring2Constraint::matrixToEulerZYX(const btMatrix3x3& mat, btVector3& xyz)
{
 // rot =  cz*cy   cz*sy*sx-cx*sz   sz*sx+cz*cx*sy
 //        cy*sz   cz*cx+sz*sy*sx   cx*sz*sy-cz*sx
 //        -sy          cy*sx         cy*cx

 btScalar fi = btGetMatrixElem(mat, 6);
 if (fi < btScalar(1.0f))
 {
  if (fi > btScalar(-1.0f))
  {
   xyz[0] = btAtan2(btGetMatrixElem(mat, 7), btGetMatrixElem(mat, 8));
   xyz[1] = btAsin(-btGetMatrixElem(mat, 6));
   xyz[2] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 0));
   return true;
  }
  else
  {
   xyz[0] = btScalar(0.0);
   xyz[1] = SIMD_HALF_PI;
   xyz[2] = -btAtan2(btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 2));
   return false;
  }
 }
 else
 {
  xyz[0] = btScalar(0.0);
  xyz[1] = -SIMD_HALF_PI;
  xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), -btGetMatrixElem(mat, 2));
 }
 return false;
}

void btGeneric6DofSpring2Constraint::calculateAngleInfo()
{
 btMatrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse()*m_calculatedTransformB.getBasis();
 switch (m_rotateOrder)
 {
 case RO_XYZ: matrixToEulerXYZ(relative_frame, m_calculatedAxisAngleDiff); break;
 case RO_XZY: matrixToEulerXZY(relative_frame, m_calculatedAxisAngleDiff); break;
 case RO_YXZ: matrixToEulerYXZ(relative_frame, m_calculatedAxisAngleDiff); break;
 case RO_YZX: matrixToEulerYZX(relative_frame, m_calculatedAxisAngleDiff); break;
 case RO_ZXY: matrixToEulerZXY(relative_frame, m_calculatedAxisAngleDiff); break;
 case RO_ZYX: matrixToEulerZYX(relative_frame, m_calculatedAxisAngleDiff); break;
 default: btAssert(false);
 }
 // in euler angle mode we do not actually constrain the angular velocity
 // along the axes axis[0] and axis[2] (although we do use axis[1]) :
 //
 //    to get			constrain w2-w1 along		...not
 //    ------			---------------------		------
 //    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
 //    d(angle[1])/dt = 0	ax[1]
 //    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
 //
 // constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
 // to prove the result for angle[0], write the expression for angle[0] from
 // GetInfo1 then take the derivative. to prove this for angle[2] it is
 // easier to take the euler rate expression for d(angle[2])/dt with respect
 // to the components of w and set that to 0.
 switch (m_rotateOrder)
 {
 case RO_XYZ:
 {
  //Is this the "line of nodes" calculation choosing planes YZ (B coordinate system) and xy (A coordinate system)? (http://en.wikipedia.org/wiki/Euler_angles)
  //The two planes are non-homologous, so this is a Tait?ryan angle formalism and not a proper Euler
  //Extrinsic rotations are equal to the reversed order intrinsic rotations so the above xyz extrinsic rotations (axes are fixed) are the same as the zy'x" intrinsic rotations (axes are refreshed after each rotation)
  //that is why xy and YZ planes are chosen (this will describe a zy'x" intrinsic rotation) (see the figure on the left at http://en.wikipedia.org/wiki/Euler_angles under Tait?ryan angles)
  // x' = Nperp = N.cross(axis2)
  // y' = N = axis2.cross(axis0)	
  // z' = z
  //
  // x" = X
  // y" = y'
  // z" = ??
  //in other words:
  //first rotate around z
  //second rotate around y'= z.cross(X)
  //third rotate around x" = X
  //Original XYZ extrinsic rotation order. 
  //Planes: xy and YZ normals: z, X.  Plane intersection (N) is z.cross(X)
  btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
  btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);
  m_calculatedAxis[1] = axis2.cross(axis0);
  m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
  m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);
  break;
 }
 case RO_XZY:
 {
  //planes: xz,ZY normals: y, X
  //first rotate around y
  //second rotate around z'= y.cross(X)
  //third rotate around x" = X
  btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
  btVector3 axis1 = m_calculatedTransformA.getBasis().getColumn(1);
  m_calculatedAxis[2] = axis0.cross(axis1);
  m_calculatedAxis[0] = axis1.cross(m_calculatedAxis[2]);
  m_calculatedAxis[1] = m_calculatedAxis[2].cross(axis0);
  break;
 }
 case RO_YXZ:
 {
  //planes: yx,XZ normals: z, Y
  //first rotate around z
  //second rotate around x'= z.cross(Y)
  //third rotate around y" = Y
  btVector3 axis1 = m_calculatedTransformB.getBasis().getColumn(1);
  btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);
  m_calculatedAxis[0] = axis1.cross(axis2);
  m_calculatedAxis[1] = axis2.cross(m_calculatedAxis[0]);
  m_calculatedAxis[2] = m_calculatedAxis[0].cross(axis1);
  break;
 }
 case RO_YZX:
 {
  //planes: yz,ZX normals: x, Y
  //first rotate around x
  //second rotate around z'= x.cross(Y)
  //third rotate around y" = Y
  btVector3 axis0 = m_calculatedTransformA.getBasis().getColumn(0);
  btVector3 axis1 = m_calculatedTransformB.getBasis().getColumn(1);
  m_calculatedAxis[2] = axis0.cross(axis1);
  m_calculatedAxis[0] = axis1.cross(m_calculatedAxis[2]);
  m_calculatedAxis[1] = m_calculatedAxis[2].cross(axis0);
  break;
 }
 case RO_ZXY:
 {
  //planes: zx,XY normals: y, Z
  //first rotate around y
  //second rotate around x'= y.cross(Z)
  //third rotate around z" = Z
  btVector3 axis1 = m_calculatedTransformA.getBasis().getColumn(1);
  btVector3 axis2 = m_calculatedTransformB.getBasis().getColumn(2);
  m_calculatedAxis[0] = axis1.cross(axis2);
  m_calculatedAxis[1] = axis2.cross(m_calculatedAxis[0]);
  m_calculatedAxis[2] = m_calculatedAxis[0].cross(axis1);
  break;
 }
 case RO_ZYX:
 {
  //planes: zy,YX normals: x, Z
  //first rotate around x
  //second rotate around y' = x.cross(Z)
  //third rotate around z" = Z
  btVector3 axis0 = m_calculatedTransformA.getBasis().getColumn(0);
  btVector3 axis2 = m_calculatedTransformB.getBasis().getColumn(2);
  m_calculatedAxis[1] = axis2.cross(axis0);
  m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
  m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);
  break;
 }
 default:
  btAssert(false);
 }

 m_calculatedAxis[0].normalize();
 m_calculatedAxis[1].normalize();
 m_calculatedAxis[2].normalize();

}

void btGeneric6DofSpring2Constraint::calculateTransforms()
{
 calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

void btGeneric6DofSpring2Constraint::calculateTransforms(const btTransform& transA, const btTransform& transB)
{
 m_calculatedTransformA = transA * m_frameInA;
 m_calculatedTransformB = transB * m_frameInB;
 calculateLinearInfo();
 calculateAngleInfo();

 btScalar miA = getRigidBodyA().getInvMass();
 btScalar miB = getRigidBodyB().getInvMass();
 m_hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
 btScalar miS = miA + miB;
 if (miS > btScalar(0.f))
 {
  m_factA = miB / miS;
 }
 else
 {
  m_factA = btScalar(0.5f);
 }
 m_factB = btScalar(1.0f) - m_factA;
}


void btGeneric6DofSpring2Constraint::testAngularLimitMotor(int axis_index)
{
 btScalar angle = m_calculatedAxisAngleDiff[axis_index];
 angle = btAdjustAngleToLimits(angle, m_angularLimits[axis_index].m_loLimit, m_angularLimits[axis_index].m_hiLimit);
 m_angularLimits[axis_index].m_currentPosition = angle;
 m_angularLimits[axis_index].testLimitValue(angle);
}


void btGeneric6DofSpring2Constraint::getInfo1(btConstraintInfo1* info)
{
 //prepare constraint
 calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
 info->m_numConstraintRows = 0;
 info->nub = 0;
 int i;
 //test linear limits
 for (i = 0; i < 3; i++)
 {
  if (m_linearLimits.m_currentLimit[i] == 4) info->m_numConstraintRows += 2;
  else if (m_linearLimits.m_currentLimit[i] != 0) info->m_numConstraintRows += 1;
  if (m_linearLimits.m_enableMotor[i]) info->m_numConstraintRows += 1;
  if (m_linearLimits.m_enableSpring[i]) info->m_numConstraintRows += 1;
 }
 //test angular limits
 for (i = 0; i<3; i++)
 {
  testAngularLimitMotor(i);
  if (m_angularLimits[i].m_currentLimit == 4) info->m_numConstraintRows += 2;
  else if (m_angularLimits[i].m_currentLimit != 0) info->m_numConstraintRows += 1;
  if (m_angularLimits[i].m_enableMotor) info->m_numConstraintRows += 1;
  if (m_angularLimits[i].m_enableSpring) info->m_numConstraintRows += 1;
 }
}


void btGeneric6DofSpring2Constraint::getInfo2(btConstraintInfo2* info)
{
 const btTransform& transA = m_rbA.getCenterOfMassTransform();
 const btTransform& transB = m_rbB.getCenterOfMassTransform();
 const btVector3& linVelA = m_rbA.getLinearVelocity();
 const btVector3& linVelB = m_rbB.getLinearVelocity();
 const btVector3& angVelA = m_rbA.getAngularVelocity();
 const btVector3& angVelB = m_rbB.getAngularVelocity();

 // for stability better to solve angular limits first
 int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
 setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
}


int btGeneric6DofSpring2Constraint::setLinearLimits(btConstraintInfo2* info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
 //solve linear limits
 btRotationalLimitMotor2 limot;
 for (int i = 0; i<3; i++)
 {
  if (m_linearLimits.m_currentLimit[i] || m_linearLimits.m_enableMotor[i] || m_linearLimits.m_enableSpring[i])
  { // re-use rotational motor code
   limot.m_bounce = m_linearLimits.m_bounce[i];
   limot.m_currentLimit = m_linearLimits.m_currentLimit[i];
   limot.m_currentPosition = m_linearLimits.m_currentLinearDiff[i];
   limot.m_currentLimitError = m_linearLimits.m_currentLimitError[i];
   limot.m_currentLimitErrorHi = m_linearLimits.m_currentLimitErrorHi[i];
   limot.m_enableMotor = m_linearLimits.m_enableMotor[i];
   limot.m_servoMotor = m_linearLimits.m_servoMotor[i];
   limot.m_servoTarget = m_linearLimits.m_servoTarget[i];
   limot.m_enableSpring = m_linearLimits.m_enableSpring[i];
   limot.m_springStiffness = m_linearLimits.m_springStiffness[i];
   limot.m_springStiffnessLimited = m_linearLimits.m_springStiffnessLimited[i];
   limot.m_springDamping = m_linearLimits.m_springDamping[i];
   limot.m_springDampingLimited = m_linearLimits.m_springDampingLimited[i];
   limot.m_equilibriumPoint = m_linearLimits.m_equilibriumPoint[i];
   limot.m_hiLimit = m_linearLimits.m_upperLimit[i];
   limot.m_loLimit = m_linearLimits.m_lowerLimit[i];
   limot.m_maxMotorForce = m_linearLimits.m_maxMotorForce[i];
   limot.m_targetVelocity = m_linearLimits.m_targetVelocity[i];
   btVector3 axis = m_calculatedTransformA.getBasis().getColumn(i);
   int flags = m_flags >> (i * BT_6DOF_FLAGS_AXIS_SHIFT2);
   limot.m_stopCFM = (flags & BT_6DOF_FLAGS_CFM_STOP2) ? m_linearLimits.m_stopCFM[i] : info->cfm[0];
   limot.m_stopERP = (flags & BT_6DOF_FLAGS_ERP_STOP2) ? m_linearLimits.m_stopERP[i] : info->erp;
   limot.m_motorCFM = (flags & BT_6DOF_FLAGS_CFM_MOTO2) ? m_linearLimits.m_motorCFM[i] : info->cfm[0];
   limot.m_motorERP = (flags & BT_6DOF_FLAGS_ERP_MOTO2) ? m_linearLimits.m_motorERP[i] : info->erp;

   //rotAllowed is a bit of a magic from the original 6dof. The calculation of it here is something that imitates the original behavior as much as possible.
   int indx1 = (i + 1) % 3;
   int indx2 = (i + 2) % 3;
   int rotAllowed = 1; // rotations around orthos to current axis (it is used only when one of the body is static)
#define D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION 1.0e-3
   bool indx1Violated = m_angularLimits[indx1].m_currentLimit == 1 ||
    m_angularLimits[indx1].m_currentLimit == 2 ||
    (m_angularLimits[indx1].m_currentLimit == 3 && (m_angularLimits[indx1].m_currentLimitError < -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx1].m_currentLimitError > D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION)) ||
    (m_angularLimits[indx1].m_currentLimit == 4 && (m_angularLimits[indx1].m_currentLimitError < -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx1].m_currentLimitErrorHi > D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION));
   bool indx2Violated = m_angularLimits[indx2].m_currentLimit == 1 ||
    m_angularLimits[indx2].m_currentLimit == 2 ||
    (m_angularLimits[indx2].m_currentLimit == 3 && (m_angularLimits[indx2].m_currentLimitError < -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx2].m_currentLimitError > D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION)) ||
    (m_angularLimits[indx2].m_currentLimit == 4 && (m_angularLimits[indx2].m_currentLimitError < -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx2].m_currentLimitErrorHi > D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION));
   if (indx1Violated && indx2Violated)
   {
    rotAllowed = 0;
   }
   row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0, rotAllowed);

  }
 }
 return row;
}



int btGeneric6DofSpring2Constraint::setAngularLimits(btConstraintInfo2 *info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
 int row = row_offset;

 //order of rotational constraint rows
 int cIdx[] = { 0, 1, 2 };
 switch (m_rotateOrder)
 {
 case RO_XYZ: cIdx[0] = 0; cIdx[1] = 1; cIdx[2] = 2; break;
 case RO_XZY: cIdx[0] = 0; cIdx[1] = 2; cIdx[2] = 1; break;
 case RO_YXZ: cIdx[0] = 1; cIdx[1] = 0; cIdx[2] = 2; break;
 case RO_YZX: cIdx[0] = 1; cIdx[1] = 2; cIdx[2] = 0; break;
 case RO_ZXY: cIdx[0] = 2; cIdx[1] = 0; cIdx[2] = 1; break;
 case RO_ZYX: cIdx[0] = 2; cIdx[1] = 1; cIdx[2] = 0; break;
 default: btAssert(false);
 }

 for (int ii = 0; ii < 3; ii++)
 {
  int i = cIdx[ii];
  if (m_angularLimits[i].m_currentLimit || m_angularLimits[i].m_enableMotor || m_angularLimits[i].m_enableSpring)
  {
   btVector3 axis = getAxis(i);
   int flags = m_flags >> ((i + 3) * BT_6DOF_FLAGS_AXIS_SHIFT2);
   if (!(flags & BT_6DOF_FLAGS_CFM_STOP2))
   {
    m_angularLimits[i].m_stopCFM = info->cfm[0];
   }
   if (!(flags & BT_6DOF_FLAGS_ERP_STOP2))
   {
    m_angularLimits[i].m_stopERP = info->erp;
   }
   if (!(flags & BT_6DOF_FLAGS_CFM_MOTO2))
   {
    m_angularLimits[i].m_motorCFM = info->cfm[0];
   }
   if (!(flags & BT_6DOF_FLAGS_ERP_MOTO2))
   {
    m_angularLimits[i].m_motorERP = info->erp;
   }
   row += get_limit_motor_info2(&m_angularLimits[i], transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 1);
  }
 }

 return row;
}


void btGeneric6DofSpring2Constraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
 m_frameInA = frameA;
 m_frameInB = frameB;
 buildJacobian();
 calculateTransforms();
}


void btGeneric6DofSpring2Constraint::calculateLinearInfo()
{
 m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
 m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
 for (int i = 0; i < 3; i++)
 {
  m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
  m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
 }
}

void btGeneric6DofSpring2Constraint::calculateJacobi(btRotationalLimitMotor2 * limot, const btTransform& transA, const btTransform& transB, btConstraintInfo2 *info, int srow, btVector3& ax1, int rotational, int rotAllowed)
{
 btScalar *J1 = rotational ? info->m_J1angularAxis : info->m_J1linearAxis;
 btScalar *J2 = rotational ? info->m_J2angularAxis : info->m_J2linearAxis;

 J1[srow + 0] = ax1[0];
 J1[srow + 1] = ax1[1];
 J1[srow + 2] = ax1[2];

 J2[srow + 0] = -ax1[0];
 J2[srow + 1] = -ax1[1];
 J2[srow + 2] = -ax1[2];

 if (!rotational)
 {
  btVector3 tmpA, tmpB, relA, relB;
  // get vector from bodyB to frameB in WCS
  relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
  // same for bodyA
  relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
  tmpA = relA.cross(ax1);
  tmpB = relB.cross(ax1);
  if (m_hasStaticBody && (!rotAllowed))
  {
   tmpA *= m_factA;
   tmpB *= m_factB;
  }
  int i;
  for (i = 0; i<3; i++) info->m_J1angularAxis[srow + i] = tmpA[i];
  for (i = 0; i<3; i++) info->m_J2angularAxis[srow + i] = -tmpB[i];
 }
}


int btGeneric6DofSpring2Constraint::get_limit_motor_info2(
 btRotationalLimitMotor2 * limot,
 const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
 btConstraintInfo2 *info, int row, btVector3& ax1, int rotational, int rotAllowed)
{
 int count = 0;
 int srow = row * info->rowskip;

 if (limot->m_currentLimit == 4)
 {
  btScalar vel = rotational ? angVelA.dot(ax1) - angVelB.dot(ax1) : linVelA.dot(ax1) - linVelB.dot(ax1);

  calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);
  info->m_constraintError[srow] = info->fps * limot->m_stopERP * limot->m_currentLimitError * (rotational ? -1 : 1);
  if (rotational) {
   if (info->m_constraintError[srow] - vel*limot->m_stopERP > 0) {
    btScalar bounceerror = -limot->m_bounce* vel;
    if (bounceerror > info->m_constraintError[srow]) info->m_constraintError[srow] = bounceerror;
   }
  }
  else {
   if (info->m_constraintError[srow] - vel*limot->m_stopERP < 0) {
    btScalar bounceerror = -limot->m_bounce* vel;
    if (bounceerror < info->m_constraintError[srow]) info->m_constraintError[srow] = bounceerror;
   }
  }
  info->m_lowerLimit[srow] = rotational ? 0 : -SIMD_INFINITY;
  info->m_upperLimit[srow] = rotational ? SIMD_INFINITY : 0;
  info->cfm[srow] = limot->m_stopCFM;
  srow += info->rowskip;
  ++count;

  calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);
  info->m_constraintError[srow] = info->fps * limot->m_stopERP * limot->m_currentLimitErrorHi * (rotational ? -1 : 1);
  if (rotational) {
   if (info->m_constraintError[srow] - vel*limot->m_stopERP < 0) {
    btScalar bounceerror = -limot->m_bounce* vel;
    if (bounceerror < info->m_constraintError[srow]) info->m_constraintError[srow] = bounceerror;
   }
  }
  else {
   if (info->m_constraintError[srow] - vel*limot->m_stopERP > 0) {
    btScalar bounceerror = -limot->m_bounce* vel;
    if (bounceerror > info->m_constraintError[srow]) info->m_constraintError[srow] = bounceerror;
   }
  }
  info->m_lowerLimit[srow] = rotational ? -SIMD_INFINITY : 0;
  info->m_upperLimit[srow] = rotational ? 0 : SIMD_INFINITY;
  info->cfm[srow] = limot->m_stopCFM;
  srow += info->rowskip;
  ++count;
 }
 else
  if (limot->m_currentLimit == 3)
  {
   calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);
   info->m_constraintError[srow] = info->fps * limot->m_stopERP * limot->m_currentLimitError * (rotational ? -1 : 1);
   info->m_lowerLimit[srow] = -SIMD_INFINITY;
   info->m_upperLimit[srow] = SIMD_INFINITY;
   info->cfm[srow] = limot->m_stopCFM;
   srow += info->rowskip;
   ++count;
  }

 if (limot->m_enableMotor && !limot->m_servoMotor)
 {
  calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);
  btScalar tag_vel = rotational ? limot->m_targetVelocity : -limot->m_targetVelocity;
  btScalar mot_fact = getMotorFactor(limot->m_currentPosition,
   limot->m_loLimit,
   limot->m_hiLimit,
   tag_vel,
   info->fps * limot->m_motorERP);
  info->m_constraintError[srow] = mot_fact * limot->m_targetVelocity;
  info->m_lowerLimit[srow] = -limot->m_maxMotorForce;
  info->m_upperLimit[srow] = limot->m_maxMotorForce;
  info->cfm[srow] = limot->m_motorCFM;
  srow += info->rowskip;
  ++count;
 }

 if (limot->m_enableMotor && limot->m_servoMotor)
 {
  btScalar error = limot->m_currentPosition - limot->m_servoTarget;
  btScalar curServoTarget = limot->m_servoTarget;
  if (rotational)
  {
   if (error > SIMD_PI)
   {
    error -= SIMD_2_PI;
    curServoTarget += SIMD_2_PI;
   }
   if (error < -SIMD_PI)
   {
    error += SIMD_2_PI;
    curServoTarget -= SIMD_2_PI;
   }
  }

  calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);
  btScalar targetvelocity = error<0 ? -limot->m_targetVelocity : limot->m_targetVelocity;
  btScalar tag_vel = -targetvelocity;
  btScalar mot_fact;
  if (error != 0)
  {
   btScalar lowLimit;
   btScalar hiLimit;
   if (limot->m_loLimit > limot->m_hiLimit)
   {
    lowLimit = error > 0 ? curServoTarget : -SIMD_INFINITY;
    hiLimit = error < 0 ? curServoTarget : SIMD_INFINITY;
   }
   else
   {
    lowLimit = error > 0 && curServoTarget>limot->m_loLimit ? curServoTarget : limot->m_loLimit;
    hiLimit = error < 0 && curServoTarget<limot->m_hiLimit ? curServoTarget : limot->m_hiLimit;
   }
   mot_fact = getMotorFactor(limot->m_currentPosition, lowLimit, hiLimit, tag_vel, info->fps * limot->m_motorERP);
  }
  else
  {
   mot_fact = 0;
  }
  info->m_constraintError[srow] = mot_fact * targetvelocity * (rotational ? -1 : 1);
  info->m_lowerLimit[srow] = -limot->m_maxMotorForce;
  info->m_upperLimit[srow] = limot->m_maxMotorForce;
  info->cfm[srow] = limot->m_motorCFM;
  srow += info->rowskip;
  ++count;
 }

 if (limot->m_enableSpring)
 {
  btScalar error = limot->m_currentPosition - limot->m_equilibriumPoint;
  calculateJacobi(limot, transA, transB, info, srow, ax1, rotational, rotAllowed);

  //btScalar cfm = 1.0 / ((1.0/info->fps)*limot->m_springStiffness+ limot->m_springDamping);
  //if(cfm > 0.99999)
  //	cfm = 0.99999;
  //btScalar erp = (1.0/info->fps)*limot->m_springStiffness / ((1.0/info->fps)*limot->m_springStiffness + limot->m_springDamping);
  //info->m_constraintError[srow] = info->fps * erp * error * (rotational ? -1.0 : 1.0);
  //info->m_lowerLimit[srow] = -SIMD_INFINITY;
  //info->m_upperLimit[srow] = SIMD_INFINITY;

  btScalar dt = BT_ONE / info->fps;
  btScalar kd = limot->m_springDamping;
  btScalar ks = limot->m_springStiffness;
  btScalar vel = rotational ? angVelA.dot(ax1) - angVelB.dot(ax1) : linVelA.dot(ax1) - linVelB.dot(ax1);
  //		btScalar erp = 0.1;
  btScalar cfm = BT_ZERO;
  btScalar mA = BT_ONE / m_rbA.getInvMass();
  btScalar mB = BT_ONE / m_rbB.getInvMass();
  btScalar m = mA > mB ? mB : mA;
  btScalar angularfreq = sqrt(ks / m);


  //limit stiffness (the spring should not be sampled faster that the quarter of its angular frequency)
  if (limot->m_springStiffnessLimited && 0.25 < angularfreq * dt)
  {
   ks = BT_ONE / dt / dt / btScalar(16.0) * m;
  }
  //avoid damping that would blow up the spring
  if (limot->m_springDampingLimited && kd * dt > m)
  {
   kd = m / dt;
  }
  btScalar fs = ks * error * dt;
  btScalar fd = -kd * (vel) * (rotational ? -1 : 1) * dt;
  btScalar f = (fs + fd);

  info->m_constraintError[srow] = (vel + f * (rotational ? -1 : 1));

  btScalar minf = f < fd ? f : fd;
  btScalar maxf = f < fd ? fd : f;
  if (!rotational)
  {
   info->m_lowerLimit[srow] = minf > 0 ? 0 : minf;
   info->m_upperLimit[srow] = maxf < 0 ? 0 : maxf;
  }
  else
  {
   info->m_lowerLimit[srow] = -maxf > 0 ? 0 : -maxf;
   info->m_upperLimit[srow] = -minf < 0 ? 0 : -minf;
  }

  info->cfm[srow] = cfm;
  srow += info->rowskip;
  ++count;
 }

 return count;
}


//override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
//If no axis is provided, it uses the default axis for this constraint.
void btGeneric6DofSpring2Constraint::setParam(int num, btScalar value, int axis)
{
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   m_linearLimits.m_stopERP[axis] = value;
   m_flags |= BT_6DOF_FLAGS_ERP_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_STOP_CFM:
   m_linearLimits.m_stopCFM[axis] = value;
   m_flags |= BT_6DOF_FLAGS_CFM_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_ERP:
   m_linearLimits.m_motorERP[axis] = value;
   m_flags |= BT_6DOF_FLAGS_ERP_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_CFM:
   m_linearLimits.m_motorCFM[axis] = value;
   m_flags |= BT_6DOF_FLAGS_CFM_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   m_angularLimits[axis - 3].m_stopERP = value;
   m_flags |= BT_6DOF_FLAGS_ERP_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_STOP_CFM:
   m_angularLimits[axis - 3].m_stopCFM = value;
   m_flags |= BT_6DOF_FLAGS_CFM_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_ERP:
   m_angularLimits[axis - 3].m_motorERP = value;
   m_flags |= BT_6DOF_FLAGS_ERP_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  case BT_CONSTRAINT_CFM:
   m_angularLimits[axis - 3].m_motorCFM = value;
   m_flags |= BT_6DOF_FLAGS_CFM_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
}

//return the local value of parameter
btScalar btGeneric6DofSpring2Constraint::getParam(int num, int axis) const
{
 btScalar retVal = 0;
 if ((axis >= 0) && (axis < 3))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_linearLimits.m_stopERP[axis];
   break;
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_linearLimits.m_stopCFM[axis];
   break;
  case BT_CONSTRAINT_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_linearLimits.m_motorERP[axis];
   break;
  case BT_CONSTRAINT_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_linearLimits.m_motorCFM[axis];
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else if ((axis >= 3) && (axis < 6))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_angularLimits[axis - 3].m_stopERP;
   break;
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_angularLimits[axis - 3].m_stopCFM;
   break;
  case BT_CONSTRAINT_ERP:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_angularLimits[axis - 3].m_motorERP;
   break;
  case BT_CONSTRAINT_CFM:
   btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_MOTO2 << (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
   retVal = m_angularLimits[axis - 3].m_motorCFM;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
 return retVal;
}



void btGeneric6DofSpring2Constraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
 btVector3 zAxis = axis1.normalized();
 btVector3 yAxis = axis2.normalized();
 btVector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system

 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);

 // now get constraint frame in local coordinate systems
 m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

 calculateTransforms();
}

void btGeneric6DofSpring2Constraint::setBounce(int index, btScalar bounce)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_bounce[index] = bounce;
 else
  m_angularLimits[index - 3].m_bounce = bounce;
}

void btGeneric6DofSpring2Constraint::enableMotor(int index, bool onOff)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_enableMotor[index] = onOff;
 else
  m_angularLimits[index - 3].m_enableMotor = onOff;
}

void btGeneric6DofSpring2Constraint::setServo(int index, bool onOff)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_servoMotor[index] = onOff;
 else
  m_angularLimits[index - 3].m_servoMotor = onOff;
}

void btGeneric6DofSpring2Constraint::setTargetVelocity(int index, btScalar velocity)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_targetVelocity[index] = velocity;
 else
  m_angularLimits[index - 3].m_targetVelocity = velocity;
}



void btGeneric6DofSpring2Constraint::setServoTarget(int index, btScalar targetOrg)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
 {
  m_linearLimits.m_servoTarget[index] = targetOrg;
 }
 else
 {
  //wrap between -PI and PI, see also
  //https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi

  btScalar target = targetOrg + SIMD_PI;
  if (1)
  {
   btScalar m = target - SIMD_2_PI * floor(target / SIMD_2_PI);
   // handle boundary cases resulted from floating-point cut off:
   {
    if (m >= SIMD_2_PI)
    {
     target = 0;
    }
    else
    {
     if (m<0)
     {
      if (SIMD_2_PI + m == SIMD_2_PI)
       target = 0;
      else
       target = SIMD_2_PI + m;
     }
     else
     {
      target = m;
     }
    }
   }
   target -= SIMD_PI;
  }

  m_angularLimits[index - 3].m_servoTarget = target;
 }
}

void btGeneric6DofSpring2Constraint::setMaxMotorForce(int index, btScalar force)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_maxMotorForce[index] = force;
 else
  m_angularLimits[index - 3].m_maxMotorForce = force;
}

void btGeneric6DofSpring2Constraint::enableSpring(int index, bool onOff)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_enableSpring[index] = onOff;
 else
  m_angularLimits[index - 3].m_enableSpring = onOff;
}

void btGeneric6DofSpring2Constraint::setStiffness(int index, btScalar stiffness, bool limitIfNeeded)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3) {
  m_linearLimits.m_springStiffness[index] = stiffness;
  m_linearLimits.m_springStiffnessLimited[index] = limitIfNeeded;
 }
 else {
  m_angularLimits[index - 3].m_springStiffness = stiffness;
  m_angularLimits[index - 3].m_springStiffnessLimited = limitIfNeeded;
 }
}

void btGeneric6DofSpring2Constraint::setDamping(int index, btScalar damping, bool limitIfNeeded)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3) {
  m_linearLimits.m_springDamping[index] = damping;
  m_linearLimits.m_springDampingLimited[index] = limitIfNeeded;
 }
 else {
  m_angularLimits[index - 3].m_springDamping = damping;
  m_angularLimits[index - 3].m_springDampingLimited = limitIfNeeded;
 }
}

void btGeneric6DofSpring2Constraint::setEquilibriumPoint()
{
 calculateTransforms();
 int i;
 for (i = 0; i < 3; i++)
  m_linearLimits.m_equilibriumPoint[i] = m_calculatedLinearDiff[i];
 for (i = 0; i < 3; i++)
  m_angularLimits[i].m_equilibriumPoint = m_calculatedAxisAngleDiff[i];
}

void btGeneric6DofSpring2Constraint::setEquilibriumPoint(int index)
{
 btAssert((index >= 0) && (index < 6));
 calculateTransforms();
 if (index<3)
  m_linearLimits.m_equilibriumPoint[index] = m_calculatedLinearDiff[index];
 else
  m_angularLimits[index - 3].m_equilibriumPoint = m_calculatedAxisAngleDiff[index - 3];
}

void btGeneric6DofSpring2Constraint::setEquilibriumPoint(int index, btScalar val)
{
 btAssert((index >= 0) && (index < 6));
 if (index<3)
  m_linearLimits.m_equilibriumPoint[index] = val;
 else
  m_angularLimits[index - 3].m_equilibriumPoint = val;
}


//////////////////////////// btRotationalLimitMotor2 ////////////////////////////////////

void btRotationalLimitMotor2::testLimitValue(btScalar test_value)
{
 //we can't normalize the angles here because we would lost the sign that we use later, but it doesn't seem to be a problem
 if (m_loLimit > m_hiLimit) {
  m_currentLimit = 0;
  m_currentLimitError = btScalar(0.f);
 }
 else if (m_loLimit == m_hiLimit) {
  m_currentLimitError = test_value - m_loLimit;
  m_currentLimit = 3;
 }
 else {
  m_currentLimitError = test_value - m_loLimit;
  m_currentLimitErrorHi = test_value - m_hiLimit;
  m_currentLimit = 4;
 }
}

//////////////////////////// btTranslationalLimitMotor2 ////////////////////////////////////

void btTranslationalLimitMotor2::testLimitValue(int limitIndex, btScalar test_value)
{
 btScalar loLimit = m_lowerLimit[limitIndex];
 btScalar hiLimit = m_upperLimit[limitIndex];
 if (loLimit > hiLimit) {
  m_currentLimitError[limitIndex] = 0;
  m_currentLimit[limitIndex] = 0;
 }
 else if (loLimit == hiLimit) {
  m_currentLimitError[limitIndex] = test_value - loLimit;
  m_currentLimit[limitIndex] = 3;
 }
 else {
  m_currentLimitError[limitIndex] = test_value - loLimit;
  m_currentLimitErrorHi[limitIndex] = test_value - hiLimit;
  m_currentLimit[limitIndex] = 4;
 }
}


/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc.

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpringConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"


btGeneric6DofSpringConstraint::btGeneric6DofSpringConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA)
 : btGeneric6DofConstraint(rbA, rbB, frameInA, frameInB, useLinearReferenceFrameA)
{
 init();
}


btGeneric6DofSpringConstraint::btGeneric6DofSpringConstraint(btRigidBody& rbB, const btTransform& frameInB, bool useLinearReferenceFrameB)
 : btGeneric6DofConstraint(rbB, frameInB, useLinearReferenceFrameB)
{
 init();
}


void btGeneric6DofSpringConstraint::init()
{
 m_objectType = D6_SPRING_CONSTRAINT_TYPE;

 for (int i = 0; i < 6; i++)
 {
  m_springEnabled[i] = false;
  m_equilibriumPoint[i] = btScalar(0.f);
  m_springStiffness[i] = btScalar(0.f);
  m_springDamping[i] = btScalar(1.f);
 }
}


void btGeneric6DofSpringConstraint::enableSpring(int index, bool onOff)
{
 btAssert((index >= 0) && (index < 6));
 m_springEnabled[index] = onOff;
 if (index < 3)
 {
  m_linearLimits.m_enableMotor[index] = onOff;
 }
 else
 {
  m_angularLimits[index - 3].m_enableMotor = onOff;
 }
}



void btGeneric6DofSpringConstraint::setStiffness(int index, btScalar stiffness)
{
 btAssert((index >= 0) && (index < 6));
 m_springStiffness[index] = stiffness;
}


void btGeneric6DofSpringConstraint::setDamping(int index, btScalar damping)
{
 btAssert((index >= 0) && (index < 6));
 m_springDamping[index] = damping;
}


void btGeneric6DofSpringConstraint::setEquilibriumPoint()
{
 calculateTransforms();
 int i;

 for (i = 0; i < 3; i++)
 {
  m_equilibriumPoint[i] = m_calculatedLinearDiff[i];
 }
 for (i = 0; i < 3; i++)
 {
  m_equilibriumPoint[i + 3] = m_calculatedAxisAngleDiff[i];
 }
}



void btGeneric6DofSpringConstraint::setEquilibriumPoint(int index)
{
 btAssert((index >= 0) && (index < 6));
 calculateTransforms();
 if (index < 3)
 {
  m_equilibriumPoint[index] = m_calculatedLinearDiff[index];
 }
 else
 {
  m_equilibriumPoint[index] = m_calculatedAxisAngleDiff[index - 3];
 }
}

void btGeneric6DofSpringConstraint::setEquilibriumPoint(int index, btScalar val)
{
 btAssert((index >= 0) && (index < 6));
 m_equilibriumPoint[index] = val;
}


void btGeneric6DofSpringConstraint::internalUpdateSprings(btConstraintInfo2* info)
{
 // it is assumed that calculateTransforms() have been called before this call
 int i;
 //btVector3 relVel = m_rbB.getLinearVelocity() - m_rbA.getLinearVelocity();
 for (i = 0; i < 3; i++)
 {
  if (m_springEnabled[i])
  {
   // get current position of constraint
   btScalar currPos = m_calculatedLinearDiff[i];
   // calculate difference
   btScalar delta = currPos - m_equilibriumPoint[i];
   // spring force is (delta * m_stiffness) according to Hooke's Law
   btScalar force = delta * m_springStiffness[i];
   btScalar velFactor = info->fps * m_springDamping[i] / btScalar(info->m_numIterations);
   m_linearLimits.m_targetVelocity[i] = velFactor * force;
   m_linearLimits.m_maxMotorForce[i] = btFabs(force) / info->fps;
  }
 }
 for (i = 0; i < 3; i++)
 {
  if (m_springEnabled[i + 3])
  {
   // get current position of constraint
   btScalar currPos = m_calculatedAxisAngleDiff[i];
   // calculate difference
   btScalar delta = currPos - m_equilibriumPoint[i + 3];
   // spring force is (-delta * m_stiffness) according to Hooke's Law
   btScalar force = -delta * m_springStiffness[i + 3];
   btScalar velFactor = info->fps * m_springDamping[i + 3] / btScalar(info->m_numIterations);
   m_angularLimits[i].m_targetVelocity = velFactor * force;
   m_angularLimits[i].m_maxMotorForce = btFabs(force) / info->fps;
  }
 }
}


void btGeneric6DofSpringConstraint::getInfo2(btConstraintInfo2* info)
{
 // this will be called by constraint solver at the constraint setup stage
 // set current motor parameters
 internalUpdateSprings(info);
 // do the rest of job for constraint setup
 btGeneric6DofConstraint::getInfo2(info);
}


void btGeneric6DofSpringConstraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
 btVector3 zAxis = axis1.normalized();
 btVector3 yAxis = axis2.normalized();
 btVector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system

 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);

 // now get constraint frame in local coordinate systems
 m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

 calculateTransforms();
}



/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc.

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletDynamics/ConstraintSolver/btHinge2Constraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"



// constructor
// anchor, axis1 and axis2 are in world coordinate system
// axis1 must be orthogonal to axis2
btHinge2Constraint::btHinge2Constraint(btRigidBody& rbA, btRigidBody& rbB, btVector3& anchor, btVector3& axis1, btVector3& axis2)
 : btGeneric6DofSpring2Constraint(rbA, rbB, btTransform::getIdentity(), btTransform::getIdentity(), RO_XYZ),
 m_anchor(anchor),
 m_axis1(axis1),
 m_axis2(axis2)
{
 // build frame basis
 // 6DOF constraint uses Euler angles and to define limits
 // it is assumed that rotational order is :
 // Z - first, allowed limits are (-PI,PI);
 // new position of Y - second (allowed limits are (-PI/2 + epsilon, PI/2 - epsilon), where epsilon is a small positive number 
 // used to prevent constraint from instability on poles;
 // new position of X, allowed limits are (-PI,PI);
 // So to simulate ODE Universal joint we should use parent axis as Z, child axis as Y and limit all other DOFs
 // Build the frame in world coordinate system first
 btVector3 zAxis = axis1.normalize();
 btVector3 xAxis = axis2.normalize();
 btVector3 yAxis = zAxis.cross(xAxis); // we want right coordinate system
 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);
 frameInW.setOrigin(anchor);
 // now get constraint frame in local coordinate systems
 m_frameInA = rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = rbB.getCenterOfMassTransform().inverse() * frameInW;
 // sei limits
 setLinearLowerLimit(btVector3(0.f, 0.f, -1.f));
 setLinearUpperLimit(btVector3(0.f, 0.f, 1.f));
 // like front wheels of a car
 setAngularLowerLimit(btVector3(1.f, 0.f, -SIMD_HALF_PI * 0.5f));
 setAngularUpperLimit(btVector3(-1.f, 0.f, SIMD_HALF_PI * 0.5f));
 // enable suspension
 enableSpring(2, true);
 setStiffness(2, SIMD_PI * SIMD_PI * 4.f);
 setDamping(2, 0.01f);
 setEquilibriumPoint();
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMinMax.h"
#include <new>
#include "BulletDynamics/ConstraintSolver/btSolverBody.h"



//#define HINGE_USE_OBSOLETE_SOLVER false
#define HINGE_USE_OBSOLETE_SOLVER false

#define HINGE_USE_FRAME_OFFSET true

#ifndef __SPU__





btHingeConstraint::btHingeConstraint(btRigidBody& rbA, btRigidBody& rbB, const btVector3& pivotInA, const btVector3& pivotInB,
 const btVector3& axisInA, const btVector3& axisInB, bool useReferenceFrameA)
 :btTypedConstraint(HINGE_CONSTRAINT_TYPE, rbA, rbB),
#ifdef _BT_USE_CENTER_LIMIT_
 m_limit(),
#endif
 m_angularOnly(false),
 m_enableAngularMotor(false),
 m_useSolveConstraintObsolete(HINGE_USE_OBSOLETE_SOLVER),
 m_useOffsetForConstraintFrame(HINGE_USE_FRAME_OFFSET),
 m_useReferenceFrameA(useReferenceFrameA),
 m_flags(0),
 m_normalCFM(0),
 m_normalERP(0),
 m_stopCFM(0),
 m_stopERP(0)
{
 m_rbAFrame.getOrigin() = pivotInA;

 // since no frame is given, assume this to be zero angle and just pick rb transform axis
 btVector3 rbAxisA1 = rbA.getCenterOfMassTransform().getBasis().getColumn(0);

 btVector3 rbAxisA2;
 btScalar projection = axisInA.dot(rbAxisA1);
 if (projection >= 1.0f - SIMD_EPSILON) {
  rbAxisA1 = -rbA.getCenterOfMassTransform().getBasis().getColumn(2);
  rbAxisA2 = rbA.getCenterOfMassTransform().getBasis().getColumn(1);
 }
 else if (projection <= -1.0f + SIMD_EPSILON) {
  rbAxisA1 = rbA.getCenterOfMassTransform().getBasis().getColumn(2);
  rbAxisA2 = rbA.getCenterOfMassTransform().getBasis().getColumn(1);
 }
 else {
  rbAxisA2 = axisInA.cross(rbAxisA1);
  rbAxisA1 = rbAxisA2.cross(axisInA);
 }

 m_rbAFrame.getBasis().setValue(rbAxisA1.getX(), rbAxisA2.getX(), axisInA.getX(),
  rbAxisA1.getY(), rbAxisA2.getY(), axisInA.getY(),
  rbAxisA1.getZ(), rbAxisA2.getZ(), axisInA.getZ());

 btQuaternion rotationArc = shortestArcQuat(axisInA, axisInB);
 btVector3 rbAxisB1 = quatRotate(rotationArc, rbAxisA1);
 btVector3 rbAxisB2 = axisInB.cross(rbAxisB1);

 m_rbBFrame.getOrigin() = pivotInB;
 m_rbBFrame.getBasis().setValue(rbAxisB1.getX(), rbAxisB2.getX(), axisInB.getX(),
  rbAxisB1.getY(), rbAxisB2.getY(), axisInB.getY(),
  rbAxisB1.getZ(), rbAxisB2.getZ(), axisInB.getZ());

#ifndef	_BT_USE_CENTER_LIMIT_
 //start with free
 m_lowerLimit = btScalar(1.0f);
 m_upperLimit = btScalar(-1.0f);
 m_biasFactor = 0.3f;
 m_relaxationFactor = 1.0f;
 m_limitSoftness = 0.9f;
 m_solveLimit = false;
#endif
 m_referenceSign = m_useReferenceFrameA ? btScalar(-1.f) : btScalar(1.f);
}



btHingeConstraint::btHingeConstraint(btRigidBody& rbA, const btVector3& pivotInA, const btVector3& axisInA, bool useReferenceFrameA)
 :btTypedConstraint(HINGE_CONSTRAINT_TYPE, rbA),
#ifdef _BT_USE_CENTER_LIMIT_
 m_limit(),
#endif
 m_angularOnly(false), m_enableAngularMotor(false),
 m_useSolveConstraintObsolete(HINGE_USE_OBSOLETE_SOLVER),
 m_useOffsetForConstraintFrame(HINGE_USE_FRAME_OFFSET),
 m_useReferenceFrameA(useReferenceFrameA),
 m_flags(0),
 m_normalCFM(0),
 m_normalERP(0),
 m_stopCFM(0),
 m_stopERP(0)
{

 // since no frame is given, assume this to be zero angle and just pick rb transform axis
 // fixed axis in worldspace
 btVector3 rbAxisA1, rbAxisA2;
 btPlaneSpace1(axisInA, rbAxisA1, rbAxisA2);

 m_rbAFrame.getOrigin() = pivotInA;
 m_rbAFrame.getBasis().setValue(rbAxisA1.getX(), rbAxisA2.getX(), axisInA.getX(),
  rbAxisA1.getY(), rbAxisA2.getY(), axisInA.getY(),
  rbAxisA1.getZ(), rbAxisA2.getZ(), axisInA.getZ());

 btVector3 axisInB = rbA.getCenterOfMassTransform().getBasis() * axisInA;

 btQuaternion rotationArc = shortestArcQuat(axisInA, axisInB);
 btVector3 rbAxisB1 = quatRotate(rotationArc, rbAxisA1);
 btVector3 rbAxisB2 = axisInB.cross(rbAxisB1);


 m_rbBFrame.getOrigin() = rbA.getCenterOfMassTransform()(pivotInA);
 m_rbBFrame.getBasis().setValue(rbAxisB1.getX(), rbAxisB2.getX(), axisInB.getX(),
  rbAxisB1.getY(), rbAxisB2.getY(), axisInB.getY(),
  rbAxisB1.getZ(), rbAxisB2.getZ(), axisInB.getZ());

#ifndef	_BT_USE_CENTER_LIMIT_
 //start with free
 m_lowerLimit = btScalar(1.0f);
 m_upperLimit = btScalar(-1.0f);
 m_biasFactor = 0.3f;
 m_relaxationFactor = 1.0f;
 m_limitSoftness = 0.9f;
 m_solveLimit = false;
#endif
 m_referenceSign = m_useReferenceFrameA ? btScalar(-1.f) : btScalar(1.f);
}



btHingeConstraint::btHingeConstraint(btRigidBody& rbA, btRigidBody& rbB,
 const btTransform& rbAFrame, const btTransform& rbBFrame, bool useReferenceFrameA)
 :btTypedConstraint(HINGE_CONSTRAINT_TYPE, rbA, rbB), m_rbAFrame(rbAFrame), m_rbBFrame(rbBFrame),
#ifdef _BT_USE_CENTER_LIMIT_
 m_limit(),
#endif
 m_angularOnly(false),
 m_enableAngularMotor(false),
 m_useSolveConstraintObsolete(HINGE_USE_OBSOLETE_SOLVER),
 m_useOffsetForConstraintFrame(HINGE_USE_FRAME_OFFSET),
 m_useReferenceFrameA(useReferenceFrameA),
 m_flags(0),
 m_normalCFM(0),
 m_normalERP(0),
 m_stopCFM(0),
 m_stopERP(0)
{
#ifndef	_BT_USE_CENTER_LIMIT_
 //start with free
 m_lowerLimit = btScalar(1.0f);
 m_upperLimit = btScalar(-1.0f);
 m_biasFactor = 0.3f;
 m_relaxationFactor = 1.0f;
 m_limitSoftness = 0.9f;
 m_solveLimit = false;
#endif
 m_referenceSign = m_useReferenceFrameA ? btScalar(-1.f) : btScalar(1.f);
}



btHingeConstraint::btHingeConstraint(btRigidBody& rbA, const btTransform& rbAFrame, bool useReferenceFrameA)
 :btTypedConstraint(HINGE_CONSTRAINT_TYPE, rbA), m_rbAFrame(rbAFrame), m_rbBFrame(rbAFrame),
#ifdef _BT_USE_CENTER_LIMIT_
 m_limit(),
#endif
 m_angularOnly(false),
 m_enableAngularMotor(false),
 m_useSolveConstraintObsolete(HINGE_USE_OBSOLETE_SOLVER),
 m_useOffsetForConstraintFrame(HINGE_USE_FRAME_OFFSET),
 m_useReferenceFrameA(useReferenceFrameA),
 m_flags(0),
 m_normalCFM(0),
 m_normalERP(0),
 m_stopCFM(0),
 m_stopERP(0)
{
 ///not providing rigidbody B means implicitly using worldspace for body B

 m_rbBFrame.getOrigin() = m_rbA.getCenterOfMassTransform()(m_rbAFrame.getOrigin());
#ifndef	_BT_USE_CENTER_LIMIT_
 //start with free
 m_lowerLimit = btScalar(1.0f);
 m_upperLimit = btScalar(-1.0f);
 m_biasFactor = 0.3f;
 m_relaxationFactor = 1.0f;
 m_limitSoftness = 0.9f;
 m_solveLimit = false;
#endif
 m_referenceSign = m_useReferenceFrameA ? btScalar(-1.f) : btScalar(1.f);
}



void	btHingeConstraint::buildJacobian()
{
 if (m_useSolveConstraintObsolete)
 {
  m_appliedImpulse = btScalar(0.);
  m_accMotorImpulse = btScalar(0.);

  if (!m_angularOnly)
  {
   btVector3 pivotAInW = m_rbA.getCenterOfMassTransform()*m_rbAFrame.getOrigin();
   btVector3 pivotBInW = m_rbB.getCenterOfMassTransform()*m_rbBFrame.getOrigin();
   btVector3 relPos = pivotBInW - pivotAInW;

   btVector3 normal[3];
   if (relPos.length2() > SIMD_EPSILON)
   {
    normal[0] = relPos.normalized();
   }
   else
   {
    normal[0].setValue(btScalar(1.0), 0, 0);
   }

   btPlaneSpace1(normal[0], normal[1], normal[2]);

   for (int i = 0; i<3; i++)
   {
    new (&m_jac[i]) btJacobianEntry(
     m_rbA.getCenterOfMassTransform().getBasis().transpose(),
     m_rbB.getCenterOfMassTransform().getBasis().transpose(),
     pivotAInW - m_rbA.getCenterOfMassPosition(),
     pivotBInW - m_rbB.getCenterOfMassPosition(),
     normal[i],
     m_rbA.getInvInertiaDiagLocal(),
     m_rbA.getInvMass(),
     m_rbB.getInvInertiaDiagLocal(),
     m_rbB.getInvMass());
   }
  }

  //calculate two perpendicular jointAxis, orthogonal to hingeAxis
  //these two jointAxis require equal angular velocities for both bodies

  //this is unused for now, it's a todo
  btVector3 jointAxis0local;
  btVector3 jointAxis1local;

  btPlaneSpace1(m_rbAFrame.getBasis().getColumn(2), jointAxis0local, jointAxis1local);

  btVector3 jointAxis0 = getRigidBodyA().getCenterOfMassTransform().getBasis() * jointAxis0local;
  btVector3 jointAxis1 = getRigidBodyA().getCenterOfMassTransform().getBasis() * jointAxis1local;
  btVector3 hingeAxisWorld = getRigidBodyA().getCenterOfMassTransform().getBasis() * m_rbAFrame.getBasis().getColumn(2);

  new (&m_jacAng[0])	btJacobianEntry(jointAxis0,
   m_rbA.getCenterOfMassTransform().getBasis().transpose(),
   m_rbB.getCenterOfMassTransform().getBasis().transpose(),
   m_rbA.getInvInertiaDiagLocal(),
   m_rbB.getInvInertiaDiagLocal());

  new (&m_jacAng[1])	btJacobianEntry(jointAxis1,
   m_rbA.getCenterOfMassTransform().getBasis().transpose(),
   m_rbB.getCenterOfMassTransform().getBasis().transpose(),
   m_rbA.getInvInertiaDiagLocal(),
   m_rbB.getInvInertiaDiagLocal());

  new (&m_jacAng[2])	btJacobianEntry(hingeAxisWorld,
   m_rbA.getCenterOfMassTransform().getBasis().transpose(),
   m_rbB.getCenterOfMassTransform().getBasis().transpose(),
   m_rbA.getInvInertiaDiagLocal(),
   m_rbB.getInvInertiaDiagLocal());

  // clear accumulator
  m_accLimitImpulse = btScalar(0.);

  // test angular limit
  testLimit(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());

  //Compute K = J*W*J' for hinge axis
  btVector3 axisA = getRigidBodyA().getCenterOfMassTransform().getBasis() *  m_rbAFrame.getBasis().getColumn(2);
  m_kHinge = 1.0f / (getRigidBodyA().computeAngularImpulseDenominator(axisA) +
   getRigidBodyB().computeAngularImpulseDenominator(axisA));

 }
}


#endif //__SPU__


static inline btScalar btNormalizeAnglePositive(btScalar angle)
{
 return btFmod(btFmod(angle, btScalar(2.0*SIMD_PI)) + btScalar(2.0*SIMD_PI), btScalar(2.0*SIMD_PI));
}



static btScalar btShortestAngularDistance(btScalar accAngle, btScalar curAngle)
{
 btScalar result = btNormalizeAngle(btNormalizeAnglePositive(btNormalizeAnglePositive(curAngle) -
  btNormalizeAnglePositive(accAngle)));
 return result;
}

static btScalar btShortestAngleUpdate(btScalar accAngle, btScalar curAngle)
{
 btScalar tol((btScalar)0.3);
 btScalar result = btShortestAngularDistance(accAngle, curAngle);

 if (btFabs(result) > tol)
  return curAngle;
 else
  return accAngle + result;

 return curAngle;
}


btScalar btHingeAccumulatedAngleConstraint::getAccumulatedHingeAngle()
{
 btScalar hingeAngle = getHingeAngle();
 m_accumulatedAngle = btShortestAngleUpdate(m_accumulatedAngle, hingeAngle);
 return m_accumulatedAngle;
}
void	btHingeAccumulatedAngleConstraint::setAccumulatedHingeAngle(btScalar accAngle)
{
 m_accumulatedAngle = accAngle;
}

void btHingeAccumulatedAngleConstraint::getInfo1(btConstraintInfo1* info)
{
 //update m_accumulatedAngle
 btScalar curHingeAngle = getHingeAngle();
 m_accumulatedAngle = btShortestAngleUpdate(m_accumulatedAngle, curHingeAngle);

 btHingeConstraint::getInfo1(info);

}


void btHingeConstraint::getInfo1(btConstraintInfo1* info)
{


 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  info->m_numConstraintRows = 5; // Fixed 3 linear + 2 angular
  info->nub = 1;
  //always add the row, to avoid computation (data is not available yet)
  //prepare constraint
  testLimit(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
  if (getSolveLimit() || getEnableAngularMotor())
  {
   info->m_numConstraintRows++; // limit 3rd anguar as well
   info->nub--;
  }

 }
}

void btHingeConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  //always add the 'limit' row, to avoid computation (data is not available yet)
  info->m_numConstraintRows = 6; // Fixed 3 linear + 2 angular
  info->nub = 0;
 }
}

void btHingeConstraint::getInfo2(btConstraintInfo2* info)
{
 if (m_useOffsetForConstraintFrame)
 {
  getInfo2InternalUsingFrameOffset(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getAngularVelocity(), m_rbB.getAngularVelocity());
 }
 else
 {
  getInfo2Internal(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getAngularVelocity(), m_rbB.getAngularVelocity());
 }
}


void	btHingeConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& angVelA, const btVector3& angVelB)
{
 ///the regular (virtual) implementation getInfo2 already performs 'testLimit' during getInfo1, so we need to do it now
 testLimit(transA, transB);

 getInfo2Internal(info, transA, transB, angVelA, angVelB);
}


void btHingeConstraint::getInfo2Internal(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& angVelA, const btVector3& angVelB)
{

 btAssert(!m_useSolveConstraintObsolete);
 int i, skip = info->rowskip;
 // transforms in world space
 btTransform trA = transA*m_rbAFrame;
 btTransform trB = transB*m_rbBFrame;
 // pivot point
 btVector3 pivotAInW = trA.getOrigin();
 btVector3 pivotBInW = trB.getOrigin();
#if 0
 if (0)
 {
  for (i = 0; i<6; i++)
  {
   info->m_J1linearAxis[i*skip] = 0;
   info->m_J1linearAxis[i*skip + 1] = 0;
   info->m_J1linearAxis[i*skip + 2] = 0;

   info->m_J1angularAxis[i*skip] = 0;
   info->m_J1angularAxis[i*skip + 1] = 0;
   info->m_J1angularAxis[i*skip + 2] = 0;

   info->m_J2linearAxis[i*skip] = 0;
   info->m_J2linearAxis[i*skip + 1] = 0;
   info->m_J2linearAxis[i*skip + 2] = 0;

   info->m_J2angularAxis[i*skip] = 0;
   info->m_J2angularAxis[i*skip + 1] = 0;
   info->m_J2angularAxis[i*skip + 2] = 0;

   info->m_constraintError[i*skip] = 0.f;
  }
 }
#endif //#if 0
 // linear (all fixed)

 if (!m_angularOnly)
 {
  info->m_J1linearAxis[0] = 1;
  info->m_J1linearAxis[skip + 1] = 1;
  info->m_J1linearAxis[2 * skip + 2] = 1;

  info->m_J2linearAxis[0] = -1;
  info->m_J2linearAxis[skip + 1] = -1;
  info->m_J2linearAxis[2 * skip + 2] = -1;
 }




 btVector3 a1 = pivotAInW - transA.getOrigin();
 {
  btVector3* angular0 = (btVector3*)(info->m_J1angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J1angularAxis + skip);
  btVector3* angular2 = (btVector3*)(info->m_J1angularAxis + 2 * skip);
  btVector3 a1neg = -a1;
  a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }
 btVector3 a2 = pivotBInW - transB.getOrigin();
 {
  btVector3* angular0 = (btVector3*)(info->m_J2angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J2angularAxis + skip);
  btVector3* angular2 = (btVector3*)(info->m_J2angularAxis + 2 * skip);
  a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }
 // linear RHS
 btScalar normalErp = (m_flags & BT_HINGE_FLAGS_ERP_NORM) ? m_normalERP : info->erp;

 btScalar k = info->fps * normalErp;
 if (!m_angularOnly)
 {
  for (i = 0; i < 3; i++)
  {
   info->m_constraintError[i * skip] = k * (pivotBInW[i] - pivotAInW[i]);
  }
 }
 // make rotations around X and Y equal
 // the hinge axis should be the only unconstrained
 // rotational axis, the angular velocity of the two bodies perpendicular to
 // the hinge axis should be equal. thus the constraint equations are
 //    p*w1 - p*w2 = 0
 //    q*w1 - q*w2 = 0
 // where p and q are unit vectors normal to the hinge axis, and w1 and w2
 // are the angular velocity vectors of the two bodies.
 // get hinge axis (Z)
 btVector3 ax1 = trA.getBasis().getColumn(2);
 // get 2 orthos to hinge axis (X, Y)
 btVector3 p = trA.getBasis().getColumn(0);
 btVector3 q = trA.getBasis().getColumn(1);
 // set the two hinge angular rows 
 int s3 = 3 * info->rowskip;
 int s4 = 4 * info->rowskip;

 info->m_J1angularAxis[s3 + 0] = p[0];
 info->m_J1angularAxis[s3 + 1] = p[1];
 info->m_J1angularAxis[s3 + 2] = p[2];
 info->m_J1angularAxis[s4 + 0] = q[0];
 info->m_J1angularAxis[s4 + 1] = q[1];
 info->m_J1angularAxis[s4 + 2] = q[2];

 info->m_J2angularAxis[s3 + 0] = -p[0];
 info->m_J2angularAxis[s3 + 1] = -p[1];
 info->m_J2angularAxis[s3 + 2] = -p[2];
 info->m_J2angularAxis[s4 + 0] = -q[0];
 info->m_J2angularAxis[s4 + 1] = -q[1];
 info->m_J2angularAxis[s4 + 2] = -q[2];
 // compute the right hand side of the constraint equation. set relative
 // body velocities along p and q to bring the hinge back into alignment.
 // if ax1,ax2 are the unit length hinge axes as computed from body1 and
 // body2, we need to rotate both bodies along the axis u = (ax1 x ax2).
 // if `theta' is the angle between ax1 and ax2, we need an angular velocity
 // along u to cover angle erp*theta in one step :
 //   |angular_velocity| = angle/time = erp*theta / stepsize
 //                      = (erp*fps) * theta
 //    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
 //                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
 // ...as ax1 and ax2 are unit length. if theta is smallish,
 // theta ~= sin(theta), so
 //    angular_velocity  = (erp*fps) * (ax1 x ax2)
 // ax1 x ax2 is in the plane space of ax1, so we project the angular
 // velocity to p and q to find the right hand side.
 btVector3 ax2 = trB.getBasis().getColumn(2);
 btVector3 u = ax1.cross(ax2);
 info->m_constraintError[s3] = k * u.dot(p);
 info->m_constraintError[s4] = k * u.dot(q);
 // check angular limits
 int nrow = 4; // last filled row
 int srow;
 btScalar limit_err = btScalar(0.0);
 int limit = 0;
 if (getSolveLimit())
 {
#ifdef	_BT_USE_CENTER_LIMIT_
  limit_err = m_limit.getCorrection() * m_referenceSign;
#else
  limit_err = m_correction * m_referenceSign;
#endif
  limit = (limit_err > btScalar(0.0)) ? 1 : 2;

 }
 // if the hinge has joint limits or motor, add in the extra row
 bool powered = getEnableAngularMotor();
 if (limit || powered)
 {
  nrow++;
  srow = nrow * info->rowskip;
  info->m_J1angularAxis[srow + 0] = ax1[0];
  info->m_J1angularAxis[srow + 1] = ax1[1];
  info->m_J1angularAxis[srow + 2] = ax1[2];

  info->m_J2angularAxis[srow + 0] = -ax1[0];
  info->m_J2angularAxis[srow + 1] = -ax1[1];
  info->m_J2angularAxis[srow + 2] = -ax1[2];

  btScalar lostop = getLowerLimit();
  btScalar histop = getUpperLimit();
  if (limit && (lostop == histop))
  {  // the joint motor is ineffective
   powered = false;
  }
  info->m_constraintError[srow] = btScalar(0.0f);
  btScalar currERP = (m_flags & BT_HINGE_FLAGS_ERP_STOP) ? m_stopERP : normalErp;
  if (powered)
  {
   if (m_flags & BT_HINGE_FLAGS_CFM_NORM)
   {
    info->cfm[srow] = m_normalCFM;
   }
   btScalar mot_fact = getMotorFactor(m_hingeAngle, lostop, histop, m_motorTargetVelocity, info->fps * currERP);
   info->m_constraintError[srow] += mot_fact * m_motorTargetVelocity * m_referenceSign;
   info->m_lowerLimit[srow] = -m_maxMotorImpulse;
   info->m_upperLimit[srow] = m_maxMotorImpulse;
  }
  if (limit)
  {
   k = info->fps * currERP;
   info->m_constraintError[srow] += k * limit_err;
   if (m_flags & BT_HINGE_FLAGS_CFM_STOP)
   {
    info->cfm[srow] = m_stopCFM;
   }
   if (lostop == histop)
   {
    // limited low and high simultaneously
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else if (limit == 1)
   { // low limit
    info->m_lowerLimit[srow] = 0;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else
   { // high limit
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = 0;
   }
   // bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
#ifdef	_BT_USE_CENTER_LIMIT_
   btScalar bounce = m_limit.getRelaxationFactor();
#else
   btScalar bounce = m_relaxationFactor;
#endif
   if (bounce > btScalar(0.0))
   {
    btScalar vel = angVelA.dot(ax1);
    vel -= angVelB.dot(ax1);
    // only apply bounce if the velocity is incoming, and if the
    // resulting c[] exceeds what we already have.
    if (limit == 1)
    {	// low limit
     if (vel < 0)
     {
      btScalar newc = -bounce * vel;
      if (newc > info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
    else
    {	// high limit - all those computations are reversed
     if (vel > 0)
     {
      btScalar newc = -bounce * vel;
      if (newc < info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
   }
#ifdef	_BT_USE_CENTER_LIMIT_
   info->m_constraintError[srow] *= m_limit.getBiasFactor();
#else
   info->m_constraintError[srow] *= m_biasFactor;
#endif
  } // if(limit)
 } // if angular limit or powered
}


void btHingeConstraint::setFrames(const btTransform & frameA, const btTransform & frameB)
{
 m_rbAFrame = frameA;
 m_rbBFrame = frameB;
 buildJacobian();
}


void	btHingeConstraint::updateRHS(btScalar	timeStep)
{
 (void)timeStep;

}




btScalar btHingeConstraint::getHingeAngle()
{
 return getHingeAngle(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

btScalar btHingeConstraint::getHingeAngle(const btTransform& transA, const btTransform& transB)
{
 const btVector3 refAxis0 = transA.getBasis() * m_rbAFrame.getBasis().getColumn(0);
 const btVector3 refAxis1 = transA.getBasis() * m_rbAFrame.getBasis().getColumn(1);
 const btVector3 swingAxis = transB.getBasis() * m_rbBFrame.getBasis().getColumn(1);
 //	btScalar angle = btAtan2Fast(swingAxis.dot(refAxis0), swingAxis.dot(refAxis1));
 btScalar angle = btAtan2(swingAxis.dot(refAxis0), swingAxis.dot(refAxis1));
 return m_referenceSign * angle;
}



void btHingeConstraint::testLimit(const btTransform& transA, const btTransform& transB)
{
 // Compute limit information
 m_hingeAngle = getHingeAngle(transA, transB);
#ifdef	_BT_USE_CENTER_LIMIT_
 m_limit.test(m_hingeAngle);
#else
 m_correction = btScalar(0.);
 m_limitSign = btScalar(0.);
 m_solveLimit = false;
 if (m_lowerLimit <= m_upperLimit)
 {
  m_hingeAngle = btAdjustAngleToLimits(m_hingeAngle, m_lowerLimit, m_upperLimit);
  if (m_hingeAngle <= m_lowerLimit)
  {
   m_correction = (m_lowerLimit - m_hingeAngle);
   m_limitSign = 1.0f;
   m_solveLimit = true;
  }
  else if (m_hingeAngle >= m_upperLimit)
  {
   m_correction = m_upperLimit - m_hingeAngle;
   m_limitSign = -1.0f;
   m_solveLimit = true;
  }
 }
#endif
 return;
}


static btVector3 vHinge(0, 0, btScalar(1));

void btHingeConstraint::setMotorTarget(const btQuaternion& qAinB, btScalar dt)
{
 // convert target from body to constraint space
 btQuaternion qConstraint = m_rbBFrame.getRotation().inverse() * qAinB * m_rbAFrame.getRotation();
 qConstraint.normalize();

 // extract "pure" hinge component
 btVector3 vNoHinge = quatRotate(qConstraint, vHinge); vNoHinge.normalize();
 btQuaternion qNoHinge = shortestArcQuat(vHinge, vNoHinge);
 btQuaternion qHinge = qNoHinge.inverse() * qConstraint;
 qHinge.normalize();

 // compute angular target, clamped to limits
 btScalar targetAngle = qHinge.getAngle();
 if (targetAngle > SIMD_PI) // long way around. flip quat and recalculate.
 {
  qHinge = -(qHinge);
  targetAngle = qHinge.getAngle();
 }
 if (qHinge.getZ() < 0)
  targetAngle = -targetAngle;

 setMotorTarget(targetAngle, dt);
}

void btHingeConstraint::setMotorTarget(btScalar targetAngle, btScalar dt)
{
#ifdef	_BT_USE_CENTER_LIMIT_
 m_limit.fit(targetAngle);
#else
 if (m_lowerLimit < m_upperLimit)
 {
  if (targetAngle < m_lowerLimit)
   targetAngle = m_lowerLimit;
  else if (targetAngle > m_upperLimit)
   targetAngle = m_upperLimit;
 }
#endif
 // compute angular velocity
 btScalar curAngle = getHingeAngle(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
 btScalar dAngle = targetAngle - curAngle;
 m_motorTargetVelocity = dAngle / dt;
}



void btHingeConstraint::getInfo2InternalUsingFrameOffset(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& angVelA, const btVector3& angVelB)
{
 btAssert(!m_useSolveConstraintObsolete);
 int i, s = info->rowskip;
 // transforms in world space
 btTransform trA = transA*m_rbAFrame;
 btTransform trB = transB*m_rbBFrame;
 // pivot point
 //	btVector3 pivotAInW = trA.getOrigin();
 //	btVector3 pivotBInW = trB.getOrigin();
#if 1
 // difference between frames in WCS
 btVector3 ofs = trB.getOrigin() - trA.getOrigin();
 // now get weight factors depending on masses
 btScalar miA = getRigidBodyA().getInvMass();
 btScalar miB = getRigidBodyB().getInvMass();
 bool hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
 btScalar miS = miA + miB;
 btScalar factA, factB;
 if (miS > btScalar(0.f))
 {
  factA = miB / miS;
 }
 else
 {
  factA = btScalar(0.5f);
 }
 factB = btScalar(1.0f) - factA;
 // get the desired direction of hinge axis
 // as weighted sum of Z-orthos of frameA and frameB in WCS
 btVector3 ax1A = trA.getBasis().getColumn(2);
 btVector3 ax1B = trB.getBasis().getColumn(2);
 btVector3 ax1 = ax1A * factA + ax1B * factB;
 ax1.normalize();
 // fill first 3 rows 
 // we want: velA + wA x relA == velB + wB x relB
 btTransform bodyA_trans = transA;
 btTransform bodyB_trans = transB;
 int s0 = 0;
 int s1 = s;
 int s2 = s * 2;
 int nrow = 2; // last filled row
 btVector3 tmpA, tmpB, relA, relB, p, q;
 // get vector from bodyB to frameB in WCS
 relB = trB.getOrigin() - bodyB_trans.getOrigin();
 // get its projection to hinge axis
 btVector3 projB = ax1 * relB.dot(ax1);
 // get vector directed from bodyB to hinge axis (and orthogonal to it)
 btVector3 orthoB = relB - projB;
 // same for bodyA
 relA = trA.getOrigin() - bodyA_trans.getOrigin();
 btVector3 projA = ax1 * relA.dot(ax1);
 btVector3 orthoA = relA - projA;
 btVector3 totalDist = projA - projB;
 // get offset vectors relA and relB
 relA = orthoA + totalDist * factA;
 relB = orthoB - totalDist * factB;
 // now choose average ortho to hinge axis
 p = orthoB * factA + orthoA * factB;
 btScalar len2 = p.length2();
 if (len2 > SIMD_EPSILON)
 {
  p /= btSqrt(len2);
 }
 else
 {
  p = trA.getBasis().getColumn(1);
 }
 // make one more ortho
 q = ax1.cross(p);
 // fill three rows
 tmpA = relA.cross(p);
 tmpB = relB.cross(p);
 for (i = 0; i<3; i++) info->m_J1angularAxis[s0 + i] = tmpA[i];
 for (i = 0; i<3; i++) info->m_J2angularAxis[s0 + i] = -tmpB[i];
 tmpA = relA.cross(q);
 tmpB = relB.cross(q);
 if (hasStaticBody && getSolveLimit())
 { // to make constraint between static and dynamic objects more rigid
   // remove wA (or wB) from equation if angular limit is hit
  tmpB *= factB;
  tmpA *= factA;
 }
 for (i = 0; i<3; i++) info->m_J1angularAxis[s1 + i] = tmpA[i];
 for (i = 0; i<3; i++) info->m_J2angularAxis[s1 + i] = -tmpB[i];
 tmpA = relA.cross(ax1);
 tmpB = relB.cross(ax1);
 if (hasStaticBody)
 { // to make constraint between static and dynamic objects more rigid
   // remove wA (or wB) from equation
  tmpB *= factB;
  tmpA *= factA;
 }
 for (i = 0; i<3; i++) info->m_J1angularAxis[s2 + i] = tmpA[i];
 for (i = 0; i<3; i++) info->m_J2angularAxis[s2 + i] = -tmpB[i];

 btScalar normalErp = (m_flags & BT_HINGE_FLAGS_ERP_NORM) ? m_normalERP : info->erp;
 btScalar k = info->fps * normalErp;

 if (!m_angularOnly)
 {
  for (i = 0; i<3; i++) info->m_J1linearAxis[s0 + i] = p[i];
  for (i = 0; i<3; i++) info->m_J1linearAxis[s1 + i] = q[i];
  for (i = 0; i<3; i++) info->m_J1linearAxis[s2 + i] = ax1[i];

  for (i = 0; i<3; i++) info->m_J2linearAxis[s0 + i] = -p[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s1 + i] = -q[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s2 + i] = -ax1[i];

  // compute three elements of right hand side

  btScalar rhs = k * p.dot(ofs);
  info->m_constraintError[s0] = rhs;
  rhs = k * q.dot(ofs);
  info->m_constraintError[s1] = rhs;
  rhs = k * ax1.dot(ofs);
  info->m_constraintError[s2] = rhs;
 }
 // the hinge axis should be the only unconstrained
 // rotational axis, the angular velocity of the two bodies perpendicular to
 // the hinge axis should be equal. thus the constraint equations are
 //    p*w1 - p*w2 = 0
 //    q*w1 - q*w2 = 0
 // where p and q are unit vectors normal to the hinge axis, and w1 and w2
 // are the angular velocity vectors of the two bodies.
 int s3 = 3 * s;
 int s4 = 4 * s;
 info->m_J1angularAxis[s3 + 0] = p[0];
 info->m_J1angularAxis[s3 + 1] = p[1];
 info->m_J1angularAxis[s3 + 2] = p[2];
 info->m_J1angularAxis[s4 + 0] = q[0];
 info->m_J1angularAxis[s4 + 1] = q[1];
 info->m_J1angularAxis[s4 + 2] = q[2];

 info->m_J2angularAxis[s3 + 0] = -p[0];
 info->m_J2angularAxis[s3 + 1] = -p[1];
 info->m_J2angularAxis[s3 + 2] = -p[2];
 info->m_J2angularAxis[s4 + 0] = -q[0];
 info->m_J2angularAxis[s4 + 1] = -q[1];
 info->m_J2angularAxis[s4 + 2] = -q[2];
 // compute the right hand side of the constraint equation. set relative
 // body velocities along p and q to bring the hinge back into alignment.
 // if ax1A,ax1B are the unit length hinge axes as computed from bodyA and
 // bodyB, we need to rotate both bodies along the axis u = (ax1 x ax2).
 // if "theta" is the angle between ax1 and ax2, we need an angular velocity
 // along u to cover angle erp*theta in one step :
 //   |angular_velocity| = angle/time = erp*theta / stepsize
 //                      = (erp*fps) * theta
 //    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
 //                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
 // ...as ax1 and ax2 are unit length. if theta is smallish,
 // theta ~= sin(theta), so
 //    angular_velocity  = (erp*fps) * (ax1 x ax2)
 // ax1 x ax2 is in the plane space of ax1, so we project the angular
 // velocity to p and q to find the right hand side.
 k = info->fps * normalErp;//??

 btVector3 u = ax1A.cross(ax1B);
 info->m_constraintError[s3] = k * u.dot(p);
 info->m_constraintError[s4] = k * u.dot(q);
#endif
 // check angular limits
 nrow = 4; // last filled row
 int srow;
 btScalar limit_err = btScalar(0.0);
 int limit = 0;
 if (getSolveLimit())
 {
#ifdef	_BT_USE_CENTER_LIMIT_
  limit_err = m_limit.getCorrection() * m_referenceSign;
#else
  limit_err = m_correction * m_referenceSign;
#endif
  limit = (limit_err > btScalar(0.0)) ? 1 : 2;

 }
 // if the hinge has joint limits or motor, add in the extra row
 bool powered = getEnableAngularMotor();
 if (limit || powered)
 {
  nrow++;
  srow = nrow * info->rowskip;
  info->m_J1angularAxis[srow + 0] = ax1[0];
  info->m_J1angularAxis[srow + 1] = ax1[1];
  info->m_J1angularAxis[srow + 2] = ax1[2];

  info->m_J2angularAxis[srow + 0] = -ax1[0];
  info->m_J2angularAxis[srow + 1] = -ax1[1];
  info->m_J2angularAxis[srow + 2] = -ax1[2];

  btScalar lostop = getLowerLimit();
  btScalar histop = getUpperLimit();
  if (limit && (lostop == histop))
  {  // the joint motor is ineffective
   powered = false;
  }
  info->m_constraintError[srow] = btScalar(0.0f);
  btScalar currERP = (m_flags & BT_HINGE_FLAGS_ERP_STOP) ? m_stopERP : normalErp;
  if (powered)
  {
   if (m_flags & BT_HINGE_FLAGS_CFM_NORM)
   {
    info->cfm[srow] = m_normalCFM;
   }
   btScalar mot_fact = getMotorFactor(m_hingeAngle, lostop, histop, m_motorTargetVelocity, info->fps * currERP);
   info->m_constraintError[srow] += mot_fact * m_motorTargetVelocity * m_referenceSign;
   info->m_lowerLimit[srow] = -m_maxMotorImpulse;
   info->m_upperLimit[srow] = m_maxMotorImpulse;
  }
  if (limit)
  {
   k = info->fps * currERP;
   info->m_constraintError[srow] += k * limit_err;
   if (m_flags & BT_HINGE_FLAGS_CFM_STOP)
   {
    info->cfm[srow] = m_stopCFM;
   }
   if (lostop == histop)
   {
    // limited low and high simultaneously
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else if (limit == 1)
   { // low limit
    info->m_lowerLimit[srow] = 0;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else
   { // high limit
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = 0;
   }
   // bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
#ifdef	_BT_USE_CENTER_LIMIT_
   btScalar bounce = m_limit.getRelaxationFactor();
#else
   btScalar bounce = m_relaxationFactor;
#endif
   if (bounce > btScalar(0.0))
   {
    btScalar vel = angVelA.dot(ax1);
    vel -= angVelB.dot(ax1);
    // only apply bounce if the velocity is incoming, and if the
    // resulting c[] exceeds what we already have.
    if (limit == 1)
    {	// low limit
     if (vel < 0)
     {
      btScalar newc = -bounce * vel;
      if (newc > info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
    else
    {	// high limit - all those computations are reversed
     if (vel > 0)
     {
      btScalar newc = -bounce * vel;
      if (newc < info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
   }
#ifdef	_BT_USE_CENTER_LIMIT_
   info->m_constraintError[srow] *= m_limit.getBiasFactor();
#else
   info->m_constraintError[srow] *= m_biasFactor;
#endif
  } // if(limit)
 } // if angular limit or powered
}


///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void btHingeConstraint::setParam(int num, btScalar value, int axis)
{
 if ((axis == -1) || (axis == 5))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   m_stopERP = value;
   m_flags |= BT_HINGE_FLAGS_ERP_STOP;
   break;
  case BT_CONSTRAINT_STOP_CFM:
   m_stopCFM = value;
   m_flags |= BT_HINGE_FLAGS_CFM_STOP;
   break;
  case BT_CONSTRAINT_CFM:
   m_normalCFM = value;
   m_flags |= BT_HINGE_FLAGS_CFM_NORM;
   break;
  case BT_CONSTRAINT_ERP:
   m_normalERP = value;
   m_flags |= BT_HINGE_FLAGS_ERP_NORM;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
}

///return the local value of parameter
btScalar btHingeConstraint::getParam(int num, int axis) const
{
 btScalar retVal = 0;
 if ((axis == -1) || (axis == 5))
 {
  switch (num)
  {
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & BT_HINGE_FLAGS_ERP_STOP);
   retVal = m_stopERP;
   break;
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & BT_HINGE_FLAGS_CFM_STOP);
   retVal = m_stopCFM;
   break;
  case BT_CONSTRAINT_CFM:
   btAssertConstrParams(m_flags & BT_HINGE_FLAGS_CFM_NORM);
   retVal = m_normalCFM;
   break;
  case BT_CONSTRAINT_ERP:
   btAssertConstrParams(m_flags & BT_HINGE_FLAGS_ERP_NORM);
   retVal = m_normalERP;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 else
 {
  btAssertConstrParams(0);
 }
 return retVal;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/ConstraintSolver/btNNCGConstraintSolver.h"






btScalar btNNCGConstraintSolver::solveGroupCacheFriendlySetup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 btScalar val = btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySetup(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

 m_pNC.resizeNoInitialize(m_tmpSolverNonContactConstraintPool.size());
 m_pC.resizeNoInitialize(m_tmpSolverContactConstraintPool.size());
 m_pCF.resizeNoInitialize(m_tmpSolverContactFrictionConstraintPool.size());
 m_pCRF.resizeNoInitialize(m_tmpSolverContactRollingFrictionConstraintPool.size());

 m_deltafNC.resizeNoInitialize(m_tmpSolverNonContactConstraintPool.size());
 m_deltafC.resizeNoInitialize(m_tmpSolverContactConstraintPool.size());
 m_deltafCF.resizeNoInitialize(m_tmpSolverContactFrictionConstraintPool.size());
 m_deltafCRF.resizeNoInitialize(m_tmpSolverContactRollingFrictionConstraintPool.size());

 return val;
}

btScalar btNNCGConstraintSolver::solveSingleIteration(int iteration, btCollisionObject** /*bodies */, int /*numBodies*/, btPersistentManifold** /*manifoldPtr*/, int /*numManifolds*/, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* /*debugDrawer*/)
{

 int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
 int numConstraintPool = m_tmpSolverContactConstraintPool.size();
 int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

 if (infoGlobal.m_solverMode & SOLVER_RANDMIZE_ORDER)
 {
  if (1)			// uncomment this for a bit less random ((iteration & 7) == 0)
  {

   for (int j = 0; j<numNonContactPool; ++j) {
    int tmp = m_orderNonContactConstraintPool[j];
    int swapi = btRandInt2(j + 1);
    m_orderNonContactConstraintPool[j] = m_orderNonContactConstraintPool[swapi];
    m_orderNonContactConstraintPool[swapi] = tmp;
   }

   //contact/friction constraints are not solved more than 
   if (iteration< infoGlobal.m_numIterations)
   {
    for (int j = 0; j<numConstraintPool; ++j) {
     int tmp = m_orderTmpConstraintPool[j];
     int swapi = btRandInt2(j + 1);
     m_orderTmpConstraintPool[j] = m_orderTmpConstraintPool[swapi];
     m_orderTmpConstraintPool[swapi] = tmp;
    }

    for (int j = 0; j<numFrictionPool; ++j) {
     int tmp = m_orderFrictionConstraintPool[j];
     int swapi = btRandInt2(j + 1);
     m_orderFrictionConstraintPool[j] = m_orderFrictionConstraintPool[swapi];
     m_orderFrictionConstraintPool[swapi] = tmp;
    }
   }
  }
 }


 btScalar deltaflengthsqr = 0;
 {
  for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
  {
   btSolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
   if (iteration < constraint.m_overrideNumSolverIterations)
   {
    btScalar deltaf = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[constraint.m_solverBodyIdA], m_tmpSolverBodyPool[constraint.m_solverBodyIdB], constraint);
    m_deltafNC[j] = deltaf;
    deltaflengthsqr += deltaf * deltaf;
   }
  }
 }


 if (m_onlyForNoneContact)
 {
  if (iteration == 0)
  {
   for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++) m_pNC[j] = m_deltafNC[j];
  }
  else {
   // deltaflengthsqrprev can be 0 only if the solver solved the problem exactly in the previous iteration. In this case we should have quit, but mainly for debug reason with this 'hack' it is now allowed to continue the calculation
   btScalar beta = m_deltafLengthSqrPrev>0 ? deltaflengthsqr / m_deltafLengthSqrPrev : 2;
   if (beta>1)
   {
    for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++) m_pNC[j] = 0;
   }
   else
   {
    for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
    {
     btSolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
     if (iteration < constraint.m_overrideNumSolverIterations)
     {
      btScalar additionaldeltaimpulse = beta * m_pNC[j];
      constraint.m_appliedImpulse = btScalar(constraint.m_appliedImpulse) + additionaldeltaimpulse;
      m_pNC[j] = beta * m_pNC[j] + m_deltafNC[j];
      btSolverBody& body1 = m_tmpSolverBodyPool[constraint.m_solverBodyIdA];
      btSolverBody& body2 = m_tmpSolverBodyPool[constraint.m_solverBodyIdB];
      const btSolverConstraint& c = constraint;
      body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, additionaldeltaimpulse);
      body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, additionaldeltaimpulse);
     }
    }
   }
  }
  m_deltafLengthSqrPrev = deltaflengthsqr;
 }



 {

  if (iteration< infoGlobal.m_numIterations)
  {
   for (int j = 0; j<numConstraints; j++)
   {
    if (constraints[j]->isEnabled())
    {
     int bodyAid = getOrInitSolverBody(constraints[j]->getRigidBodyA(), infoGlobal.m_timeStep);
     int bodyBid = getOrInitSolverBody(constraints[j]->getRigidBodyB(), infoGlobal.m_timeStep);
     btSolverBody& bodyA = m_tmpSolverBodyPool[bodyAid];
     btSolverBody& bodyB = m_tmpSolverBodyPool[bodyBid];
     constraints[j]->solveConstraintObsolete(bodyA, bodyB, infoGlobal.m_timeStep);
    }
   }

   ///solve all contact constraints
   if (infoGlobal.m_solverMode & SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
   {
    int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
    int multiplier = (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS) ? 2 : 1;

    for (int c = 0; c<numPoolConstraints; c++)
    {
     btScalar totalImpulse = 0;

     {
      const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[c]];
      btScalar deltaf = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
      m_deltafC[c] = deltaf;
      deltaflengthsqr += deltaf*deltaf;
      totalImpulse = solveManifold.m_appliedImpulse;
     }
     bool applyFriction = true;
     if (applyFriction)
     {
      {

       btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier]];

       if (totalImpulse>btScalar(0))
       {
        solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
        solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;
        btScalar deltaf = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
        m_deltafCF[c*multiplier] = deltaf;
        deltaflengthsqr += deltaf*deltaf;
       }
       else {
        m_deltafCF[c*multiplier] = 0;
       }
      }

      if (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS)
      {

       btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier + 1]];

       if (totalImpulse>btScalar(0))
       {
        solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
        solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;
        btScalar deltaf = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
        m_deltafCF[c*multiplier + 1] = deltaf;
        deltaflengthsqr += deltaf*deltaf;
       }
       else {
        m_deltafCF[c*multiplier + 1] = 0;
       }
      }
     }
    }

   }
   else//SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
   {
    //solve the friction constraints after all contact constraints, don't interleave them
    int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
    int j;

    for (j = 0; j<numPoolConstraints; j++)
    {
     const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
     btScalar deltaf = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     m_deltafC[j] = deltaf;
     deltaflengthsqr += deltaf*deltaf;
    }



    ///solve all friction constraints

    int numFrictionPoolConstraints = m_tmpSolverContactFrictionConstraintPool.size();
    for (j = 0; j<numFrictionPoolConstraints; j++)
    {
     btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
     btScalar totalImpulse = m_tmpSolverContactConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;

     if (totalImpulse>btScalar(0))
     {
      solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
      solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

      btScalar deltaf = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
      m_deltafCF[j] = deltaf;
      deltaflengthsqr += deltaf*deltaf;
     }
     else {
      m_deltafCF[j] = 0;
     }
    }
   }

   {
    int numRollingFrictionPoolConstraints = m_tmpSolverContactRollingFrictionConstraintPool.size();
    for (int j = 0; j<numRollingFrictionPoolConstraints; j++)
    {

     btSolverConstraint& rollingFrictionConstraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
     btScalar totalImpulse = m_tmpSolverContactConstraintPool[rollingFrictionConstraint.m_frictionIndex].m_appliedImpulse;
     if (totalImpulse>btScalar(0))
     {
      btScalar rollingFrictionMagnitude = rollingFrictionConstraint.m_friction*totalImpulse;
      if (rollingFrictionMagnitude>rollingFrictionConstraint.m_friction)
       rollingFrictionMagnitude = rollingFrictionConstraint.m_friction;

      rollingFrictionConstraint.m_lowerLimit = -rollingFrictionMagnitude;
      rollingFrictionConstraint.m_upperLimit = rollingFrictionMagnitude;

      btScalar deltaf = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdA], m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdB], rollingFrictionConstraint);
      m_deltafCRF[j] = deltaf;
      deltaflengthsqr += deltaf*deltaf;
     }
     else {
      m_deltafCRF[j] = 0;
     }
    }
   }

  }



 }




 if (!m_onlyForNoneContact)
 {
  if (iteration == 0)
  {
   for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++) m_pNC[j] = m_deltafNC[j];
   for (int j = 0; j<m_tmpSolverContactConstraintPool.size(); j++) m_pC[j] = m_deltafC[j];
   for (int j = 0; j<m_tmpSolverContactFrictionConstraintPool.size(); j++) m_pCF[j] = m_deltafCF[j];
   for (int j = 0; j<m_tmpSolverContactRollingFrictionConstraintPool.size(); j++) m_pCRF[j] = m_deltafCRF[j];
  }
  else
  {
   // deltaflengthsqrprev can be 0 only if the solver solved the problem exactly in the previous iteration. In this case we should have quit, but mainly for debug reason with this 'hack' it is now allowed to continue the calculation
   btScalar beta = m_deltafLengthSqrPrev>0 ? deltaflengthsqr / m_deltafLengthSqrPrev : 2;
   if (beta>1) {
    for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++) m_pNC[j] = 0;
    for (int j = 0; j<m_tmpSolverContactConstraintPool.size(); j++) m_pC[j] = 0;
    for (int j = 0; j<m_tmpSolverContactFrictionConstraintPool.size(); j++) m_pCF[j] = 0;
    for (int j = 0; j<m_tmpSolverContactRollingFrictionConstraintPool.size(); j++) m_pCRF[j] = 0;
   }
   else {
    for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
    {
     btSolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
     if (iteration < constraint.m_overrideNumSolverIterations) {
      btScalar additionaldeltaimpulse = beta * m_pNC[j];
      constraint.m_appliedImpulse = btScalar(constraint.m_appliedImpulse) + additionaldeltaimpulse;
      m_pNC[j] = beta * m_pNC[j] + m_deltafNC[j];
      btSolverBody& body1 = m_tmpSolverBodyPool[constraint.m_solverBodyIdA];
      btSolverBody& body2 = m_tmpSolverBodyPool[constraint.m_solverBodyIdB];
      const btSolverConstraint& c = constraint;
      body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, additionaldeltaimpulse);
      body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, additionaldeltaimpulse);
     }
    }
    for (int j = 0; j<m_tmpSolverContactConstraintPool.size(); j++)
    {
     btSolverConstraint& constraint = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
     if (iteration< infoGlobal.m_numIterations) {
      btScalar additionaldeltaimpulse = beta * m_pC[j];
      constraint.m_appliedImpulse = btScalar(constraint.m_appliedImpulse) + additionaldeltaimpulse;
      m_pC[j] = beta * m_pC[j] + m_deltafC[j];
      btSolverBody& body1 = m_tmpSolverBodyPool[constraint.m_solverBodyIdA];
      btSolverBody& body2 = m_tmpSolverBodyPool[constraint.m_solverBodyIdB];
      const btSolverConstraint& c = constraint;
      body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, additionaldeltaimpulse);
      body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, additionaldeltaimpulse);
     }
    }
    for (int j = 0; j<m_tmpSolverContactFrictionConstraintPool.size(); j++)
    {
     btSolverConstraint& constraint = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
     if (iteration< infoGlobal.m_numIterations) {
      btScalar additionaldeltaimpulse = beta * m_pCF[j];
      constraint.m_appliedImpulse = btScalar(constraint.m_appliedImpulse) + additionaldeltaimpulse;
      m_pCF[j] = beta * m_pCF[j] + m_deltafCF[j];
      btSolverBody& body1 = m_tmpSolverBodyPool[constraint.m_solverBodyIdA];
      btSolverBody& body2 = m_tmpSolverBodyPool[constraint.m_solverBodyIdB];
      const btSolverConstraint& c = constraint;
      body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, additionaldeltaimpulse);
      body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, additionaldeltaimpulse);
     }
    }
    {
     for (int j = 0; j<m_tmpSolverContactRollingFrictionConstraintPool.size(); j++)
     {
      btSolverConstraint& constraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
      if (iteration< infoGlobal.m_numIterations) {
       btScalar additionaldeltaimpulse = beta * m_pCRF[j];
       constraint.m_appliedImpulse = btScalar(constraint.m_appliedImpulse) + additionaldeltaimpulse;
       m_pCRF[j] = beta * m_pCRF[j] + m_deltafCRF[j];
       btSolverBody& body1 = m_tmpSolverBodyPool[constraint.m_solverBodyIdA];
       btSolverBody& body2 = m_tmpSolverBodyPool[constraint.m_solverBodyIdB];
       const btSolverConstraint& c = constraint;
       body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, additionaldeltaimpulse);
       body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, additionaldeltaimpulse);
      }
     }
    }
   }
  }
  m_deltafLengthSqrPrev = deltaflengthsqr;
 }

 return deltaflengthsqr;
}

btScalar btNNCGConstraintSolver::solveGroupCacheFriendlyFinish(btCollisionObject** bodies, int numBodies, const btContactSolverInfo& infoGlobal)
{
 m_pNC.resizeNoInitialize(0);
 m_pC.resizeNoInitialize(0);
 m_pCF.resizeNoInitialize(0);
 m_pCRF.resizeNoInitialize(0);

 m_deltafNC.resizeNoInitialize(0);
 m_deltafC.resizeNoInitialize(0);
 m_deltafCF.resizeNoInitialize(0);
 m_deltafCRF.resizeNoInitialize(0);

 return btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyFinish(bodies, numBodies, infoGlobal);
}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include <new>





btPoint2PointConstraint::btPoint2PointConstraint(btRigidBody& rbA, btRigidBody& rbB, const btVector3& pivotInA, const btVector3& pivotInB)
 :btTypedConstraint(POINT2POINT_CONSTRAINT_TYPE, rbA, rbB), m_pivotInA(pivotInA), m_pivotInB(pivotInB),
 m_flags(0),
 m_useSolveConstraintObsolete(false)
{

}


btPoint2PointConstraint::btPoint2PointConstraint(btRigidBody& rbA, const btVector3& pivotInA)
 :btTypedConstraint(POINT2POINT_CONSTRAINT_TYPE, rbA), m_pivotInA(pivotInA), m_pivotInB(rbA.getCenterOfMassTransform()(pivotInA)),
 m_flags(0),
 m_useSolveConstraintObsolete(false)
{

}

void	btPoint2PointConstraint::buildJacobian()
{

 ///we need it for both methods
 {
  m_appliedImpulse = btScalar(0.);

  btVector3	normal(0, 0, 0);

  for (int i = 0; i<3; i++)
  {
   normal[i] = 1;
   new (&m_jac[i]) btJacobianEntry(
    m_rbA.getCenterOfMassTransform().getBasis().transpose(),
    m_rbB.getCenterOfMassTransform().getBasis().transpose(),
    m_rbA.getCenterOfMassTransform()*m_pivotInA - m_rbA.getCenterOfMassPosition(),
    m_rbB.getCenterOfMassTransform()*m_pivotInB - m_rbB.getCenterOfMassPosition(),
    normal,
    m_rbA.getInvInertiaDiagLocal(),
    m_rbA.getInvMass(),
    m_rbB.getInvInertiaDiagLocal(),
    m_rbB.getInvMass());
   normal[i] = 0;
  }
 }


}

void btPoint2PointConstraint::getInfo1(btConstraintInfo1* info)
{
 getInfo1NonVirtual(info);
}

void btPoint2PointConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  info->m_numConstraintRows = 3;
  info->nub = 3;
 }
}




void btPoint2PointConstraint::getInfo2(btConstraintInfo2* info)
{
 getInfo2NonVirtual(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

void btPoint2PointConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& body0_trans, const btTransform& body1_trans)
{
 btAssert(!m_useSolveConstraintObsolete);

 //retrieve matrices

 // anchor points in global coordinates with respect to body PORs.

 // set jacobian
 info->m_J1linearAxis[0] = 1;
 info->m_J1linearAxis[info->rowskip + 1] = 1;
 info->m_J1linearAxis[2 * info->rowskip + 2] = 1;

 btVector3 a1 = body0_trans.getBasis()*getPivotInA();
 {
  btVector3* angular0 = (btVector3*)(info->m_J1angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J1angularAxis + info->rowskip);
  btVector3* angular2 = (btVector3*)(info->m_J1angularAxis + 2 * info->rowskip);
  btVector3 a1neg = -a1;
  a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }

 info->m_J2linearAxis[0] = -1;
 info->m_J2linearAxis[info->rowskip + 1] = -1;
 info->m_J2linearAxis[2 * info->rowskip + 2] = -1;

 btVector3 a2 = body1_trans.getBasis()*getPivotInB();

 {
  //	btVector3 a2n = -a2;
  btVector3* angular0 = (btVector3*)(info->m_J2angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J2angularAxis + info->rowskip);
  btVector3* angular2 = (btVector3*)(info->m_J2angularAxis + 2 * info->rowskip);
  a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }



 // set right hand side
 btScalar currERP = (m_flags & BT_P2P_FLAGS_ERP) ? m_erp : info->erp;
 btScalar k = info->fps * currERP;
 int j;
 for (j = 0; j<3; j++)
 {
  info->m_constraintError[j*info->rowskip] = k * (a2[j] + body1_trans.getOrigin()[j] - a1[j] - body0_trans.getOrigin()[j]);
  //printf("info->m_constraintError[%d]=%f\n",j,info->m_constraintError[j]);
 }
 if (m_flags & BT_P2P_FLAGS_CFM)
 {
  for (j = 0; j<3; j++)
  {
   info->cfm[j*info->rowskip] = m_cfm;
  }
 }

 btScalar impulseClamp = m_setting.m_impulseClamp;//
 for (j = 0; j<3; j++)
 {
  if (m_setting.m_impulseClamp > 0)
  {
   info->m_lowerLimit[j*info->rowskip] = -impulseClamp;
   info->m_upperLimit[j*info->rowskip] = impulseClamp;
  }
 }
 info->m_damping = m_setting.m_damping;

}



void	btPoint2PointConstraint::updateRHS(btScalar	timeStep)
{
 (void)timeStep;

}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void btPoint2PointConstraint::setParam(int num, btScalar value, int axis)
{
 if (axis != -1)
 {
  btAssertConstrParams(0);
 }
 else
 {
  switch (num)
  {
  case BT_CONSTRAINT_ERP:
  case BT_CONSTRAINT_STOP_ERP:
   m_erp = value;
   m_flags |= BT_P2P_FLAGS_ERP;
   break;
  case BT_CONSTRAINT_CFM:
  case BT_CONSTRAINT_STOP_CFM:
   m_cfm = value;
   m_flags |= BT_P2P_FLAGS_CFM;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
}

///return the local value of parameter
btScalar btPoint2PointConstraint::getParam(int num, int axis) const
{
 btScalar retVal(SIMD_INFINITY);
 if (axis != -1)
 {
  btAssertConstrParams(0);
 }
 else
 {
  switch (num)
  {
  case BT_CONSTRAINT_ERP:
  case BT_CONSTRAINT_STOP_ERP:
   btAssertConstrParams(m_flags & BT_P2P_FLAGS_ERP);
   retVal = m_erp;
   break;
  case BT_CONSTRAINT_CFM:
  case BT_CONSTRAINT_STOP_CFM:
   btAssertConstrParams(m_flags & BT_P2P_FLAGS_CFM);
   retVal = m_cfm;
   break;
  default:
   btAssertConstrParams(0);
  }
 }
 return retVal;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//#define COMPUTE_IMPULSE_DENOM 1
//#define BT_ADDITIONAL_DEBUG

//It is not necessary (redundant) to refresh contact manifolds, this refresh has been moved to the collision algorithms.

#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"

#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btCpuFeatureUtility.h"

//#include "btJacobianEntry.h"
#include "LinearMath/btMinMax.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include <new>
#include "LinearMath/btStackAlloc.h"
#include "LinearMath/btQuickprof.h"
//#include "btSolverBody.h"
//#include "btSolverConstraint.h"
#include "LinearMath/btAlignedObjectArray.h"
#include <string.h> //for memset

int		gNumSplitImpulseRecoveries = 0;

#include "BulletDynamics/Dynamics/btRigidBody.h"

//#define VERBOSE_RESIDUAL_PRINTF 1
///This is the scalar reference implementation of solving a single constraint row, the innerloop of the Projected Gauss Seidel/Sequential Impulse constraint solver
///Below are optional SSE2 and SSE4/FMA3 versions. We assume most hardware has SSE2. For SSE4/FMA3 we perform a CPU feature check.
static btSimdScalar gResolveSingleConstraintRowGeneric_scalar_reference(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 btScalar deltaImpulse = c.m_rhs - btScalar(c.m_appliedImpulse)*c.m_cfm;
 const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(body1.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetDeltaAngularVelocity());
 const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(body2.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetDeltaAngularVelocity());

 //	const btScalar delta_rel_vel	=	deltaVel1Dotn-deltaVel2Dotn;
 deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
 deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;

 const btScalar sum = btScalar(c.m_appliedImpulse) + deltaImpulse;
 if (sum < c.m_lowerLimit)
 {
  deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_lowerLimit;
 }
 else if (sum > c.m_upperLimit)
 {
  deltaImpulse = c.m_upperLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_upperLimit;
 }
 else
 {
  c.m_appliedImpulse = sum;
 }

 body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
 body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);

 return deltaImpulse;
}


static btSimdScalar gResolveSingleConstraintRowLowerLimit_scalar_reference(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 btScalar deltaImpulse = c.m_rhs - btScalar(c.m_appliedImpulse)*c.m_cfm;
 const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(body1.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetDeltaAngularVelocity());
 const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(body2.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetDeltaAngularVelocity());

 deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
 deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;
 const btScalar sum = btScalar(c.m_appliedImpulse) + deltaImpulse;
 if (sum < c.m_lowerLimit)
 {
  deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
  c.m_appliedImpulse = c.m_lowerLimit;
 }
 else
 {
  c.m_appliedImpulse = sum;
 }
 body1.internalApplyImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
 body2.internalApplyImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);

 return deltaImpulse;
}



#ifdef USE_SIMD
#include <emmintrin.h>


#define btVecSplat(x, e) _mm_shuffle_ps(x, x, _MM_SHUFFLE(e,e,e,e))
static inline __m128 btSimdDot3(__m128 vec0, __m128 vec1)
{
 __m128 result = _mm_mul_ps(vec0, vec1);
 return _mm_add_ps(btVecSplat(result, 0), _mm_add_ps(btVecSplat(result, 1), btVecSplat(result, 2)));
}

#if defined (BT_ALLOW_SSE4)
#include <intrin.h>

#define USE_FMA					1
#define USE_FMA3_INSTEAD_FMA4	1
#define USE_SSE4_DOT			1

#define SSE4_DP(a, b)			_mm_dp_ps(a, b, 0x7f)
#define SSE4_DP_FP(a, b)		_mm_cvtss_f32(_mm_dp_ps(a, b, 0x7f))

#if USE_SSE4_DOT
#define DOT_PRODUCT(a, b)		SSE4_DP(a, b)
#else
#define DOT_PRODUCT(a, b)		btSimdDot3(a, b)
#endif

#if USE_FMA
#if USE_FMA3_INSTEAD_FMA4
// a*b + c
#define FMADD(a, b, c)		_mm_fmadd_ps(a, b, c)
// -(a*b) + c
#define FMNADD(a, b, c)		_mm_fnmadd_ps(a, b, c)
#else // USE_FMA3
// a*b + c
#define FMADD(a, b, c)		_mm_macc_ps(a, b, c)
// -(a*b) + c
#define FMNADD(a, b, c)		_mm_nmacc_ps(a, b, c)
#endif
#else // USE_FMA
// c + a*b
#define FMADD(a, b, c)		_mm_add_ps(c, _mm_mul_ps(a, b))
// c - a*b
#define FMNADD(a, b, c)		_mm_sub_ps(c, _mm_mul_ps(a, b))
#endif
#endif

// Project Gauss Seidel or the equivalent Sequential Impulse
static btSimdScalar gResolveSingleConstraintRowGeneric_sse2(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 btSimdScalar deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, body2.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 btSimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128 upperMinApplied = _mm_sub_ps(upperLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, deltaImpulse), _mm_andnot_ps(resultUpperLess, upperMinApplied));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, c.m_appliedImpulse), _mm_andnot_ps(resultUpperLess, upperLimit1));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps((c.m_contactNormal2).mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
 return deltaImpulse;
}


// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
static btSimdScalar gResolveSingleConstraintRowGeneric_sse4_1_fma3(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
#if defined (BT_ALLOW_SSE4)
 __m128 tmp = _mm_set_ps1(c.m_jacDiagABInv);
 __m128 deltaImpulse = _mm_set_ps1(c.m_rhs - btScalar(c.m_appliedImpulse)*c.m_cfm);
 const __m128 lowerLimit = _mm_set_ps1(c.m_lowerLimit);
 const __m128 upperLimit = _mm_set_ps1(c.m_upperLimit);
 const __m128 deltaVel1Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal1.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 const __m128 deltaVel2Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal2.mVec128, body2.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128));
 deltaImpulse = FMNADD(deltaVel1Dotn, tmp, deltaImpulse);
 deltaImpulse = FMNADD(deltaVel2Dotn, tmp, deltaImpulse);
 tmp = _mm_add_ps(c.m_appliedImpulse, deltaImpulse); // sum
 const __m128 maskLower = _mm_cmpgt_ps(tmp, lowerLimit);
 const __m128 maskUpper = _mm_cmpgt_ps(upperLimit, tmp);
 deltaImpulse = _mm_blendv_ps(_mm_sub_ps(lowerLimit, c.m_appliedImpulse), _mm_blendv_ps(_mm_sub_ps(upperLimit, c.m_appliedImpulse), deltaImpulse, maskUpper), maskLower);
 c.m_appliedImpulse = _mm_blendv_ps(lowerLimit, _mm_blendv_ps(upperLimit, tmp, maskUpper), maskLower);
 body1.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal1.mVec128, body1.internalGetInvMass().mVec128), deltaImpulse, body1.internalGetDeltaLinearVelocity().mVec128);
 body1.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentA.mVec128, deltaImpulse, body1.internalGetDeltaAngularVelocity().mVec128);
 body2.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal2.mVec128, body2.internalGetInvMass().mVec128), deltaImpulse, body2.internalGetDeltaLinearVelocity().mVec128);
 body2.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentB.mVec128, deltaImpulse, body2.internalGetDeltaAngularVelocity().mVec128);
 return deltaImpulse;
#else
 return gResolveSingleConstraintRowGeneric_sse2(body1, body2, c);
#endif
}



static btSimdScalar gResolveSingleConstraintRowLowerLimit_sse2(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 btSimdScalar deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, body2.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 btSimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps(c.m_contactNormal2.mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body1.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(body2.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
 return deltaImpulse;
}


// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
static btSimdScalar gResolveSingleConstraintRowLowerLimit_sse4_1_fma3(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
#ifdef BT_ALLOW_SSE4
 __m128 tmp = _mm_set_ps1(c.m_jacDiagABInv);
 __m128 deltaImpulse = _mm_set_ps1(c.m_rhs - btScalar(c.m_appliedImpulse)*c.m_cfm);
 const __m128 lowerLimit = _mm_set_ps1(c.m_lowerLimit);
 const __m128 deltaVel1Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal1.mVec128, body1.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos1CrossNormal.mVec128, body1.internalGetDeltaAngularVelocity().mVec128));
 const __m128 deltaVel2Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal2.mVec128, body2.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos2CrossNormal.mVec128, body2.internalGetDeltaAngularVelocity().mVec128));
 deltaImpulse = FMNADD(deltaVel1Dotn, tmp, deltaImpulse);
 deltaImpulse = FMNADD(deltaVel2Dotn, tmp, deltaImpulse);
 tmp = _mm_add_ps(c.m_appliedImpulse, deltaImpulse);
 const __m128 mask = _mm_cmpgt_ps(tmp, lowerLimit);
 deltaImpulse = _mm_blendv_ps(_mm_sub_ps(lowerLimit, c.m_appliedImpulse), deltaImpulse, mask);
 c.m_appliedImpulse = _mm_blendv_ps(lowerLimit, tmp, mask);
 body1.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal1.mVec128, body1.internalGetInvMass().mVec128), deltaImpulse, body1.internalGetDeltaLinearVelocity().mVec128);
 body1.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentA.mVec128, deltaImpulse, body1.internalGetDeltaAngularVelocity().mVec128);
 body2.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal2.mVec128, body2.internalGetInvMass().mVec128), deltaImpulse, body2.internalGetDeltaLinearVelocity().mVec128);
 body2.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentB.mVec128, deltaImpulse, body2.internalGetDeltaAngularVelocity().mVec128);
 return deltaImpulse;
#else
 return gResolveSingleConstraintRowLowerLimit_sse2(body1, body2, c);
#endif //BT_ALLOW_SSE4
}


#endif //USE_SIMD



btSimdScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowGenericSIMD(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 return m_resolveSingleConstraintRowGeneric(body1, body2, c);
}

// Project Gauss Seidel or the equivalent Sequential Impulse
btSimdScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowGeneric(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 return m_resolveSingleConstraintRowGeneric(body1, body2, c);
}

btSimdScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowLowerLimitSIMD(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 return m_resolveSingleConstraintRowLowerLimit(body1, body2, c);
}


btSimdScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowLowerLimit(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
 return m_resolveSingleConstraintRowLowerLimit(body1, body2, c);
}


static btSimdScalar gResolveSplitPenetrationImpulse_scalar_reference(
 btSolverBody& body1,
 btSolverBody& body2,
 const btSolverConstraint& c)
{
 btScalar deltaImpulse = 0.f;

 if (c.m_rhsPenetration)
 {
  gNumSplitImpulseRecoveries++;
  deltaImpulse = c.m_rhsPenetration - btScalar(c.m_appliedPushImpulse)*c.m_cfm;
  const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(body1.internalGetPushVelocity()) + c.m_relpos1CrossNormal.dot(body1.internalGetTurnVelocity());
  const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(body2.internalGetPushVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetTurnVelocity());

  deltaImpulse -= deltaVel1Dotn*c.m_jacDiagABInv;
  deltaImpulse -= deltaVel2Dotn*c.m_jacDiagABInv;
  const btScalar sum = btScalar(c.m_appliedPushImpulse) + deltaImpulse;
  if (sum < c.m_lowerLimit)
  {
   deltaImpulse = c.m_lowerLimit - c.m_appliedPushImpulse;
   c.m_appliedPushImpulse = c.m_lowerLimit;
  }
  else
  {
   c.m_appliedPushImpulse = sum;
  }
  body1.internalApplyPushImpulse(c.m_contactNormal1*body1.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
  body2.internalApplyPushImpulse(c.m_contactNormal2*body2.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
 }
 return deltaImpulse;
}

static btSimdScalar gResolveSplitPenetrationImpulse_sse2(btSolverBody& body1, btSolverBody& body2, const btSolverConstraint& c)
{
#ifdef USE_SIMD
 if (!c.m_rhsPenetration)
  return 0.f;

 gNumSplitImpulseRecoveries++;

 __m128 cpAppliedImp = _mm_set1_ps(c.m_appliedPushImpulse);
 __m128	lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
 __m128	upperLimit1 = _mm_set1_ps(c.m_upperLimit);
 __m128 deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhsPenetration), _mm_mul_ps(_mm_set1_ps(c.m_appliedPushImpulse), _mm_set1_ps(c.m_cfm)));
 __m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, body1.internalGetPushVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, body1.internalGetTurnVelocity().mVec128));
 __m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, body2.internalGetPushVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, body2.internalGetTurnVelocity().mVec128));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
 btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
 btSimdScalar resultLowerLess, resultUpperLess;
 resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
 resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
 __m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
 deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
 c.m_appliedPushImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
 __m128	linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, body1.internalGetInvMass().mVec128);
 __m128	linearComponentB = _mm_mul_ps(c.m_contactNormal2.mVec128, body2.internalGetInvMass().mVec128);
 __m128 impulseMagnitude = deltaImpulse;
 body1.internalGetPushVelocity().mVec128 = _mm_add_ps(body1.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
 body1.internalGetTurnVelocity().mVec128 = _mm_add_ps(body1.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
 body2.internalGetPushVelocity().mVec128 = _mm_add_ps(body2.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
 body2.internalGetTurnVelocity().mVec128 = _mm_add_ps(body2.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
 return deltaImpulse;
#else
 return gResolveSplitPenetrationImpulse_scalar_reference(body1, body2, c);
#endif
}


btSequentialImpulseConstraintSolver::btSequentialImpulseConstraintSolver()
{
 m_btSeed2 = 0;
 m_cachedSolverMode = 0;
 setupSolverFunctions(false);
}

void btSequentialImpulseConstraintSolver::setupSolverFunctions(bool useSimd)
{
 m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_scalar_reference;
 m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_scalar_reference;
 m_resolveSplitPenetrationImpulse = gResolveSplitPenetrationImpulse_scalar_reference;

 if (useSimd)
 {
#ifdef USE_SIMD
  m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_sse2;
  m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_sse2;
  m_resolveSplitPenetrationImpulse = gResolveSplitPenetrationImpulse_sse2;

#ifdef BT_ALLOW_SSE4
  int cpuFeatures = btCpuFeatureUtility::getCpuFeatures();
  if ((cpuFeatures & btCpuFeatureUtility::CPU_FEATURE_FMA3) && (cpuFeatures & btCpuFeatureUtility::CPU_FEATURE_SSE4_1))
  {
   m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_sse4_1_fma3;
   m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_sse4_1_fma3;
  }
#endif//BT_ALLOW_SSE4
#endif //USE_SIMD
 }
}

btSequentialImpulseConstraintSolver::~btSequentialImpulseConstraintSolver()
{
}

btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getScalarConstraintRowSolverGeneric()
{
 return gResolveSingleConstraintRowGeneric_scalar_reference;
}

btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getScalarConstraintRowSolverLowerLimit()
{
 return gResolveSingleConstraintRowLowerLimit_scalar_reference;
}


#ifdef USE_SIMD
btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getSSE2ConstraintRowSolverGeneric()
{
 return gResolveSingleConstraintRowGeneric_sse2;
}
btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getSSE2ConstraintRowSolverLowerLimit()
{
 return gResolveSingleConstraintRowLowerLimit_sse2;
}
#ifdef BT_ALLOW_SSE4
btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getSSE4_1ConstraintRowSolverGeneric()
{
 return gResolveSingleConstraintRowGeneric_sse4_1_fma3;
}
btSingleConstraintRowSolver	btSequentialImpulseConstraintSolver::getSSE4_1ConstraintRowSolverLowerLimit()
{
 return gResolveSingleConstraintRowLowerLimit_sse4_1_fma3;
}
#endif //BT_ALLOW_SSE4
#endif //USE_SIMD

unsigned long btSequentialImpulseConstraintSolver::btRand2()
{
 m_btSeed2 = (1664525L * m_btSeed2 + 1013904223L) & 0xffffffff;
 return m_btSeed2;
}



//See ODE: adam's all-int straightforward(?) dRandInt (0..n-1)
int btSequentialImpulseConstraintSolver::btRandInt2(int n)
{
 // seems good; xor-fold and modulus
 const unsigned long un = static_cast<unsigned long>(n);
 unsigned long r = btRand2();

 // note: probably more aggressive than it needs to be -- might be
 //       able to get away without one or two of the innermost branches.
 if (un <= 0x00010000UL) {
  r ^= (r >> 16);
  if (un <= 0x00000100UL) {
   r ^= (r >> 8);
   if (un <= 0x00000010UL) {
    r ^= (r >> 4);
    if (un <= 0x00000004UL) {
     r ^= (r >> 2);
     if (un <= 0x00000002UL) {
      r ^= (r >> 1);
     }
    }
   }
  }
 }

 return (int)(r % un);
}



void	btSequentialImpulseConstraintSolver::initSolverBody(btSolverBody* solverBody, btCollisionObject* collisionObject, btScalar timeStep)
{

 btRigidBody* rb = collisionObject ? btRigidBody::upcast(collisionObject) : 0;

 solverBody->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
 solverBody->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
 solverBody->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
 solverBody->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);

 if (rb)
 {
  solverBody->m_worldTransform = rb->getWorldTransform();
  solverBody->internalSetInvMass(btVector3(rb->getInvMass(), rb->getInvMass(), rb->getInvMass())*rb->getLinearFactor());
  solverBody->m_originalBody = rb;
  solverBody->m_angularFactor = rb->getAngularFactor();
  solverBody->m_linearFactor = rb->getLinearFactor();
  solverBody->m_linearVelocity = rb->getLinearVelocity();
  solverBody->m_angularVelocity = rb->getAngularVelocity();
  solverBody->m_externalForceImpulse = rb->getTotalForce()*rb->getInvMass()*timeStep;
  solverBody->m_externalTorqueImpulse = rb->getTotalTorque()*rb->getInvInertiaTensorWorld()*timeStep;

 }
 else
 {
  solverBody->m_worldTransform.setIdentity();
  solverBody->internalSetInvMass(btVector3(0, 0, 0));
  solverBody->m_originalBody = 0;
  solverBody->m_angularFactor.setValue(1, 1, 1);
  solverBody->m_linearFactor.setValue(1, 1, 1);
  solverBody->m_linearVelocity.setValue(0, 0, 0);
  solverBody->m_angularVelocity.setValue(0, 0, 0);
  solverBody->m_externalForceImpulse.setValue(0, 0, 0);
  solverBody->m_externalTorqueImpulse.setValue(0, 0, 0);
 }


}






btScalar btSequentialImpulseConstraintSolver::restitutionCurve(btScalar rel_vel, btScalar restitution, btScalar velocityThreshold)
{
 //printf("rel_vel =%f\n", rel_vel);
 if (btFabs(rel_vel)<velocityThreshold)
  return 0.;

 btScalar rest = restitution * -rel_vel;
 return rest;
}



void	btSequentialImpulseConstraintSolver::applyAnisotropicFriction(btCollisionObject* colObj, btVector3& frictionDirection, int frictionMode)
{


 if (colObj && colObj->hasAnisotropicFriction(frictionMode))
 {
  // transform to local coordinates
  btVector3 loc_lateral = frictionDirection * colObj->getWorldTransform().getBasis();
  const btVector3& friction_scaling = colObj->getAnisotropicFriction();
  //apply anisotropic friction
  loc_lateral *= friction_scaling;
  // ... and transform it back to global coordinates
  frictionDirection = colObj->getWorldTransform().getBasis() * loc_lateral;
 }

}




void btSequentialImpulseConstraintSolver::setupFrictionConstraint(btSolverConstraint& solverConstraint, const btVector3& normalAxis, int  solverBodyIdA, int solverBodyIdB, btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, const btContactSolverInfo& infoGlobal, btScalar desiredVelocity, btScalar cfmSlip)
{


 btSolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
 btSolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

 btRigidBody* body0 = m_tmpSolverBodyPool[solverBodyIdA].m_originalBody;
 btRigidBody* body1 = m_tmpSolverBodyPool[solverBodyIdB].m_originalBody;

 solverConstraint.m_solverBodyIdA = solverBodyIdA;
 solverConstraint.m_solverBodyIdB = solverBodyIdB;

 solverConstraint.m_friction = cp.m_combinedFriction;
 solverConstraint.m_originalContactPoint = 0;

 solverConstraint.m_appliedImpulse = 0.f;
 solverConstraint.m_appliedPushImpulse = 0.f;

 if (body0)
 {
  solverConstraint.m_contactNormal1 = normalAxis;
  btVector3 ftorqueAxis1 = rel_pos1.cross(solverConstraint.m_contactNormal1);
  solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentA = body0->getInvInertiaTensorWorld()*ftorqueAxis1*body0->getAngularFactor();
 }
 else
 {
  solverConstraint.m_contactNormal1.setZero();
  solverConstraint.m_relpos1CrossNormal.setZero();
  solverConstraint.m_angularComponentA.setZero();
 }

 if (body1)
 {
  solverConstraint.m_contactNormal2 = -normalAxis;
  btVector3 ftorqueAxis1 = rel_pos2.cross(solverConstraint.m_contactNormal2);
  solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentB = body1->getInvInertiaTensorWorld()*ftorqueAxis1*body1->getAngularFactor();
 }
 else
 {
  solverConstraint.m_contactNormal2.setZero();
  solverConstraint.m_relpos2CrossNormal.setZero();
  solverConstraint.m_angularComponentB.setZero();
 }

 {
  btVector3 vec;
  btScalar denom0 = 0.f;
  btScalar denom1 = 0.f;
  if (body0)
  {
   vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
   denom0 = body0->getInvMass() + normalAxis.dot(vec);
  }
  if (body1)
  {
   vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
   denom1 = body1->getInvMass() + normalAxis.dot(vec);
  }
  btScalar denom = relaxation / (denom0 + denom1);
  solverConstraint.m_jacDiagABInv = denom;
 }

 {


  btScalar rel_vel;
  btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(body0 ? solverBodyA.m_linearVelocity + solverBodyA.m_externalForceImpulse : btVector3(0, 0, 0))
   + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : btVector3(0, 0, 0));
  btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(body1 ? solverBodyB.m_linearVelocity + solverBodyB.m_externalForceImpulse : btVector3(0, 0, 0))
   + solverConstraint.m_relpos2CrossNormal.dot(body1 ? solverBodyB.m_angularVelocity : btVector3(0, 0, 0));

  rel_vel = vel1Dotn + vel2Dotn;

  //		btScalar positionalError = 0.f;

  btScalar velocityError = desiredVelocity - rel_vel;
  btScalar velocityImpulse = velocityError * solverConstraint.m_jacDiagABInv;

  btScalar penetrationImpulse = btScalar(0);

  if (cp.m_contactPointFlags & BT_CONTACT_FLAG_FRICTION_ANCHOR)
  {
   btScalar distance = (cp.getPositionWorldOnA() - cp.getPositionWorldOnB()).dot(normalAxis);
   btScalar positionalError = -distance * infoGlobal.m_frictionERP / infoGlobal.m_timeStep;
   penetrationImpulse = positionalError*solverConstraint.m_jacDiagABInv;
  }

  solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
  solverConstraint.m_rhsPenetration = 0.f;
  solverConstraint.m_cfm = cfmSlip;
  solverConstraint.m_lowerLimit = -solverConstraint.m_friction;
  solverConstraint.m_upperLimit = solverConstraint.m_friction;

 }
}

btSolverConstraint&	btSequentialImpulseConstraintSolver::addFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, const btContactSolverInfo& infoGlobal, btScalar desiredVelocity, btScalar cfmSlip)
{
 btSolverConstraint& solverConstraint = m_tmpSolverContactFrictionConstraintPool.expandNonInitializing();
 solverConstraint.m_frictionIndex = frictionIndex;
 setupFrictionConstraint(solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, rel_pos1, rel_pos2,
  colObj0, colObj1, relaxation, infoGlobal, desiredVelocity, cfmSlip);
 return solverConstraint;
}


void btSequentialImpulseConstraintSolver::setupTorsionalFrictionConstraint(btSolverConstraint& solverConstraint, const btVector3& normalAxis1, int solverBodyIdA, int  solverBodyIdB,
 btManifoldPoint& cp, btScalar combinedTorsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2,
 btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation,
 btScalar desiredVelocity, btScalar cfmSlip)

{
 btVector3 normalAxis(0, 0, 0);


 solverConstraint.m_contactNormal1 = normalAxis;
 solverConstraint.m_contactNormal2 = -normalAxis;
 btSolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
 btSolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

 btRigidBody* body0 = m_tmpSolverBodyPool[solverBodyIdA].m_originalBody;
 btRigidBody* body1 = m_tmpSolverBodyPool[solverBodyIdB].m_originalBody;

 solverConstraint.m_solverBodyIdA = solverBodyIdA;
 solverConstraint.m_solverBodyIdB = solverBodyIdB;

 solverConstraint.m_friction = combinedTorsionalFriction;
 solverConstraint.m_originalContactPoint = 0;

 solverConstraint.m_appliedImpulse = 0.f;
 solverConstraint.m_appliedPushImpulse = 0.f;

 {
  btVector3 ftorqueAxis1 = -normalAxis1;
  solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentA = body0 ? body0->getInvInertiaTensorWorld()*ftorqueAxis1*body0->getAngularFactor() : btVector3(0, 0, 0);
 }
 {
  btVector3 ftorqueAxis1 = normalAxis1;
  solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
  solverConstraint.m_angularComponentB = body1 ? body1->getInvInertiaTensorWorld()*ftorqueAxis1*body1->getAngularFactor() : btVector3(0, 0, 0);
 }


 {
  btVector3 iMJaA = body0 ? body0->getInvInertiaTensorWorld()*solverConstraint.m_relpos1CrossNormal : btVector3(0, 0, 0);
  btVector3 iMJaB = body1 ? body1->getInvInertiaTensorWorld()*solverConstraint.m_relpos2CrossNormal : btVector3(0, 0, 0);
  btScalar sum = 0;
  sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
  sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
  solverConstraint.m_jacDiagABInv = btScalar(1.) / sum;
 }

 {


  btScalar rel_vel;
  btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(body0 ? solverBodyA.m_linearVelocity + solverBodyA.m_externalForceImpulse : btVector3(0, 0, 0))
   + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : btVector3(0, 0, 0));
  btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(body1 ? solverBodyB.m_linearVelocity + solverBodyB.m_externalForceImpulse : btVector3(0, 0, 0))
   + solverConstraint.m_relpos2CrossNormal.dot(body1 ? solverBodyB.m_angularVelocity : btVector3(0, 0, 0));

  rel_vel = vel1Dotn + vel2Dotn;

  //		btScalar positionalError = 0.f;

  btSimdScalar velocityError = desiredVelocity - rel_vel;
  btSimdScalar	velocityImpulse = velocityError * btSimdScalar(solverConstraint.m_jacDiagABInv);
  solverConstraint.m_rhs = velocityImpulse;
  solverConstraint.m_cfm = cfmSlip;
  solverConstraint.m_lowerLimit = -solverConstraint.m_friction;
  solverConstraint.m_upperLimit = solverConstraint.m_friction;

 }
}








btSolverConstraint&	btSequentialImpulseConstraintSolver::addTorsionalFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, btScalar combinedTorsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, btScalar desiredVelocity, btScalar cfmSlip)
{
 btSolverConstraint& solverConstraint = m_tmpSolverContactRollingFrictionConstraintPool.expandNonInitializing();
 solverConstraint.m_frictionIndex = frictionIndex;
 setupTorsionalFrictionConstraint(solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, combinedTorsionalFriction, rel_pos1, rel_pos2,
  colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
 return solverConstraint;
}


int	btSequentialImpulseConstraintSolver::getOrInitSolverBody(btCollisionObject& body, btScalar timeStep)
{
#if BT_THREADSAFE
 int solverBodyId = -1;
 if (!body.isStaticOrKinematicObject())
 {
  // dynamic body
  // Dynamic bodies can only be in one island, so it's safe to write to the companionId
  solverBodyId = body.getCompanionId();
  if (solverBodyId < 0)
  {
   if (btRigidBody* rb = btRigidBody::upcast(&body))
   {
    solverBodyId = m_tmpSolverBodyPool.size();
    btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
    initSolverBody(&solverBody, &body, timeStep);
    body.setCompanionId(solverBodyId);
   }
  }
 }
 else if (body.isKinematicObject())
 {
  //
  // NOTE: must test for kinematic before static because some kinematic objects also
  //   identify as "static"
  //
  // Kinematic bodies can be in multiple islands at once, so it is a
  // race condition to write to them, so we use an alternate method
  // to record the solverBodyId
  int uniqueId = body.getWorldArrayIndex();
  const int INVALID_SOLVER_BODY_ID = -1;
  if (uniqueId >= m_kinematicBodyUniqueIdToSolverBodyTable.size())
  {
   m_kinematicBodyUniqueIdToSolverBodyTable.resize(uniqueId + 1, INVALID_SOLVER_BODY_ID);
  }
  solverBodyId = m_kinematicBodyUniqueIdToSolverBodyTable[uniqueId];
  // if no table entry yet,
  if (solverBodyId == INVALID_SOLVER_BODY_ID)
  {
   // create a table entry for this body
   btRigidBody* rb = btRigidBody::upcast(&body);
   solverBodyId = m_tmpSolverBodyPool.size();
   btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
   initSolverBody(&solverBody, &body, timeStep);
   m_kinematicBodyUniqueIdToSolverBodyTable[uniqueId] = solverBodyId;
  }
 }
 else
 {
  // all fixed bodies (inf mass) get mapped to a single solver id
  if (m_fixedBodyId < 0)
  {
   m_fixedBodyId = m_tmpSolverBodyPool.size();
   btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
   initSolverBody(&fixedBody, 0, timeStep);
  }
  solverBodyId = m_fixedBodyId;
 }
 btAssert(solverBodyId < m_tmpSolverBodyPool.size());
 return solverBodyId;
#else // BT_THREADSAFE

 int solverBodyIdA = -1;

 if (body.getCompanionId() >= 0)
 {
  //body has already been converted
  solverBodyIdA = body.getCompanionId();
  btAssert(solverBodyIdA < m_tmpSolverBodyPool.size());
 }
 else
 {
  btRigidBody* rb = btRigidBody::upcast(&body);
  //convert both active and kinematic objects (for their velocity)
  if (rb && (rb->getInvMass() || rb->isKinematicObject()))
  {
   solverBodyIdA = m_tmpSolverBodyPool.size();
   btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
   initSolverBody(&solverBody, &body, timeStep);
   body.setCompanionId(solverBodyIdA);
  }
  else
  {

   if (m_fixedBodyId<0)
   {
    m_fixedBodyId = m_tmpSolverBodyPool.size();
    btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
    initSolverBody(&fixedBody, 0, timeStep);
   }
   return m_fixedBodyId;
   //			return 0;//assume first one is a fixed solver body
  }
 }

 return solverBodyIdA;
#endif // BT_THREADSAFE

}
#include <stdio.h>


void btSequentialImpulseConstraintSolver::setupContactConstraint(btSolverConstraint& solverConstraint,
 int solverBodyIdA, int solverBodyIdB,
 btManifoldPoint& cp, const btContactSolverInfo& infoGlobal,
 btScalar& relaxation,
 const btVector3& rel_pos1, const btVector3& rel_pos2)
{

 //	const btVector3& pos1 = cp.getPositionWorldOnA();
 //	const btVector3& pos2 = cp.getPositionWorldOnB();

 btSolverBody* bodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 btSolverBody* bodyB = &m_tmpSolverBodyPool[solverBodyIdB];

 btRigidBody* rb0 = bodyA->m_originalBody;
 btRigidBody* rb1 = bodyB->m_originalBody;

 //			btVector3 rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin();
 //			btVector3 rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();
 //rel_pos1 = pos1 - bodyA->getWorldTransform().getOrigin();
 //rel_pos2 = pos2 - bodyB->getWorldTransform().getOrigin();

 relaxation = infoGlobal.m_sor;
 btScalar invTimeStep = btScalar(1) / infoGlobal.m_timeStep;

 //cfm = 1 /       ( dt * kp + kd )
 //erp = dt * kp / ( dt * kp + kd )

 btScalar cfm = infoGlobal.m_globalCfm;
 btScalar erp = infoGlobal.m_erp2;

 if ((cp.m_contactPointFlags&BT_CONTACT_FLAG_HAS_CONTACT_CFM) || (cp.m_contactPointFlags&BT_CONTACT_FLAG_HAS_CONTACT_ERP))
 {
  if (cp.m_contactPointFlags&BT_CONTACT_FLAG_HAS_CONTACT_CFM)
   cfm = cp.m_contactCFM;
  if (cp.m_contactPointFlags&BT_CONTACT_FLAG_HAS_CONTACT_ERP)
   erp = cp.m_contactERP;
 }
 else
 {
  if (cp.m_contactPointFlags & BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING)
  {
   btScalar denom = (infoGlobal.m_timeStep * cp.m_combinedContactStiffness1 + cp.m_combinedContactDamping1);
   if (denom < SIMD_EPSILON)
   {
    denom = SIMD_EPSILON;
   }
   cfm = btScalar(1) / denom;
   erp = (infoGlobal.m_timeStep * cp.m_combinedContactStiffness1) / denom;
  }
 }

 cfm *= invTimeStep;


 btVector3 torqueAxis0 = rel_pos1.cross(cp.m_normalWorldOnB);
 solverConstraint.m_angularComponentA = rb0 ? rb0->getInvInertiaTensorWorld()*torqueAxis0*rb0->getAngularFactor() : btVector3(0, 0, 0);
 btVector3 torqueAxis1 = rel_pos2.cross(cp.m_normalWorldOnB);
 solverConstraint.m_angularComponentB = rb1 ? rb1->getInvInertiaTensorWorld()*-torqueAxis1*rb1->getAngularFactor() : btVector3(0, 0, 0);

 {
#ifdef COMPUTE_IMPULSE_DENOM
  btScalar denom0 = rb0->computeImpulseDenominator(pos1, cp.m_normalWorldOnB);
  btScalar denom1 = rb1->computeImpulseDenominator(pos2, cp.m_normalWorldOnB);
#else
  btVector3 vec;
  btScalar denom0 = 0.f;
  btScalar denom1 = 0.f;
  if (rb0)
  {
   vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
   denom0 = rb0->getInvMass() + cp.m_normalWorldOnB.dot(vec);
  }
  if (rb1)
  {
   vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
   denom1 = rb1->getInvMass() + cp.m_normalWorldOnB.dot(vec);
  }
#endif //COMPUTE_IMPULSE_DENOM

  btScalar denom = relaxation / (denom0 + denom1 + cfm);
  solverConstraint.m_jacDiagABInv = denom;
 }

 if (rb0)
 {
  solverConstraint.m_contactNormal1 = cp.m_normalWorldOnB;
  solverConstraint.m_relpos1CrossNormal = torqueAxis0;
 }
 else
 {
  solverConstraint.m_contactNormal1.setZero();
  solverConstraint.m_relpos1CrossNormal.setZero();
 }
 if (rb1)
 {
  solverConstraint.m_contactNormal2 = -cp.m_normalWorldOnB;
  solverConstraint.m_relpos2CrossNormal = -torqueAxis1;
 }
 else
 {
  solverConstraint.m_contactNormal2.setZero();
  solverConstraint.m_relpos2CrossNormal.setZero();
 }

 btScalar restitution = 0.f;
 btScalar penetration = cp.getDistance() + infoGlobal.m_linearSlop;

 {
  btVector3 vel1, vel2;

  vel1 = rb0 ? rb0->getVelocityInLocalPoint(rel_pos1) : btVector3(0, 0, 0);
  vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : btVector3(0, 0, 0);

  //			btVector3 vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : btVector3(0,0,0);
  btVector3 vel = vel1 - vel2;
  btScalar rel_vel = cp.m_normalWorldOnB.dot(vel);



  solverConstraint.m_friction = cp.m_combinedFriction;


  restitution = restitutionCurve(rel_vel, cp.m_combinedRestitution, infoGlobal.m_restitutionVelocityThreshold);
  if (restitution <= btScalar(0.))
  {
   restitution = 0.f;
  };
 }


 ///warm starting (or zero if disabled)
 if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
 {
  solverConstraint.m_appliedImpulse = cp.m_appliedImpulse * infoGlobal.m_warmstartingFactor;
  if (rb0)
   bodyA->internalApplyImpulse(solverConstraint.m_contactNormal1*bodyA->internalGetInvMass()*rb0->getLinearFactor(), solverConstraint.m_angularComponentA, solverConstraint.m_appliedImpulse);
  if (rb1)
   bodyB->internalApplyImpulse(-solverConstraint.m_contactNormal2*bodyB->internalGetInvMass()*rb1->getLinearFactor(), -solverConstraint.m_angularComponentB, -(btScalar)solverConstraint.m_appliedImpulse);
 }
 else
 {
  solverConstraint.m_appliedImpulse = 0.f;
 }

 solverConstraint.m_appliedPushImpulse = 0.f;

 {

  btVector3 externalForceImpulseA = bodyA->m_originalBody ? bodyA->m_externalForceImpulse : btVector3(0, 0, 0);
  btVector3 externalTorqueImpulseA = bodyA->m_originalBody ? bodyA->m_externalTorqueImpulse : btVector3(0, 0, 0);
  btVector3 externalForceImpulseB = bodyB->m_originalBody ? bodyB->m_externalForceImpulse : btVector3(0, 0, 0);
  btVector3 externalTorqueImpulseB = bodyB->m_originalBody ? bodyB->m_externalTorqueImpulse : btVector3(0, 0, 0);


  btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(bodyA->m_linearVelocity + externalForceImpulseA)
   + solverConstraint.m_relpos1CrossNormal.dot(bodyA->m_angularVelocity + externalTorqueImpulseA);
  btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(bodyB->m_linearVelocity + externalForceImpulseB)
   + solverConstraint.m_relpos2CrossNormal.dot(bodyB->m_angularVelocity + externalTorqueImpulseB);
  btScalar rel_vel = vel1Dotn + vel2Dotn;

  btScalar positionalError = 0.f;
  btScalar	velocityError = restitution - rel_vel;// * damping;



  if (penetration>0)
  {
   positionalError = 0;

   velocityError -= penetration *invTimeStep;
  }
  else
  {
   positionalError = -penetration * erp*invTimeStep;

  }

  btScalar  penetrationImpulse = positionalError*solverConstraint.m_jacDiagABInv;
  btScalar velocityImpulse = velocityError *solverConstraint.m_jacDiagABInv;

  if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
  {
   //combine position and velocity into rhs
   solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;//-solverConstraint.m_contactNormal1.dot(bodyA->m_externalForce*bodyA->m_invMass-bodyB->m_externalForce/bodyB->m_invMass)*solverConstraint.m_jacDiagABInv;
   solverConstraint.m_rhsPenetration = 0.f;

  }
  else
  {
   //split position and velocity into rhs and m_rhsPenetration
   solverConstraint.m_rhs = velocityImpulse;
   solverConstraint.m_rhsPenetration = penetrationImpulse;
  }
  solverConstraint.m_cfm = cfm*solverConstraint.m_jacDiagABInv;
  solverConstraint.m_lowerLimit = 0;
  solverConstraint.m_upperLimit = 1e10f;
 }




}



void btSequentialImpulseConstraintSolver::setFrictionConstraintImpulse(btSolverConstraint& solverConstraint,
 int solverBodyIdA, int solverBodyIdB,
 btManifoldPoint& cp, const btContactSolverInfo& infoGlobal)
{

 btSolverBody* bodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 btSolverBody* bodyB = &m_tmpSolverBodyPool[solverBodyIdB];

 btRigidBody* rb0 = bodyA->m_originalBody;
 btRigidBody* rb1 = bodyB->m_originalBody;

 {
  btSolverConstraint& frictionConstraint1 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex];
  if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
  {
   frictionConstraint1.m_appliedImpulse = cp.m_appliedImpulseLateral1 * infoGlobal.m_warmstartingFactor;
   if (rb0)
    bodyA->internalApplyImpulse(frictionConstraint1.m_contactNormal1*rb0->getInvMass()*rb0->getLinearFactor(), frictionConstraint1.m_angularComponentA, frictionConstraint1.m_appliedImpulse);
   if (rb1)
    bodyB->internalApplyImpulse(-frictionConstraint1.m_contactNormal2*rb1->getInvMass()*rb1->getLinearFactor(), -frictionConstraint1.m_angularComponentB, -(btScalar)frictionConstraint1.m_appliedImpulse);
  }
  else
  {
   frictionConstraint1.m_appliedImpulse = 0.f;
  }
 }

 if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
 {
  btSolverConstraint& frictionConstraint2 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex + 1];
  if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
  {
   frictionConstraint2.m_appliedImpulse = cp.m_appliedImpulseLateral2  * infoGlobal.m_warmstartingFactor;
   if (rb0)
    bodyA->internalApplyImpulse(frictionConstraint2.m_contactNormal1*rb0->getInvMass(), frictionConstraint2.m_angularComponentA, frictionConstraint2.m_appliedImpulse);
   if (rb1)
    bodyB->internalApplyImpulse(-frictionConstraint2.m_contactNormal2*rb1->getInvMass(), -frictionConstraint2.m_angularComponentB, -(btScalar)frictionConstraint2.m_appliedImpulse);
  }
  else
  {
   frictionConstraint2.m_appliedImpulse = 0.f;
  }
 }
}




void	btSequentialImpulseConstraintSolver::convertContact(btPersistentManifold* manifold, const btContactSolverInfo& infoGlobal)
{
 btCollisionObject* colObj0 = 0, *colObj1 = 0;

 colObj0 = (btCollisionObject*)manifold->getBody0();
 colObj1 = (btCollisionObject*)manifold->getBody1();

 int solverBodyIdA = getOrInitSolverBody(*colObj0, infoGlobal.m_timeStep);
 int solverBodyIdB = getOrInitSolverBody(*colObj1, infoGlobal.m_timeStep);

 //	btRigidBody* bodyA = btRigidBody::upcast(colObj0);
 //	btRigidBody* bodyB = btRigidBody::upcast(colObj1);

 btSolverBody* solverBodyA = &m_tmpSolverBodyPool[solverBodyIdA];
 btSolverBody* solverBodyB = &m_tmpSolverBodyPool[solverBodyIdB];



 ///avoid collision response between two static objects
 if (!solverBodyA || (solverBodyA->m_invMass.fuzzyZero() && (!solverBodyB || solverBodyB->m_invMass.fuzzyZero())))
  return;

 int rollingFriction = 1;
 for (int j = 0; j<manifold->getNumContacts(); j++)
 {

  btManifoldPoint& cp = manifold->getContactPoint(j);

  if (cp.getDistance() <= manifold->getContactProcessingThreshold())
  {
   btVector3 rel_pos1;
   btVector3 rel_pos2;
   btScalar relaxation;


   int frictionIndex = m_tmpSolverContactConstraintPool.size();
   btSolverConstraint& solverConstraint = m_tmpSolverContactConstraintPool.expandNonInitializing();
   solverConstraint.m_solverBodyIdA = solverBodyIdA;
   solverConstraint.m_solverBodyIdB = solverBodyIdB;

   solverConstraint.m_originalContactPoint = &cp;

   const btVector3& pos1 = cp.getPositionWorldOnA();
   const btVector3& pos2 = cp.getPositionWorldOnB();

   rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin();
   rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();

   btVector3 vel1;
   btVector3 vel2;

   solverBodyA->getVelocityInLocalPointNoDelta(rel_pos1, vel1);
   solverBodyB->getVelocityInLocalPointNoDelta(rel_pos2, vel2);

   btVector3 vel = vel1 - vel2;
   btScalar rel_vel = cp.m_normalWorldOnB.dot(vel);

   setupContactConstraint(solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal, relaxation, rel_pos1, rel_pos2);




   /////setup the friction constraints

   solverConstraint.m_frictionIndex = m_tmpSolverContactFrictionConstraintPool.size();

   if ((cp.m_combinedRollingFriction>0.f) && (rollingFriction>0))
   {

    {
     addTorsionalFrictionConstraint(cp.m_normalWorldOnB, solverBodyIdA, solverBodyIdB, frictionIndex, cp, cp.m_combinedSpinningFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
     btVector3 axis0, axis1;
     btPlaneSpace1(cp.m_normalWorldOnB, axis0, axis1);
     axis0.normalize();
     axis1.normalize();

     applyAnisotropicFriction(colObj0, axis0, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
     applyAnisotropicFriction(colObj1, axis0, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
     applyAnisotropicFriction(colObj0, axis1, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
     applyAnisotropicFriction(colObj1, axis1, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
     if (axis0.length()>0.001)
      addTorsionalFrictionConstraint(axis0, solverBodyIdA, solverBodyIdB, frictionIndex, cp,
       cp.m_combinedRollingFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
     if (axis1.length()>0.001)
      addTorsionalFrictionConstraint(axis1, solverBodyIdA, solverBodyIdB, frictionIndex, cp,
       cp.m_combinedRollingFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);

    }
   }

   ///Bullet has several options to set the friction directions
   ///By default, each contact has only a single friction direction that is recomputed automatically very frame
   ///based on the relative linear velocity.
   ///If the relative velocity it zero, it will automatically compute a friction direction.

   ///You can also enable two friction directions, using the SOLVER_USE_2_FRICTION_DIRECTIONS.
   ///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
   ///
   ///If you choose SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
   ///
   ///The user can manually override the friction directions for certain contacts using a contact callback,
   ///and set the cp.m_lateralFrictionInitialized to true
   ///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
   ///this will give a conveyor belt effect
   ///

   if (!(infoGlobal.m_solverMode & SOLVER_ENABLE_FRICTION_DIRECTION_CACHING) || !(cp.m_contactPointFlags&BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED))
   {
    cp.m_lateralFrictionDir1 = vel - cp.m_normalWorldOnB * rel_vel;
    btScalar lat_rel_vel = cp.m_lateralFrictionDir1.length2();
    if (!(infoGlobal.m_solverMode & SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION) && lat_rel_vel > SIMD_EPSILON)
    {
     cp.m_lateralFrictionDir1 *= 1.f / btSqrt(lat_rel_vel);
     applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
     applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
     addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);

     if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
     {
      cp.m_lateralFrictionDir2 = cp.m_lateralFrictionDir1.cross(cp.m_normalWorldOnB);
      cp.m_lateralFrictionDir2.normalize();//??
      applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
      applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
      addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);
     }

    }
    else
    {
     btPlaneSpace1(cp.m_normalWorldOnB, cp.m_lateralFrictionDir1, cp.m_lateralFrictionDir2);

     applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
     applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
     addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);

     if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
     {
      applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
      applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
      addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);
     }


     if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS) && (infoGlobal.m_solverMode & SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION))
     {
      cp.m_contactPointFlags |= BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED;
     }
    }

   }
   else
   {
    addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal, cp.m_contactMotion1, cp.m_frictionCFM);

    if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
     addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal, cp.m_contactMotion2, cp.m_frictionCFM);

   }
   setFrictionConstraintImpulse(solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal);




  }
 }
}

void btSequentialImpulseConstraintSolver::convertContacts(btPersistentManifold** manifoldPtr, int numManifolds, const btContactSolverInfo& infoGlobal)
{
 int i;
 btPersistentManifold* manifold = 0;
 //			btCollisionObject* colObj0=0,*colObj1=0;


 for (i = 0; i<numManifolds; i++)
 {
  manifold = manifoldPtr[i];
  convertContact(manifold, infoGlobal);
 }
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySetup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 m_fixedBodyId = -1;
 BT_PROFILE("solveGroupCacheFriendlySetup");
 (void)debugDrawer;

 // if solver mode has changed,
 if (infoGlobal.m_solverMode != m_cachedSolverMode)
 {
  // update solver functions to use SIMD or non-SIMD
  bool useSimd = !!(infoGlobal.m_solverMode & SOLVER_SIMD);
  setupSolverFunctions(useSimd);
  m_cachedSolverMode = infoGlobal.m_solverMode;
 }
 m_maxOverrideNumSolverIterations = 0;

#ifdef BT_ADDITIONAL_DEBUG
 //make sure that dynamic bodies exist for all (enabled) constraints
 for (int i = 0; i<numConstraints; i++)
 {
  btTypedConstraint* constraint = constraints[i];
  if (constraint->isEnabled())
  {
   if (!constraint->getRigidBodyA().isStaticOrKinematicObject())
   {
    bool found = false;
    for (int b = 0; b<numBodies; b++)
    {

     if (&constraint->getRigidBodyA() == bodies[b])
     {
      found = true;
      break;
     }
    }
    btAssert(found);
   }
   if (!constraint->getRigidBodyB().isStaticOrKinematicObject())
   {
    bool found = false;
    for (int b = 0; b<numBodies; b++)
    {
     if (&constraint->getRigidBodyB() == bodies[b])
     {
      found = true;
      break;
     }
    }
    btAssert(found);
   }
  }
 }
 //make sure that dynamic bodies exist for all contact manifolds
 for (int i = 0; i<numManifolds; i++)
 {
  if (!manifoldPtr[i]->getBody0()->isStaticOrKinematicObject())
  {
   bool found = false;
   for (int b = 0; b<numBodies; b++)
   {

    if (manifoldPtr[i]->getBody0() == bodies[b])
    {
     found = true;
     break;
    }
   }
   btAssert(found);
  }
  if (!manifoldPtr[i]->getBody1()->isStaticOrKinematicObject())
  {
   bool found = false;
   for (int b = 0; b<numBodies; b++)
   {
    if (manifoldPtr[i]->getBody1() == bodies[b])
    {
     found = true;
     break;
    }
   }
   btAssert(found);
  }
 }
#endif //BT_ADDITIONAL_DEBUG


 for (int i = 0; i < numBodies; i++)
 {
  bodies[i]->setCompanionId(-1);
 }
#if BT_THREADSAFE
 m_kinematicBodyUniqueIdToSolverBodyTable.resize(0);
#endif // BT_THREADSAFE

 m_tmpSolverBodyPool.reserve(numBodies + 1);
 m_tmpSolverBodyPool.resize(0);

 //btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
 //initSolverBody(&fixedBody,0);

 //convert all bodies


 for (int i = 0; i<numBodies; i++)
 {
  int bodyId = getOrInitSolverBody(*bodies[i], infoGlobal.m_timeStep);

  btRigidBody* body = btRigidBody::upcast(bodies[i]);
  if (body && body->getInvMass())
  {
   btSolverBody& solverBody = m_tmpSolverBodyPool[bodyId];
   btVector3 gyroForce(0, 0, 0);
   if (body->getFlags()&BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT)
   {
    gyroForce = body->computeGyroscopicForceExplicit(infoGlobal.m_maxGyroscopicForce);
    solverBody.m_externalTorqueImpulse -= gyroForce*body->getInvInertiaTensorWorld()*infoGlobal.m_timeStep;
   }
   if (body->getFlags()&BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD)
   {
    gyroForce = body->computeGyroscopicImpulseImplicit_World(infoGlobal.m_timeStep);
    solverBody.m_externalTorqueImpulse += gyroForce;
   }
   if (body->getFlags()&BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY)
   {
    gyroForce = body->computeGyroscopicImpulseImplicit_Body(infoGlobal.m_timeStep);
    solverBody.m_externalTorqueImpulse += gyroForce;

   }


  }
 }

 if (1)
 {
  int j;
  for (j = 0; j<numConstraints; j++)
  {
   btTypedConstraint* constraint = constraints[j];
   constraint->buildJacobian();
   constraint->internalSetAppliedImpulse(0.0f);
  }
 }

 //btRigidBody* rb0=0,*rb1=0;

 //if (1)
 {
  {

   int totalNumRows = 0;
   int i;

   m_tmpConstraintSizesPool.resizeNoInitialize(numConstraints);
   //calculate the total number of contraint rows
   for (i = 0; i<numConstraints; i++)
   {
    btTypedConstraint::btConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];
    btJointFeedback* fb = constraints[i]->getJointFeedback();
    if (fb)
    {
     fb->m_appliedForceBodyA.setZero();
     fb->m_appliedTorqueBodyA.setZero();
     fb->m_appliedForceBodyB.setZero();
     fb->m_appliedTorqueBodyB.setZero();
    }

    if (constraints[i]->isEnabled())
    {
    }
    if (constraints[i]->isEnabled())
    {
     constraints[i]->getInfo1(&info1);
    }
    else
    {
     info1.m_numConstraintRows = 0;
     info1.nub = 0;
    }
    totalNumRows += info1.m_numConstraintRows;
   }
   m_tmpSolverNonContactConstraintPool.resizeNoInitialize(totalNumRows);


   ///setup the btSolverConstraints
   int currentRow = 0;

   for (i = 0; i<numConstraints; i++)
   {
    const btTypedConstraint::btConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];

    if (info1.m_numConstraintRows)
    {
     btAssert(currentRow<totalNumRows);

     btSolverConstraint* currentConstraintRow = &m_tmpSolverNonContactConstraintPool[currentRow];
     btTypedConstraint* constraint = constraints[i];
     btRigidBody& rbA = constraint->getRigidBodyA();
     btRigidBody& rbB = constraint->getRigidBodyB();

     int solverBodyIdA = getOrInitSolverBody(rbA, infoGlobal.m_timeStep);
     int solverBodyIdB = getOrInitSolverBody(rbB, infoGlobal.m_timeStep);

     btSolverBody* bodyAPtr = &m_tmpSolverBodyPool[solverBodyIdA];
     btSolverBody* bodyBPtr = &m_tmpSolverBodyPool[solverBodyIdB];




     int overrideNumSolverIterations = constraint->getOverrideNumSolverIterations() > 0 ? constraint->getOverrideNumSolverIterations() : infoGlobal.m_numIterations;
     if (overrideNumSolverIterations>m_maxOverrideNumSolverIterations)
      m_maxOverrideNumSolverIterations = overrideNumSolverIterations;


     int j;
     for (j = 0; j<info1.m_numConstraintRows; j++)
     {
      memset(&currentConstraintRow[j], 0, sizeof(btSolverConstraint));
      currentConstraintRow[j].m_lowerLimit = -SIMD_INFINITY;
      currentConstraintRow[j].m_upperLimit = SIMD_INFINITY;
      currentConstraintRow[j].m_appliedImpulse = 0.f;
      currentConstraintRow[j].m_appliedPushImpulse = 0.f;
      currentConstraintRow[j].m_solverBodyIdA = solverBodyIdA;
      currentConstraintRow[j].m_solverBodyIdB = solverBodyIdB;
      currentConstraintRow[j].m_overrideNumSolverIterations = overrideNumSolverIterations;
     }

     bodyAPtr->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
     bodyAPtr->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
     bodyBPtr->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);


     btTypedConstraint::btConstraintInfo2 info2;
     info2.fps = 1.f / infoGlobal.m_timeStep;
     info2.erp = infoGlobal.m_erp;
     info2.m_J1linearAxis = currentConstraintRow->m_contactNormal1;
     info2.m_J1angularAxis = currentConstraintRow->m_relpos1CrossNormal;
     info2.m_J2linearAxis = currentConstraintRow->m_contactNormal2;
     info2.m_J2angularAxis = currentConstraintRow->m_relpos2CrossNormal;
     info2.rowskip = sizeof(btSolverConstraint) / sizeof(btScalar);//check this
                                                                   ///the size of btSolverConstraint needs be a multiple of btScalar
     btAssert(info2.rowskip * sizeof(btScalar) == sizeof(btSolverConstraint));
     info2.m_constraintError = &currentConstraintRow->m_rhs;
     currentConstraintRow->m_cfm = infoGlobal.m_globalCfm;
     info2.m_damping = infoGlobal.m_damping;
     info2.cfm = &currentConstraintRow->m_cfm;
     info2.m_lowerLimit = &currentConstraintRow->m_lowerLimit;
     info2.m_upperLimit = &currentConstraintRow->m_upperLimit;
     info2.m_numIterations = infoGlobal.m_numIterations;
     constraints[i]->getInfo2(&info2);

     ///finalize the constraint setup
     for (j = 0; j<info1.m_numConstraintRows; j++)
     {
      btSolverConstraint& solverConstraint = currentConstraintRow[j];

      if (solverConstraint.m_upperLimit >= constraints[i]->getBreakingImpulseThreshold())
      {
       solverConstraint.m_upperLimit = constraints[i]->getBreakingImpulseThreshold();
      }

      if (solverConstraint.m_lowerLimit <= -constraints[i]->getBreakingImpulseThreshold())
      {
       solverConstraint.m_lowerLimit = -constraints[i]->getBreakingImpulseThreshold();
      }

      solverConstraint.m_originalContactPoint = constraint;

      {
       const btVector3& ftorqueAxis1 = solverConstraint.m_relpos1CrossNormal;
       solverConstraint.m_angularComponentA = constraint->getRigidBodyA().getInvInertiaTensorWorld()*ftorqueAxis1*constraint->getRigidBodyA().getAngularFactor();
      }
      {
       const btVector3& ftorqueAxis2 = solverConstraint.m_relpos2CrossNormal;
       solverConstraint.m_angularComponentB = constraint->getRigidBodyB().getInvInertiaTensorWorld()*ftorqueAxis2*constraint->getRigidBodyB().getAngularFactor();
      }

      {
       btVector3 iMJlA = solverConstraint.m_contactNormal1*rbA.getInvMass();
       btVector3 iMJaA = rbA.getInvInertiaTensorWorld()*solverConstraint.m_relpos1CrossNormal;
       btVector3 iMJlB = solverConstraint.m_contactNormal2*rbB.getInvMass();//sign of normal?
       btVector3 iMJaB = rbB.getInvInertiaTensorWorld()*solverConstraint.m_relpos2CrossNormal;

       btScalar sum = iMJlA.dot(solverConstraint.m_contactNormal1);
       sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
       sum += iMJlB.dot(solverConstraint.m_contactNormal2);
       sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
       btScalar fsum = btFabs(sum);
       btAssert(fsum > SIMD_EPSILON);
       btScalar sorRelaxation = 1.f;//todo: get from globalInfo?
       solverConstraint.m_jacDiagABInv = fsum>SIMD_EPSILON ? sorRelaxation / sum : 0.f;
      }



      {
       btScalar rel_vel;
       btVector3 externalForceImpulseA = bodyAPtr->m_originalBody ? bodyAPtr->m_externalForceImpulse : btVector3(0, 0, 0);
       btVector3 externalTorqueImpulseA = bodyAPtr->m_originalBody ? bodyAPtr->m_externalTorqueImpulse : btVector3(0, 0, 0);

       btVector3 externalForceImpulseB = bodyBPtr->m_originalBody ? bodyBPtr->m_externalForceImpulse : btVector3(0, 0, 0);
       btVector3 externalTorqueImpulseB = bodyBPtr->m_originalBody ? bodyBPtr->m_externalTorqueImpulse : btVector3(0, 0, 0);

       btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(rbA.getLinearVelocity() + externalForceImpulseA)
        + solverConstraint.m_relpos1CrossNormal.dot(rbA.getAngularVelocity() + externalTorqueImpulseA);

       btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(rbB.getLinearVelocity() + externalForceImpulseB)
        + solverConstraint.m_relpos2CrossNormal.dot(rbB.getAngularVelocity() + externalTorqueImpulseB);

       rel_vel = vel1Dotn + vel2Dotn;
       btScalar restitution = 0.f;
       btScalar positionalError = solverConstraint.m_rhs;//already filled in by getConstraintInfo2
       btScalar	velocityError = restitution - rel_vel * info2.m_damping;
       btScalar	penetrationImpulse = positionalError*solverConstraint.m_jacDiagABInv;
       btScalar	velocityImpulse = velocityError *solverConstraint.m_jacDiagABInv;
       solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
       solverConstraint.m_appliedImpulse = 0.f;


      }
     }
    }
    currentRow += m_tmpConstraintSizesPool[i].m_numConstraintRows;
   }
  }

  convertContacts(manifoldPtr, numManifolds, infoGlobal);

 }

 //	btContactSolverInfo info = infoGlobal;


 int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
 int numConstraintPool = m_tmpSolverContactConstraintPool.size();
 int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

 ///@todo: use stack allocator for such temporarily memory, same for solver bodies/constraints
 m_orderNonContactConstraintPool.resizeNoInitialize(numNonContactPool);
 if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
  m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool * 2);
 else
  m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool);

 m_orderFrictionConstraintPool.resizeNoInitialize(numFrictionPool);
 {
  int i;
  for (i = 0; i<numNonContactPool; i++)
  {
   m_orderNonContactConstraintPool[i] = i;
  }
  for (i = 0; i<numConstraintPool; i++)
  {
   m_orderTmpConstraintPool[i] = i;
  }
  for (i = 0; i<numFrictionPool; i++)
  {
   m_orderFrictionConstraintPool[i] = i;
  }
 }

 return 0.f;

}


btScalar btSequentialImpulseConstraintSolver::solveSingleIteration(int iteration, btCollisionObject** /*bodies */, int /*numBodies*/, btPersistentManifold** /*manifoldPtr*/, int /*numManifolds*/, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* /*debugDrawer*/)
{
 btScalar leastSquaresResidual = 0.f;

 int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
 int numConstraintPool = m_tmpSolverContactConstraintPool.size();
 int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

 if (infoGlobal.m_solverMode & SOLVER_RANDMIZE_ORDER)
 {
  if (1)			// uncomment this for a bit less random ((iteration & 7) == 0)
  {

   for (int j = 0; j<numNonContactPool; ++j) {
    int tmp = m_orderNonContactConstraintPool[j];
    int swapi = btRandInt2(j + 1);
    m_orderNonContactConstraintPool[j] = m_orderNonContactConstraintPool[swapi];
    m_orderNonContactConstraintPool[swapi] = tmp;
   }

   //contact/friction constraints are not solved more than
   if (iteration< infoGlobal.m_numIterations)
   {
    for (int j = 0; j<numConstraintPool; ++j) {
     int tmp = m_orderTmpConstraintPool[j];
     int swapi = btRandInt2(j + 1);
     m_orderTmpConstraintPool[j] = m_orderTmpConstraintPool[swapi];
     m_orderTmpConstraintPool[swapi] = tmp;
    }

    for (int j = 0; j<numFrictionPool; ++j) {
     int tmp = m_orderFrictionConstraintPool[j];
     int swapi = btRandInt2(j + 1);
     m_orderFrictionConstraintPool[j] = m_orderFrictionConstraintPool[swapi];
     m_orderFrictionConstraintPool[swapi] = tmp;
    }
   }
  }
 }

 ///solve all joint constraints
 for (int j = 0; j<m_tmpSolverNonContactConstraintPool.size(); j++)
 {
  btSolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
  if (iteration < constraint.m_overrideNumSolverIterations)
  {
   btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[constraint.m_solverBodyIdA], m_tmpSolverBodyPool[constraint.m_solverBodyIdB], constraint);
   leastSquaresResidual += residual*residual;
  }
 }

 if (iteration< infoGlobal.m_numIterations)
 {
  for (int j = 0; j<numConstraints; j++)
  {
   if (constraints[j]->isEnabled())
   {
    int bodyAid = getOrInitSolverBody(constraints[j]->getRigidBodyA(), infoGlobal.m_timeStep);
    int bodyBid = getOrInitSolverBody(constraints[j]->getRigidBodyB(), infoGlobal.m_timeStep);
    btSolverBody& bodyA = m_tmpSolverBodyPool[bodyAid];
    btSolverBody& bodyB = m_tmpSolverBodyPool[bodyBid];
    constraints[j]->solveConstraintObsolete(bodyA, bodyB, infoGlobal.m_timeStep);
   }
  }

  ///solve all contact constraints
  if (infoGlobal.m_solverMode & SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
  {
   int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
   int multiplier = (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS) ? 2 : 1;

   for (int c = 0; c<numPoolConstraints; c++)
   {
    btScalar totalImpulse = 0;

    {
     const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[c]];
     btScalar residual = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     leastSquaresResidual += residual*residual;

     totalImpulse = solveManifold.m_appliedImpulse;
    }
    bool applyFriction = true;
    if (applyFriction)
    {
     {

      btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier]];

      if (totalImpulse>btScalar(0))
      {
       solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
       solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

       btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
       leastSquaresResidual += residual*residual;
      }
     }

     if (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS)
     {

      btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c*multiplier + 1]];

      if (totalImpulse>btScalar(0))
      {
       solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
       solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

       btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
       leastSquaresResidual += residual*residual;
      }
     }
    }
   }

  }
  else//SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
  {
   //solve the friction constraints after all contact constraints, don't interleave them
   int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
   int j;

   for (j = 0; j<numPoolConstraints; j++)
   {
    const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
    btScalar residual = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
    leastSquaresResidual += residual*residual;
   }



   ///solve all friction constraints

   int numFrictionPoolConstraints = m_tmpSolverContactFrictionConstraintPool.size();
   for (j = 0; j<numFrictionPoolConstraints; j++)
   {
    btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
    btScalar totalImpulse = m_tmpSolverContactConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;

    if (totalImpulse>btScalar(0))
    {
     solveManifold.m_lowerLimit = -(solveManifold.m_friction*totalImpulse);
     solveManifold.m_upperLimit = solveManifold.m_friction*totalImpulse;

     btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
     leastSquaresResidual += residual*residual;
    }
   }
  }


  int numRollingFrictionPoolConstraints = m_tmpSolverContactRollingFrictionConstraintPool.size();
  for (int j = 0; j<numRollingFrictionPoolConstraints; j++)
  {

   btSolverConstraint& rollingFrictionConstraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
   btScalar totalImpulse = m_tmpSolverContactConstraintPool[rollingFrictionConstraint.m_frictionIndex].m_appliedImpulse;
   if (totalImpulse>btScalar(0))
   {
    btScalar rollingFrictionMagnitude = rollingFrictionConstraint.m_friction*totalImpulse;
    if (rollingFrictionMagnitude>rollingFrictionConstraint.m_friction)
     rollingFrictionMagnitude = rollingFrictionConstraint.m_friction;

    rollingFrictionConstraint.m_lowerLimit = -rollingFrictionMagnitude;
    rollingFrictionConstraint.m_upperLimit = rollingFrictionMagnitude;

    btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdA], m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdB], rollingFrictionConstraint);
    leastSquaresResidual += residual*residual;
   }
  }


 }
 return leastSquaresResidual;
}


void btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySplitImpulseIterations(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 int iteration;
 if (infoGlobal.m_splitImpulse)
 {
  {
   for (iteration = 0; iteration<infoGlobal.m_numIterations; iteration++)
   {
    btScalar leastSquaresResidual = 0.f;
    {
     int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
     int j;
     for (j = 0; j<numPoolConstraints; j++)
     {
      const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];

      btScalar residual = resolveSplitPenetrationImpulse(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
      leastSquaresResidual += residual*residual;
     }
    }
    if (leastSquaresResidual <= infoGlobal.m_leastSquaresResidualThreshold || iteration >= (infoGlobal.m_numIterations - 1))
    {
#ifdef VERBOSE_RESIDUAL_PRINTF
     printf("residual = %f at iteration #%d\n", leastSquaresResidual, iteration);
#endif
     break;
    }
   }
  }
 }
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 BT_PROFILE("solveGroupCacheFriendlyIterations");

 {
  ///this is a special step to resolve penetrations (just for contacts)
  solveGroupCacheFriendlySplitImpulseIterations(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

  int maxIterations = m_maxOverrideNumSolverIterations > infoGlobal.m_numIterations ? m_maxOverrideNumSolverIterations : infoGlobal.m_numIterations;

  for (int iteration = 0; iteration< maxIterations; iteration++)
   //for ( int iteration = maxIterations-1  ; iteration >= 0;iteration--)
  {
   m_leastSquaresResidual = solveSingleIteration(iteration, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

   if (m_leastSquaresResidual <= infoGlobal.m_leastSquaresResidualThreshold || (iteration >= (maxIterations - 1)))
   {
#ifdef VERBOSE_RESIDUAL_PRINTF
    printf("residual = %f at iteration #%d\n", m_leastSquaresResidual, iteration);
#endif
    break;
   }
  }

 }
 return 0.f;
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyFinish(btCollisionObject** bodies, int numBodies, const btContactSolverInfo& infoGlobal)
{
 int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
 int i, j;

 if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
 {
  for (j = 0; j<numPoolConstraints; j++)
  {
   const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[j];
   btManifoldPoint* pt = (btManifoldPoint*)solveManifold.m_originalContactPoint;
   btAssert(pt);
   pt->m_appliedImpulse = solveManifold.m_appliedImpulse;
   //	float f = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
   //	printf("pt->m_appliedImpulseLateral1 = %f\n", f);
   pt->m_appliedImpulseLateral1 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
   //printf("pt->m_appliedImpulseLateral1 = %f\n", pt->m_appliedImpulseLateral1);
   if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
   {
    pt->m_appliedImpulseLateral2 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex + 1].m_appliedImpulse;
   }
   //do a callback here?
  }
 }

 numPoolConstraints = m_tmpSolverNonContactConstraintPool.size();
 for (j = 0; j<numPoolConstraints; j++)
 {
  const btSolverConstraint& solverConstr = m_tmpSolverNonContactConstraintPool[j];
  btTypedConstraint* constr = (btTypedConstraint*)solverConstr.m_originalContactPoint;
  btJointFeedback* fb = constr->getJointFeedback();
  if (fb)
  {
   fb->m_appliedForceBodyA += solverConstr.m_contactNormal1*solverConstr.m_appliedImpulse*constr->getRigidBodyA().getLinearFactor() / infoGlobal.m_timeStep;
   fb->m_appliedForceBodyB += solverConstr.m_contactNormal2*solverConstr.m_appliedImpulse*constr->getRigidBodyB().getLinearFactor() / infoGlobal.m_timeStep;
   fb->m_appliedTorqueBodyA += solverConstr.m_relpos1CrossNormal* constr->getRigidBodyA().getAngularFactor()*solverConstr.m_appliedImpulse / infoGlobal.m_timeStep;
   fb->m_appliedTorqueBodyB += solverConstr.m_relpos2CrossNormal* constr->getRigidBodyB().getAngularFactor()*solverConstr.m_appliedImpulse / infoGlobal.m_timeStep; /*RGM ???? */

  }

  constr->internalSetAppliedImpulse(solverConstr.m_appliedImpulse);
  if (btFabs(solverConstr.m_appliedImpulse) >= constr->getBreakingImpulseThreshold())
  {
   constr->setEnabled(false);
  }
 }



 for (i = 0; i<m_tmpSolverBodyPool.size(); i++)
 {
  btRigidBody* body = m_tmpSolverBodyPool[i].m_originalBody;
  if (body)
  {
   if (infoGlobal.m_splitImpulse)
    m_tmpSolverBodyPool[i].writebackVelocityAndTransform(infoGlobal.m_timeStep, infoGlobal.m_splitImpulseTurnErp);
   else
    m_tmpSolverBodyPool[i].writebackVelocity();

   m_tmpSolverBodyPool[i].m_originalBody->setLinearVelocity(
    m_tmpSolverBodyPool[i].m_linearVelocity +
    m_tmpSolverBodyPool[i].m_externalForceImpulse);

   m_tmpSolverBodyPool[i].m_originalBody->setAngularVelocity(
    m_tmpSolverBodyPool[i].m_angularVelocity +
    m_tmpSolverBodyPool[i].m_externalTorqueImpulse);

   if (infoGlobal.m_splitImpulse)
    m_tmpSolverBodyPool[i].m_originalBody->setWorldTransform(m_tmpSolverBodyPool[i].m_worldTransform);

   m_tmpSolverBodyPool[i].m_originalBody->setCompanionId(-1);
  }
 }

 m_tmpSolverContactConstraintPool.resizeNoInitialize(0);
 m_tmpSolverNonContactConstraintPool.resizeNoInitialize(0);
 m_tmpSolverContactFrictionConstraintPool.resizeNoInitialize(0);
 m_tmpSolverContactRollingFrictionConstraintPool.resizeNoInitialize(0);

 m_tmpSolverBodyPool.resizeNoInitialize(0);
 return 0.f;
}



/// btSequentialImpulseConstraintSolver Sequentially applies impulses
btScalar btSequentialImpulseConstraintSolver::solveGroup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer, btDispatcher* /*dispatcher*/)
{

 BT_PROFILE("solveGroup");
 //you need to provide at least some bodies

 solveGroupCacheFriendlySetup(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

 solveGroupCacheFriendlyIterations(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

 solveGroupCacheFriendlyFinish(bodies, numBodies, infoGlobal);

 return 0.f;
}

void	btSequentialImpulseConstraintSolver::reset()
{
 m_btSeed2 = 0;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
Added by Roman Ponomarev (rponom@gmail.com)
April 04, 2008
*/



#include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include <new>

#define USE_OFFSET_FOR_CONSTANT_FRAME true

void btSliderConstraint::initParams()
{
 m_lowerLinLimit = btScalar(1.0);
 m_upperLinLimit = btScalar(-1.0);
 m_lowerAngLimit = btScalar(0.);
 m_upperAngLimit = btScalar(0.);
 m_softnessDirLin = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionDirLin = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingDirLin = btScalar(0.);
 m_cfmDirLin = SLIDER_CONSTRAINT_DEF_CFM;
 m_softnessDirAng = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionDirAng = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingDirAng = btScalar(0.);
 m_cfmDirAng = SLIDER_CONSTRAINT_DEF_CFM;
 m_softnessOrthoLin = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionOrthoLin = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingOrthoLin = SLIDER_CONSTRAINT_DEF_DAMPING;
 m_cfmOrthoLin = SLIDER_CONSTRAINT_DEF_CFM;
 m_softnessOrthoAng = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionOrthoAng = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingOrthoAng = SLIDER_CONSTRAINT_DEF_DAMPING;
 m_cfmOrthoAng = SLIDER_CONSTRAINT_DEF_CFM;
 m_softnessLimLin = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionLimLin = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingLimLin = SLIDER_CONSTRAINT_DEF_DAMPING;
 m_cfmLimLin = SLIDER_CONSTRAINT_DEF_CFM;
 m_softnessLimAng = SLIDER_CONSTRAINT_DEF_SOFTNESS;
 m_restitutionLimAng = SLIDER_CONSTRAINT_DEF_RESTITUTION;
 m_dampingLimAng = SLIDER_CONSTRAINT_DEF_DAMPING;
 m_cfmLimAng = SLIDER_CONSTRAINT_DEF_CFM;

 m_poweredLinMotor = false;
 m_targetLinMotorVelocity = btScalar(0.);
 m_maxLinMotorForce = btScalar(0.);
 m_accumulatedLinMotorImpulse = btScalar(0.0);

 m_poweredAngMotor = false;
 m_targetAngMotorVelocity = btScalar(0.);
 m_maxAngMotorForce = btScalar(0.);
 m_accumulatedAngMotorImpulse = btScalar(0.0);

 m_flags = 0;
 m_flags = 0;

 m_useOffsetForConstraintFrame = USE_OFFSET_FOR_CONSTANT_FRAME;

 calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}





btSliderConstraint::btSliderConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA)
 : btTypedConstraint(SLIDER_CONSTRAINT_TYPE, rbA, rbB),
 m_useSolveConstraintObsolete(false),
 m_frameInA(frameInA),
 m_frameInB(frameInB),
 m_useLinearReferenceFrameA(useLinearReferenceFrameA)
{
 initParams();
}



btSliderConstraint::btSliderConstraint(btRigidBody& rbB, const btTransform& frameInB, bool useLinearReferenceFrameA)
 : btTypedConstraint(SLIDER_CONSTRAINT_TYPE, getFixedBody(), rbB),
 m_useSolveConstraintObsolete(false),
 m_frameInB(frameInB),
 m_useLinearReferenceFrameA(useLinearReferenceFrameA)
{
 ///not providing rigidbody A means implicitly using worldspace for body A
 m_frameInA = rbB.getCenterOfMassTransform() * m_frameInB;
 //	m_frameInA.getOrigin() = m_rbA.getCenterOfMassTransform()(m_frameInA.getOrigin());

 initParams();
}






void btSliderConstraint::getInfo1(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  info->m_numConstraintRows = 4; // Fixed 2 linear + 2 angular
  info->nub = 2;
  //prepare constraint
  calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
  testAngLimits();
  testLinLimits();
  if (getSolveLinLimit() || getPoweredLinMotor())
  {
   info->m_numConstraintRows++; // limit 3rd linear as well
   info->nub--;
  }
  if (getSolveAngLimit() || getPoweredAngMotor())
  {
   info->m_numConstraintRows++; // limit 3rd angular as well
   info->nub--;
  }
 }
}

void btSliderConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{

 info->m_numConstraintRows = 6; // Fixed 2 linear + 2 angular + 1 limit (even if not used)
 info->nub = 0;
}

void btSliderConstraint::getInfo2(btConstraintInfo2* info)
{
 getInfo2NonVirtual(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getLinearVelocity(), m_rbB.getLinearVelocity(), m_rbA.getInvMass(), m_rbB.getInvMass());
}







void btSliderConstraint::calculateTransforms(const btTransform& transA, const btTransform& transB)
{
 if (m_useLinearReferenceFrameA || (!m_useSolveConstraintObsolete))
 {
  m_calculatedTransformA = transA * m_frameInA;
  m_calculatedTransformB = transB * m_frameInB;
 }
 else
 {
  m_calculatedTransformA = transB * m_frameInB;
  m_calculatedTransformB = transA * m_frameInA;
 }
 m_realPivotAInW = m_calculatedTransformA.getOrigin();
 m_realPivotBInW = m_calculatedTransformB.getOrigin();
 m_sliderAxis = m_calculatedTransformA.getBasis().getColumn(0); // along X
 if (m_useLinearReferenceFrameA || m_useSolveConstraintObsolete)
 {
  m_delta = m_realPivotBInW - m_realPivotAInW;
 }
 else
 {
  m_delta = m_realPivotAInW - m_realPivotBInW;
 }
 m_projPivotInW = m_realPivotAInW + m_sliderAxis.dot(m_delta) * m_sliderAxis;
 btVector3 normalWorld;
 int i;
 //linear part
 for (i = 0; i < 3; i++)
 {
  normalWorld = m_calculatedTransformA.getBasis().getColumn(i);
  m_depth[i] = m_delta.dot(normalWorld);
 }
}



void btSliderConstraint::testLinLimits(void)
{
 m_solveLinLim = false;
 m_linPos = m_depth[0];
 if (m_lowerLinLimit <= m_upperLinLimit)
 {
  if (m_depth[0] > m_upperLinLimit)
  {
   m_depth[0] -= m_upperLinLimit;
   m_solveLinLim = true;
  }
  else if (m_depth[0] < m_lowerLinLimit)
  {
   m_depth[0] -= m_lowerLinLimit;
   m_solveLinLim = true;
  }
  else
  {
   m_depth[0] = btScalar(0.);
  }
 }
 else
 {
  m_depth[0] = btScalar(0.);
 }
}



void btSliderConstraint::testAngLimits(void)
{
 m_angDepth = btScalar(0.);
 m_solveAngLim = false;
 if (m_lowerAngLimit <= m_upperAngLimit)
 {
  const btVector3 axisA0 = m_calculatedTransformA.getBasis().getColumn(1);
  const btVector3 axisA1 = m_calculatedTransformA.getBasis().getColumn(2);
  const btVector3 axisB0 = m_calculatedTransformB.getBasis().getColumn(1);
  //		btScalar rot = btAtan2Fast(axisB0.dot(axisA1), axisB0.dot(axisA0));  
  btScalar rot = btAtan2(axisB0.dot(axisA1), axisB0.dot(axisA0));
  rot = btAdjustAngleToLimits(rot, m_lowerAngLimit, m_upperAngLimit);
  m_angPos = rot;
  if (rot < m_lowerAngLimit)
  {
   m_angDepth = rot - m_lowerAngLimit;
   m_solveAngLim = true;
  }
  else if (rot > m_upperAngLimit)
  {
   m_angDepth = rot - m_upperAngLimit;
   m_solveAngLim = true;
  }
 }
}

btVector3 btSliderConstraint::getAncorInA(void)
{
 btVector3 ancorInA;
 ancorInA = m_realPivotAInW + (m_lowerLinLimit + m_upperLinLimit) * btScalar(0.5) * m_sliderAxis;
 ancorInA = m_rbA.getCenterOfMassTransform().inverse() * ancorInA;
 return ancorInA;
}



btVector3 btSliderConstraint::getAncorInB(void)
{
 btVector3 ancorInB;
 ancorInB = m_frameInB.getOrigin();
 return ancorInB;
}


void btSliderConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, btScalar rbAinvMass, btScalar rbBinvMass)
{
 const btTransform& trA = getCalculatedTransformA();
 const btTransform& trB = getCalculatedTransformB();

 btAssert(!m_useSolveConstraintObsolete);
 int i, s = info->rowskip;

 btScalar signFact = m_useLinearReferenceFrameA ? btScalar(1.0f) : btScalar(-1.0f);

 // difference between frames in WCS
 btVector3 ofs = trB.getOrigin() - trA.getOrigin();
 // now get weight factors depending on masses
 btScalar miA = rbAinvMass;
 btScalar miB = rbBinvMass;
 bool hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
 btScalar miS = miA + miB;
 btScalar factA, factB;
 if (miS > btScalar(0.f))
 {
  factA = miB / miS;
 }
 else
 {
  factA = btScalar(0.5f);
 }
 factB = btScalar(1.0f) - factA;
 btVector3 ax1, p, q;
 btVector3 ax1A = trA.getBasis().getColumn(0);
 btVector3 ax1B = trB.getBasis().getColumn(0);
 if (m_useOffsetForConstraintFrame)
 {
  // get the desired direction of slider axis
  // as weighted sum of X-orthos of frameA and frameB in WCS
  ax1 = ax1A * factA + ax1B * factB;
  ax1.normalize();
  // construct two orthos to slider axis
  btPlaneSpace1(ax1, p, q);
 }
 else
 { // old way - use frameA
  ax1 = trA.getBasis().getColumn(0);
  // get 2 orthos to slider axis (Y, Z)
  p = trA.getBasis().getColumn(1);
  q = trA.getBasis().getColumn(2);
 }
 // make rotations around these orthos equal
 // the slider axis should be the only unconstrained
 // rotational axis, the angular velocity of the two bodies perpendicular to
 // the slider axis should be equal. thus the constraint equations are
 //    p*w1 - p*w2 = 0
 //    q*w1 - q*w2 = 0
 // where p and q are unit vectors normal to the slider axis, and w1 and w2
 // are the angular velocity vectors of the two bodies.
 info->m_J1angularAxis[0] = p[0];
 info->m_J1angularAxis[1] = p[1];
 info->m_J1angularAxis[2] = p[2];
 info->m_J1angularAxis[s + 0] = q[0];
 info->m_J1angularAxis[s + 1] = q[1];
 info->m_J1angularAxis[s + 2] = q[2];

 info->m_J2angularAxis[0] = -p[0];
 info->m_J2angularAxis[1] = -p[1];
 info->m_J2angularAxis[2] = -p[2];
 info->m_J2angularAxis[s + 0] = -q[0];
 info->m_J2angularAxis[s + 1] = -q[1];
 info->m_J2angularAxis[s + 2] = -q[2];
 // compute the right hand side of the constraint equation. set relative
 // body velocities along p and q to bring the slider back into alignment.
 // if ax1A,ax1B are the unit length slider axes as computed from bodyA and
 // bodyB, we need to rotate both bodies along the axis u = (ax1 x ax2).
 // if "theta" is the angle between ax1 and ax2, we need an angular velocity
 // along u to cover angle erp*theta in one step :
 //   |angular_velocity| = angle/time = erp*theta / stepsize
 //                      = (erp*fps) * theta
 //    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
 //                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
 // ...as ax1 and ax2 are unit length. if theta is smallish,
 // theta ~= sin(theta), so
 //    angular_velocity  = (erp*fps) * (ax1 x ax2)
 // ax1 x ax2 is in the plane space of ax1, so we project the angular
 // velocity to p and q to find the right hand side.
 //	btScalar k = info->fps * info->erp * getSoftnessOrthoAng();
 btScalar currERP = (m_flags & BT_SLIDER_FLAGS_ERP_ORTANG) ? m_softnessOrthoAng : m_softnessOrthoAng * info->erp;
 btScalar k = info->fps * currERP;

 btVector3 u = ax1A.cross(ax1B);
 info->m_constraintError[0] = k * u.dot(p);
 info->m_constraintError[s] = k * u.dot(q);
 if (m_flags & BT_SLIDER_FLAGS_CFM_ORTANG)
 {
  info->cfm[0] = m_cfmOrthoAng;
  info->cfm[s] = m_cfmOrthoAng;
 }

 int nrow = 1; // last filled row
 int srow;
 btScalar limit_err;
 int limit;

 // next two rows. 
 // we want: velA + wA x relA == velB + wB x relB ... but this would
 // result in three equations, so we project along two orthos to the slider axis

 btTransform bodyA_trans = transA;
 btTransform bodyB_trans = transB;
 nrow++;
 int s2 = nrow * s;
 nrow++;
 int s3 = nrow * s;
 btVector3 tmpA(0, 0, 0), tmpB(0, 0, 0), relA(0, 0, 0), relB(0, 0, 0), c(0, 0, 0);
 if (m_useOffsetForConstraintFrame)
 {
  // get vector from bodyB to frameB in WCS
  relB = trB.getOrigin() - bodyB_trans.getOrigin();
  // get its projection to slider axis
  btVector3 projB = ax1 * relB.dot(ax1);
  // get vector directed from bodyB to slider axis (and orthogonal to it)
  btVector3 orthoB = relB - projB;
  // same for bodyA
  relA = trA.getOrigin() - bodyA_trans.getOrigin();
  btVector3 projA = ax1 * relA.dot(ax1);
  btVector3 orthoA = relA - projA;
  // get desired offset between frames A and B along slider axis
  btScalar sliderOffs = m_linPos - m_depth[0];
  // desired vector from projection of center of bodyA to projection of center of bodyB to slider axis
  btVector3 totalDist = projA + ax1 * sliderOffs - projB;
  // get offset vectors relA and relB
  relA = orthoA + totalDist * factA;
  relB = orthoB - totalDist * factB;
  // now choose average ortho to slider axis
  p = orthoB * factA + orthoA * factB;
  btScalar len2 = p.length2();
  if (len2 > SIMD_EPSILON)
  {
   p /= btSqrt(len2);
  }
  else
  {
   p = trA.getBasis().getColumn(1);
  }
  // make one more ortho
  q = ax1.cross(p);
  // fill two rows
  tmpA = relA.cross(p);
  tmpB = relB.cross(p);
  for (i = 0; i<3; i++) info->m_J1angularAxis[s2 + i] = tmpA[i];
  for (i = 0; i<3; i++) info->m_J2angularAxis[s2 + i] = -tmpB[i];
  tmpA = relA.cross(q);
  tmpB = relB.cross(q);
  if (hasStaticBody && getSolveAngLimit())
  { // to make constraint between static and dynamic objects more rigid
    // remove wA (or wB) from equation if angular limit is hit
   tmpB *= factB;
   tmpA *= factA;
  }
  for (i = 0; i<3; i++) info->m_J1angularAxis[s3 + i] = tmpA[i];
  for (i = 0; i<3; i++) info->m_J2angularAxis[s3 + i] = -tmpB[i];
  for (i = 0; i<3; i++) info->m_J1linearAxis[s2 + i] = p[i];
  for (i = 0; i<3; i++) info->m_J1linearAxis[s3 + i] = q[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s2 + i] = -p[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s3 + i] = -q[i];
 }
 else
 {	// old way - maybe incorrect if bodies are not on the slider axis
   // see discussion "Bug in slider constraint" http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=4024&start=0
  c = bodyB_trans.getOrigin() - bodyA_trans.getOrigin();
  btVector3 tmp = c.cross(p);
  for (i = 0; i<3; i++) info->m_J1angularAxis[s2 + i] = factA*tmp[i];
  for (i = 0; i<3; i++) info->m_J2angularAxis[s2 + i] = factB*tmp[i];
  tmp = c.cross(q);
  for (i = 0; i<3; i++) info->m_J1angularAxis[s3 + i] = factA*tmp[i];
  for (i = 0; i<3; i++) info->m_J2angularAxis[s3 + i] = factB*tmp[i];

  for (i = 0; i<3; i++) info->m_J1linearAxis[s2 + i] = p[i];
  for (i = 0; i<3; i++) info->m_J1linearAxis[s3 + i] = q[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s2 + i] = -p[i];
  for (i = 0; i<3; i++) info->m_J2linearAxis[s3 + i] = -q[i];
 }
 // compute two elements of right hand side

 //	k = info->fps * info->erp * getSoftnessOrthoLin();
 currERP = (m_flags & BT_SLIDER_FLAGS_ERP_ORTLIN) ? m_softnessOrthoLin : m_softnessOrthoLin * info->erp;
 k = info->fps * currERP;

 btScalar rhs = k * p.dot(ofs);
 info->m_constraintError[s2] = rhs;
 rhs = k * q.dot(ofs);
 info->m_constraintError[s3] = rhs;
 if (m_flags & BT_SLIDER_FLAGS_CFM_ORTLIN)
 {
  info->cfm[s2] = m_cfmOrthoLin;
  info->cfm[s3] = m_cfmOrthoLin;
 }


 // check linear limits
 limit_err = btScalar(0.0);
 limit = 0;
 if (getSolveLinLimit())
 {
  limit_err = getLinDepth() *  signFact;
  limit = (limit_err > btScalar(0.0)) ? 2 : 1;
 }
 bool powered = getPoweredLinMotor();
 // if the slider has joint limits or motor, add in the extra row
 if (limit || powered)
 {
  nrow++;
  srow = nrow * info->rowskip;
  info->m_J1linearAxis[srow + 0] = ax1[0];
  info->m_J1linearAxis[srow + 1] = ax1[1];
  info->m_J1linearAxis[srow + 2] = ax1[2];
  info->m_J2linearAxis[srow + 0] = -ax1[0];
  info->m_J2linearAxis[srow + 1] = -ax1[1];
  info->m_J2linearAxis[srow + 2] = -ax1[2];
  // linear torque decoupling step:
  //
  // we have to be careful that the linear constraint forces (+/- ax1) applied to the two bodies
  // do not create a torque couple. in other words, the points that the
  // constraint force is applied at must lie along the same ax1 axis.
  // a torque couple will result in limited slider-jointed free
  // bodies from gaining angular momentum.
  if (m_useOffsetForConstraintFrame)
  {
   // this is needed only when bodyA and bodyB are both dynamic.
   if (!hasStaticBody)
   {
    tmpA = relA.cross(ax1);
    tmpB = relB.cross(ax1);
    info->m_J1angularAxis[srow + 0] = tmpA[0];
    info->m_J1angularAxis[srow + 1] = tmpA[1];
    info->m_J1angularAxis[srow + 2] = tmpA[2];
    info->m_J2angularAxis[srow + 0] = -tmpB[0];
    info->m_J2angularAxis[srow + 1] = -tmpB[1];
    info->m_J2angularAxis[srow + 2] = -tmpB[2];
   }
  }
  else
  { // The old way. May be incorrect if bodies are not on the slider axis
   btVector3 ltd;	// Linear Torque Decoupling vector (a torque)
   ltd = c.cross(ax1);
   info->m_J1angularAxis[srow + 0] = factA*ltd[0];
   info->m_J1angularAxis[srow + 1] = factA*ltd[1];
   info->m_J1angularAxis[srow + 2] = factA*ltd[2];
   info->m_J2angularAxis[srow + 0] = factB*ltd[0];
   info->m_J2angularAxis[srow + 1] = factB*ltd[1];
   info->m_J2angularAxis[srow + 2] = factB*ltd[2];
  }
  // right-hand part
  btScalar lostop = getLowerLinLimit();
  btScalar histop = getUpperLinLimit();
  if (limit && (lostop == histop))
  {  // the joint motor is ineffective
   powered = false;
  }
  info->m_constraintError[srow] = 0.;
  info->m_lowerLimit[srow] = 0.;
  info->m_upperLimit[srow] = 0.;
  currERP = (m_flags & BT_SLIDER_FLAGS_ERP_LIMLIN) ? m_softnessLimLin : info->erp;
  if (powered)
  {
   if (m_flags & BT_SLIDER_FLAGS_CFM_DIRLIN)
   {
    info->cfm[srow] = m_cfmDirLin;
   }
   btScalar tag_vel = getTargetLinMotorVelocity();
   btScalar mot_fact = getMotorFactor(m_linPos, m_lowerLinLimit, m_upperLinLimit, tag_vel, info->fps * currERP);
   info->m_constraintError[srow] -= signFact * mot_fact * getTargetLinMotorVelocity();
   info->m_lowerLimit[srow] += -getMaxLinMotorForce() / info->fps;
   info->m_upperLimit[srow] += getMaxLinMotorForce() / info->fps;
  }
  if (limit)
  {
   k = info->fps * currERP;
   info->m_constraintError[srow] += k * limit_err;
   if (m_flags & BT_SLIDER_FLAGS_CFM_LIMLIN)
   {
    info->cfm[srow] = m_cfmLimLin;
   }
   if (lostop == histop)
   {	// limited low and high simultaneously
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else if (limit == 1)
   { // low limit
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = 0;
   }
   else
   { // high limit
    info->m_lowerLimit[srow] = 0;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   // bounce (we'll use slider parameter abs(1.0 - m_dampingLimLin) for that)
   btScalar bounce = btFabs(btScalar(1.0) - getDampingLimLin());
   if (bounce > btScalar(0.0))
   {
    btScalar vel = linVelA.dot(ax1);
    vel -= linVelB.dot(ax1);
    vel *= signFact;
    // only apply bounce if the velocity is incoming, and if the
    // resulting c[] exceeds what we already have.
    if (limit == 1)
    {	// low limit
     if (vel < 0)
     {
      btScalar newc = -bounce * vel;
      if (newc > info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
    else
    { // high limit - all those computations are reversed
     if (vel > 0)
     {
      btScalar newc = -bounce * vel;
      if (newc < info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
   }
   info->m_constraintError[srow] *= getSoftnessLimLin();
  } // if(limit)
 } // if linear limit
   // check angular limits
 limit_err = btScalar(0.0);
 limit = 0;
 if (getSolveAngLimit())
 {
  limit_err = getAngDepth();
  limit = (limit_err > btScalar(0.0)) ? 1 : 2;
 }
 // if the slider has joint limits, add in the extra row
 powered = getPoweredAngMotor();
 if (limit || powered)
 {
  nrow++;
  srow = nrow * info->rowskip;
  info->m_J1angularAxis[srow + 0] = ax1[0];
  info->m_J1angularAxis[srow + 1] = ax1[1];
  info->m_J1angularAxis[srow + 2] = ax1[2];

  info->m_J2angularAxis[srow + 0] = -ax1[0];
  info->m_J2angularAxis[srow + 1] = -ax1[1];
  info->m_J2angularAxis[srow + 2] = -ax1[2];

  btScalar lostop = getLowerAngLimit();
  btScalar histop = getUpperAngLimit();
  if (limit && (lostop == histop))
  {  // the joint motor is ineffective
   powered = false;
  }
  currERP = (m_flags & BT_SLIDER_FLAGS_ERP_LIMANG) ? m_softnessLimAng : info->erp;
  if (powered)
  {
   if (m_flags & BT_SLIDER_FLAGS_CFM_DIRANG)
   {
    info->cfm[srow] = m_cfmDirAng;
   }
   btScalar mot_fact = getMotorFactor(m_angPos, m_lowerAngLimit, m_upperAngLimit, getTargetAngMotorVelocity(), info->fps * currERP);
   info->m_constraintError[srow] = mot_fact * getTargetAngMotorVelocity();
   info->m_lowerLimit[srow] = -getMaxAngMotorForce() / info->fps;
   info->m_upperLimit[srow] = getMaxAngMotorForce() / info->fps;
  }
  if (limit)
  {
   k = info->fps * currERP;
   info->m_constraintError[srow] += k * limit_err;
   if (m_flags & BT_SLIDER_FLAGS_CFM_LIMANG)
   {
    info->cfm[srow] = m_cfmLimAng;
   }
   if (lostop == histop)
   {
    // limited low and high simultaneously
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else if (limit == 1)
   { // low limit
    info->m_lowerLimit[srow] = 0;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else
   { // high limit
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = 0;
   }
   // bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
   btScalar bounce = btFabs(btScalar(1.0) - getDampingLimAng());
   if (bounce > btScalar(0.0))
   {
    btScalar vel = m_rbA.getAngularVelocity().dot(ax1);
    vel -= m_rbB.getAngularVelocity().dot(ax1);
    // only apply bounce if the velocity is incoming, and if the
    // resulting c[] exceeds what we already have.
    if (limit == 1)
    {	// low limit
     if (vel < 0)
     {
      btScalar newc = -bounce * vel;
      if (newc > info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
    else
    {	// high limit - all those computations are reversed
     if (vel > 0)
     {
      btScalar newc = -bounce * vel;
      if (newc < info->m_constraintError[srow])
      {
       info->m_constraintError[srow] = newc;
      }
     }
    }
   }
   info->m_constraintError[srow] *= getSoftnessLimAng();
  } // if(limit)
 } // if angular limit or powered
}


///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void btSliderConstraint::setParam(int num, btScalar value, int axis)
{
 switch (num)
 {
 case BT_CONSTRAINT_STOP_ERP:
  if (axis < 1)
  {
   m_softnessLimLin = value;
   m_flags |= BT_SLIDER_FLAGS_ERP_LIMLIN;
  }
  else if (axis < 3)
  {
   m_softnessOrthoLin = value;
   m_flags |= BT_SLIDER_FLAGS_ERP_ORTLIN;
  }
  else if (axis == 3)
  {
   m_softnessLimAng = value;
   m_flags |= BT_SLIDER_FLAGS_ERP_LIMANG;
  }
  else if (axis < 6)
  {
   m_softnessOrthoAng = value;
   m_flags |= BT_SLIDER_FLAGS_ERP_ORTANG;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 case BT_CONSTRAINT_CFM:
  if (axis < 1)
  {
   m_cfmDirLin = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_DIRLIN;
  }
  else if (axis == 3)
  {
   m_cfmDirAng = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_DIRANG;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 case BT_CONSTRAINT_STOP_CFM:
  if (axis < 1)
  {
   m_cfmLimLin = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_LIMLIN;
  }
  else if (axis < 3)
  {
   m_cfmOrthoLin = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_ORTLIN;
  }
  else if (axis == 3)
  {
   m_cfmLimAng = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_LIMANG;
  }
  else if (axis < 6)
  {
   m_cfmOrthoAng = value;
   m_flags |= BT_SLIDER_FLAGS_CFM_ORTANG;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 }
}

///return the local value of parameter
btScalar btSliderConstraint::getParam(int num, int axis) const
{
 btScalar retVal(SIMD_INFINITY);
 switch (num)
 {
 case BT_CONSTRAINT_STOP_ERP:
  if (axis < 1)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_ERP_LIMLIN);
   retVal = m_softnessLimLin;
  }
  else if (axis < 3)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_ERP_ORTLIN);
   retVal = m_softnessOrthoLin;
  }
  else if (axis == 3)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_ERP_LIMANG);
   retVal = m_softnessLimAng;
  }
  else if (axis < 6)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_ERP_ORTANG);
   retVal = m_softnessOrthoAng;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 case BT_CONSTRAINT_CFM:
  if (axis < 1)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_DIRLIN);
   retVal = m_cfmDirLin;
  }
  else if (axis == 3)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_DIRANG);
   retVal = m_cfmDirAng;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 case BT_CONSTRAINT_STOP_CFM:
  if (axis < 1)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_LIMLIN);
   retVal = m_cfmLimLin;
  }
  else if (axis < 3)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_ORTLIN);
   retVal = m_cfmOrthoLin;
  }
  else if (axis == 3)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_LIMANG);
   retVal = m_cfmLimAng;
  }
  else if (axis < 6)
  {
   btAssertConstrParams(m_flags & BT_SLIDER_FLAGS_CFM_ORTANG);
   retVal = m_cfmOrthoAng;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 }
 return retVal;
}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletDynamics/ConstraintSolver/btSolve2LinearConstraint.h"

#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"


void btSolve2LinearConstraint::resolveUnilateralPairConstraint(
 btRigidBody* body1,
 btRigidBody* body2,

 const btMatrix3x3& world2A,
 const btMatrix3x3& world2B,

 const btVector3& invInertiaADiag,
 const btScalar invMassA,
 const btVector3& linvelA, const btVector3& angvelA,
 const btVector3& rel_posA1,
 const btVector3& invInertiaBDiag,
 const btScalar invMassB,
 const btVector3& linvelB, const btVector3& angvelB,
 const btVector3& rel_posA2,

 btScalar depthA, const btVector3& normalA,
 const btVector3& rel_posB1, const btVector3& rel_posB2,
 btScalar depthB, const btVector3& normalB,
 btScalar& imp0, btScalar& imp1)
{
 (void)linvelA;
 (void)linvelB;
 (void)angvelB;
 (void)angvelA;



 imp0 = btScalar(0.);
 imp1 = btScalar(0.);

 btScalar len = btFabs(normalA.length()) - btScalar(1.);
 if (btFabs(len) >= SIMD_EPSILON)
  return;

 btAssert(len < SIMD_EPSILON);


 //this jacobian entry could be re-used for all iterations
 btJacobianEntry jacA(world2A, world2B, rel_posA1, rel_posA2, normalA, invInertiaADiag, invMassA,
  invInertiaBDiag, invMassB);
 btJacobianEntry jacB(world2A, world2B, rel_posB1, rel_posB2, normalB, invInertiaADiag, invMassA,
  invInertiaBDiag, invMassB);

 //const btScalar vel0 = jacA.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
 //const btScalar vel1 = jacB.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);

 const btScalar vel0 = normalA.dot(body1->getVelocityInLocalPoint(rel_posA1) - body2->getVelocityInLocalPoint(rel_posA1));
 const btScalar vel1 = normalB.dot(body1->getVelocityInLocalPoint(rel_posB1) - body2->getVelocityInLocalPoint(rel_posB1));

 //	btScalar penetrationImpulse = (depth*contactTau*timeCorrection)  * massTerm;//jacDiagABInv
 btScalar massTerm = btScalar(1.) / (invMassA + invMassB);


 // calculate rhs (or error) terms
 const btScalar dv0 = depthA  * m_tau * massTerm - vel0 * m_damping;
 const btScalar dv1 = depthB  * m_tau * massTerm - vel1 * m_damping;


 // dC/dv * dv = -C

 // jacobian * impulse = -error
 //

 //impulse = jacobianInverse * -error

 // inverting 2x2 symmetric system (offdiagonal are equal!)
 // 


 btScalar nonDiag = jacA.getNonDiagonal(jacB, invMassA, invMassB);
 btScalar	invDet = btScalar(1.0) / (jacA.getDiagonal() * jacB.getDiagonal() - nonDiag * nonDiag);

 //imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
 //imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * - nonDiag * invDet;

 imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
 imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * -nonDiag * invDet;

 //[a b]								  [d -c]
 //[c d] inverse = (1 / determinant) * [-b a] where determinant is (ad - bc)

 //[jA nD] * [imp0] = [dv0]
 //[nD jB]   [imp1]   [dv1]

}



void btSolve2LinearConstraint::resolveBilateralPairConstraint(
 btRigidBody* body1,
 btRigidBody* body2,
 const btMatrix3x3& world2A,
 const btMatrix3x3& world2B,

 const btVector3& invInertiaADiag,
 const btScalar invMassA,
 const btVector3& linvelA, const btVector3& angvelA,
 const btVector3& rel_posA1,
 const btVector3& invInertiaBDiag,
 const btScalar invMassB,
 const btVector3& linvelB, const btVector3& angvelB,
 const btVector3& rel_posA2,

 btScalar depthA, const btVector3& normalA,
 const btVector3& rel_posB1, const btVector3& rel_posB2,
 btScalar depthB, const btVector3& normalB,
 btScalar& imp0, btScalar& imp1)
{

 (void)linvelA;
 (void)linvelB;
 (void)angvelA;
 (void)angvelB;



 imp0 = btScalar(0.);
 imp1 = btScalar(0.);

 btScalar len = btFabs(normalA.length()) - btScalar(1.);
 if (btFabs(len) >= SIMD_EPSILON)
  return;

 btAssert(len < SIMD_EPSILON);


 //this jacobian entry could be re-used for all iterations
 btJacobianEntry jacA(world2A, world2B, rel_posA1, rel_posA2, normalA, invInertiaADiag, invMassA,
  invInertiaBDiag, invMassB);
 btJacobianEntry jacB(world2A, world2B, rel_posB1, rel_posB2, normalB, invInertiaADiag, invMassA,
  invInertiaBDiag, invMassB);

 //const btScalar vel0 = jacA.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
 //const btScalar vel1 = jacB.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);

 const btScalar vel0 = normalA.dot(body1->getVelocityInLocalPoint(rel_posA1) - body2->getVelocityInLocalPoint(rel_posA1));
 const btScalar vel1 = normalB.dot(body1->getVelocityInLocalPoint(rel_posB1) - body2->getVelocityInLocalPoint(rel_posB1));

 // calculate rhs (or error) terms
 const btScalar dv0 = depthA  * m_tau - vel0 * m_damping;
 const btScalar dv1 = depthB  * m_tau - vel1 * m_damping;

 // dC/dv * dv = -C

 // jacobian * impulse = -error
 //

 //impulse = jacobianInverse * -error

 // inverting 2x2 symmetric system (offdiagonal are equal!)
 // 


 btScalar nonDiag = jacA.getNonDiagonal(jacB, invMassA, invMassB);
 btScalar	invDet = btScalar(1.0) / (jacA.getDiagonal() * jacB.getDiagonal() - nonDiag * nonDiag);

 //imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
 //imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * - nonDiag * invDet;

 imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
 imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * -nonDiag * invDet;

 //[a b]								  [d -c]
 //[c d] inverse = (1 / determinant) * [-b a] where determinant is (ad - bc)

 //[jA nD] * [imp0] = [dv0]
 //[nD jB]   [imp1]   [dv1]

 if (imp0 > btScalar(0.0))
 {
  if (imp1 > btScalar(0.0))
  {
   //both positive
  }
  else
  {
   imp1 = btScalar(0.);

   // now imp0>0 imp1<0
   imp0 = dv0 / jacA.getDiagonal();
   if (imp0 > btScalar(0.0))
   {
   }
   else
   {
    imp0 = btScalar(0.);
   }
  }
 }
 else
 {
  imp0 = btScalar(0.);

  imp1 = dv1 / jacB.getDiagonal();
  if (imp1 <= btScalar(0.0))
  {
   imp1 = btScalar(0.);
   // now imp0>0 imp1<0
   imp0 = dv0 / jacA.getDiagonal();
   if (imp0 > btScalar(0.0))
   {
   }
   else
   {
    imp0 = btScalar(0.);
   }
  }
  else
  {
  }
 }
}


/*
void btSolve2LinearConstraint::resolveAngularConstraint(	const btMatrix3x3& invInertiaAWS,
const btScalar invMassA,
const btVector3& linvelA,const btVector3& angvelA,
const btVector3& rel_posA1,
const btMatrix3x3& invInertiaBWS,
const btScalar invMassB,
const btVector3& linvelB,const btVector3& angvelB,
const btVector3& rel_posA2,

btScalar depthA, const btVector3& normalA,
const btVector3& rel_posB1,const btVector3& rel_posB2,
btScalar depthB, const btVector3& normalB,
btScalar& imp0,btScalar& imp1)
{

}
*/

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btSerializer.h"


#define DEFAULT_DEBUGDRAW_SIZE btScalar(0.05f)

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA)
 :btTypedObject(type),
 m_userConstraintType(-1),
 m_userConstraintPtr((void*)-1),
 m_breakingImpulseThreshold(SIMD_INFINITY),
 m_isEnabled(true),
 m_needsFeedback(false),
 m_overrideNumSolverIterations(-1),
 m_rbA(rbA),
 m_rbB(getFixedBody()),
 m_appliedImpulse(btScalar(0.)),
 m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
 m_jointFeedback(0)
{
}


btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA, btRigidBody& rbB)
 :btTypedObject(type),
 m_userConstraintType(-1),
 m_userConstraintPtr((void*)-1),
 m_breakingImpulseThreshold(SIMD_INFINITY),
 m_isEnabled(true),
 m_needsFeedback(false),
 m_overrideNumSolverIterations(-1),
 m_rbA(rbA),
 m_rbB(rbB),
 m_appliedImpulse(btScalar(0.)),
 m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
 m_jointFeedback(0)
{
}




btScalar btTypedConstraint::getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact)
{
 if (lowLim > uppLim)
 {
  return btScalar(1.0f);
 }
 else if (lowLim == uppLim)
 {
  return btScalar(0.0f);
 }
 btScalar lim_fact = btScalar(1.0f);
 btScalar delta_max = vel / timeFact;
 if (delta_max < btScalar(0.0f))
 {
  if ((pos >= lowLim) && (pos < (lowLim - delta_max)))
  {
   lim_fact = (lowLim - pos) / delta_max;
  }
  else if (pos  < lowLim)
  {
   lim_fact = btScalar(0.0f);
  }
  else
  {
   lim_fact = btScalar(1.0f);
  }
 }
 else if (delta_max > btScalar(0.0f))
 {
  if ((pos <= uppLim) && (pos > (uppLim - delta_max)))
  {
   lim_fact = (uppLim - pos) / delta_max;
  }
  else if (pos  > uppLim)
  {
   lim_fact = btScalar(0.0f);
  }
  else
  {
   lim_fact = btScalar(1.0f);
  }
 }
 else
 {
  lim_fact = btScalar(0.0f);
 }
 return lim_fact;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btTypedConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
 btTypedConstraintData2* tcd = (btTypedConstraintData2*)dataBuffer;

 tcd->m_rbA = (btRigidBodyData*)serializer->getUniquePointer(&m_rbA);
 tcd->m_rbB = (btRigidBodyData*)serializer->getUniquePointer(&m_rbB);
 char* name = (char*)serializer->findNameForPointer(this);
 tcd->m_name = (char*)serializer->getUniquePointer(name);
 if (tcd->m_name)
 {
  serializer->serializeName(name);
 }

 tcd->m_objectType = m_objectType;
 tcd->m_needsFeedback = m_needsFeedback;
 tcd->m_overrideNumSolverIterations = m_overrideNumSolverIterations;
 tcd->m_breakingImpulseThreshold = m_breakingImpulseThreshold;
 tcd->m_isEnabled = m_isEnabled ? 1 : 0;

 tcd->m_userConstraintId = m_userConstraintId;
 tcd->m_userConstraintType = m_userConstraintType;

 tcd->m_appliedImpulse = m_appliedImpulse;
 tcd->m_dbgDrawSize = m_dbgDrawSize;

 tcd->m_disableCollisionsBetweenLinkedBodies = false;

 int i;
 for (i = 0; i<m_rbA.getNumConstraintRefs(); i++)
  if (m_rbA.getConstraintRef(i) == this)
   tcd->m_disableCollisionsBetweenLinkedBodies = true;
 for (i = 0; i<m_rbB.getNumConstraintRefs(); i++)
  if (m_rbB.getConstraintRef(i) == this)
   tcd->m_disableCollisionsBetweenLinkedBodies = true;

 return btTypedConstraintDataName;
}

btRigidBody& btTypedConstraint::getFixedBody()
{
 static btRigidBody s_fixed(0, 0, 0);
 s_fixed.setMassProps(btScalar(0.), btVector3(btScalar(0.), btScalar(0.), btScalar(0.)));
 return s_fixed;
}


void btAngularLimit::set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor)
{
 m_halfRange = (high - low) / 2.0f;
 m_center = btNormalizeAngle(low + m_halfRange);
 m_softness = _softness;
 m_biasFactor = _biasFactor;
 m_relaxationFactor = _relaxationFactor;
}

void btAngularLimit::test(const btScalar angle)
{
 m_correction = 0.0f;
 m_sign = 0.0f;
 m_solveLimit = false;

 if (m_halfRange >= 0.0f)
 {
  btScalar deviation = btNormalizeAngle(angle - m_center);
  if (deviation < -m_halfRange)
  {
   m_solveLimit = true;
   m_correction = -(deviation + m_halfRange);
   m_sign = +1.0f;
  }
  else if (deviation > m_halfRange)
  {
   m_solveLimit = true;
   m_correction = m_halfRange - deviation;
   m_sign = -1.0f;
  }
 }
}


btScalar btAngularLimit::getError() const
{
 return m_correction * m_sign;
}

void btAngularLimit::fit(btScalar& angle) const
{
 if (m_halfRange > 0.0f)
 {
  btScalar relativeAngle = btNormalizeAngle(angle - m_center);
  if (!btEqual(relativeAngle, m_halfRange))
  {
   if (relativeAngle > 0.0f)
   {
    angle = getHigh();
   }
   else
   {
    angle = getLow();
   }
  }
 }
}

btScalar btAngularLimit::getLow() const
{
 return btNormalizeAngle(m_center - m_halfRange);
}

btScalar btAngularLimit::getHigh() const
{
 return btNormalizeAngle(m_center + m_halfRange);
}
/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc.

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/



#include "BulletDynamics/ConstraintSolver/btUniversalConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"



#define UNIV_EPS btScalar(0.01f)


// constructor
// anchor, axis1 and axis2 are in world coordinate system
// axis1 must be orthogonal to axis2
btUniversalConstraint::btUniversalConstraint(btRigidBody& rbA, btRigidBody& rbB, const btVector3& anchor, const btVector3& axis1, const btVector3& axis2)
 : btGeneric6DofConstraint(rbA, rbB, btTransform::getIdentity(), btTransform::getIdentity(), true),
 m_anchor(anchor),
 m_axis1(axis1),
 m_axis2(axis2)
{
 // build frame basis
 // 6DOF constraint uses Euler angles and to define limits
 // it is assumed that rotational order is :
 // Z - first, allowed limits are (-PI,PI);
 // new position of Y - second (allowed limits are (-PI/2 + epsilon, PI/2 - epsilon), where epsilon is a small positive number 
 // used to prevent constraint from instability on poles;
 // new position of X, allowed limits are (-PI,PI);
 // So to simulate ODE Universal joint we should use parent axis as Z, child axis as Y and limit all other DOFs
 // Build the frame in world coordinate system first
 btVector3 zAxis = m_axis1.normalize();
 btVector3 yAxis = m_axis2.normalize();
 btVector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system
 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);
 frameInW.setOrigin(anchor);
 // now get constraint frame in local coordinate systems
 m_frameInA = rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = rbB.getCenterOfMassTransform().inverse() * frameInW;
 // sei limits
 setLinearLowerLimit(btVector3(0., 0., 0.));
 setLinearUpperLimit(btVector3(0., 0., 0.));
 setAngularLowerLimit(btVector3(0.f, -SIMD_HALF_PI + UNIV_EPS, -SIMD_PI + UNIV_EPS));
 setAngularUpperLimit(btVector3(0.f, SIMD_HALF_PI - UNIV_EPS, SIMD_PI - UNIV_EPS));
}

void btUniversalConstraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
 m_axis1 = axis1;
 m_axis2 = axis2;

 btVector3 zAxis = axis1.normalized();
 btVector3 yAxis = axis2.normalized();
 btVector3 xAxis = yAxis.cross(zAxis); // we want right coordinate system

 btTransform frameInW;
 frameInW.setIdentity();
 frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
  xAxis[1], yAxis[1], zAxis[1],
  xAxis[2], yAxis[2], zAxis[2]);
 frameInW.setOrigin(m_anchor);

 // now get constraint frame in local coordinate systems
 m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
 m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

 calculateTransforms();
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"

#include "BulletCollision/CollisionShapes/btMinkowskiSumShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "LinearMath/btTransformUtil.h"

btSubsimplexConvexCast::btSubsimplexConvexCast(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver)
 :m_simplexSolver(simplexSolver),
 m_convexA(convexA), m_convexB(convexB)
{
}

///Typically the conservative advancement reaches solution in a few iterations, clip it to 32 for degenerate cases.
///See discussion about this here http://continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=565
#ifdef BT_USE_DOUBLE_PRECISION
#define MAX_ITERATIONS 64
#else
#define MAX_ITERATIONS3 32
#endif
bool	btSubsimplexConvexCast::calcTimeOfImpact(
 const btTransform& fromA,
 const btTransform& toA,
 const btTransform& fromB,
 const btTransform& toB,
 CastResult& result)
{

 m_simplexSolver->reset();

 btVector3 linVelA, linVelB;
 linVelA = toA.getOrigin() - fromA.getOrigin();
 linVelB = toB.getOrigin() - fromB.getOrigin();

 btScalar lambda = btScalar(0.);

 btTransform interpolatedTransA = fromA;
 btTransform interpolatedTransB = fromB;

 ///take relative motion
 btVector3 r = (linVelA - linVelB);
 btVector3 v;

 btVector3 supVertexA = fromA(m_convexA->localGetSupportingVertex(-r*fromA.getBasis()));
 btVector3 supVertexB = fromB(m_convexB->localGetSupportingVertex(r*fromB.getBasis()));
 v = supVertexA - supVertexB;
 int maxIter = MAX_ITERATIONS3;

 btVector3 n;
 n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));

 btVector3 c;




 btScalar dist2 = v.length2();
#ifdef BT_USE_DOUBLE_PRECISION
 btScalar epsilon = btScalar(0.0001);
#else
 btScalar epsilon = btScalar(0.0001);
#endif //BT_USE_DOUBLE_PRECISION
 btVector3	w, p;
 btScalar VdotR;

 while ((dist2 > epsilon) && maxIter--)
 {
  supVertexA = interpolatedTransA(m_convexA->localGetSupportingVertex(-v*interpolatedTransA.getBasis()));
  supVertexB = interpolatedTransB(m_convexB->localGetSupportingVertex(v*interpolatedTransB.getBasis()));
  w = supVertexA - supVertexB;

  btScalar VdotW = v.dot(w);

  if (lambda > btScalar(1.0))
  {
   return false;
  }

  if (VdotW > btScalar(0.))
  {
   VdotR = v.dot(r);

   if (VdotR >= -(SIMD_EPSILON*SIMD_EPSILON))
    return false;
   else
   {
    lambda = lambda - VdotW / VdotR;
    //interpolate to next lambda
    //	x = s + lambda * r;
    interpolatedTransA.getOrigin().setInterpolate3(fromA.getOrigin(), toA.getOrigin(), lambda);
    interpolatedTransB.getOrigin().setInterpolate3(fromB.getOrigin(), toB.getOrigin(), lambda);
    //m_simplexSolver->reset();
    //check next line
    w = supVertexA - supVertexB;

    n = v;

   }
  }
  ///Just like regular GJK only add the vertex if it isn't already (close) to current vertex, it would lead to divisions by zero and NaN etc.
  if (!m_simplexSolver->inSimplex(w))
   m_simplexSolver->addVertex(w, supVertexA, supVertexB);

  if (m_simplexSolver->closest(v))
  {
   dist2 = v.length2();

   //todo: check this normal for validity
   //n=v;
   //printf("V=%f , %f, %f\n",v[0],v[1],v[2]);
   //printf("DIST2=%f\n",dist2);
   //printf("numverts = %i\n",m_simplexSolver->numVertices());
  }
  else
  {
   dist2 = btScalar(0.);
  }
 }

 //int numiter = MAX_ITERATIONS - maxIter;
 //	printf("number of iterations: %d", numiter);

 //don't report a time of impact when moving 'away' from the hitnormal


 result.m_fraction = lambda;
 if (n.length2() >= (SIMD_EPSILON*SIMD_EPSILON))
  result.m_normal = n.normalized();
 else
  result.m_normal = btVector3(btScalar(0.0), btScalar(0.0), btScalar(0.0));

 //don't report time of impact for motion away from the contact normal (or causes minor penetration)
 if (result.m_normal.dot(r) >= -result.m_allowedPenetration)
  return false;

 btVector3 hitA, hitB;
 m_simplexSolver->compute_points(hitA, hitB);
 result.m_hitPoint = hitB;
 return true;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Elsevier CDROM license agreements grants nonexclusive license to use the software
for any purpose, commercial or non-commercial as long as the following credit is included
identifying the original source of the software:

Parts of the source are "from the book Real-Time Collision Detection by
Christer Ericson, published by Morgan Kaufmann Publishers,
(c) 2005 Elsevier Inc."

*/


#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"

#define VERTA  0
#define VERTB  1
#define VERTC  2
#define VERTD  3

#define CATCH_DEGENERATE_TETRAHEDRON 1
void	btVoronoiSimplexSolver::removeVertex(int index)
{

 btAssert(m_numVertices>0);
 m_numVertices--;
 m_simplexVectorW[index] = m_simplexVectorW[m_numVertices];
 m_simplexPointsP[index] = m_simplexPointsP[m_numVertices];
 m_simplexPointsQ[index] = m_simplexPointsQ[m_numVertices];
}

void	btVoronoiSimplexSolver::reduceVertices(const btUsageBitfield& usedVerts)
{
 if ((numVertices() >= 4) && (!usedVerts.usedVertexD))
  removeVertex(3);

 if ((numVertices() >= 3) && (!usedVerts.usedVertexC))
  removeVertex(2);

 if ((numVertices() >= 2) && (!usedVerts.usedVertexB))
  removeVertex(1);

 if ((numVertices() >= 1) && (!usedVerts.usedVertexA))
  removeVertex(0);

}





//clear the simplex, remove all the vertices
void btVoronoiSimplexSolver::reset()
{
 m_cachedValidClosest = false;
 m_numVertices = 0;
 m_needsUpdate = true;
 m_lastW = btVector3(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 m_cachedBC.reset();
}



//add a vertex
void btVoronoiSimplexSolver::addVertex(const btVector3& w, const btVector3& p, const btVector3& q)
{
 m_lastW = w;
 m_needsUpdate = true;

 m_simplexVectorW[m_numVertices] = w;
 m_simplexPointsP[m_numVertices] = p;
 m_simplexPointsQ[m_numVertices] = q;

 m_numVertices++;
}

bool	btVoronoiSimplexSolver::updateClosestVectorAndPoints()
{

 if (m_needsUpdate)
 {
  m_cachedBC.reset();

  m_needsUpdate = false;

  switch (numVertices())
  {
  case 0:
   m_cachedValidClosest = false;
   break;
  case 1:
  {
   m_cachedP1 = m_simplexPointsP[0];
   m_cachedP2 = m_simplexPointsQ[0];
   m_cachedV = m_cachedP1 - m_cachedP2; //== m_simplexVectorW[0]
   m_cachedBC.reset();
   m_cachedBC.setBarycentricCoordinates(btScalar(1.), btScalar(0.), btScalar(0.), btScalar(0.));
   m_cachedValidClosest = m_cachedBC.isValid();
   break;
  };
  case 2:
  {
   //closest point origin from line segment
   const btVector3& from = m_simplexVectorW[0];
   const btVector3& to = m_simplexVectorW[1];
   btVector3 nearest;

   btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));
   btVector3 diff = p - from;
   btVector3 v = to - from;
   btScalar t = v.dot(diff);

   if (t > 0) {
    btScalar dotVV = v.dot(v);
    if (t < dotVV) {
     t /= dotVV;
     diff -= t*v;
     m_cachedBC.m_usedVertices.usedVertexA = true;
     m_cachedBC.m_usedVertices.usedVertexB = true;
    }
    else {
     t = 1;
     diff -= v;
     //reduce to 1 point
     m_cachedBC.m_usedVertices.usedVertexB = true;
    }
   }
   else
   {
    t = 0;
    //reduce to 1 point
    m_cachedBC.m_usedVertices.usedVertexA = true;
   }
   m_cachedBC.setBarycentricCoordinates(1 - t, t);
   nearest = from + t*v;

   m_cachedP1 = m_simplexPointsP[0] + t * (m_simplexPointsP[1] - m_simplexPointsP[0]);
   m_cachedP2 = m_simplexPointsQ[0] + t * (m_simplexPointsQ[1] - m_simplexPointsQ[0]);
   m_cachedV = m_cachedP1 - m_cachedP2;

   reduceVertices(m_cachedBC.m_usedVertices);

   m_cachedValidClosest = m_cachedBC.isValid();
   break;
  }
  case 3:
  {
   //closest point origin from triangle 
   btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));

   const btVector3& a = m_simplexVectorW[0];
   const btVector3& b = m_simplexVectorW[1];
   const btVector3& c = m_simplexVectorW[2];

   closestPtPointTriangle(p, a, b, c, m_cachedBC);
   m_cachedP1 = m_simplexPointsP[0] * m_cachedBC.m_barycentricCoords[0] +
    m_simplexPointsP[1] * m_cachedBC.m_barycentricCoords[1] +
    m_simplexPointsP[2] * m_cachedBC.m_barycentricCoords[2];

   m_cachedP2 = m_simplexPointsQ[0] * m_cachedBC.m_barycentricCoords[0] +
    m_simplexPointsQ[1] * m_cachedBC.m_barycentricCoords[1] +
    m_simplexPointsQ[2] * m_cachedBC.m_barycentricCoords[2];

   m_cachedV = m_cachedP1 - m_cachedP2;

   reduceVertices(m_cachedBC.m_usedVertices);
   m_cachedValidClosest = m_cachedBC.isValid();

   break;
  }
  case 4:
  {


   btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));

   const btVector3& a = m_simplexVectorW[0];
   const btVector3& b = m_simplexVectorW[1];
   const btVector3& c = m_simplexVectorW[2];
   const btVector3& d = m_simplexVectorW[3];

   bool hasSeperation = closestPtPointTetrahedron(p, a, b, c, d, m_cachedBC);

   if (hasSeperation)
   {

    m_cachedP1 = m_simplexPointsP[0] * m_cachedBC.m_barycentricCoords[0] +
     m_simplexPointsP[1] * m_cachedBC.m_barycentricCoords[1] +
     m_simplexPointsP[2] * m_cachedBC.m_barycentricCoords[2] +
     m_simplexPointsP[3] * m_cachedBC.m_barycentricCoords[3];

    m_cachedP2 = m_simplexPointsQ[0] * m_cachedBC.m_barycentricCoords[0] +
     m_simplexPointsQ[1] * m_cachedBC.m_barycentricCoords[1] +
     m_simplexPointsQ[2] * m_cachedBC.m_barycentricCoords[2] +
     m_simplexPointsQ[3] * m_cachedBC.m_barycentricCoords[3];

    m_cachedV = m_cachedP1 - m_cachedP2;
    reduceVertices(m_cachedBC.m_usedVertices);
   }
   else
   {
    //					printf("sub distance got penetration\n");

    if (m_cachedBC.m_degenerate)
    {
     m_cachedValidClosest = false;
    }
    else
    {
     m_cachedValidClosest = true;
     //degenerate case == false, penetration = true + zero
     m_cachedV.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
    }
    break;
   }

   m_cachedValidClosest = m_cachedBC.isValid();

   //closest point origin from tetrahedron
   break;
  }
  default:
  {
   m_cachedValidClosest = false;
  }
  };
 }

 return m_cachedValidClosest;

}

//return/calculate the closest vertex
bool btVoronoiSimplexSolver::closest(btVector3& v)
{
 bool succes = updateClosestVectorAndPoints();
 v = m_cachedV;
 return succes;
}



btScalar btVoronoiSimplexSolver::maxVertex()
{
 int i, numverts = numVertices();
 btScalar maxV = btScalar(0.);
 for (i = 0; i<numverts; i++)
 {
  btScalar curLen2 = m_simplexVectorW[i].length2();
  if (maxV < curLen2)
   maxV = curLen2;
 }
 return maxV;
}



//return the current simplex
int btVoronoiSimplexSolver::getSimplex(btVector3 *pBuf, btVector3 *qBuf, btVector3 *yBuf) const
{
 int i;
 for (i = 0; i<numVertices(); i++)
 {
  yBuf[i] = m_simplexVectorW[i];
  pBuf[i] = m_simplexPointsP[i];
  qBuf[i] = m_simplexPointsQ[i];
 }
 return numVertices();
}




bool btVoronoiSimplexSolver::inSimplex(const btVector3& w)
{
 bool found = false;
 int i, numverts = numVertices();
 //btScalar maxV = btScalar(0.);

 //w is in the current (reduced) simplex
 for (i = 0; i<numverts; i++)
 {
#ifdef BT_USE_EQUAL_VERTEX_THRESHOLD
  if (m_simplexVectorW[i].distance2(w) <= m_equalVertexThreshold)
#else
  if (m_simplexVectorW[i] == w)
#endif
  {
   found = true;
   break;
  }
 }

 //check in case lastW is already removed
 if (w == m_lastW)
  return true;

 return found;
}

void btVoronoiSimplexSolver::backup_closest(btVector3& v)
{
 v = m_cachedV;
}


bool btVoronoiSimplexSolver::emptySimplex() const
{
 return (numVertices() == 0);

}

void btVoronoiSimplexSolver::compute_points(btVector3& p1, btVector3& p2)
{
 updateClosestVectorAndPoints();
 p1 = m_cachedP1;
 p2 = m_cachedP2;

}




bool	btVoronoiSimplexSolver::closestPtPointTriangle(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, btSubSimplexClosestResult& result)
{
 result.m_usedVertices.reset();

 // Check if P in vertex region outside A
 btVector3 ab = b - a;
 btVector3 ac = c - a;
 btVector3 ap = p - a;
 btScalar d1 = ab.dot(ap);
 btScalar d2 = ac.dot(ap);
 if (d1 <= btScalar(0.0) && d2 <= btScalar(0.0))
 {
  result.m_closestPointOnSimplex = a;
  result.m_usedVertices.usedVertexA = true;
  result.setBarycentricCoordinates(1, 0, 0);
  return true;// a; // barycentric coordinates (1,0,0)
 }

 // Check if P in vertex region outside B
 btVector3 bp = p - b;
 btScalar d3 = ab.dot(bp);
 btScalar d4 = ac.dot(bp);
 if (d3 >= btScalar(0.0) && d4 <= d3)
 {
  result.m_closestPointOnSimplex = b;
  result.m_usedVertices.usedVertexB = true;
  result.setBarycentricCoordinates(0, 1, 0);

  return true; // b; // barycentric coordinates (0,1,0)
 }
 // Check if P in edge region of AB, if so return projection of P onto AB
 btScalar vc = d1*d4 - d3*d2;
 if (vc <= btScalar(0.0) && d1 >= btScalar(0.0) && d3 <= btScalar(0.0)) {
  btScalar v = d1 / (d1 - d3);
  result.m_closestPointOnSimplex = a + v * ab;
  result.m_usedVertices.usedVertexA = true;
  result.m_usedVertices.usedVertexB = true;
  result.setBarycentricCoordinates(1 - v, v, 0);
  return true;
  //return a + v * ab; // barycentric coordinates (1-v,v,0)
 }

 // Check if P in vertex region outside C
 btVector3 cp = p - c;
 btScalar d5 = ab.dot(cp);
 btScalar d6 = ac.dot(cp);
 if (d6 >= btScalar(0.0) && d5 <= d6)
 {
  result.m_closestPointOnSimplex = c;
  result.m_usedVertices.usedVertexC = true;
  result.setBarycentricCoordinates(0, 0, 1);
  return true;//c; // barycentric coordinates (0,0,1)
 }

 // Check if P in edge region of AC, if so return projection of P onto AC
 btScalar vb = d5*d2 - d1*d6;
 if (vb <= btScalar(0.0) && d2 >= btScalar(0.0) && d6 <= btScalar(0.0)) {
  btScalar w = d2 / (d2 - d6);
  result.m_closestPointOnSimplex = a + w * ac;
  result.m_usedVertices.usedVertexA = true;
  result.m_usedVertices.usedVertexC = true;
  result.setBarycentricCoordinates(1 - w, 0, w);
  return true;
  //return a + w * ac; // barycentric coordinates (1-w,0,w)
 }

 // Check if P in edge region of BC, if so return projection of P onto BC
 btScalar va = d3*d6 - d5*d4;
 if (va <= btScalar(0.0) && (d4 - d3) >= btScalar(0.0) && (d5 - d6) >= btScalar(0.0)) {
  btScalar w = (d4 - d3) / ((d4 - d3) + (d5 - d6));

  result.m_closestPointOnSimplex = b + w * (c - b);
  result.m_usedVertices.usedVertexB = true;
  result.m_usedVertices.usedVertexC = true;
  result.setBarycentricCoordinates(0, 1 - w, w);
  return true;
  // return b + w * (c - b); // barycentric coordinates (0,1-w,w)
 }

 // P inside face region. Compute Q through its barycentric coordinates (u,v,w)
 btScalar denom = btScalar(1.0) / (va + vb + vc);
 btScalar v = vb * denom;
 btScalar w = vc * denom;

 result.m_closestPointOnSimplex = a + ab * v + ac * w;
 result.m_usedVertices.usedVertexA = true;
 result.m_usedVertices.usedVertexB = true;
 result.m_usedVertices.usedVertexC = true;
 result.setBarycentricCoordinates(1 - v - w, v, w);

 return true;
 //	return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = btScalar(1.0) - v - w

}





/// Test if point p and d lie on opposite sides of plane through abc
int btVoronoiSimplexSolver::pointOutsideOfPlane(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d)
{
 btVector3 normal = (b - a).cross(c - a);

 btScalar signp = (p - a).dot(normal); // [AP AB AC]
 btScalar signd = (d - a).dot(normal); // [AD AB AC]

#ifdef CATCH_DEGENERATE_TETRAHEDRON
#ifdef BT_USE_DOUBLE_PRECISION
 if (signd * signd < (btScalar(1e-8) * btScalar(1e-8)))
 {
  return -1;
 }
#else
 if (signd * signd < (btScalar(1e-4) * btScalar(1e-4)))
 {
  //		printf("affine dependent/degenerate\n");//
  return -1;
 }
#endif

#endif
 // Points on opposite sides if expression signs are opposite
 return signp * signd < btScalar(0.);
}


bool	btVoronoiSimplexSolver::closestPtPointTetrahedron(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d, btSubSimplexClosestResult& finalResult)
{
 btSubSimplexClosestResult tempResult;

 // Start out assuming point inside all halfspaces, so closest to itself
 finalResult.m_closestPointOnSimplex = p;
 finalResult.m_usedVertices.reset();
 finalResult.m_usedVertices.usedVertexA = true;
 finalResult.m_usedVertices.usedVertexB = true;
 finalResult.m_usedVertices.usedVertexC = true;
 finalResult.m_usedVertices.usedVertexD = true;

 int pointOutsideABC = pointOutsideOfPlane(p, a, b, c, d);
 int pointOutsideACD = pointOutsideOfPlane(p, a, c, d, b);
 int	pointOutsideADB = pointOutsideOfPlane(p, a, d, b, c);
 int	pointOutsideBDC = pointOutsideOfPlane(p, b, d, c, a);

 if (pointOutsideABC < 0 || pointOutsideACD < 0 || pointOutsideADB < 0 || pointOutsideBDC < 0)
 {
  finalResult.m_degenerate = true;
  return false;
 }

 if (!pointOutsideABC && !pointOutsideACD && !pointOutsideADB && !pointOutsideBDC)
 {
  return false;
 }


 btScalar bestSqDist = FLT_MAX;
 // If point outside face abc then compute closest point on abc
 if (pointOutsideABC)
 {
  closestPtPointTriangle(p, a, b, c, tempResult);
  btVector3 q = tempResult.m_closestPointOnSimplex;

  btScalar sqDist = (q - p).dot(q - p);
  // Update best closest point if (squared) distance is less than current best
  if (sqDist < bestSqDist) {
   bestSqDist = sqDist;
   finalResult.m_closestPointOnSimplex = q;
   //convert result bitmask!
   finalResult.m_usedVertices.reset();
   finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;
   finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexB;
   finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexC;
   finalResult.setBarycentricCoordinates(
    tempResult.m_barycentricCoords[VERTA],
    tempResult.m_barycentricCoords[VERTB],
    tempResult.m_barycentricCoords[VERTC],
    0
   );

  }
 }


 // Repeat test for face acd
 if (pointOutsideACD)
 {
  closestPtPointTriangle(p, a, c, d, tempResult);
  btVector3 q = tempResult.m_closestPointOnSimplex;
  //convert result bitmask!

  btScalar sqDist = (q - p).dot(q - p);
  if (sqDist < bestSqDist)
  {
   bestSqDist = sqDist;
   finalResult.m_closestPointOnSimplex = q;
   finalResult.m_usedVertices.reset();
   finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;

   finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexB;
   finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexC;
   finalResult.setBarycentricCoordinates(
    tempResult.m_barycentricCoords[VERTA],
    0,
    tempResult.m_barycentricCoords[VERTB],
    tempResult.m_barycentricCoords[VERTC]
   );

  }
 }
 // Repeat test for face adb


 if (pointOutsideADB)
 {
  closestPtPointTriangle(p, a, d, b, tempResult);
  btVector3 q = tempResult.m_closestPointOnSimplex;
  //convert result bitmask!

  btScalar sqDist = (q - p).dot(q - p);
  if (sqDist < bestSqDist)
  {
   bestSqDist = sqDist;
   finalResult.m_closestPointOnSimplex = q;
   finalResult.m_usedVertices.reset();
   finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;
   finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexC;

   finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexB;
   finalResult.setBarycentricCoordinates(
    tempResult.m_barycentricCoords[VERTA],
    tempResult.m_barycentricCoords[VERTC],
    0,
    tempResult.m_barycentricCoords[VERTB]
   );

  }
 }
 // Repeat test for face bdc


 if (pointOutsideBDC)
 {
  closestPtPointTriangle(p, b, d, c, tempResult);
  btVector3 q = tempResult.m_closestPointOnSimplex;
  //convert result bitmask!
  btScalar sqDist = (q - p).dot(q - p);
  if (sqDist < bestSqDist)
  {
   bestSqDist = sqDist;
   finalResult.m_closestPointOnSimplex = q;
   finalResult.m_usedVertices.reset();
   //
   finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexA;
   finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexC;
   finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexB;

   finalResult.setBarycentricCoordinates(
    0,
    tempResult.m_barycentricCoords[VERTA],
    tempResult.m_barycentricCoords[VERTC],
    tempResult.m_barycentricCoords[VERTB]
   );

  }
 }

 //help! we ended up full !

 if (finalResult.m_usedVertices.usedVertexA &&
  finalResult.m_usedVertices.usedVertexB &&
  finalResult.m_usedVertices.usedVertexC &&
  finalResult.m_usedVertices.usedVertexD)
 {
  return true;
 }

 return true;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  http://bulletphysics.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include <stdio.h>
#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionDispatch/btGhostObject.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "LinearMath/btDefaultMotionState.h"
#include "BulletDynamics/Character/btKinematicCharacterController.h"


// static helper method
static btVector3
getNormalizedVector(const btVector3& v)
{
 btVector3 n(0, 0, 0);

 if (v.length() > SIMD_EPSILON) {
  n = v.normalized();
 }
 return n;
}


///@todo Interact with dynamic objects,
///Ride kinematicly animated platforms properly
///More realistic (or maybe just a config option) falling
/// -> Should integrate falling velocity manually and use that in stepDown()
///Support jumping
///Support ducking
class btKinematicClosestNotMeRayResultCallback : public btCollisionWorld::ClosestRayResultCallback
{
public:
 btKinematicClosestNotMeRayResultCallback(btCollisionObject* me) : btCollisionWorld::ClosestRayResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))
 {
  m_me = me;
 }

 virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& rayResult, bool normalInWorldSpace)
 {
  if (rayResult.m_collisionObject == m_me)
   return 1.0;

  return ClosestRayResultCallback::addSingleResult(rayResult, normalInWorldSpace);
 }
protected:
 btCollisionObject* m_me;
};

class btKinematicClosestNotMeConvexResultCallback : public btCollisionWorld::ClosestConvexResultCallback
{
public:
 btKinematicClosestNotMeConvexResultCallback(btCollisionObject* me, const btVector3& up, btScalar minSlopeDot)
  : btCollisionWorld::ClosestConvexResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))
  , m_me(me)
  , m_up(up)
  , m_minSlopeDot(minSlopeDot)
 {
 }

 virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult, bool normalInWorldSpace)
 {
  if (convexResult.m_hitCollisionObject == m_me)
   return btScalar(1.0);

  if (!convexResult.m_hitCollisionObject->hasContactResponse())
   return btScalar(1.0);

  btVector3 hitNormalWorld;
  if (normalInWorldSpace)
  {
   hitNormalWorld = convexResult.m_hitNormalLocal;
  }
  else
  {
   ///need to transform normal into worldspace
   hitNormalWorld = convexResult.m_hitCollisionObject->getWorldTransform().getBasis()*convexResult.m_hitNormalLocal;
  }

  btScalar dotUp = m_up.dot(hitNormalWorld);
  if (dotUp < m_minSlopeDot) {
   return btScalar(1.0);
  }

  return ClosestConvexResultCallback::addSingleResult(convexResult, normalInWorldSpace);
 }
protected:
 btCollisionObject* m_me;
 const btVector3 m_up;
 btScalar m_minSlopeDot;
};

/*
* Returns the reflection direction of a ray going 'direction' hitting a surface with normal 'normal'
*
* from: http://www-cs-students.stanford.edu/~adityagp/final/node3.html
*/
btVector3 btKinematicCharacterController::computeReflectionDirection(const btVector3& direction, const btVector3& normal)
{
 return direction - (btScalar(2.0) * direction.dot(normal)) * normal;
}

/*
* Returns the portion of 'direction' that is parallel to 'normal'
*/
btVector3 btKinematicCharacterController::parallelComponent(const btVector3& direction, const btVector3& normal)
{
 btScalar magnitude = direction.dot(normal);
 return normal * magnitude;
}

/*
* Returns the portion of 'direction' that is perpindicular to 'normal'
*/
btVector3 btKinematicCharacterController::perpindicularComponent(const btVector3& direction, const btVector3& normal)
{
 return direction - parallelComponent(direction, normal);
}

btKinematicCharacterController::btKinematicCharacterController(btPairCachingGhostObject* ghostObject, btConvexShape* convexShape, btScalar stepHeight, const btVector3& up)
{
 m_ghostObject = ghostObject;
 m_up.setValue(0.0f, 0.0f, 1.0f);
 m_jumpAxis.setValue(0.0f, 0.0f, 1.0f);
 m_addedMargin = (btScalar)0.02;
 m_walkDirection.setValue(0.0, 0.0, 0.0);
 m_AngVel.setValue(0.0, 0.0, 0.0);
 m_useGhostObjectSweepTest = true;
 m_turnAngle = btScalar(0.0);
 m_convexShape = convexShape;
 m_useWalkDirection = true;	// use walk direction by default, legacy behavior
 m_velocityTimeInterval = 0.0;
 m_verticalVelocity = 0.0;
 m_verticalOffset = 0.0;
 m_gravity = (btScalar)(9.8 * 3.0); // 3G acceleration.
 m_fallSpeed = 55.0; // Terminal velocity of a sky diver in m/s.
 m_jumpSpeed = 10.0; // ?
 m_SetjumpSpeed = m_jumpSpeed;
 m_wasOnGround = false;
 m_wasJumping = false;
 m_interpolateUp = true;
 m_currentStepOffset = 0.0;
 m_maxPenetrationDepth = (btScalar)0.2;
 full_drop = false;
 bounce_fix = false;
 m_linearDamping = btScalar(0.0);
 m_angularDamping = btScalar(0.0);

 setUp(up);
 setStepHeight(stepHeight);
 setMaxSlope(btRadians(45.0));
}

btKinematicCharacterController::~btKinematicCharacterController()
{
}

btPairCachingGhostObject* btKinematicCharacterController::getGhostObject()
{
 return m_ghostObject;
}

bool btKinematicCharacterController::recoverFromPenetration(btCollisionWorld* collisionWorld)
{
 // Here we must refresh the overlapping paircache as the penetrating movement itself or the
 // previous recovery iteration might have used setWorldTransform and pushed us into an object
 // that is not in the previous cache contents from the last timestep, as will happen if we
 // are pushed into a new AABB overlap. Unhandled this means the next convex sweep gets stuck.
 //
 // Do this by calling the broadphase's setAabb with the moved AABB, this will update the broadphase
 // paircache and the ghostobject's internal paircache at the same time.    /BW

 btVector3 minAabb, maxAabb;
 m_convexShape->getAabb(m_ghostObject->getWorldTransform(), minAabb, maxAabb);
 collisionWorld->getBroadphase()->setAabb(m_ghostObject->getBroadphaseHandle(),
  minAabb,
  maxAabb,
  collisionWorld->getDispatcher());

 bool penetration = false;

 collisionWorld->getDispatcher()->dispatchAllCollisionPairs(m_ghostObject->getOverlappingPairCache(), collisionWorld->getDispatchInfo(), collisionWorld->getDispatcher());

 m_currentPosition = m_ghostObject->getWorldTransform().getOrigin();

 //	btScalar maxPen = btScalar(0.0);
 for (int i = 0; i < m_ghostObject->getOverlappingPairCache()->getNumOverlappingPairs(); i++)
 {
  m_manifoldArray.resize(0);

  btBroadphasePair* collisionPair = &m_ghostObject->getOverlappingPairCache()->getOverlappingPairArray()[i];

  btCollisionObject* obj0 = static_cast<btCollisionObject*>(collisionPair->m_pProxy0->m_clientObject);
  btCollisionObject* obj1 = static_cast<btCollisionObject*>(collisionPair->m_pProxy1->m_clientObject);

  if ((obj0 && !obj0->hasContactResponse()) || (obj1 && !obj1->hasContactResponse()))
   continue;

  if (!needsCollision(obj0, obj1))
   continue;

  if (collisionPair->m_algorithm)
   collisionPair->m_algorithm->getAllContactManifolds(m_manifoldArray);


  for (int j = 0; j<m_manifoldArray.size(); j++)
  {
   btPersistentManifold* manifold = m_manifoldArray[j];
   btScalar directionSign = manifold->getBody0() == m_ghostObject ? btScalar(-1.0) : btScalar(1.0);
   for (int p = 0; p<manifold->getNumContacts(); p++)
   {
    const btManifoldPoint&pt = manifold->getContactPoint(p);

    btScalar dist = pt.getDistance();

    if (dist < -m_maxPenetrationDepth)
    {
     // TODO: cause problems on slopes, not sure if it is needed
     //if (dist < maxPen)
     //{
     //	maxPen = dist;
     //	m_touchingNormal = pt.m_normalWorldOnB * directionSign;//??

     //}
     m_currentPosition += pt.m_normalWorldOnB * directionSign * dist * btScalar(0.2);
     penetration = true;
    }
    else {
     //printf("touching %f\n", dist);
    }
   }

   //manifold->clearManifold();
  }
 }
 btTransform newTrans = m_ghostObject->getWorldTransform();
 newTrans.setOrigin(m_currentPosition);
 m_ghostObject->setWorldTransform(newTrans);
 //	printf("m_touchingNormal = %f,%f,%f\n",m_touchingNormal[0],m_touchingNormal[1],m_touchingNormal[2]);
 return penetration;
}

void btKinematicCharacterController::stepUp(btCollisionWorld* world)
{
 btScalar stepHeight = 0.0f;
 if (m_verticalVelocity < 0.0)
  stepHeight = m_stepHeight;

 // phase 1: up
 btTransform start, end;

 start.setIdentity();
 end.setIdentity();

 /* FIXME: Handle penetration properly */
 start.setOrigin(m_currentPosition);

 m_targetPosition = m_currentPosition + m_up * (stepHeight)+m_jumpAxis * ((m_verticalOffset > 0.f ? m_verticalOffset : 0.f));
 m_currentPosition = m_targetPosition;

 end.setOrigin(m_targetPosition);

 start.setRotation(m_currentOrientation);
 end.setRotation(m_targetOrientation);

 btKinematicClosestNotMeConvexResultCallback callback(m_ghostObject, -m_up, m_maxSlopeCosine);
 callback.m_collisionFilterGroup = getGhostObject()->getBroadphaseHandle()->m_collisionFilterGroup;
 callback.m_collisionFilterMask = getGhostObject()->getBroadphaseHandle()->m_collisionFilterMask;

 if (m_useGhostObjectSweepTest)
 {
  m_ghostObject->convexSweepTest(m_convexShape, start, end, callback, world->getDispatchInfo().m_allowedCcdPenetration);
 }
 else
 {
  world->convexSweepTest(m_convexShape, start, end, callback, world->getDispatchInfo().m_allowedCcdPenetration);
 }

 if (callback.hasHit() && m_ghostObject->hasContactResponse() && needsCollision(m_ghostObject, callback.m_hitCollisionObject))
 {
  // Only modify the position if the hit was a slope and not a wall or ceiling.
  if (callback.m_hitNormalWorld.dot(m_up) > 0.0)
  {
   // we moved up only a fraction of the step height
   m_currentStepOffset = stepHeight * callback.m_closestHitFraction;
   if (m_interpolateUp == true)
    m_currentPosition.setInterpolate3(m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
   else
    m_currentPosition = m_targetPosition;
  }

  btTransform& xform = m_ghostObject->getWorldTransform();
  xform.setOrigin(m_currentPosition);
  m_ghostObject->setWorldTransform(xform);

  // fix penetration if we hit a ceiling for example
  int numPenetrationLoops = 0;
  m_touchingContact = false;
  while (recoverFromPenetration(world))
  {
   numPenetrationLoops++;
   m_touchingContact = true;
   if (numPenetrationLoops > 4)
   {
    //printf("character could not recover from penetration = %d\n", numPenetrationLoops);
    break;
   }
  }
  m_targetPosition = m_ghostObject->getWorldTransform().getOrigin();
  m_currentPosition = m_targetPosition;

  if (m_verticalOffset > 0)
  {
   m_verticalOffset = 0.0;
   m_verticalVelocity = 0.0;
   m_currentStepOffset = m_stepHeight;
  }
 }
 else {
  m_currentStepOffset = stepHeight;
  m_currentPosition = m_targetPosition;
 }
}

bool btKinematicCharacterController::needsCollision(const btCollisionObject* body0, const btCollisionObject* body1)
{
 bool collides = (body0->getBroadphaseHandle()->m_collisionFilterGroup & body1->getBroadphaseHandle()->m_collisionFilterMask) != 0;
 collides = collides && (body1->getBroadphaseHandle()->m_collisionFilterGroup & body0->getBroadphaseHandle()->m_collisionFilterMask);
 return collides;
}

void btKinematicCharacterController::updateTargetPositionBasedOnCollision(const btVector3& hitNormal, btScalar tangentMag, btScalar normalMag)
{
 btVector3 movementDirection = m_targetPosition - m_currentPosition;
 btScalar movementLength = movementDirection.length();
 if (movementLength>SIMD_EPSILON)
 {
  movementDirection.normalize();

  btVector3 reflectDir = computeReflectionDirection(movementDirection, hitNormal);
  reflectDir.normalize();

  btVector3 parallelDir, perpindicularDir;

  parallelDir = parallelComponent(reflectDir, hitNormal);
  perpindicularDir = perpindicularComponent(reflectDir, hitNormal);

  m_targetPosition = m_currentPosition;
  if (0)//tangentMag != 0.0)
  {
   btVector3 parComponent = parallelDir * btScalar(tangentMag*movementLength);
   //			printf("parComponent=%f,%f,%f\n",parComponent[0],parComponent[1],parComponent[2]);
   m_targetPosition += parComponent;
  }

  if (normalMag != 0.0)
  {
   btVector3 perpComponent = perpindicularDir * btScalar(normalMag*movementLength);
   //			printf("perpComponent=%f,%f,%f\n",perpComponent[0],perpComponent[1],perpComponent[2]);
   m_targetPosition += perpComponent;
  }
 }
 else
 {
  //		printf("movementLength don't normalize a zero vector\n");
 }
}

void btKinematicCharacterController::stepForwardAndStrafe(btCollisionWorld* collisionWorld, const btVector3& walkMove)
{
 // printf("m_normalizedDirection=%f,%f,%f\n",
 // 	m_normalizedDirection[0],m_normalizedDirection[1],m_normalizedDirection[2]);
 // phase 2: forward and strafe
 btTransform start, end;

 m_targetPosition = m_currentPosition + walkMove;

 start.setIdentity();
 end.setIdentity();

 btScalar fraction = 1.0;
 btScalar distance2 = (m_currentPosition - m_targetPosition).length2();
 //	printf("distance2=%f\n",distance2);

 int maxIter = 10;

 while (fraction > btScalar(0.01) && maxIter-- > 0)
 {
  start.setOrigin(m_currentPosition);
  end.setOrigin(m_targetPosition);
  btVector3 sweepDirNegative(m_currentPosition - m_targetPosition);

  start.setRotation(m_currentOrientation);
  end.setRotation(m_targetOrientation);

  btKinematicClosestNotMeConvexResultCallback callback(m_ghostObject, sweepDirNegative, btScalar(0.0));
  callback.m_collisionFilterGroup = getGhostObject()->getBroadphaseHandle()->m_collisionFilterGroup;
  callback.m_collisionFilterMask = getGhostObject()->getBroadphaseHandle()->m_collisionFilterMask;


  btScalar margin = m_convexShape->getMargin();
  m_convexShape->setMargin(margin + m_addedMargin);

  if (!(start == end))
  {
   if (m_useGhostObjectSweepTest)
   {
    m_ghostObject->convexSweepTest(m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
   }
   else
   {
    collisionWorld->convexSweepTest(m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
   }
  }
  m_convexShape->setMargin(margin);


  fraction -= callback.m_closestHitFraction;

  if (callback.hasHit() && m_ghostObject->hasContactResponse() && needsCollision(m_ghostObject, callback.m_hitCollisionObject))
  {
   // we moved only a fraction
   //btScalar hitDistance;
   //hitDistance = (callback.m_hitPointWorld - m_currentPosition).length();

   //			m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);

   updateTargetPositionBasedOnCollision(callback.m_hitNormalWorld);
   btVector3 currentDir = m_targetPosition - m_currentPosition;
   distance2 = currentDir.length2();
   if (distance2 > SIMD_EPSILON)
   {
    currentDir.normalize();
    /* See Quake2: "If velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners." */
    if (currentDir.dot(m_normalizedDirection) <= btScalar(0.0))
    {
     break;
    }
   }
   else
   {
    //				printf("currentDir: don't normalize a zero vector\n");
    break;
   }

  }
  else
  {
   m_currentPosition = m_targetPosition;
  }
 }
}

void btKinematicCharacterController::stepDown(btCollisionWorld* collisionWorld, btScalar dt)
{
 btTransform start, end, end_double;
 bool runonce = false;

 // phase 3: down
 /*btScalar additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;
 btVector3 step_drop = m_up * (m_currentStepOffset + additionalDownStep);
 btScalar downVelocity = (additionalDownStep == 0.0 && m_verticalVelocity<0.0?-m_verticalVelocity:0.0) * dt;
 btVector3 gravity_drop = m_up * downVelocity;
 m_targetPosition -= (step_drop + gravity_drop);*/

 btVector3 orig_position = m_targetPosition;

 btScalar downVelocity = (m_verticalVelocity<0.f ? -m_verticalVelocity : 0.f) * dt;

 if (m_verticalVelocity > 0.0)
  return;

 if (downVelocity > 0.0 && downVelocity > m_fallSpeed
  && (m_wasOnGround || !m_wasJumping))
  downVelocity = m_fallSpeed;

 btVector3 step_drop = m_up * (m_currentStepOffset + downVelocity);
 m_targetPosition -= step_drop;

 btKinematicClosestNotMeConvexResultCallback callback(m_ghostObject, m_up, m_maxSlopeCosine);
 callback.m_collisionFilterGroup = getGhostObject()->getBroadphaseHandle()->m_collisionFilterGroup;
 callback.m_collisionFilterMask = getGhostObject()->getBroadphaseHandle()->m_collisionFilterMask;

 btKinematicClosestNotMeConvexResultCallback callback2(m_ghostObject, m_up, m_maxSlopeCosine);
 callback2.m_collisionFilterGroup = getGhostObject()->getBroadphaseHandle()->m_collisionFilterGroup;
 callback2.m_collisionFilterMask = getGhostObject()->getBroadphaseHandle()->m_collisionFilterMask;

 while (1)
 {
  start.setIdentity();
  end.setIdentity();

  end_double.setIdentity();

  start.setOrigin(m_currentPosition);
  end.setOrigin(m_targetPosition);

  start.setRotation(m_currentOrientation);
  end.setRotation(m_targetOrientation);

  //set double test for 2x the step drop, to check for a large drop vs small drop
  end_double.setOrigin(m_targetPosition - step_drop);

  if (m_useGhostObjectSweepTest)
  {
   m_ghostObject->convexSweepTest(m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);

   if (!callback.hasHit() && m_ghostObject->hasContactResponse())
   {
    //test a double fall height, to see if the character should interpolate it's fall (full) or not (partial)
    m_ghostObject->convexSweepTest(m_convexShape, start, end_double, callback2, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
   }
  }
  else
  {
   collisionWorld->convexSweepTest(m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);

   if (!callback.hasHit() && m_ghostObject->hasContactResponse())
   {
    //test a double fall height, to see if the character should interpolate it's fall (large) or not (small)
    collisionWorld->convexSweepTest(m_convexShape, start, end_double, callback2, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
   }
  }

  btScalar downVelocity2 = (m_verticalVelocity<0.f ? -m_verticalVelocity : 0.f) * dt;
  bool has_hit;
  if (bounce_fix == true)
   has_hit = (callback.hasHit() || callback2.hasHit()) && m_ghostObject->hasContactResponse() && needsCollision(m_ghostObject, callback.m_hitCollisionObject);
  else
   has_hit = callback2.hasHit() && m_ghostObject->hasContactResponse() && needsCollision(m_ghostObject, callback2.m_hitCollisionObject);

  btScalar stepHeight = 0.0f;
  if (m_verticalVelocity < 0.0)
   stepHeight = m_stepHeight;

  if (downVelocity2 > 0.0 && downVelocity2 < stepHeight && has_hit == true && runonce == false
   && (m_wasOnGround || !m_wasJumping))
  {
   //redo the velocity calculation when falling a small amount, for fast stairs motion
   //for larger falls, use the smoother/slower interpolated movement by not touching the target position

   m_targetPosition = orig_position;
   downVelocity = stepHeight;

   step_drop = m_up * (m_currentStepOffset + downVelocity);
   m_targetPosition -= step_drop;
   runonce = true;
   continue; //re-run previous tests
  }
  break;
 }

 if ((m_ghostObject->hasContactResponse() && (callback.hasHit() && needsCollision(m_ghostObject, callback.m_hitCollisionObject))) || runonce == true)
 {
  // we dropped a fraction of the height -> hit floor
  btScalar fraction = (m_currentPosition.getY() - callback.m_hitPointWorld.getY()) / 2;

  //printf("hitpoint: %g - pos %g\n", callback.m_hitPointWorld.getY(), m_currentPosition.getY());

  if (bounce_fix == true)
  {
   if (full_drop == true)
    m_currentPosition.setInterpolate3(m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
   else
    //due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually
    m_currentPosition.setInterpolate3(m_currentPosition, m_targetPosition, fraction);
  }
  else
   m_currentPosition.setInterpolate3(m_currentPosition, m_targetPosition, callback.m_closestHitFraction);

  full_drop = false;

  m_verticalVelocity = 0.0;
  m_verticalOffset = 0.0;
  m_wasJumping = false;
 }
 else {
  // we dropped the full height

  full_drop = true;

  if (bounce_fix == true)
  {
   downVelocity = (m_verticalVelocity<0.f ? -m_verticalVelocity : 0.f) * dt;
   if (downVelocity > m_fallSpeed && (m_wasOnGround || !m_wasJumping))
   {
    m_targetPosition += step_drop; //undo previous target change
    downVelocity = m_fallSpeed;
    step_drop = m_up * (m_currentStepOffset + downVelocity);
    m_targetPosition -= step_drop;
   }
  }
  //printf("full drop - %g, %g\n", m_currentPosition.getY(), m_targetPosition.getY());

  m_currentPosition = m_targetPosition;
 }
}



void btKinematicCharacterController::setWalkDirection
(
 const btVector3& walkDirection
)
{
 m_useWalkDirection = true;
 m_walkDirection = walkDirection;
 m_normalizedDirection = getNormalizedVector(m_walkDirection);
}



void btKinematicCharacterController::setVelocityForTimeInterval
(
 const btVector3& velocity,
 btScalar timeInterval
)
{
 //	printf("setVelocity!\n");
 //	printf("  interval: %f\n", timeInterval);
 //	printf("  velocity: (%f, %f, %f)\n",
 //		 velocity.x(), velocity.y(), velocity.z());

 m_useWalkDirection = false;
 m_walkDirection = velocity;
 m_normalizedDirection = getNormalizedVector(m_walkDirection);
 m_velocityTimeInterval += timeInterval;
}

void btKinematicCharacterController::setAngularVelocity(const btVector3& velocity)
{
 m_AngVel = velocity;
}

const btVector3& btKinematicCharacterController::getAngularVelocity() const
{
 return m_AngVel;
}

void btKinematicCharacterController::setLinearVelocity(const btVector3& velocity)
{
 m_walkDirection = velocity;

 // HACK: if we are moving in the direction of the up, treat it as a jump :(
 if (m_walkDirection.length2() > 0)
 {
  btVector3 w = velocity.normalized();
  btScalar c = w.dot(m_up);
  if (c != 0)
  {
   //there is a component in walkdirection for vertical velocity
   btVector3 upComponent = m_up * (btSin(SIMD_HALF_PI - btAcos(c)) * m_walkDirection.length());
   m_walkDirection -= upComponent;
   m_verticalVelocity = (c < 0.0f ? -1 : 1) * upComponent.length();

   if (c > 0.0f)
   {
    m_wasJumping = true;
    m_jumpPosition = m_ghostObject->getWorldTransform().getOrigin();
   }
  }
 }
 else
  m_verticalVelocity = 0.0f;
}

btVector3 btKinematicCharacterController::getLinearVelocity() const
{
 return m_walkDirection + (m_verticalVelocity * m_up);
}

void btKinematicCharacterController::reset(btCollisionWorld* collisionWorld)
{
 m_verticalVelocity = 0.0;
 m_verticalOffset = 0.0;
 m_wasOnGround = false;
 m_wasJumping = false;
 m_walkDirection.setValue(0, 0, 0);
 m_velocityTimeInterval = 0.0;

 //clear pair cache
 btHashedOverlappingPairCache *cache = m_ghostObject->getOverlappingPairCache();
 while (cache->getOverlappingPairArray().size() > 0)
 {
  cache->removeOverlappingPair(cache->getOverlappingPairArray()[0].m_pProxy0, cache->getOverlappingPairArray()[0].m_pProxy1, collisionWorld->getDispatcher());
 }
}

void btKinematicCharacterController::warp(const btVector3& origin)
{
 btTransform xform;
 xform.setIdentity();
 xform.setOrigin(origin);
 m_ghostObject->setWorldTransform(xform);
}


void btKinematicCharacterController::preStep(btCollisionWorld* collisionWorld)
{
 m_currentPosition = m_ghostObject->getWorldTransform().getOrigin();
 m_targetPosition = m_currentPosition;

 m_currentOrientation = m_ghostObject->getWorldTransform().getRotation();
 m_targetOrientation = m_currentOrientation;
 //	printf("m_targetPosition=%f,%f,%f\n",m_targetPosition[0],m_targetPosition[1],m_targetPosition[2]);
}

void btKinematicCharacterController::playerStep(btCollisionWorld* collisionWorld, btScalar dt)
{
 //	printf("playerStep(): ");
 //	printf("  dt = %f", dt);

 if (m_AngVel.length2() > 0.0f)
 {
  m_AngVel *= btPow(btScalar(1) - m_angularDamping, dt);
 }

 // integrate for angular velocity
 if (m_AngVel.length2() > 0.0f)
 {
  btTransform xform;
  xform = m_ghostObject->getWorldTransform();

  btQuaternion rot(m_AngVel.normalized(), m_AngVel.length() * dt);

  btQuaternion orn = rot * xform.getRotation();

  xform.setRotation(orn);
  m_ghostObject->setWorldTransform(xform);

  m_currentPosition = m_ghostObject->getWorldTransform().getOrigin();
  m_targetPosition = m_currentPosition;
  m_currentOrientation = m_ghostObject->getWorldTransform().getRotation();
  m_targetOrientation = m_currentOrientation;
 }

 // quick check...
 if (!m_useWalkDirection && (m_velocityTimeInterval <= 0.0)) {
  //		printf("\n");
  return;		// no motion
 }

 m_wasOnGround = onGround();

 //btVector3 lvel = m_walkDirection;
 //btScalar c = 0.0f;

 if (m_walkDirection.length2() > 0)
 {
  // apply damping
  m_walkDirection *= btPow(btScalar(1) - m_linearDamping, dt);
 }

 m_verticalVelocity *= btPow(btScalar(1) - m_linearDamping, dt);

 // Update fall velocity.
 m_verticalVelocity -= m_gravity * dt;
 if (m_verticalVelocity > 0.0 && m_verticalVelocity > m_jumpSpeed)
 {
  m_verticalVelocity = m_jumpSpeed;
 }
 if (m_verticalVelocity < 0.0 && btFabs(m_verticalVelocity) > btFabs(m_fallSpeed))
 {
  m_verticalVelocity = -btFabs(m_fallSpeed);
 }
 m_verticalOffset = m_verticalVelocity * dt;

 btTransform xform;
 xform = m_ghostObject->getWorldTransform();

 //	printf("walkDirection(%f,%f,%f)\n",walkDirection[0],walkDirection[1],walkDirection[2]);
 //	printf("walkSpeed=%f\n",walkSpeed);

 stepUp(collisionWorld);
 //todo: Experimenting with behavior of controller when it hits a ceiling..
 //bool hitUp = stepUp (collisionWorld);	
 //if (hitUp)
 //{
 //	m_verticalVelocity -= m_gravity * dt;
 //	if (m_verticalVelocity > 0.0 && m_verticalVelocity > m_jumpSpeed)
 //	{
 //		m_verticalVelocity = m_jumpSpeed;
 //	}
 //	if (m_verticalVelocity < 0.0 && btFabs(m_verticalVelocity) > btFabs(m_fallSpeed))
 //	{
 //		m_verticalVelocity = -btFabs(m_fallSpeed);
 //	}
 //	m_verticalOffset = m_verticalVelocity * dt;

 //	xform = m_ghostObject->getWorldTransform();
 //}

 if (m_useWalkDirection) {
  stepForwardAndStrafe(collisionWorld, m_walkDirection);
 }
 else {
  //printf("  time: %f", m_velocityTimeInterval);
  // still have some time left for moving!
  btScalar dtMoving =
   (dt < m_velocityTimeInterval) ? dt : m_velocityTimeInterval;
  m_velocityTimeInterval -= dt;

  // how far will we move while we are moving?
  btVector3 move = m_walkDirection * dtMoving;

  //printf("  dtMoving: %f", dtMoving);

  // okay, step
  stepForwardAndStrafe(collisionWorld, move);
 }
 stepDown(collisionWorld, dt);

 //todo: Experimenting with max jump height
 //if (m_wasJumping)
 //{
 //	btScalar ds = m_currentPosition[m_upAxis] - m_jumpPosition[m_upAxis];
 //	if (ds > m_maxJumpHeight)
 //	{
 //		// substract the overshoot
 //		m_currentPosition[m_upAxis] -= ds - m_maxJumpHeight;

 //		// max height was reached, so potential energy is at max 
 //		// and kinematic energy is 0, thus velocity is 0.
 //		if (m_verticalVelocity > 0.0)
 //			m_verticalVelocity = 0.0;
 //	}
 //}
 // printf("\n");

 xform.setOrigin(m_currentPosition);
 m_ghostObject->setWorldTransform(xform);

 int numPenetrationLoops = 0;
 m_touchingContact = false;
 while (recoverFromPenetration(collisionWorld))
 {
  numPenetrationLoops++;
  m_touchingContact = true;
  if (numPenetrationLoops > 4)
  {
   //printf("character could not recover from penetration = %d\n", numPenetrationLoops);
   break;
  }
 }
}

void btKinematicCharacterController::setFallSpeed(btScalar fallSpeed)
{
 m_fallSpeed = fallSpeed;
}

void btKinematicCharacterController::setJumpSpeed(btScalar jumpSpeed)
{
 m_jumpSpeed = jumpSpeed;
 m_SetjumpSpeed = m_jumpSpeed;
}

void btKinematicCharacterController::setMaxJumpHeight(btScalar maxJumpHeight)
{
 m_maxJumpHeight = maxJumpHeight;
}

bool btKinematicCharacterController::canJump() const
{
 return onGround();
}

void btKinematicCharacterController::jump(const btVector3& v)
{
 m_jumpSpeed = v.length2() == 0 ? m_SetjumpSpeed : v.length();
 m_verticalVelocity = m_jumpSpeed;
 m_wasJumping = true;

 m_jumpAxis = v.length2() == 0 ? m_up : v.normalized();

 m_jumpPosition = m_ghostObject->getWorldTransform().getOrigin();

#if 0
 currently no jumping.
  btTransform xform;
 m_rigidBody->getMotionState()->getWorldTransform(xform);
 btVector3 up = xform.getBasis()[1];
 up.normalize();
 btScalar magnitude = (btScalar(1.0) / m_rigidBody->getInvMass()) * btScalar(8.0);
 m_rigidBody->applyCentralImpulse(up * magnitude);
#endif
}

void btKinematicCharacterController::setGravity(const btVector3& gravity)
{
 if (gravity.length2() > 0) setUpVector(-gravity);

 m_gravity = gravity.length();
}

btVector3 btKinematicCharacterController::getGravity() const
{
 return -m_gravity * m_up;
}

void btKinematicCharacterController::setMaxSlope(btScalar slopeRadians)
{
 m_maxSlopeRadians = slopeRadians;
 m_maxSlopeCosine = btCos(slopeRadians);
}

btScalar btKinematicCharacterController::getMaxSlope() const
{
 return m_maxSlopeRadians;
}

void btKinematicCharacterController::setMaxPenetrationDepth(btScalar d)
{
 m_maxPenetrationDepth = d;
}

btScalar btKinematicCharacterController::getMaxPenetrationDepth() const
{
 return m_maxPenetrationDepth;
}

bool btKinematicCharacterController::onGround() const
{
 return (fabs(m_verticalVelocity) < SIMD_EPSILON) && (fabs(m_verticalOffset) < SIMD_EPSILON);
}

void btKinematicCharacterController::setStepHeight(btScalar h)
{
 m_stepHeight = h;
}

btVector3* btKinematicCharacterController::getUpAxisDirections()
{
 static btVector3 sUpAxisDirection[3] = { btVector3(1.0f, 0.0f, 0.0f), btVector3(0.0f, 1.0f, 0.0f), btVector3(0.0f, 0.0f, 1.0f) };

 return sUpAxisDirection;
}

void btKinematicCharacterController::debugDraw(btIDebugDraw* debugDrawer)
{
}

void btKinematicCharacterController::setUpInterpolate(bool value)
{
 m_interpolateUp = value;
}

void btKinematicCharacterController::setUp(const btVector3& up)
{
 if (up.length2() > 0 && m_gravity > 0.0f)
 {
  setGravity(-m_gravity * up.normalized());
  return;
 }

 setUpVector(up);
}

void btKinematicCharacterController::setUpVector(const btVector3& up)
{
 if (m_up == up)
  return;

 btVector3 u = m_up;

 if (up.length2() > 0)
  m_up = up.normalized();
 else
  m_up = btVector3(0.0, 0.0, 0.0);

 if (!m_ghostObject) return;
 btQuaternion rot = getRotation(m_up, u);

 //set orientation with new up
 btTransform xform;
 xform = m_ghostObject->getWorldTransform();
 btQuaternion orn = rot.inverse() * xform.getRotation();
 xform.setRotation(orn);
 m_ghostObject->setWorldTransform(xform);
}

btQuaternion btKinematicCharacterController::getRotation(btVector3& v0, btVector3& v1) const
{
 if (v0.length2() == 0.0f || v1.length2() == 0.0f)
 {
  btQuaternion q;
  return q;
 }

 return shortestArcQuatNormalize2(v0, v1);
}

/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/


#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMinMax.h"
#include <new>



//#define CONETWIST_USE_OBSOLETE_SOLVER true
#define CONETWIST_USE_OBSOLETE_SOLVER false
#define CONETWIST_DEF_FIX_THRESH btScalar(.05f)


SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis, const btMatrix3x3& invInertiaWorld)
{
 btVector3 vec = axis * invInertiaWorld;
 return axis.dot(vec);
}




btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, btRigidBody& rbB,
 const btTransform& rbAFrame, const btTransform& rbBFrame)
 :btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA, rbB), m_rbAFrame(rbAFrame), m_rbBFrame(rbBFrame),
 m_angularOnly(false),
 m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
 init();
}

btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, const btTransform& rbAFrame)
 :btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA), m_rbAFrame(rbAFrame),
 m_angularOnly(false),
 m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
 m_rbBFrame = m_rbAFrame;
 m_rbBFrame.setOrigin(btVector3(0., 0., 0.));
 init();
}


void btConeTwistConstraint::init()
{
 m_angularOnly = false;
 m_solveTwistLimit = false;
 m_solveSwingLimit = false;
 m_bMotorEnabled = false;
 m_maxMotorImpulse = btScalar(-1);

 setLimit(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
 m_damping = btScalar(0.01);
 m_fixThresh = CONETWIST_DEF_FIX_THRESH;
 m_flags = 0;
 m_linCFM = btScalar(0.f);
 m_linERP = btScalar(0.7f);
 m_angCFM = btScalar(0.f);
}


void btConeTwistConstraint::getInfo1(btConstraintInfo1* info)
{
 if (m_useSolveConstraintObsolete)
 {
  info->m_numConstraintRows = 0;
  info->nub = 0;
 }
 else
 {
  info->m_numConstraintRows = 3;
  info->nub = 3;
  calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
  if (m_solveSwingLimit)
  {
   info->m_numConstraintRows++;
   info->nub--;
   if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
   {
    info->m_numConstraintRows++;
    info->nub--;
   }
  }
  if (m_solveTwistLimit)
  {
   info->m_numConstraintRows++;
   info->nub--;
  }
 }
}

void btConeTwistConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
 //always reserve 6 rows: object transform is not available on SPU
 info->m_numConstraintRows = 6;
 info->nub = 0;

}


void btConeTwistConstraint::getInfo2(btConstraintInfo2* info)
{
 getInfo2NonVirtual(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
}

void btConeTwistConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
 calcAngleInfo2(transA, transB, invInertiaWorldA, invInertiaWorldB);

 btAssert(!m_useSolveConstraintObsolete);
 // set jacobian
 info->m_J1linearAxis[0] = 1;
 info->m_J1linearAxis[info->rowskip + 1] = 1;
 info->m_J1linearAxis[2 * info->rowskip + 2] = 1;
 btVector3 a1 = transA.getBasis() * m_rbAFrame.getOrigin();
 {
  btVector3* angular0 = (btVector3*)(info->m_J1angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J1angularAxis + info->rowskip);
  btVector3* angular2 = (btVector3*)(info->m_J1angularAxis + 2 * info->rowskip);
  btVector3 a1neg = -a1;
  a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }
 info->m_J2linearAxis[0] = -1;
 info->m_J2linearAxis[info->rowskip + 1] = -1;
 info->m_J2linearAxis[2 * info->rowskip + 2] = -1;
 btVector3 a2 = transB.getBasis() * m_rbBFrame.getOrigin();
 {
  btVector3* angular0 = (btVector3*)(info->m_J2angularAxis);
  btVector3* angular1 = (btVector3*)(info->m_J2angularAxis + info->rowskip);
  btVector3* angular2 = (btVector3*)(info->m_J2angularAxis + 2 * info->rowskip);
  a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
 }
 // set right hand side
 btScalar linERP = (m_flags & BT_CONETWIST_FLAGS_LIN_ERP) ? m_linERP : info->erp;
 btScalar k = info->fps * linERP;
 int j;
 for (j = 0; j<3; j++)
 {
  info->m_constraintError[j*info->rowskip] = k * (a2[j] + transB.getOrigin()[j] - a1[j] - transA.getOrigin()[j]);
  info->m_lowerLimit[j*info->rowskip] = -SIMD_INFINITY;
  info->m_upperLimit[j*info->rowskip] = SIMD_INFINITY;
  if (m_flags & BT_CONETWIST_FLAGS_LIN_CFM)
  {
   info->cfm[j*info->rowskip] = m_linCFM;
  }
 }
 int row = 3;
 int srow = row * info->rowskip;
 btVector3 ax1;
 // angular limits
 if (m_solveSwingLimit)
 {
  btScalar *J1 = info->m_J1angularAxis;
  btScalar *J2 = info->m_J2angularAxis;
  if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
  {
   btTransform trA = transA*m_rbAFrame;
   btVector3 p = trA.getBasis().getColumn(1);
   btVector3 q = trA.getBasis().getColumn(2);
   int srow1 = srow + info->rowskip;
   J1[srow + 0] = p[0];
   J1[srow + 1] = p[1];
   J1[srow + 2] = p[2];
   J1[srow1 + 0] = q[0];
   J1[srow1 + 1] = q[1];
   J1[srow1 + 2] = q[2];
   J2[srow + 0] = -p[0];
   J2[srow + 1] = -p[1];
   J2[srow + 2] = -p[2];
   J2[srow1 + 0] = -q[0];
   J2[srow1 + 1] = -q[1];
   J2[srow1 + 2] = -q[2];
   btScalar fact = info->fps * m_relaxationFactor;
   info->m_constraintError[srow] = fact * m_swingAxis.dot(p);
   info->m_constraintError[srow1] = fact * m_swingAxis.dot(q);
   info->m_lowerLimit[srow] = -SIMD_INFINITY;
   info->m_upperLimit[srow] = SIMD_INFINITY;
   info->m_lowerLimit[srow1] = -SIMD_INFINITY;
   info->m_upperLimit[srow1] = SIMD_INFINITY;
   srow = srow1 + info->rowskip;
  }
  else
  {
   ax1 = m_swingAxis * m_relaxationFactor * m_relaxationFactor;
   J1[srow + 0] = ax1[0];
   J1[srow + 1] = ax1[1];
   J1[srow + 2] = ax1[2];
   J2[srow + 0] = -ax1[0];
   J2[srow + 1] = -ax1[1];
   J2[srow + 2] = -ax1[2];
   btScalar k = info->fps * m_biasFactor;

   info->m_constraintError[srow] = k * m_swingCorrection;
   if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
   {
    info->cfm[srow] = m_angCFM;
   }
   // m_swingCorrection is always positive or 0
   info->m_lowerLimit[srow] = 0;
   info->m_upperLimit[srow] = (m_bMotorEnabled && m_maxMotorImpulse >= 0.0f) ? m_maxMotorImpulse : SIMD_INFINITY;
   srow += info->rowskip;
  }
 }
 if (m_solveTwistLimit)
 {
  ax1 = m_twistAxis * m_relaxationFactor * m_relaxationFactor;
  btScalar *J1 = info->m_J1angularAxis;
  btScalar *J2 = info->m_J2angularAxis;
  J1[srow + 0] = ax1[0];
  J1[srow + 1] = ax1[1];
  J1[srow + 2] = ax1[2];
  J2[srow + 0] = -ax1[0];
  J2[srow + 1] = -ax1[1];
  J2[srow + 2] = -ax1[2];
  btScalar k = info->fps * m_biasFactor;
  info->m_constraintError[srow] = k * m_twistCorrection;
  if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
  {
   info->cfm[srow] = m_angCFM;
  }
  if (m_twistSpan > 0.0f)
  {

   if (m_twistCorrection > 0.0f)
   {
    info->m_lowerLimit[srow] = 0;
    info->m_upperLimit[srow] = SIMD_INFINITY;
   }
   else
   {
    info->m_lowerLimit[srow] = -SIMD_INFINITY;
    info->m_upperLimit[srow] = 0;
   }
  }
  else
  {
   info->m_lowerLimit[srow] = -SIMD_INFINITY;
   info->m_upperLimit[srow] = SIMD_INFINITY;
  }
  srow += info->rowskip;
 }
}



void	btConeTwistConstraint::buildJacobian()
{
 if (m_useSolveConstraintObsolete)
 {
  m_appliedImpulse = btScalar(0.);
  m_accTwistLimitImpulse = btScalar(0.);
  m_accSwingLimitImpulse = btScalar(0.);
  m_accMotorImpulse = btVector3(0., 0., 0.);

  if (!m_angularOnly)
  {
   btVector3 pivotAInW = m_rbA.getCenterOfMassTransform()*m_rbAFrame.getOrigin();
   btVector3 pivotBInW = m_rbB.getCenterOfMassTransform()*m_rbBFrame.getOrigin();
   btVector3 relPos = pivotBInW - pivotAInW;

   btVector3 normal[3];
   if (relPos.length2() > SIMD_EPSILON)
   {
    normal[0] = relPos.normalized();
   }
   else
   {
    normal[0].setValue(btScalar(1.0), 0, 0);
   }

   btPlaneSpace1(normal[0], normal[1], normal[2]);

   for (int i = 0; i<3; i++)
   {
    new (&m_jac[i]) btJacobianEntry(
     m_rbA.getCenterOfMassTransform().getBasis().transpose(),
     m_rbB.getCenterOfMassTransform().getBasis().transpose(),
     pivotAInW - m_rbA.getCenterOfMassPosition(),
     pivotBInW - m_rbB.getCenterOfMassPosition(),
     normal[i],
     m_rbA.getInvInertiaDiagLocal(),
     m_rbA.getInvMass(),
     m_rbB.getInvInertiaDiagLocal(),
     m_rbB.getInvMass());
   }
  }

  calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
 }
}



void	btConeTwistConstraint::solveConstraintObsolete(btSolverBody& bodyA, btSolverBody& bodyB, btScalar	timeStep)
{
#ifndef __SPU__
 if (m_useSolveConstraintObsolete)
 {
  btVector3 pivotAInW = m_rbA.getCenterOfMassTransform()*m_rbAFrame.getOrigin();
  btVector3 pivotBInW = m_rbB.getCenterOfMassTransform()*m_rbBFrame.getOrigin();

  btScalar tau = btScalar(0.3);

  //linear part
  if (!m_angularOnly)
  {
   btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
   btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

   btVector3 vel1;
   bodyA.internalGetVelocityInLocalPointObsolete(rel_pos1, vel1);
   btVector3 vel2;
   bodyB.internalGetVelocityInLocalPointObsolete(rel_pos2, vel2);
   btVector3 vel = vel1 - vel2;

   for (int i = 0; i<3; i++)
   {
    const btVector3& normal = m_jac[i].m_linearJointAxis;
    btScalar jacDiagABInv = btScalar(1.) / m_jac[i].getDiagonal();

    btScalar rel_vel;
    rel_vel = normal.dot(vel);
    //positional error (zeroth order error)
    btScalar depth = -(pivotAInW - pivotBInW).dot(normal); //this is the error projected on the normal
    btScalar impulse = depth*tau / timeStep  * jacDiagABInv - rel_vel * jacDiagABInv;
    m_appliedImpulse += impulse;

    btVector3 ftorqueAxis1 = rel_pos1.cross(normal);
    btVector3 ftorqueAxis2 = rel_pos2.cross(normal);
    bodyA.internalApplyImpulse(normal*m_rbA.getInvMass(), m_rbA.getInvInertiaTensorWorld()*ftorqueAxis1, impulse);
    bodyB.internalApplyImpulse(normal*m_rbB.getInvMass(), m_rbB.getInvInertiaTensorWorld()*ftorqueAxis2, -impulse);

   }
  }

  // apply motor
  if (m_bMotorEnabled)
  {
   // compute current and predicted transforms
   btTransform trACur = m_rbA.getCenterOfMassTransform();
   btTransform trBCur = m_rbB.getCenterOfMassTransform();
   btVector3 omegaA; bodyA.internalGetAngularVelocity(omegaA);
   btVector3 omegaB; bodyB.internalGetAngularVelocity(omegaB);
   btTransform trAPred; trAPred.setIdentity();
   btVector3 zerovec(0, 0, 0);
   btTransformUtil::integrateTransform(
    trACur, zerovec, omegaA, timeStep, trAPred);
   btTransform trBPred; trBPred.setIdentity();
   btTransformUtil::integrateTransform(
    trBCur, zerovec, omegaB, timeStep, trBPred);

   // compute desired transforms in world
   btTransform trPose(m_qTarget);
   btTransform trABDes = m_rbBFrame * trPose * m_rbAFrame.inverse();
   btTransform trADes = trBPred * trABDes;
   btTransform trBDes = trAPred * trABDes.inverse();

   // compute desired omegas in world
   btVector3 omegaADes, omegaBDes;

   btTransformUtil::calculateVelocity(trACur, trADes, timeStep, zerovec, omegaADes);
   btTransformUtil::calculateVelocity(trBCur, trBDes, timeStep, zerovec, omegaBDes);

   // compute delta omegas
   btVector3 dOmegaA = omegaADes - omegaA;
   btVector3 dOmegaB = omegaBDes - omegaB;

   // compute weighted avg axis of dOmega (weighting based on inertias)
   btVector3 axisA, axisB;
   btScalar kAxisAInv = 0, kAxisBInv = 0;

   if (dOmegaA.length2() > SIMD_EPSILON)
   {
    axisA = dOmegaA.normalized();
    kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(axisA);
   }

   if (dOmegaB.length2() > SIMD_EPSILON)
   {
    axisB = dOmegaB.normalized();
    kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(axisB);
   }

   btVector3 avgAxis = kAxisAInv * axisA + kAxisBInv * axisB;

   static bool bDoTorque = true;
   if (bDoTorque && avgAxis.length2() > SIMD_EPSILON)
   {
    avgAxis.normalize();
    kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(avgAxis);
    kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(avgAxis);
    btScalar kInvCombined = kAxisAInv + kAxisBInv;

    btVector3 impulse = (kAxisAInv * dOmegaA - kAxisBInv * dOmegaB) /
     (kInvCombined * kInvCombined);

    if (m_maxMotorImpulse >= 0)
    {
     btScalar fMaxImpulse = m_maxMotorImpulse;
     if (m_bNormalizedMotorStrength)
      fMaxImpulse = fMaxImpulse / kAxisAInv;

     btVector3 newUnclampedAccImpulse = m_accMotorImpulse + impulse;
     btScalar  newUnclampedMag = newUnclampedAccImpulse.length();
     if (newUnclampedMag > fMaxImpulse)
     {
      newUnclampedAccImpulse.normalize();
      newUnclampedAccImpulse *= fMaxImpulse;
      impulse = newUnclampedAccImpulse - m_accMotorImpulse;
     }
     m_accMotorImpulse += impulse;
    }

    btScalar  impulseMag = impulse.length();
    btVector3 impulseAxis = impulse / impulseMag;

    bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld()*impulseAxis, impulseMag);
    bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld()*impulseAxis, -impulseMag);

   }
  }
  else if (m_damping > SIMD_EPSILON) // no motor: do a little damping
  {
   btVector3 angVelA; bodyA.internalGetAngularVelocity(angVelA);
   btVector3 angVelB; bodyB.internalGetAngularVelocity(angVelB);
   btVector3 relVel = angVelB - angVelA;
   if (relVel.length2() > SIMD_EPSILON)
   {
    btVector3 relVelAxis = relVel.normalized();
    btScalar m_kDamping = btScalar(1.) /
     (getRigidBodyA().computeAngularImpulseDenominator(relVelAxis) +
      getRigidBodyB().computeAngularImpulseDenominator(relVelAxis));
    btVector3 impulse = m_damping * m_kDamping * relVel;

    btScalar  impulseMag = impulse.length();
    btVector3 impulseAxis = impulse / impulseMag;
    bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld()*impulseAxis, impulseMag);
    bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld()*impulseAxis, -impulseMag);
   }
  }

  // joint limits
  {
   ///solve angular part
   btVector3 angVelA;
   bodyA.internalGetAngularVelocity(angVelA);
   btVector3 angVelB;
   bodyB.internalGetAngularVelocity(angVelB);

   // solve swing limit
   if (m_solveSwingLimit)
   {
    btScalar amplitude = m_swingLimitRatio * m_swingCorrection*m_biasFactor / timeStep;
    btScalar relSwingVel = (angVelB - angVelA).dot(m_swingAxis);
    if (relSwingVel > 0)
     amplitude += m_swingLimitRatio * relSwingVel * m_relaxationFactor;
    btScalar impulseMag = amplitude * m_kSwing;

    // Clamp the accumulated impulse
    btScalar temp = m_accSwingLimitImpulse;
    m_accSwingLimitImpulse = btMax(m_accSwingLimitImpulse + impulseMag, btScalar(0.0));
    impulseMag = m_accSwingLimitImpulse - temp;

    btVector3 impulse = m_swingAxis * impulseMag;

    // don't let cone response affect twist
    // (this can happen since body A's twist doesn't match body B's AND we use an elliptical cone limit)
    {
     btVector3 impulseTwistCouple = impulse.dot(m_twistAxisA) * m_twistAxisA;
     btVector3 impulseNoTwistCouple = impulse - impulseTwistCouple;
     impulse = impulseNoTwistCouple;
    }

    impulseMag = impulse.length();
    btVector3 noTwistSwingAxis = impulse / impulseMag;

    bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld()*noTwistSwingAxis, impulseMag);
    bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld()*noTwistSwingAxis, -impulseMag);
   }


   // solve twist limit
   if (m_solveTwistLimit)
   {
    btScalar amplitude = m_twistLimitRatio * m_twistCorrection*m_biasFactor / timeStep;
    btScalar relTwistVel = (angVelB - angVelA).dot(m_twistAxis);
    if (relTwistVel > 0) // only damp when moving towards limit (m_twistAxis flipping is important)
     amplitude += m_twistLimitRatio * relTwistVel * m_relaxationFactor;
    btScalar impulseMag = amplitude * m_kTwist;

    // Clamp the accumulated impulse
    btScalar temp = m_accTwistLimitImpulse;
    m_accTwistLimitImpulse = btMax(m_accTwistLimitImpulse + impulseMag, btScalar(0.0));
    impulseMag = m_accTwistLimitImpulse - temp;

    //		btVector3 impulse = m_twistAxis * impulseMag;

    bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld()*m_twistAxis, impulseMag);
    bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld()*m_twistAxis, -impulseMag);
   }
  }
 }
#else
 btAssert(0);
#endif //__SPU__
}




void	btConeTwistConstraint::updateRHS(btScalar	timeStep)
{
 (void)timeStep;

}


#ifndef __SPU__
void btConeTwistConstraint::calcAngleInfo()
{
 m_swingCorrection = btScalar(0.);
 m_twistLimitSign = btScalar(0.);
 m_solveTwistLimit = false;
 m_solveSwingLimit = false;

 btVector3 b1Axis1(0, 0, 0), b1Axis2(0, 0, 0), b1Axis3(0, 0, 0);
 btVector3 b2Axis1(0, 0, 0), b2Axis2(0, 0, 0);

 b1Axis1 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(0);
 b2Axis1 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(0);

 btScalar swing1 = btScalar(0.), swing2 = btScalar(0.);

 btScalar swx = btScalar(0.), swy = btScalar(0.);
 btScalar thresh = btScalar(10.);
 btScalar fact;

 // Get Frame into world space
 if (m_swingSpan1 >= btScalar(0.05f))
 {
  b1Axis2 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(1);
  swx = b2Axis1.dot(b1Axis1);
  swy = b2Axis1.dot(b1Axis2);
  swing1 = btAtan2Fast(swy, swx);
  fact = (swy*swy + swx*swx) * thresh * thresh;
  fact = fact / (fact + btScalar(1.0));
  swing1 *= fact;
 }

 if (m_swingSpan2 >= btScalar(0.05f))
 {
  b1Axis3 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(2);
  swx = b2Axis1.dot(b1Axis1);
  swy = b2Axis1.dot(b1Axis3);
  swing2 = btAtan2Fast(swy, swx);
  fact = (swy*swy + swx*swx) * thresh * thresh;
  fact = fact / (fact + btScalar(1.0));
  swing2 *= fact;
 }

 btScalar RMaxAngle1Sq = 1.0f / (m_swingSpan1*m_swingSpan1);
 btScalar RMaxAngle2Sq = 1.0f / (m_swingSpan2*m_swingSpan2);
 btScalar EllipseAngle = btFabs(swing1*swing1)* RMaxAngle1Sq + btFabs(swing2*swing2) * RMaxAngle2Sq;

 if (EllipseAngle > 1.0f)
 {
  m_swingCorrection = EllipseAngle - 1.0f;
  m_solveSwingLimit = true;
  // Calculate necessary axis & factors
  m_swingAxis = b2Axis1.cross(b1Axis2* b2Axis1.dot(b1Axis2) + b1Axis3* b2Axis1.dot(b1Axis3));
  m_swingAxis.normalize();
  btScalar swingAxisSign = (b2Axis1.dot(b1Axis1) >= 0.0f) ? 1.0f : -1.0f;
  m_swingAxis *= swingAxisSign;
 }

 // Twist limits
 if (m_twistSpan >= btScalar(0.))
 {
  btVector3 b2Axis2 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(1);
  btQuaternion rotationArc = shortestArcQuat(b2Axis1, b1Axis1);
  btVector3 TwistRef = quatRotate(rotationArc, b2Axis2);
  btScalar twist = btAtan2Fast(TwistRef.dot(b1Axis3), TwistRef.dot(b1Axis2));
  m_twistAngle = twist;

  //		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? m_limitSoftness : btScalar(0.);
  btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? btScalar(1.0f) : btScalar(0.);
  if (twist <= -m_twistSpan*lockedFreeFactor)
  {
   m_twistCorrection = -(twist + m_twistSpan);
   m_solveTwistLimit = true;
   m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
   m_twistAxis.normalize();
   m_twistAxis *= -1.0f;
  }
  else if (twist >  m_twistSpan*lockedFreeFactor)
  {
   m_twistCorrection = (twist - m_twistSpan);
   m_solveTwistLimit = true;
   m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
   m_twistAxis.normalize();
  }
 }
}
#endif //__SPU__

static btVector3 vTwist(1, 0, 0); // twist axis in constraint's space



void btConeTwistConstraint::calcAngleInfo2(const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
 m_swingCorrection = btScalar(0.);
 m_twistLimitSign = btScalar(0.);
 m_solveTwistLimit = false;
 m_solveSwingLimit = false;
 // compute rotation of A wrt B (in constraint space)
 if (m_bMotorEnabled && (!m_useSolveConstraintObsolete))
 {	// it is assumed that setMotorTarget() was alredy called 
   // and motor target m_qTarget is within constraint limits
   // TODO : split rotation to pure swing and pure twist
   // compute desired transforms in world
  btTransform trPose(m_qTarget);
  btTransform trA = transA * m_rbAFrame;
  btTransform trB = transB * m_rbBFrame;
  btTransform trDeltaAB = trB * trPose * trA.inverse();
  btQuaternion qDeltaAB = trDeltaAB.getRotation();
  btVector3 swingAxis = btVector3(qDeltaAB.x(), qDeltaAB.y(), qDeltaAB.z());
  btScalar swingAxisLen2 = swingAxis.length2();
  if (btFuzzyZero(swingAxisLen2))
  {
   return;
  }
  m_swingAxis = swingAxis;
  m_swingAxis.normalize();
  m_swingCorrection = qDeltaAB.getAngle();
  if (!btFuzzyZero(m_swingCorrection))
  {
   m_solveSwingLimit = true;
  }
  return;
 }


 {
  // compute rotation of A wrt B (in constraint space)
  btQuaternion qA = transA.getRotation() * m_rbAFrame.getRotation();
  btQuaternion qB = transB.getRotation() * m_rbBFrame.getRotation();
  btQuaternion qAB = qB.inverse() * qA;
  // split rotation into cone and twist
  // (all this is done from B's perspective. Maybe I should be averaging axes...)
  btVector3 vConeNoTwist = quatRotate(qAB, vTwist); vConeNoTwist.normalize();
  btQuaternion qABCone = shortestArcQuat(vTwist, vConeNoTwist); qABCone.normalize();
  btQuaternion qABTwist = qABCone.inverse() * qAB; qABTwist.normalize();

  if (m_swingSpan1 >= m_fixThresh && m_swingSpan2 >= m_fixThresh)
  {
   btScalar swingAngle, swingLimit = 0; btVector3 swingAxis;
   computeConeLimitInfo(qABCone, swingAngle, swingAxis, swingLimit);

   if (swingAngle > swingLimit * m_limitSoftness)
   {
    m_solveSwingLimit = true;

    // compute limit ratio: 0->1, where
    // 0 == beginning of soft limit
    // 1 == hard/real limit
    m_swingLimitRatio = 1.f;
    if (swingAngle < swingLimit && m_limitSoftness < 1.f - SIMD_EPSILON)
    {
     m_swingLimitRatio = (swingAngle - swingLimit * m_limitSoftness) /
      (swingLimit - swingLimit * m_limitSoftness);
    }

    // swing correction tries to get back to soft limit
    m_swingCorrection = swingAngle - (swingLimit * m_limitSoftness);

    // adjustment of swing axis (based on ellipse normal)
    adjustSwingAxisToUseEllipseNormal(swingAxis);

    // Calculate necessary axis & factors		
    m_swingAxis = quatRotate(qB, -swingAxis);

    m_twistAxisA.setValue(0, 0, 0);

    m_kSwing = btScalar(1.) /
     (computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldA) +
      computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldB));
   }
  }
  else
  {
   // you haven't set any limits;
   // or you're trying to set at least one of the swing limits too small. (if so, do you really want a conetwist constraint?)
   // anyway, we have either hinge or fixed joint
   btVector3 ivA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(0);
   btVector3 jvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(1);
   btVector3 kvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(2);
   btVector3 ivB = transB.getBasis() * m_rbBFrame.getBasis().getColumn(0);
   btVector3 target;
   btScalar x = ivB.dot(ivA);
   btScalar y = ivB.dot(jvA);
   btScalar z = ivB.dot(kvA);
   if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
   { // fixed. We'll need to add one more row to constraint
    if ((!btFuzzyZero(y)) || (!(btFuzzyZero(z))))
    {
     m_solveSwingLimit = true;
     m_swingAxis = -ivB.cross(ivA);
    }
   }
   else
   {
    if (m_swingSpan1 < m_fixThresh)
    { // hinge around Y axis
      //					if(!(btFuzzyZero(y)))
     if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(z))))
     {
      m_solveSwingLimit = true;
      if (m_swingSpan2 >= m_fixThresh)
      {
       y = btScalar(0.f);
       btScalar span2 = btAtan2(z, x);
       if (span2 > m_swingSpan2)
       {
        x = btCos(m_swingSpan2);
        z = btSin(m_swingSpan2);
       }
       else if (span2 < -m_swingSpan2)
       {
        x = btCos(m_swingSpan2);
        z = -btSin(m_swingSpan2);
       }
      }
     }
    }
    else
    { // hinge around Z axis
      //					if(!btFuzzyZero(z))
     if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(y))))
     {
      m_solveSwingLimit = true;
      if (m_swingSpan1 >= m_fixThresh)
      {
       z = btScalar(0.f);
       btScalar span1 = btAtan2(y, x);
       if (span1 > m_swingSpan1)
       {
        x = btCos(m_swingSpan1);
        y = btSin(m_swingSpan1);
       }
       else if (span1 < -m_swingSpan1)
       {
        x = btCos(m_swingSpan1);
        y = -btSin(m_swingSpan1);
       }
      }
     }
    }
    target[0] = x * ivA[0] + y * jvA[0] + z * kvA[0];
    target[1] = x * ivA[1] + y * jvA[1] + z * kvA[1];
    target[2] = x * ivA[2] + y * jvA[2] + z * kvA[2];
    target.normalize();
    m_swingAxis = -ivB.cross(target);
    m_swingCorrection = m_swingAxis.length();

    if (!btFuzzyZero(m_swingCorrection))
     m_swingAxis.normalize();
   }
  }

  if (m_twistSpan >= btScalar(0.f))
  {
   btVector3 twistAxis;
   computeTwistLimitInfo(qABTwist, m_twistAngle, twistAxis);

   if (m_twistAngle > m_twistSpan*m_limitSoftness)
   {
    m_solveTwistLimit = true;

    m_twistLimitRatio = 1.f;
    if (m_twistAngle < m_twistSpan && m_limitSoftness < 1.f - SIMD_EPSILON)
    {
     m_twistLimitRatio = (m_twistAngle - m_twistSpan * m_limitSoftness) /
      (m_twistSpan - m_twistSpan * m_limitSoftness);
    }

    // twist correction tries to get back to soft limit
    m_twistCorrection = m_twistAngle - (m_twistSpan * m_limitSoftness);

    m_twistAxis = quatRotate(qB, -twistAxis);

    m_kTwist = btScalar(1.) /
     (computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldA) +
      computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldB));
   }

   if (m_solveSwingLimit)
    m_twistAxisA = quatRotate(qA, -twistAxis);
  }
  else
  {
   m_twistAngle = btScalar(0.f);
  }
 }
}



// given a cone rotation in constraint space, (pre: twist must already be removed)
// this method computes its corresponding swing angle and axis.
// more interestingly, it computes the cone/swing limit (angle) for this cone "pose".
void btConeTwistConstraint::computeConeLimitInfo(const btQuaternion& qCone,
 btScalar& swingAngle, // out
 btVector3& vSwingAxis, // out
 btScalar& swingLimit) // out
{
 swingAngle = qCone.getAngle();
 if (swingAngle > SIMD_EPSILON)
 {
  vSwingAxis = btVector3(qCone.x(), qCone.y(), qCone.z());
  vSwingAxis.normalize();
#if 0
  // non-zero twist?! this should never happen.
  btAssert(fabs(vSwingAxis.x()) <= SIMD_EPSILON));
#endif

  // Compute limit for given swing. tricky:
  // Given a swing axis, we're looking for the intersection with the bounding cone ellipse.
  // (Since we're dealing with angles, this ellipse is embedded on the surface of a sphere.)

  // For starters, compute the direction from center to surface of ellipse.
  // This is just the perpendicular (ie. rotate 2D vector by PI/2) of the swing axis.
  // (vSwingAxis is the cone rotation (in z,y); change vars and rotate to (x,y) coords.)
  btScalar xEllipse = vSwingAxis.y();
  btScalar yEllipse = -vSwingAxis.z();

  // Now, we use the slope of the vector (using x/yEllipse) and find the length
  // of the line that intersects the ellipse:
  //  x^2   y^2
  //  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
  //  a^2   b^2
  // Do the math and it should be clear.

  swingLimit = m_swingSpan1; // if xEllipse == 0, we have a pure vSwingAxis.z rotation: just use swingspan1
  if (fabs(xEllipse) > SIMD_EPSILON)
  {
   btScalar surfaceSlope2 = (yEllipse*yEllipse) / (xEllipse*xEllipse);
   btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
   norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
   btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
   swingLimit = sqrt(swingLimit2);
  }

  // test!
  /*swingLimit = m_swingSpan2;
  if (fabs(vSwingAxis.z()) > SIMD_EPSILON)
  {
  btScalar mag_2 = m_swingSpan1*m_swingSpan1 + m_swingSpan2*m_swingSpan2;
  btScalar sinphi = m_swingSpan2 / sqrt(mag_2);
  btScalar phi = asin(sinphi);
  btScalar theta = atan2(fabs(vSwingAxis.y()),fabs(vSwingAxis.z()));
  btScalar alpha = 3.14159f - theta - phi;
  btScalar sinalpha = sin(alpha);
  swingLimit = m_swingSpan1 * sinphi/sinalpha;
  }*/
 }
 else if (swingAngle < 0)
 {
  // this should never happen!
#if 0
  btAssert(0);
#endif
 }
}

btVector3 btConeTwistConstraint::GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const
{
 // compute x/y in ellipse using cone angle (0 -> 2*PI along surface of cone)
 btScalar xEllipse = btCos(fAngleInRadians);
 btScalar yEllipse = btSin(fAngleInRadians);

 // Use the slope of the vector (using x/yEllipse) and find the length
 // of the line that intersects the ellipse:
 //  x^2   y^2
 //  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
 //  a^2   b^2
 // Do the math and it should be clear.

 btScalar swingLimit = m_swingSpan1; // if xEllipse == 0, just use axis b (1)
 if (fabs(xEllipse) > SIMD_EPSILON)
 {
  btScalar surfaceSlope2 = (yEllipse*yEllipse) / (xEllipse*xEllipse);
  btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
  norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
  btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
  swingLimit = sqrt(swingLimit2);
 }

 // convert into point in constraint space:
 // note: twist is x-axis, swing 1 and 2 are along the z and y axes respectively
 btVector3 vSwingAxis(0, xEllipse, -yEllipse);
 btQuaternion qSwing(vSwingAxis, swingLimit);
 btVector3 vPointInConstraintSpace(fLength, 0, 0);
 return quatRotate(qSwing, vPointInConstraintSpace);
}

// given a twist rotation in constraint space, (pre: cone must already be removed)
// this method computes its corresponding angle and axis.
void btConeTwistConstraint::computeTwistLimitInfo(const btQuaternion& qTwist,
 btScalar& twistAngle, // out
 btVector3& vTwistAxis) // out
{
 btQuaternion qMinTwist = qTwist;
 twistAngle = qTwist.getAngle();

 if (twistAngle > SIMD_PI) // long way around. flip quat and recalculate.
 {
  qMinTwist = -(qTwist);
  twistAngle = qMinTwist.getAngle();
 }
 if (twistAngle < 0)
 {
  // this should never happen
#if 0
  btAssert(0);
#endif
 }

 vTwistAxis = btVector3(qMinTwist.x(), qMinTwist.y(), qMinTwist.z());
 if (twistAngle > SIMD_EPSILON)
  vTwistAxis.normalize();
}


void btConeTwistConstraint::adjustSwingAxisToUseEllipseNormal(btVector3& vSwingAxis) const
{
 // the swing axis is computed as the "twist-free" cone rotation,
 // but the cone limit is not circular, but elliptical (if swingspan1 != swingspan2).
 // so, if we're outside the limits, the closest way back inside the cone isn't 
 // along the vector back to the center. better (and more stable) to use the ellipse normal.

 // convert swing axis to direction from center to surface of ellipse
 // (ie. rotate 2D vector by PI/2)
 btScalar y = -vSwingAxis.z();
 btScalar z = vSwingAxis.y();

 // do the math...
 if (fabs(z) > SIMD_EPSILON) // avoid division by 0. and we don't need an update if z == 0.
 {
  // compute gradient/normal of ellipse surface at current "point"
  btScalar grad = y / z;
  grad *= m_swingSpan2 / m_swingSpan1;

  // adjust y/z to represent normal at point (instead of vector to point)
  if (y > 0)
   y = fabs(grad * z);
  else
   y = -fabs(grad * z);

  // convert ellipse direction back to swing axis
  vSwingAxis.setZ(-y);
  vSwingAxis.setY(z);
  vSwingAxis.normalize();
 }
}



void btConeTwistConstraint::setMotorTarget(const btQuaternion &q)
{
 //btTransform trACur = m_rbA.getCenterOfMassTransform();
 //btTransform trBCur = m_rbB.getCenterOfMassTransform();
 //	btTransform trABCur = trBCur.inverse() * trACur;
 //	btQuaternion qABCur = trABCur.getRotation();
 //	btTransform trConstraintCur = (trBCur * m_rbBFrame).inverse() * (trACur * m_rbAFrame);
 //btQuaternion qConstraintCur = trConstraintCur.getRotation();

 btQuaternion qConstraint = m_rbBFrame.getRotation().inverse() * q * m_rbAFrame.getRotation();
 setMotorTargetInConstraintSpace(qConstraint);
}


void btConeTwistConstraint::setMotorTargetInConstraintSpace(const btQuaternion &q)
{
 m_qTarget = q;

 // clamp motor target to within limits
 {
  btScalar softness = 1.f;//m_limitSoftness;

                          // split into twist and cone
  btVector3 vTwisted = quatRotate(m_qTarget, vTwist);
  btQuaternion qTargetCone = shortestArcQuat(vTwist, vTwisted); qTargetCone.normalize();
  btQuaternion qTargetTwist = qTargetCone.inverse() * m_qTarget; qTargetTwist.normalize();

  // clamp cone
  if (m_swingSpan1 >= btScalar(0.05f) && m_swingSpan2 >= btScalar(0.05f))
  {
   btScalar swingAngle, swingLimit; btVector3 swingAxis;
   computeConeLimitInfo(qTargetCone, swingAngle, swingAxis, swingLimit);

   if (fabs(swingAngle) > SIMD_EPSILON)
   {
    if (swingAngle > swingLimit*softness)
     swingAngle = swingLimit*softness;
    else if (swingAngle < -swingLimit*softness)
     swingAngle = -swingLimit*softness;
    qTargetCone = btQuaternion(swingAxis, swingAngle);
   }
  }

  // clamp twist
  if (m_twistSpan >= btScalar(0.05f))
  {
   btScalar twistAngle; btVector3 twistAxis;
   computeTwistLimitInfo(qTargetTwist, twistAngle, twistAxis);

   if (fabs(twistAngle) > SIMD_EPSILON)
   {
    // eddy todo: limitSoftness used here???
    if (twistAngle > m_twistSpan*softness)
     twistAngle = m_twistSpan*softness;
    else if (twistAngle < -m_twistSpan*softness)
     twistAngle = -m_twistSpan*softness;
    qTargetTwist = btQuaternion(twistAxis, twistAngle);
   }
  }

  m_qTarget = qTargetCone * qTargetTwist;
 }
}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
///If no axis is provided, it uses the default axis for this constraint.
void btConeTwistConstraint::setParam(int num, btScalar value, int axis)
{
 switch (num)
 {
 case BT_CONSTRAINT_ERP:
 case BT_CONSTRAINT_STOP_ERP:
  if ((axis >= 0) && (axis < 3))
  {
   m_linERP = value;
   m_flags |= BT_CONETWIST_FLAGS_LIN_ERP;
  }
  else
  {
   m_biasFactor = value;
  }
  break;
 case BT_CONSTRAINT_CFM:
 case BT_CONSTRAINT_STOP_CFM:
  if ((axis >= 0) && (axis < 3))
  {
   m_linCFM = value;
   m_flags |= BT_CONETWIST_FLAGS_LIN_CFM;
  }
  else
  {
   m_angCFM = value;
   m_flags |= BT_CONETWIST_FLAGS_ANG_CFM;
  }
  break;
 default:
  btAssertConstrParams(0);
  break;
 }
}

///return the local value of parameter
btScalar btConeTwistConstraint::getParam(int num, int axis) const
{
 btScalar retVal = 0;
 switch (num)
 {
 case BT_CONSTRAINT_ERP:
 case BT_CONSTRAINT_STOP_ERP:
  if ((axis >= 0) && (axis < 3))
  {
   btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_ERP);
   retVal = m_linERP;
  }
  else if ((axis >= 3) && (axis < 6))
  {
   retVal = m_biasFactor;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 case BT_CONSTRAINT_CFM:
 case BT_CONSTRAINT_STOP_CFM:
  if ((axis >= 0) && (axis < 3))
  {
   btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_CFM);
   retVal = m_linCFM;
  }
  else if ((axis >= 3) && (axis < 6))
  {
   btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_ANG_CFM);
   retVal = m_angCFM;
  }
  else
  {
   btAssertConstrParams(0);
  }
  break;
 default:
  btAssertConstrParams(0);
 }
 return retVal;
}


void btConeTwistConstraint::setFrames(const btTransform & frameA, const btTransform & frameB)
{
 m_rbAFrame = frameA;
 m_rbBFrame = frameB;
 buildJacobian();
 //calculateTransforms();
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "LinearMath/btMinMax.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"



btContactConstraint::btContactConstraint(btPersistentManifold* contactManifold, btRigidBody& rbA, btRigidBody& rbB)
 :btTypedConstraint(CONTACT_CONSTRAINT_TYPE, rbA, rbB),
 m_contactManifold(*contactManifold)
{

}

btContactConstraint::~btContactConstraint()
{

}

void	btContactConstraint::setContactManifold(btPersistentManifold* contactManifold)
{
 m_contactManifold = *contactManifold;
}

void btContactConstraint::getInfo1(btConstraintInfo1* info)
{

}

void btContactConstraint::getInfo2(btConstraintInfo2* info)
{

}

void	btContactConstraint::buildJacobian()
{

}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h"

//collision detection
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btQuickprof.h"

//rigidbody & constraints
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
#include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h"
#include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"


#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"


#include "BulletDynamics/Dynamics/btActionInterface.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btMotionState.h"

#include "LinearMath/btSerializer.h"

#if 0
btAlignedObjectArray<btVector3> debugContacts;
btAlignedObjectArray<btVector3> debugNormals;
int startHit = 2;
int firstHit = startHit;
#endif

SIMD_FORCE_INLINE	int	btGetConstraintIslandId(const btTypedConstraint* lhs)
{
 int islandId;

 const btCollisionObject& rcolObj0 = lhs->getRigidBodyA();
 const btCollisionObject& rcolObj1 = lhs->getRigidBodyB();
 islandId = rcolObj0.getIslandTag() >= 0 ? rcolObj0.getIslandTag() : rcolObj1.getIslandTag();
 return islandId;

}


class btSortConstraintOnIslandPredicate
{
public:

 bool operator() (const btTypedConstraint* lhs, const btTypedConstraint* rhs) const
 {
  int rIslandId0, lIslandId0;
  rIslandId0 = btGetConstraintIslandId(rhs);
  lIslandId0 = btGetConstraintIslandId(lhs);
  return lIslandId0 < rIslandId0;
 }
};

struct InplaceSolverIslandCallback : public btSimulationIslandManager::IslandCallback
{
 btContactSolverInfo*	m_solverInfo;
 btConstraintSolver*		m_solver;
 btTypedConstraint**		m_sortedConstraints;
 int						m_numConstraints;
 btIDebugDraw*			m_debugDrawer;
 btDispatcher*			m_dispatcher;

 btAlignedObjectArray<btCollisionObject*> m_bodies;
 btAlignedObjectArray<btPersistentManifold*> m_manifolds;
 btAlignedObjectArray<btTypedConstraint*> m_constraints;


 InplaceSolverIslandCallback(
  btConstraintSolver*	solver,
  btStackAlloc* stackAlloc,
  btDispatcher* dispatcher)
  :m_solverInfo(NULL),
  m_solver(solver),
  m_sortedConstraints(NULL),
  m_numConstraints(0),
  m_debugDrawer(NULL),
  m_dispatcher(dispatcher)
 {

 }

 InplaceSolverIslandCallback& operator=(InplaceSolverIslandCallback& other)
 {
  btAssert(0);
  (void)other;
  return *this;
 }

 SIMD_FORCE_INLINE void setup(btContactSolverInfo* solverInfo, btTypedConstraint** sortedConstraints, int	numConstraints, btIDebugDraw* debugDrawer)
 {
  btAssert(solverInfo);
  m_solverInfo = solverInfo;
  m_sortedConstraints = sortedConstraints;
  m_numConstraints = numConstraints;
  m_debugDrawer = debugDrawer;
  m_bodies.resize(0);
  m_manifolds.resize(0);
  m_constraints.resize(0);
 }


 virtual	void	processIsland(btCollisionObject** bodies, int numBodies, btPersistentManifold**	manifolds, int numManifolds, int islandId)
 {
  if (islandId<0)
  {
   ///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
   m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, &m_sortedConstraints[0], m_numConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
  }
  else
  {
   //also add all non-contact constraints/joints for this island
   btTypedConstraint** startConstraint = 0;
   int numCurConstraints = 0;
   int i;

   //find the first constraint for this island
   for (i = 0; i<m_numConstraints; i++)
   {
    if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
    {
     startConstraint = &m_sortedConstraints[i];
     break;
    }
   }
   //count the number of constraints in this island
   for (; i<m_numConstraints; i++)
   {
    if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
    {
     numCurConstraints++;
    }
   }

   if (m_solverInfo->m_minimumSolverBatchSize <= 1)
   {
    m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, startConstraint, numCurConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
   }
   else
   {

    for (i = 0; i<numBodies; i++)
     m_bodies.push_back(bodies[i]);
    for (i = 0; i<numManifolds; i++)
     m_manifolds.push_back(manifolds[i]);
    for (i = 0; i<numCurConstraints; i++)
     m_constraints.push_back(startConstraint[i]);
    if ((m_constraints.size() + m_manifolds.size())>m_solverInfo->m_minimumSolverBatchSize)
    {
     processConstraints();
    }
    else
    {
     //printf("deferred\n");
    }
   }
  }
 }
 void	processConstraints()
 {

  btCollisionObject** bodies = m_bodies.size() ? &m_bodies[0] : 0;
  btPersistentManifold** manifold = m_manifolds.size() ? &m_manifolds[0] : 0;
  btTypedConstraint** constraints = m_constraints.size() ? &m_constraints[0] : 0;

  m_solver->solveGroup(bodies, m_bodies.size(), manifold, m_manifolds.size(), constraints, m_constraints.size(), *m_solverInfo, m_debugDrawer, m_dispatcher);
  m_bodies.resize(0);
  m_manifolds.resize(0);
  m_constraints.resize(0);

 }

};



btDiscreteDynamicsWorld::btDiscreteDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration)
 :btDynamicsWorld(dispatcher, pairCache, collisionConfiguration),
 m_sortedConstraints(),
 m_solverIslandCallback(NULL),
 m_constraintSolver(constraintSolver),
 m_gravity(0, -10, 0),
 m_localTime(0),
 m_fixedTimeStep(0),
 m_synchronizeAllMotionStates(false),
 m_applySpeculativeContactRestitution(false),
 m_profileTimings(0),
 m_latencyMotionStateInterpolation(true)

{
 if (!m_constraintSolver)
 {
  void* mem = btAlignedAlloc(sizeof(btSequentialImpulseConstraintSolver), 16);
  m_constraintSolver = new (mem) btSequentialImpulseConstraintSolver;
  m_ownsConstraintSolver = true;
 }
 else
 {
  m_ownsConstraintSolver = false;
 }

 {
  void* mem = btAlignedAlloc(sizeof(btSimulationIslandManager), 16);
  m_islandManager = new (mem) btSimulationIslandManager();
 }

 m_ownsIslandManager = true;

 {
  void* mem = btAlignedAlloc(sizeof(InplaceSolverIslandCallback), 16);
  m_solverIslandCallback = new (mem) InplaceSolverIslandCallback(m_constraintSolver, 0, dispatcher);
 }
}


btDiscreteDynamicsWorld::~btDiscreteDynamicsWorld()
{
 //only delete it when we created it
 if (m_ownsIslandManager)
 {
  m_islandManager->~btSimulationIslandManager();
  btAlignedFree(m_islandManager);
 }
 if (m_solverIslandCallback)
 {
  m_solverIslandCallback->~InplaceSolverIslandCallback();
  btAlignedFree(m_solverIslandCallback);
 }
 if (m_ownsConstraintSolver)
 {

  m_constraintSolver->~btConstraintSolver();
  btAlignedFree(m_constraintSolver);
 }
}

void	btDiscreteDynamicsWorld::saveKinematicState(btScalar timeStep)
{
 ///would like to iterate over m_nonStaticRigidBodies, but unfortunately old API allows
 ///to switch status _after_ adding kinematic objects to the world
 ///fix it for Bullet 3.x release
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body && body->getActivationState() != ISLAND_SLEEPING)
  {
   if (body->isKinematicObject())
   {
    //to calculate velocities next frame
    body->saveKinematicState(timeStep);
   }
  }
 }

}

void	btDiscreteDynamicsWorld::debugDrawWorld()
{
 BT_PROFILE("debugDrawWorld");

 btCollisionWorld::debugDrawWorld();

 bool drawConstraints = false;
 if (getDebugDrawer())
 {
  int mode = getDebugDrawer()->getDebugMode();
  if (mode  & (btIDebugDraw::DBG_DrawConstraints | btIDebugDraw::DBG_DrawConstraintLimits))
  {
   drawConstraints = true;
  }
 }
 if (drawConstraints)
 {
  for (int i = getNumConstraints() - 1; i >= 0; i--)
  {
   btTypedConstraint* constraint = getConstraint(i);
   debugDrawConstraint(constraint);
  }
 }



 if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb | btIDebugDraw::DBG_DrawNormals)))
 {
  int i;

  if (getDebugDrawer() && getDebugDrawer()->getDebugMode())
  {
   for (i = 0; i<m_actions.size(); i++)
   {
    m_actions[i]->debugDraw(m_debugDrawer);
   }
  }
 }
 if (getDebugDrawer())
  getDebugDrawer()->flushLines();

}

void	btDiscreteDynamicsWorld::clearForces()
{
 ///@todo: iterate over awake simulation islands!
 for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
 {
  btRigidBody* body = m_nonStaticRigidBodies[i];
  //need to check if next line is ok
  //it might break backward compatibility (people applying forces on sleeping objects get never cleared and accumulate on wake-up
  body->clearForces();
 }
}

///apply gravity, call this once per timestep
void	btDiscreteDynamicsWorld::applyGravity()
{
 ///@todo: iterate over awake simulation islands!
 for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
 {
  btRigidBody* body = m_nonStaticRigidBodies[i];
  if (body->isActive())
  {
   body->applyGravity();
  }
 }
}


void	btDiscreteDynamicsWorld::synchronizeSingleMotionState(btRigidBody* body)
{
 btAssert(body);

 if (body->getMotionState() && !body->isStaticOrKinematicObject())
 {
  //we need to call the update at least once, even for sleeping objects
  //otherwise the 'graphics' transform never updates properly
  ///@todo: add 'dirty' flag
  //if (body->getActivationState() != ISLAND_SLEEPING)
  {
   btTransform interpolatedTransform;
   btTransformUtil::integrateTransform(body->getInterpolationWorldTransform(),
    body->getInterpolationLinearVelocity(), body->getInterpolationAngularVelocity(),
    (m_latencyMotionStateInterpolation && m_fixedTimeStep) ? m_localTime - m_fixedTimeStep : m_localTime*body->getHitFraction(),
    interpolatedTransform);
   body->getMotionState()->setWorldTransform(interpolatedTransform);
  }
 }
}


void	btDiscreteDynamicsWorld::synchronizeMotionStates()
{
 //	BT_PROFILE("synchronizeMotionStates");
 if (m_synchronizeAllMotionStates)
 {
  //iterate  over all collision objects
  for (int i = 0; i<m_collisionObjects.size(); i++)
  {
   btCollisionObject* colObj = m_collisionObjects[i];
   btRigidBody* body = btRigidBody::upcast(colObj);
   if (body)
    synchronizeSingleMotionState(body);
  }
 }
 else
 {
  //iterate over all active rigid bodies
  for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
  {
   btRigidBody* body = m_nonStaticRigidBodies[i];
   if (body->isActive())
    synchronizeSingleMotionState(body);
  }
 }
}


int	btDiscreteDynamicsWorld::stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep)
{
 startProfiling(timeStep);


 int numSimulationSubSteps = 0;

 if (maxSubSteps)
 {
  //fixed timestep with interpolation
  m_fixedTimeStep = fixedTimeStep;
  m_localTime += timeStep;
  if (m_localTime >= fixedTimeStep)
  {
   numSimulationSubSteps = int(m_localTime / fixedTimeStep);
   m_localTime -= numSimulationSubSteps * fixedTimeStep;
  }
 }
 else
 {
  //variable timestep
  fixedTimeStep = timeStep;
  m_localTime = m_latencyMotionStateInterpolation ? 0 : timeStep;
  m_fixedTimeStep = 0;
  if (btFuzzyZero(timeStep))
  {
   numSimulationSubSteps = 0;
   maxSubSteps = 0;
  }
  else
  {
   numSimulationSubSteps = 1;
   maxSubSteps = 1;
  }
 }

 //process some debugging flags
 if (getDebugDrawer())
 {
  btIDebugDraw* debugDrawer = getDebugDrawer();
  gDisableDeactivation = (debugDrawer->getDebugMode() & btIDebugDraw::DBG_NoDeactivation) != 0;
 }
 if (numSimulationSubSteps)
 {

  //clamp the number of substeps, to prevent simulation grinding spiralling down to a halt
  int clampedSimulationSteps = (numSimulationSubSteps > maxSubSteps) ? maxSubSteps : numSimulationSubSteps;

  saveKinematicState(fixedTimeStep*clampedSimulationSteps);

  applyGravity();



  for (int i = 0; i<clampedSimulationSteps; i++)
  {
   internalSingleStepSimulation(fixedTimeStep);
   synchronizeMotionStates();
  }

 }
 else
 {
  synchronizeMotionStates();
 }

 clearForces();

#ifndef BT_NO_PROFILE
 CProfileManager::Increment_Frame_Counter();
#endif //BT_NO_PROFILE

 return numSimulationSubSteps;
}

void	btDiscreteDynamicsWorld::internalSingleStepSimulation(btScalar timeStep)
{

 BT_PROFILE("internalSingleStepSimulation");

 if (0 != m_internalPreTickCallback) {
  (*m_internalPreTickCallback)(this, timeStep);
 }

 ///apply gravity, predict motion
 predictUnconstraintMotion(timeStep);

 btDispatcherInfo& dispatchInfo = getDispatchInfo();

 dispatchInfo.m_timeStep = timeStep;
 dispatchInfo.m_stepCount = 0;
 dispatchInfo.m_debugDraw = getDebugDrawer();


 createPredictiveContacts(timeStep);

 ///perform collision detection
 performDiscreteCollisionDetection();

 calculateSimulationIslands();


 getSolverInfo().m_timeStep = timeStep;



 ///solve contact and other joint constraints
 solveConstraints(getSolverInfo());

 ///CallbackTriggers();

 ///integrate transforms

 integrateTransforms(timeStep);

 ///update vehicle simulation
 updateActions(timeStep);

 updateActivationState(timeStep);

 if (0 != m_internalTickCallback) {
  (*m_internalTickCallback)(this, timeStep);
 }
}

void	btDiscreteDynamicsWorld::setGravity(const btVector3& gravity)
{
 m_gravity = gravity;
 for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
 {
  btRigidBody* body = m_nonStaticRigidBodies[i];
  if (body->isActive() && !(body->getFlags() &BT_DISABLE_WORLD_GRAVITY))
  {
   body->setGravity(gravity);
  }
 }
}

btVector3 btDiscreteDynamicsWorld::getGravity() const
{
 return m_gravity;
}

void	btDiscreteDynamicsWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{
 btCollisionWorld::addCollisionObject(collisionObject, collisionFilterGroup, collisionFilterMask);
}

void	btDiscreteDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
 btRigidBody* body = btRigidBody::upcast(collisionObject);
 if (body)
  removeRigidBody(body);
 else
  btCollisionWorld::removeCollisionObject(collisionObject);
}

void	btDiscreteDynamicsWorld::removeRigidBody(btRigidBody* body)
{
 m_nonStaticRigidBodies.remove(body);
 btCollisionWorld::removeCollisionObject(body);
}


void	btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body)
{
 if (!body->isStaticOrKinematicObject() && !(body->getFlags() &BT_DISABLE_WORLD_GRAVITY))
 {
  body->setGravity(m_gravity);
 }

 if (body->getCollisionShape())
 {
  if (!body->isStaticObject())
  {
   m_nonStaticRigidBodies.push_back(body);
  }
  else
  {
   body->setActivationState(ISLAND_SLEEPING);
  }

  bool isDynamic = !(body->isStaticObject() || body->isKinematicObject());
  int collisionFilterGroup = isDynamic ? int(btBroadphaseProxy::DefaultFilter) : int(btBroadphaseProxy::StaticFilter);
  int collisionFilterMask = isDynamic ? int(btBroadphaseProxy::AllFilter) : int(btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

  addCollisionObject(body, collisionFilterGroup, collisionFilterMask);
 }
}

void	btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body, int group, int mask)
{
 if (!body->isStaticOrKinematicObject() && !(body->getFlags() &BT_DISABLE_WORLD_GRAVITY))
 {
  body->setGravity(m_gravity);
 }

 if (body->getCollisionShape())
 {
  if (!body->isStaticObject())
  {
   m_nonStaticRigidBodies.push_back(body);
  }
  else
  {
   body->setActivationState(ISLAND_SLEEPING);
  }
  addCollisionObject(body, group, mask);
 }
}


void	btDiscreteDynamicsWorld::updateActions(btScalar timeStep)
{
 BT_PROFILE("updateActions");

 for (int i = 0; i<m_actions.size(); i++)
 {
  m_actions[i]->updateAction(this, timeStep);
 }
}


void	btDiscreteDynamicsWorld::updateActivationState(btScalar timeStep)
{
 BT_PROFILE("updateActivationState");

 for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
 {
  btRigidBody* body = m_nonStaticRigidBodies[i];
  if (body)
  {
   body->updateDeactivation(timeStep);

   if (body->wantsSleeping())
   {
    if (body->isStaticOrKinematicObject())
    {
     body->setActivationState(ISLAND_SLEEPING);
    }
    else
    {
     if (body->getActivationState() == ACTIVE_TAG)
      body->setActivationState(WANTS_DEACTIVATION);
     if (body->getActivationState() == ISLAND_SLEEPING)
     {
      body->setAngularVelocity(btVector3(0, 0, 0));
      body->setLinearVelocity(btVector3(0, 0, 0));
     }

    }
   }
   else
   {
    if (body->getActivationState() != DISABLE_DEACTIVATION)
     body->setActivationState(ACTIVE_TAG);
   }
  }
 }
}

void	btDiscreteDynamicsWorld::addConstraint(btTypedConstraint* constraint, bool disableCollisionsBetweenLinkedBodies)
{
 m_constraints.push_back(constraint);
 //Make sure the two bodies of a type constraint are different (possibly add this to the btTypedConstraint constructor?)
 btAssert(&constraint->getRigidBodyA() != &constraint->getRigidBodyB());

 if (disableCollisionsBetweenLinkedBodies)
 {
  constraint->getRigidBodyA().addConstraintRef(constraint);
  constraint->getRigidBodyB().addConstraintRef(constraint);
 }
}

void	btDiscreteDynamicsWorld::removeConstraint(btTypedConstraint* constraint)
{
 m_constraints.remove(constraint);
 constraint->getRigidBodyA().removeConstraintRef(constraint);
 constraint->getRigidBodyB().removeConstraintRef(constraint);
}

void	btDiscreteDynamicsWorld::addAction(btActionInterface* action)
{
 m_actions.push_back(action);
}

void	btDiscreteDynamicsWorld::removeAction(btActionInterface* action)
{
 m_actions.remove(action);
}


void	btDiscreteDynamicsWorld::addVehicle(btActionInterface* vehicle)
{
 addAction(vehicle);
}

void	btDiscreteDynamicsWorld::removeVehicle(btActionInterface* vehicle)
{
 removeAction(vehicle);
}

void	btDiscreteDynamicsWorld::addCharacter(btActionInterface* character)
{
 addAction(character);
}

void	btDiscreteDynamicsWorld::removeCharacter(btActionInterface* character)
{
 removeAction(character);
}




void	btDiscreteDynamicsWorld::solveConstraints(btContactSolverInfo& solverInfo)
{
 BT_PROFILE("solveConstraints");

 m_sortedConstraints.resize(m_constraints.size());
 int i;
 for (i = 0; i<getNumConstraints(); i++)
 {
  m_sortedConstraints[i] = m_constraints[i];
 }

 //	btAssert(0);



 m_sortedConstraints.quickSort(btSortConstraintOnIslandPredicate());

 btTypedConstraint** constraintsPtr = getNumConstraints() ? &m_sortedConstraints[0] : 0;

 m_solverIslandCallback->setup(&solverInfo, constraintsPtr, m_sortedConstraints.size(), getDebugDrawer());
 m_constraintSolver->prepareSolve(getCollisionWorld()->getNumCollisionObjects(), getCollisionWorld()->getDispatcher()->getNumManifolds());

 /// solve all the constraints for this island
 m_islandManager->buildAndProcessIslands(getCollisionWorld()->getDispatcher(), getCollisionWorld(), m_solverIslandCallback);

 m_solverIslandCallback->processConstraints();

 m_constraintSolver->allSolved(solverInfo, m_debugDrawer);
}


void	btDiscreteDynamicsWorld::calculateSimulationIslands()
{
 BT_PROFILE("calculateSimulationIslands");

 getSimulationIslandManager()->updateActivationState(getCollisionWorld(), getCollisionWorld()->getDispatcher());

 {
  //merge islands based on speculative contact manifolds too
  for (int i = 0; i<this->m_predictiveManifolds.size(); i++)
  {
   btPersistentManifold* manifold = m_predictiveManifolds[i];

   const btCollisionObject* colObj0 = manifold->getBody0();
   const btCollisionObject* colObj1 = manifold->getBody1();

   if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
    ((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
   {
    getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
   }
  }
 }

 {
  int i;
  int numConstraints = int(m_constraints.size());
  for (i = 0; i< numConstraints; i++)
  {
   btTypedConstraint* constraint = m_constraints[i];
   if (constraint->isEnabled())
   {
    const btRigidBody* colObj0 = &constraint->getRigidBodyA();
    const btRigidBody* colObj1 = &constraint->getRigidBodyB();

    if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
     ((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
    {
     getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
    }
   }
  }
 }

 //Store the island id in each body
 getSimulationIslandManager()->storeIslandActivationState(getCollisionWorld());


}




class btClosestNotMeConvexResultCallback : public btCollisionWorld::ClosestConvexResultCallback
{
public:

 btCollisionObject* m_me;
 btScalar m_allowedPenetration;
 btOverlappingPairCache* m_pairCache;
 btDispatcher* m_dispatcher;

public:
 btClosestNotMeConvexResultCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) :
  btCollisionWorld::ClosestConvexResultCallback(fromA, toA),
  m_me(me),
  m_allowedPenetration(0.0f),
  m_pairCache(pairCache),
  m_dispatcher(dispatcher)
 {
 }

 virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult, bool normalInWorldSpace)
 {
  if (convexResult.m_hitCollisionObject == m_me)
   return 1.0f;

  //ignore result if there is no contact response
  if (!convexResult.m_hitCollisionObject->hasContactResponse())
   return 1.0f;

  btVector3 linVelA, linVelB;
  linVelA = m_convexToWorld - m_convexFromWorld;
  linVelB = btVector3(0, 0, 0);//toB.getOrigin()-fromB.getOrigin();

  btVector3 relativeVelocity = (linVelA - linVelB);
  //don't report time of impact for motion away from the contact normal (or causes minor penetration)
  if (convexResult.m_hitNormalLocal.dot(relativeVelocity) >= -m_allowedPenetration)
   return 1.f;

  return ClosestConvexResultCallback::addSingleResult(convexResult, normalInWorldSpace);
 }

 virtual bool needsCollision(btBroadphaseProxy* proxy0) const
 {
  //don't collide with itself
  if (proxy0->m_clientObject == m_me)
   return false;

  ///don't do CCD when the collision filters are not matching
  if (!ClosestConvexResultCallback::needsCollision(proxy0))
   return false;

  btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;

  //call needsResponse, see http://code.google.com/p/bullet/issues/detail?id=179
  if (m_dispatcher->needsResponse(m_me, otherObj))
  {
#if 0
   ///don't do CCD when there are already contact points (touching contact/penetration)
   btAlignedObjectArray<btPersistentManifold*> manifoldArray;
   btBroadphasePair* collisionPair = m_pairCache->findPair(m_me->getBroadphaseHandle(), proxy0);
   if (collisionPair)
   {
    if (collisionPair->m_algorithm)
    {
     manifoldArray.resize(0);
     collisionPair->m_algorithm->getAllContactManifolds(manifoldArray);
     for (int j = 0; j<manifoldArray.size(); j++)
     {
      btPersistentManifold* manifold = manifoldArray[j];
      if (manifold->getNumContacts()>0)
       return false;
     }
    }
   }
#endif
   return true;
  }

  return false;
 }


};

///internal debugging variable. this value shouldn't be too high
int gNumClampedCcdMotions = 0;


void btDiscreteDynamicsWorld::createPredictiveContactsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
 btTransform predictedTrans;
 for (int i = 0; i<numBodies; i++)
 {
  btRigidBody* body = bodies[i];
  body->setHitFraction(1.f);

  if (body->isActive() && (!body->isStaticOrKinematicObject()))
  {

   body->predictIntegratedTransform(timeStep, predictedTrans);

   btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();

   if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
   {
    BT_PROFILE("predictive convexSweepTest");
    if (body->getCollisionShape()->isConvex())
    {
     gNumClampedCcdMotions++;
#ifdef PREDICTIVE_CONTACT_USE_STATIC_ONLY
     class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
     {
     public:

      StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) :
       btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
      {
      }

      virtual bool needsCollision(btBroadphaseProxy* proxy0) const
      {
       btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
       if (!otherObj->isStaticOrKinematicObject())
        return false;
       return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
      }
     };

     StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
     btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
     //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
     btSphereShape tmpSphere(body->getCcdSweptSphereRadius());//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
     sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

     sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
     sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
     btTransform modifiedPredictedTrans = predictedTrans;
     modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

     convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
     if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
     {

      btVector3 distVec = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin())*sweepResults.m_closestHitFraction;
      btScalar distance = distVec.dot(-sweepResults.m_hitNormalWorld);


      btPersistentManifold* manifold = m_dispatcher1->getNewManifold(body, sweepResults.m_hitCollisionObject);
      btMutexLock(&m_predictiveManifoldsMutex);
      m_predictiveManifolds.push_back(manifold);
      btMutexUnlock(&m_predictiveManifoldsMutex);

      btVector3 worldPointB = body->getWorldTransform().getOrigin() + distVec;
      btVector3 localPointB = sweepResults.m_hitCollisionObject->getWorldTransform().inverse()*worldPointB;

      btManifoldPoint newPoint(btVector3(0, 0, 0), localPointB, sweepResults.m_hitNormalWorld, distance);

      bool isPredictive = true;
      int index = manifold->addManifoldPoint(newPoint, isPredictive);
      btManifoldPoint& pt = manifold->getContactPoint(index);
      pt.m_combinedRestitution = 0;
      pt.m_combinedFriction = btManifoldResult::calculateCombinedFriction(body, sweepResults.m_hitCollisionObject);
      pt.m_positionWorldOnA = body->getWorldTransform().getOrigin();
      pt.m_positionWorldOnB = worldPointB;

     }
    }
   }
  }
 }
}

void btDiscreteDynamicsWorld::releasePredictiveContacts()
{
 BT_PROFILE("release predictive contact manifolds");

 for (int i = 0; i < m_predictiveManifolds.size(); i++)
 {
  btPersistentManifold* manifold = m_predictiveManifolds[i];
  this->m_dispatcher1->releaseManifold(manifold);
 }
 m_predictiveManifolds.clear();
}

void btDiscreteDynamicsWorld::createPredictiveContacts(btScalar timeStep)
{
 BT_PROFILE("createPredictiveContacts");
 releasePredictiveContacts();
 if (m_nonStaticRigidBodies.size() > 0)
 {
  createPredictiveContactsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
 }
}

void btDiscreteDynamicsWorld::integrateTransformsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
 btTransform predictedTrans;
 for (int i = 0; i<numBodies; i++)
 {
  btRigidBody* body = bodies[i];
  body->setHitFraction(1.f);

  if (body->isActive() && (!body->isStaticOrKinematicObject()))
  {

   body->predictIntegratedTransform(timeStep, predictedTrans);

   btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();



   if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
   {
    BT_PROFILE("CCD motion clamping");
    if (body->getCollisionShape()->isConvex())
    {
     gNumClampedCcdMotions++;
#ifdef USE_STATIC_ONLY
     class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
     {
     public:

      StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) :
       btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
      {
      }

      virtual bool needsCollision(btBroadphaseProxy* proxy0) const
      {
       btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
       if (!otherObj->isStaticOrKinematicObject())
        return false;
       return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
      }
     };

     StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
     btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
     //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
     btSphereShape tmpSphere(body->getCcdSweptSphereRadius());//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
     sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

     sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
     sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
     btTransform modifiedPredictedTrans = predictedTrans;
     modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

     convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
     if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
     {

      //printf("clamped integration to hit fraction = %f\n",fraction);
      body->setHitFraction(sweepResults.m_closestHitFraction);
      body->predictIntegratedTransform(timeStep*body->getHitFraction(), predictedTrans);
      body->setHitFraction(0.f);
      body->proceedToTransform(predictedTrans);

#if 0
      btVector3 linVel = body->getLinearVelocity();

      btScalar maxSpeed = body->getCcdMotionThreshold() / getSolverInfo().m_timeStep;
      btScalar maxSpeedSqr = maxSpeed*maxSpeed;
      if (linVel.length2()>maxSpeedSqr)
      {
       linVel.normalize();
       linVel *= maxSpeed;
       body->setLinearVelocity(linVel);
       btScalar ms2 = body->getLinearVelocity().length2();
       body->predictIntegratedTransform(timeStep, predictedTrans);

       btScalar sm2 = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();
       btScalar smt = body->getCcdSquareMotionThreshold();
       printf("sm2=%f\n", sm2);
      }
#else

      //don't apply the collision response right now, it will happen next frame
      //if you really need to, you can uncomment next 3 lines. Note that is uses zero restitution.
      //btScalar appliedImpulse = 0.f;
      //btScalar depth = 0.f;
      //appliedImpulse = resolveSingleCollision(body,(btCollisionObject*)sweepResults.m_hitCollisionObject,sweepResults.m_hitPointWorld,sweepResults.m_hitNormalWorld,getSolverInfo(), depth);


#endif

      continue;
     }
    }
   }


   body->proceedToTransform(predictedTrans);

  }

 }

}

void btDiscreteDynamicsWorld::integrateTransforms(btScalar timeStep)
{
 BT_PROFILE("integrateTransforms");
 if (m_nonStaticRigidBodies.size() > 0)
 {
  integrateTransformsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
 }

 ///this should probably be switched on by default, but it is not well tested yet
 if (m_applySpeculativeContactRestitution)
 {
  BT_PROFILE("apply speculative contact restitution");
  for (int i = 0; i<m_predictiveManifolds.size(); i++)
  {
   btPersistentManifold* manifold = m_predictiveManifolds[i];
   btRigidBody* body0 = btRigidBody::upcast((btCollisionObject*)manifold->getBody0());
   btRigidBody* body1 = btRigidBody::upcast((btCollisionObject*)manifold->getBody1());

   for (int p = 0; p<manifold->getNumContacts(); p++)
   {
    const btManifoldPoint& pt = manifold->getContactPoint(p);
    btScalar combinedRestitution = btManifoldResult::calculateCombinedRestitution(body0, body1);

    if (combinedRestitution>0 && pt.m_appliedImpulse != 0.f)
     //if (pt.getDistance()>0 && combinedRestitution>0 && pt.m_appliedImpulse != 0.f)
    {
     btVector3 imp = -pt.m_normalWorldOnB * pt.m_appliedImpulse* combinedRestitution;

     const btVector3& pos1 = pt.getPositionWorldOnA();
     const btVector3& pos2 = pt.getPositionWorldOnB();

     btVector3 rel_pos0 = pos1 - body0->getWorldTransform().getOrigin();
     btVector3 rel_pos1 = pos2 - body1->getWorldTransform().getOrigin();

     if (body0)
      body0->applyImpulse(imp, rel_pos0);
     if (body1)
      body1->applyImpulse(-imp, rel_pos1);
    }
   }
  }
 }
}





void	btDiscreteDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
 BT_PROFILE("predictUnconstraintMotion");
 for (int i = 0; i<m_nonStaticRigidBodies.size(); i++)
 {
  btRigidBody* body = m_nonStaticRigidBodies[i];
  if (!body->isStaticOrKinematicObject())
  {
   //don't integrate/update velocities here, it happens in the constraint solver

   body->applyDamping(timeStep);

   body->predictIntegratedTransform(timeStep, body->getInterpolationWorldTransform());
  }
 }
}


void	btDiscreteDynamicsWorld::startProfiling(btScalar timeStep)
{
 (void)timeStep;

#ifndef BT_NO_PROFILE
 CProfileManager::Reset();
#endif //BT_NO_PROFILE

}






void btDiscreteDynamicsWorld::debugDrawConstraint(btTypedConstraint* constraint)
{
 bool drawFrames = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraints) != 0;
 bool drawLimits = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraintLimits) != 0;
 btScalar dbgDrawSize = constraint->getDbgDrawSize();
 if (dbgDrawSize <= btScalar(0.f))
 {
  return;
 }

 switch (constraint->getConstraintType())
 {
 case POINT2POINT_CONSTRAINT_TYPE:
 {
  btPoint2PointConstraint* p2pC = (btPoint2PointConstraint*)constraint;
  btTransform tr;
  tr.setIdentity();
  btVector3 pivot = p2pC->getPivotInA();
  pivot = p2pC->getRigidBodyA().getCenterOfMassTransform() * pivot;
  tr.setOrigin(pivot);
  getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  // that ideally should draw the same frame
  pivot = p2pC->getPivotInB();
  pivot = p2pC->getRigidBodyB().getCenterOfMassTransform() * pivot;
  tr.setOrigin(pivot);
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
 }
 break;
 case HINGE_CONSTRAINT_TYPE:
 {
  btHingeConstraint* pHinge = (btHingeConstraint*)constraint;
  btTransform tr = pHinge->getRigidBodyA().getCenterOfMassTransform() * pHinge->getAFrame();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  tr = pHinge->getRigidBodyB().getCenterOfMassTransform() * pHinge->getBFrame();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  btScalar minAng = pHinge->getLowerLimit();
  btScalar maxAng = pHinge->getUpperLimit();
  if (minAng == maxAng)
  {
   break;
  }
  bool drawSect = true;
  if (!pHinge->hasLimit())
  {
   minAng = btScalar(0.f);
   maxAng = SIMD_2_PI;
   drawSect = false;
  }
  if (drawLimits)
  {
   btVector3& center = tr.getOrigin();
   btVector3 normal = tr.getBasis().getColumn(2);
   btVector3 axis = tr.getBasis().getColumn(0);
   getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, minAng, maxAng, btVector3(0, 0, 0), drawSect);
  }
 }
 break;
 case CONETWIST_CONSTRAINT_TYPE:
 {
  btConeTwistConstraint* pCT = (btConeTwistConstraint*)constraint;
  btTransform tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  if (drawLimits)
  {
   //const btScalar length = btScalar(5);
   const btScalar length = dbgDrawSize;
   static int nSegments = 8 * 4;
   btScalar fAngleInRadians = btScalar(2.*3.1415926) * (btScalar)(nSegments - 1) / btScalar(nSegments);
   btVector3 pPrev = pCT->GetPointForAngle(fAngleInRadians, length);
   pPrev = tr * pPrev;
   for (int i = 0; i<nSegments; i++)
   {
    fAngleInRadians = btScalar(2.*3.1415926) * (btScalar)i / btScalar(nSegments);
    btVector3 pCur = pCT->GetPointForAngle(fAngleInRadians, length);
    pCur = tr * pCur;
    getDebugDrawer()->drawLine(pPrev, pCur, btVector3(0, 0, 0));

    if (i % (nSegments / 8) == 0)
     getDebugDrawer()->drawLine(tr.getOrigin(), pCur, btVector3(0, 0, 0));

    pPrev = pCur;
   }
   btScalar tws = pCT->getTwistSpan();
   btScalar twa = pCT->getTwistAngle();
   bool useFrameB = (pCT->getRigidBodyB().getInvMass() > btScalar(0.f));
   if (useFrameB)
   {
    tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
   }
   else
   {
    tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
   }
   btVector3 pivot = tr.getOrigin();
   btVector3 normal = tr.getBasis().getColumn(0);
   btVector3 axis1 = tr.getBasis().getColumn(1);
   getDebugDrawer()->drawArc(pivot, normal, axis1, dbgDrawSize, dbgDrawSize, -twa - tws, -twa + tws, btVector3(0, 0, 0), true);

  }
 }
 break;
 case D6_SPRING_CONSTRAINT_TYPE:
 case D6_CONSTRAINT_TYPE:
 {
  btGeneric6DofConstraint* p6DOF = (btGeneric6DofConstraint*)constraint;
  btTransform tr = p6DOF->getCalculatedTransformA();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  tr = p6DOF->getCalculatedTransformB();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  if (drawLimits)
  {
   tr = p6DOF->getCalculatedTransformA();
   const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
   btVector3 up = tr.getBasis().getColumn(2);
   btVector3 axis = tr.getBasis().getColumn(0);
   btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
   btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
   btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
   btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
   getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
   axis = tr.getBasis().getColumn(1);
   btScalar ay = p6DOF->getAngle(1);
   btScalar az = p6DOF->getAngle(2);
   btScalar cy = btCos(ay);
   btScalar sy = btSin(ay);
   btScalar cz = btCos(az);
   btScalar sz = btSin(az);
   btVector3 ref;
   ref[0] = cy*cz*axis[0] + cy*sz*axis[1] - sy*axis[2];
   ref[1] = -sz*axis[0] + cz*axis[1];
   ref[2] = cz*sy*axis[0] + sz*sy*axis[1] + cy*axis[2];
   tr = p6DOF->getCalculatedTransformB();
   btVector3 normal = -tr.getBasis().getColumn(0);
   btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
   btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
   if (minFi > maxFi)
   {
    getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
   }
   else if (minFi < maxFi)
   {
    getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
   }
   tr = p6DOF->getCalculatedTransformA();
   btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
   btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
   getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
  }
 }
 break;
 ///note: the code for D6_SPRING_2_CONSTRAINT_TYPE is identical to D6_CONSTRAINT_TYPE, the D6_CONSTRAINT_TYPE+D6_SPRING_CONSTRAINT_TYPE will likely become obsolete/deprecated at some stage
 case D6_SPRING_2_CONSTRAINT_TYPE:
 {
  {
   btGeneric6DofSpring2Constraint* p6DOF = (btGeneric6DofSpring2Constraint*)constraint;
   btTransform tr = p6DOF->getCalculatedTransformA();
   if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
   tr = p6DOF->getCalculatedTransformB();
   if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
   if (drawLimits)
   {
    tr = p6DOF->getCalculatedTransformA();
    const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
    btVector3 up = tr.getBasis().getColumn(2);
    btVector3 axis = tr.getBasis().getColumn(0);
    btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
    btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
    btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
    btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
    getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
    axis = tr.getBasis().getColumn(1);
    btScalar ay = p6DOF->getAngle(1);
    btScalar az = p6DOF->getAngle(2);
    btScalar cy = btCos(ay);
    btScalar sy = btSin(ay);
    btScalar cz = btCos(az);
    btScalar sz = btSin(az);
    btVector3 ref;
    ref[0] = cy*cz*axis[0] + cy*sz*axis[1] - sy*axis[2];
    ref[1] = -sz*axis[0] + cz*axis[1];
    ref[2] = cz*sy*axis[0] + sz*sy*axis[1] + cy*axis[2];
    tr = p6DOF->getCalculatedTransformB();
    btVector3 normal = -tr.getBasis().getColumn(0);
    btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
    btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
    if (minFi > maxFi)
    {
     getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
    }
    else if (minFi < maxFi)
    {
     getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
    }
    tr = p6DOF->getCalculatedTransformA();
    btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
    btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
    getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
   }
  }
  break;
 }
 case SLIDER_CONSTRAINT_TYPE:
 {
  btSliderConstraint* pSlider = (btSliderConstraint*)constraint;
  btTransform tr = pSlider->getCalculatedTransformA();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  tr = pSlider->getCalculatedTransformB();
  if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
  if (drawLimits)
  {
   btTransform tr = pSlider->getUseLinearReferenceFrameA() ? pSlider->getCalculatedTransformA() : pSlider->getCalculatedTransformB();
   btVector3 li_min = tr * btVector3(pSlider->getLowerLinLimit(), 0.f, 0.f);
   btVector3 li_max = tr * btVector3(pSlider->getUpperLinLimit(), 0.f, 0.f);
   getDebugDrawer()->drawLine(li_min, li_max, btVector3(0, 0, 0));
   btVector3 normal = tr.getBasis().getColumn(0);
   btVector3 axis = tr.getBasis().getColumn(1);
   btScalar a_min = pSlider->getLowerAngLimit();
   btScalar a_max = pSlider->getUpperAngLimit();
   const btVector3& center = pSlider->getCalculatedTransformB().getOrigin();
   getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, a_min, a_max, btVector3(0, 0, 0), true);
  }
 }
 break;
 default:
  break;
 }
 return;
}





void	btDiscreteDynamicsWorld::setConstraintSolver(btConstraintSolver* solver)
{
 if (m_ownsConstraintSolver)
 {
  btAlignedFree(m_constraintSolver);
 }
 m_ownsConstraintSolver = false;
 m_constraintSolver = solver;
 m_solverIslandCallback->m_solver = solver;
}

btConstraintSolver* btDiscreteDynamicsWorld::getConstraintSolver()
{
 return m_constraintSolver;
}


int		btDiscreteDynamicsWorld::getNumConstraints() const
{
 return int(m_constraints.size());
}
btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index)
{
 return m_constraints[index];
}
const btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index) const
{
 return m_constraints[index];
}



void	btDiscreteDynamicsWorld::serializeRigidBodies(btSerializer* serializer)
{
 int i;
 //serialize all collision objects
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
  {
   int len = colObj->calculateSerializeBufferSize();
   btChunk* chunk = serializer->allocate(len, 1);
   const char* structType = colObj->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, colObj);
  }
 }

 for (i = 0; i<m_constraints.size(); i++)
 {
  btTypedConstraint* constraint = m_constraints[i];
  int size = constraint->calculateSerializeBufferSize();
  btChunk* chunk = serializer->allocate(size, 1);
  const char* structType = constraint->serialize(chunk->m_oldPtr, serializer);
  serializer->finalizeChunk(chunk, structType, BT_CONSTRAINT_CODE, constraint);
 }
}




void	btDiscreteDynamicsWorld::serializeDynamicsWorldInfo(btSerializer* serializer)
{
#ifdef BT_USE_DOUBLE_PRECISION
 int len = sizeof(btDynamicsWorldDoubleData);
 btChunk* chunk = serializer->allocate(len, 1);
 btDynamicsWorldDoubleData* worldInfo = (btDynamicsWorldDoubleData*)chunk->m_oldPtr;
#else//BT_USE_DOUBLE_PRECISION
 int len = sizeof(btDynamicsWorldFloatData);
 btChunk* chunk = serializer->allocate(len, 1);
 btDynamicsWorldFloatData* worldInfo = (btDynamicsWorldFloatData*)chunk->m_oldPtr;
#endif//BT_USE_DOUBLE_PRECISION

 memset(worldInfo, 0x00, len);

 m_gravity.serialize(worldInfo->m_gravity);
 worldInfo->m_solverInfo.m_tau = getSolverInfo().m_tau;
 worldInfo->m_solverInfo.m_damping = getSolverInfo().m_damping;
 worldInfo->m_solverInfo.m_friction = getSolverInfo().m_friction;
 worldInfo->m_solverInfo.m_timeStep = getSolverInfo().m_timeStep;

 worldInfo->m_solverInfo.m_restitution = getSolverInfo().m_restitution;
 worldInfo->m_solverInfo.m_maxErrorReduction = getSolverInfo().m_maxErrorReduction;
 worldInfo->m_solverInfo.m_sor = getSolverInfo().m_sor;
 worldInfo->m_solverInfo.m_erp = getSolverInfo().m_erp;

 worldInfo->m_solverInfo.m_erp2 = getSolverInfo().m_erp2;
 worldInfo->m_solverInfo.m_globalCfm = getSolverInfo().m_globalCfm;
 worldInfo->m_solverInfo.m_splitImpulsePenetrationThreshold = getSolverInfo().m_splitImpulsePenetrationThreshold;
 worldInfo->m_solverInfo.m_splitImpulseTurnErp = getSolverInfo().m_splitImpulseTurnErp;

 worldInfo->m_solverInfo.m_linearSlop = getSolverInfo().m_linearSlop;
 worldInfo->m_solverInfo.m_warmstartingFactor = getSolverInfo().m_warmstartingFactor;
 worldInfo->m_solverInfo.m_maxGyroscopicForce = getSolverInfo().m_maxGyroscopicForce;
 worldInfo->m_solverInfo.m_singleAxisRollingFrictionThreshold = getSolverInfo().m_singleAxisRollingFrictionThreshold;

 worldInfo->m_solverInfo.m_numIterations = getSolverInfo().m_numIterations;
 worldInfo->m_solverInfo.m_solverMode = getSolverInfo().m_solverMode;
 worldInfo->m_solverInfo.m_restingContactRestitutionThreshold = getSolverInfo().m_restingContactRestitutionThreshold;
 worldInfo->m_solverInfo.m_minimumSolverBatchSize = getSolverInfo().m_minimumSolverBatchSize;

 worldInfo->m_solverInfo.m_splitImpulse = getSolverInfo().m_splitImpulse;

 // Fill padding with zeros to appease msan.
 memset(worldInfo->m_solverInfo.m_padding, 0, sizeof(worldInfo->m_solverInfo.m_padding));

#ifdef BT_USE_DOUBLE_PRECISION
 const char* structType = "btDynamicsWorldDoubleData";
#else//BT_USE_DOUBLE_PRECISION
 const char* structType = "btDynamicsWorldFloatData";
#endif//BT_USE_DOUBLE_PRECISION
 serializer->finalizeChunk(chunk, structType, BT_DYNAMICSWORLD_CODE, worldInfo);
}

void	btDiscreteDynamicsWorld::serialize(btSerializer* serializer)
{

 serializer->startSerialization();

 serializeDynamicsWorldInfo(serializer);

 serializeCollisionObjects(serializer);

 serializeRigidBodies(serializer);

 serializer->finishSerialization();
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletDynamics/Dynamics/btDiscreteDynamicsWorldMt.h"

//collision detection
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletDynamics/Dynamics/btSimulationIslandManagerMt.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btQuickprof.h"

//rigidbody & constraints
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
#include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h"
#include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"


#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"


#include "BulletDynamics/Dynamics/btActionInterface.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btMotionState.h"

#include "LinearMath/btSerializer.h"


struct InplaceSolverIslandCallbackMt : public btSimulationIslandManagerMt::IslandCallback
{
 btContactSolverInfo*	m_solverInfo;
 btConstraintSolver*		m_solver;
 btIDebugDraw*			m_debugDrawer;
 btDispatcher*			m_dispatcher;

 InplaceSolverIslandCallbackMt(
  btConstraintSolver*	solver,
  btStackAlloc* stackAlloc,
  btDispatcher* dispatcher)
  :m_solverInfo(NULL),
  m_solver(solver),
  m_debugDrawer(NULL),
  m_dispatcher(dispatcher)
 {

 }

 InplaceSolverIslandCallbackMt& operator=(InplaceSolverIslandCallbackMt& other)
 {
  btAssert(0);
  (void)other;
  return *this;
 }

 SIMD_FORCE_INLINE void setup(btContactSolverInfo* solverInfo, btIDebugDraw* debugDrawer)
 {
  btAssert(solverInfo);
  m_solverInfo = solverInfo;
  m_debugDrawer = debugDrawer;
 }


 virtual	void	processIsland(btCollisionObject** bodies,
  int numBodies,
  btPersistentManifold** manifolds,
  int numManifolds,
  btTypedConstraint** constraints,
  int numConstraints,
  int islandId
 )
 {
  m_solver->solveGroup(bodies,
   numBodies,
   manifolds,
   numManifolds,
   constraints,
   numConstraints,
   *m_solverInfo,
   m_debugDrawer,
   m_dispatcher
  );
 }

};


///
/// btConstraintSolverPoolMt
///

btConstraintSolverPoolMt::ThreadSolver* btConstraintSolverPoolMt::getAndLockThreadSolver()
{
 int i = 0;
#if BT_THREADSAFE
 i = btGetCurrentThreadIndex() % m_solvers.size();
#endif // #if BT_THREADSAFE
 while (true)
 {
  ThreadSolver& solver = m_solvers[i];
  if (solver.mutex.tryLock())
  {
   return &solver;
  }
  // failed, try the next one
  i = (i + 1) % m_solvers.size();
 }
 return NULL;
}

void btConstraintSolverPoolMt::init(btConstraintSolver** solvers, int numSolvers)
{
 m_solverType = BT_SEQUENTIAL_IMPULSE_SOLVER;
 m_solvers.resize(numSolvers);
 for (int i = 0; i < numSolvers; ++i)
 {
  m_solvers[i].solver = solvers[i];
 }
 if (numSolvers > 0)
 {
  m_solverType = solvers[0]->getSolverType();
 }
}

// create the solvers for me
btConstraintSolverPoolMt::btConstraintSolverPoolMt(int numSolvers)
{
 btAlignedObjectArray<btConstraintSolver*> solvers;
 solvers.reserve(numSolvers);
 for (int i = 0; i < numSolvers; ++i)
 {
  btConstraintSolver* solver = new btSequentialImpulseConstraintSolver();
  solvers.push_back(solver);
 }
 init(&solvers[0], numSolvers);
}

// pass in fully constructed solvers (destructor will delete them)
btConstraintSolverPoolMt::btConstraintSolverPoolMt(btConstraintSolver** solvers, int numSolvers)
{
 init(solvers, numSolvers);
}

btConstraintSolverPoolMt::~btConstraintSolverPoolMt()
{
 // delete all solvers
 for (int i = 0; i < m_solvers.size(); ++i)
 {
  ThreadSolver& solver = m_solvers[i];
  delete solver.solver;
  solver.solver = NULL;
 }
}

///solve a group of constraints
btScalar btConstraintSolverPoolMt::solveGroup(btCollisionObject** bodies,
 int numBodies,
 btPersistentManifold** manifolds,
 int numManifolds,
 btTypedConstraint** constraints,
 int numConstraints,
 const btContactSolverInfo& info,
 btIDebugDraw* debugDrawer,
 btDispatcher* dispatcher
)
{
 ThreadSolver* ts = getAndLockThreadSolver();
 ts->solver->solveGroup(bodies, numBodies, manifolds, numManifolds, constraints, numConstraints, info, debugDrawer, dispatcher);
 ts->mutex.unlock();
 return 0.0f;
}

void btConstraintSolverPoolMt::reset()
{
 for (int i = 0; i < m_solvers.size(); ++i)
 {
  ThreadSolver& solver = m_solvers[i];
  solver.mutex.lock();
  solver.solver->reset();
  solver.mutex.unlock();
 }
}


///
/// btDiscreteDynamicsWorldMt
///

btDiscreteDynamicsWorldMt::btDiscreteDynamicsWorldMt(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolverPoolMt* constraintSolver, btCollisionConfiguration* collisionConfiguration)
 : btDiscreteDynamicsWorld(dispatcher, pairCache, constraintSolver, collisionConfiguration)
{
 if (m_ownsIslandManager)
 {
  m_islandManager->~btSimulationIslandManager();
  btAlignedFree(m_islandManager);
 }
 {
  void* mem = btAlignedAlloc(sizeof(InplaceSolverIslandCallbackMt), 16);
  m_solverIslandCallbackMt = new (mem) InplaceSolverIslandCallbackMt(m_constraintSolver, 0, dispatcher);
 }
 {
  void* mem = btAlignedAlloc(sizeof(btSimulationIslandManagerMt), 16);
  btSimulationIslandManagerMt* im = new (mem) btSimulationIslandManagerMt();
  im->setMinimumSolverBatchSize(m_solverInfo.m_minimumSolverBatchSize);
  m_islandManager = im;
 }
}


btDiscreteDynamicsWorldMt::~btDiscreteDynamicsWorldMt()
{
 if (m_solverIslandCallbackMt)
 {
  m_solverIslandCallbackMt->~InplaceSolverIslandCallbackMt();
  btAlignedFree(m_solverIslandCallbackMt);
 }
 if (m_ownsConstraintSolver)
 {
  m_constraintSolver->~btConstraintSolver();
  btAlignedFree(m_constraintSolver);
 }
}


void btDiscreteDynamicsWorldMt::solveConstraints(btContactSolverInfo& solverInfo)
{
 BT_PROFILE("solveConstraints");

 m_solverIslandCallbackMt->setup(&solverInfo, getDebugDrawer());
 m_constraintSolver->prepareSolve(getCollisionWorld()->getNumCollisionObjects(), getCollisionWorld()->getDispatcher()->getNumManifolds());

 /// solve all the constraints for this island
 btSimulationIslandManagerMt* im = static_cast<btSimulationIslandManagerMt*>(m_islandManager);
 im->buildAndProcessIslands(getCollisionWorld()->getDispatcher(), getCollisionWorld(), m_constraints, m_solverIslandCallbackMt);

 m_constraintSolver->allSolved(solverInfo, m_debugDrawer);
}


struct UpdaterUnconstrainedMotion : public btIParallelForBody
{
 btScalar timeStep;
 btRigidBody** rigidBodies;

 void forLoop(int iBegin, int iEnd) const BT_OVERRIDE
 {
  for (int i = iBegin; i < iEnd; ++i)
  {
   btRigidBody* body = rigidBodies[i];
   if (!body->isStaticOrKinematicObject())
   {
    //don't integrate/update velocities here, it happens in the constraint solver
    body->applyDamping(timeStep);
    body->predictIntegratedTransform(timeStep, body->getInterpolationWorldTransform());
   }
  }
 }
};


void btDiscreteDynamicsWorldMt::predictUnconstraintMotion(btScalar timeStep)
{
 BT_PROFILE("predictUnconstraintMotion");
 if (m_nonStaticRigidBodies.size() > 0)
 {
  UpdaterUnconstrainedMotion update;
  update.timeStep = timeStep;
  update.rigidBodies = &m_nonStaticRigidBodies[0];
  int grainSize = 50;  // num of iterations per task for task scheduler
  btParallelFor(0, m_nonStaticRigidBodies.size(), grainSize, update);
 }
}


void btDiscreteDynamicsWorldMt::createPredictiveContacts(btScalar timeStep)
{
 BT_PROFILE("createPredictiveContacts");
 releasePredictiveContacts();
 if (m_nonStaticRigidBodies.size() > 0)
 {
  UpdaterCreatePredictiveContacts update;
  update.world = this;
  update.timeStep = timeStep;
  update.rigidBodies = &m_nonStaticRigidBodies[0];
  int grainSize = 50;  // num of iterations per task for task scheduler
  btParallelFor(0, m_nonStaticRigidBodies.size(), grainSize, update);
 }
}


void btDiscreteDynamicsWorldMt::integrateTransforms(btScalar timeStep)
{
 BT_PROFILE("integrateTransforms");
 if (m_nonStaticRigidBodies.size() > 0)
 {
  UpdaterIntegrateTransforms update;
  update.world = this;
  update.timeStep = timeStep;
  update.rigidBodies = &m_nonStaticRigidBodies[0];
  int grainSize = 50;  // num of iterations per task for task scheduler
  btParallelFor(0, m_nonStaticRigidBodies.size(), grainSize, update);
 }
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMotionState.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "LinearMath/btSerializer.h"

//'temporarily' global variables
btScalar	gDeactivationTime = btScalar(2.);
bool	gDisableDeactivation = false;
static int uniqueId = 0;


btRigidBody::btRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
 setupRigidBody(constructionInfo);
}

btRigidBody::btRigidBody(btScalar mass, btMotionState *motionState, btCollisionShape *collisionShape, const btVector3 &localInertia)
{
 btRigidBodyConstructionInfo cinfo(mass, motionState, collisionShape, localInertia);
 setupRigidBody(cinfo);
}

void	btRigidBody::setupRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{

 m_internalType = CO_RIGID_BODY;

 m_linearVelocity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
 m_angularFactor.setValue(1, 1, 1);
 m_linearFactor.setValue(1, 1, 1);
 m_gravity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 m_gravity_acceleration.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0)),
  setDamping(constructionInfo.m_linearDamping, constructionInfo.m_angularDamping);

 m_linearSleepingThreshold = constructionInfo.m_linearSleepingThreshold;
 m_angularSleepingThreshold = constructionInfo.m_angularSleepingThreshold;
 m_optionalMotionState = constructionInfo.m_motionState;
 m_contactSolverType = 0;
 m_frictionSolverType = 0;
 m_additionalDamping = constructionInfo.m_additionalDamping;
 m_additionalDampingFactor = constructionInfo.m_additionalDampingFactor;
 m_additionalLinearDampingThresholdSqr = constructionInfo.m_additionalLinearDampingThresholdSqr;
 m_additionalAngularDampingThresholdSqr = constructionInfo.m_additionalAngularDampingThresholdSqr;
 m_additionalAngularDampingFactor = constructionInfo.m_additionalAngularDampingFactor;

 if (m_optionalMotionState)
 {
  m_optionalMotionState->getWorldTransform(m_worldTransform);
 }
 else
 {
  m_worldTransform = constructionInfo.m_startWorldTransform;
 }

 m_interpolationWorldTransform = m_worldTransform;
 m_interpolationLinearVelocity.setValue(0, 0, 0);
 m_interpolationAngularVelocity.setValue(0, 0, 0);

 //moved to btCollisionObject
 m_friction = constructionInfo.m_friction;
 m_rollingFriction = constructionInfo.m_rollingFriction;
 m_spinningFriction = constructionInfo.m_spinningFriction;

 m_restitution = constructionInfo.m_restitution;

 setCollisionShape(constructionInfo.m_collisionShape);
 m_debugBodyId = uniqueId++;

 setMassProps(constructionInfo.m_mass, constructionInfo.m_localInertia);
 updateInertiaTensor();

 m_rigidbodyFlags = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;


 m_deltaLinearVelocity.setZero();
 m_deltaAngularVelocity.setZero();
 m_invMass = m_inverseMass*m_linearFactor;
 m_pushVelocity.setZero();
 m_turnVelocity.setZero();



}


void btRigidBody::predictIntegratedTransform(btScalar timeStep, btTransform& predictedTransform)
{
 btTransformUtil::integrateTransform(m_worldTransform, m_linearVelocity, m_angularVelocity, timeStep, predictedTransform);
}

void			btRigidBody::saveKinematicState(btScalar timeStep)
{
 //todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities
 if (timeStep != btScalar(0.))
 {
  //if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform
  if (getMotionState())
   getMotionState()->getWorldTransform(m_worldTransform);
  btVector3 linVel, angVel;

  btTransformUtil::calculateVelocity(m_interpolationWorldTransform, m_worldTransform, timeStep, m_linearVelocity, m_angularVelocity);
  m_interpolationLinearVelocity = m_linearVelocity;
  m_interpolationAngularVelocity = m_angularVelocity;
  m_interpolationWorldTransform = m_worldTransform;
  //printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());
 }
}

void	btRigidBody::getAabb(btVector3& aabbMin, btVector3& aabbMax) const
{
 getCollisionShape()->getAabb(m_worldTransform, aabbMin, aabbMax);
}




void btRigidBody::setGravity(const btVector3& acceleration)
{
 if (m_inverseMass != btScalar(0.0))
 {
  m_gravity = acceleration * (btScalar(1.0) / m_inverseMass);
 }
 m_gravity_acceleration = acceleration;
}






void btRigidBody::setDamping(btScalar lin_damping, btScalar ang_damping)
{
 m_linearDamping = btClamped(lin_damping, (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
 m_angularDamping = btClamped(ang_damping, (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
}




///applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping
void			btRigidBody::applyDamping(btScalar timeStep)
{
 //On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74
 //todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway

 //#define USE_OLD_DAMPING_METHOD 1
#ifdef USE_OLD_DAMPING_METHOD
 m_linearVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_linearDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
 m_angularVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_angularDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
#else
 m_linearVelocity *= btPow(btScalar(1) - m_linearDamping, timeStep);
 m_angularVelocity *= btPow(btScalar(1) - m_angularDamping, timeStep);
#endif

 if (m_additionalDamping)
 {
  //Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
  //Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
  if ((m_angularVelocity.length2() < m_additionalAngularDampingThresholdSqr) &&
   (m_linearVelocity.length2() < m_additionalLinearDampingThresholdSqr))
  {
   m_angularVelocity *= m_additionalDampingFactor;
   m_linearVelocity *= m_additionalDampingFactor;
  }


  btScalar speed = m_linearVelocity.length();
  if (speed < m_linearDamping)
  {
   btScalar dampVel = btScalar(0.005);
   if (speed > dampVel)
   {
    btVector3 dir = m_linearVelocity.normalized();
    m_linearVelocity -= dir * dampVel;
   }
   else
   {
    m_linearVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
   }
  }

  btScalar angSpeed = m_angularVelocity.length();
  if (angSpeed < m_angularDamping)
  {
   btScalar angDampVel = btScalar(0.005);
   if (angSpeed > angDampVel)
   {
    btVector3 dir = m_angularVelocity.normalized();
    m_angularVelocity -= dir * angDampVel;
   }
   else
   {
    m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
   }
  }
 }
}


void btRigidBody::applyGravity()
{
 if (isStaticOrKinematicObject())
  return;

 applyCentralForce(m_gravity);

}

void btRigidBody::proceedToTransform(const btTransform& newTrans)
{
 setCenterOfMassTransform(newTrans);
}


void btRigidBody::setMassProps(btScalar mass, const btVector3& inertia)
{
 if (mass == btScalar(0.))
 {
  m_collisionFlags |= btCollisionObject::CF_STATIC_OBJECT;
  m_inverseMass = btScalar(0.);
 }
 else
 {
  m_collisionFlags &= (~btCollisionObject::CF_STATIC_OBJECT);
  m_inverseMass = btScalar(1.0) / mass;
 }

 //Fg = m * a
 m_gravity = mass * m_gravity_acceleration;

 m_invInertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
  inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
  inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));

 m_invMass = m_linearFactor*m_inverseMass;
}


void btRigidBody::updateInertiaTensor()
{
 m_invInertiaTensorWorld = m_worldTransform.getBasis().scaled(m_invInertiaLocal) * m_worldTransform.getBasis().transpose();
}



btVector3 btRigidBody::getLocalInertia() const
{

 btVector3 inertiaLocal;
 const btVector3 inertia = m_invInertiaLocal;
 inertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
  inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
  inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));
 return inertiaLocal;
}

inline btVector3 evalEulerEqn(const btVector3& w1, const btVector3& w0, const btVector3& T, const btScalar dt,
 const btMatrix3x3 &I)
{
 const btVector3 w2 = I*w1 + w1.cross(I*w1)*dt - (T*dt + I*w0);
 return w2;
}

inline btMatrix3x3 evalEulerEqnDeriv(const btVector3& w1, const btVector3& w0, const btScalar dt,
 const btMatrix3x3 &I)
{

 btMatrix3x3 w1x, Iw1x;
 const btVector3 Iwi = (I*w1);
 w1.getSkewSymmetricMatrix(&w1x[0], &w1x[1], &w1x[2]);
 Iwi.getSkewSymmetricMatrix(&Iw1x[0], &Iw1x[1], &Iw1x[2]);

 const btMatrix3x3 dfw1 = I + (w1x*I - Iw1x)*dt;
 return dfw1;
}

btVector3 btRigidBody::computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const
{
 btVector3 inertiaLocal = getLocalInertia();
 btMatrix3x3 inertiaTensorWorld = getWorldTransform().getBasis().scaled(inertiaLocal) * getWorldTransform().getBasis().transpose();
 btVector3 tmp = inertiaTensorWorld*getAngularVelocity();
 btVector3 gf = getAngularVelocity().cross(tmp);
 btScalar l2 = gf.length2();
 if (l2>maxGyroscopicForce*maxGyroscopicForce)
 {
  gf *= btScalar(1.) / btSqrt(l2)*maxGyroscopicForce;
 }
 return gf;
}


btVector3 btRigidBody::computeGyroscopicImpulseImplicit_Body(btScalar step) const
{
 btVector3 idl = getLocalInertia();
 btVector3 omega1 = getAngularVelocity();
 btQuaternion q = getWorldTransform().getRotation();

 // Convert to body coordinates
 btVector3 omegab = quatRotate(q.inverse(), omega1);
 btMatrix3x3 Ib;
 Ib.setValue(idl.x(), 0, 0,
  0, idl.y(), 0,
  0, 0, idl.z());

 btVector3 ibo = Ib*omegab;

 // Residual vector
 btVector3 f = step * omegab.cross(ibo);

 btMatrix3x3 skew0;
 omegab.getSkewSymmetricMatrix(&skew0[0], &skew0[1], &skew0[2]);
 btVector3 om = Ib*omegab;
 btMatrix3x3 skew1;
 om.getSkewSymmetricMatrix(&skew1[0], &skew1[1], &skew1[2]);

 // Jacobian
 btMatrix3x3 J = Ib + (skew0*Ib - skew1)*step;

 //	btMatrix3x3 Jinv = J.inverse();
 //	btVector3 omega_div = Jinv*f;
 btVector3 omega_div = J.solve33(f);

 // Single Newton-Raphson update
 omegab = omegab - omega_div;//Solve33(J, f);
                             // Back to world coordinates
 btVector3 omega2 = quatRotate(q, omegab);
 btVector3 gf = omega2 - omega1;
 return gf;
}



btVector3 btRigidBody::computeGyroscopicImpulseImplicit_World(btScalar step) const
{
 // use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.
 // calculate using implicit euler step so it's stable.

 const btVector3 inertiaLocal = getLocalInertia();
 const btVector3 w0 = getAngularVelocity();

 btMatrix3x3 I;

 I = m_worldTransform.getBasis().scaled(inertiaLocal) *
  m_worldTransform.getBasis().transpose();

 // use newtons method to find implicit solution for new angular velocity (w')
 // f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0 
 // df/dw' = I + 1xIw'*step + w'xI*step

 btVector3 w1 = w0;

 // one step of newton's method
 {
  const btVector3 fw = evalEulerEqn(w1, w0, btVector3(0, 0, 0), step, I);
  const btMatrix3x3 dfw = evalEulerEqnDeriv(w1, w0, step, I);

  btVector3 dw;
  dw = dfw.solve33(fw);
  //const btMatrix3x3 dfw_inv = dfw.inverse();
  //dw = dfw_inv*fw;

  w1 -= dw;
 }

 btVector3 gf = (w1 - w0);
 return gf;
}


void btRigidBody::integrateVelocities(btScalar step)
{
 if (isStaticOrKinematicObject())
  return;

 m_linearVelocity += m_totalForce * (m_inverseMass * step);
 m_angularVelocity += m_invInertiaTensorWorld * m_totalTorque * step;

#define MAX_ANGVEL SIMD_HALF_PI
 /// clamp angular velocity. collision calculations will fail on higher angular velocities	
 btScalar angvel = m_angularVelocity.length();
 if (angvel*step > MAX_ANGVEL)
 {
  m_angularVelocity *= (MAX_ANGVEL / step) / angvel;
 }

}

btQuaternion btRigidBody::getOrientation() const
{
 btQuaternion orn;
 m_worldTransform.getBasis().getRotation(orn);
 return orn;
}


void btRigidBody::setCenterOfMassTransform(const btTransform& xform)
{

 if (isKinematicObject())
 {
  m_interpolationWorldTransform = m_worldTransform;
 }
 else
 {
  m_interpolationWorldTransform = xform;
 }
 m_interpolationLinearVelocity = getLinearVelocity();
 m_interpolationAngularVelocity = getAngularVelocity();
 m_worldTransform = xform;
 updateInertiaTensor();
}





void btRigidBody::addConstraintRef(btTypedConstraint* c)
{
 ///disable collision with the 'other' body

 int index = m_constraintRefs.findLinearSearch(c);
 //don't add constraints that are already referenced
 //btAssert(index == m_constraintRefs.size());
 if (index == m_constraintRefs.size())
 {
  m_constraintRefs.push_back(c);
  btCollisionObject* colObjA = &c->getRigidBodyA();
  btCollisionObject* colObjB = &c->getRigidBodyB();
  if (colObjA == this)
  {
   colObjA->setIgnoreCollisionCheck(colObjB, true);
  }
  else
  {
   colObjB->setIgnoreCollisionCheck(colObjA, true);
  }
 }
}

void btRigidBody::removeConstraintRef(btTypedConstraint* c)
{
 int index = m_constraintRefs.findLinearSearch(c);
 //don't remove constraints that are not referenced
 if (index < m_constraintRefs.size())
 {
  m_constraintRefs.remove(c);
  btCollisionObject* colObjA = &c->getRigidBodyA();
  btCollisionObject* colObjB = &c->getRigidBodyB();
  if (colObjA == this)
  {
   colObjA->setIgnoreCollisionCheck(colObjB, false);
  }
  else
  {
   colObjB->setIgnoreCollisionCheck(colObjA, false);
  }
 }
}

int	btRigidBody::calculateSerializeBufferSize()	const
{
 int sz = sizeof(btRigidBodyData);
 return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btRigidBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
 btRigidBodyData* rbd = (btRigidBodyData*)dataBuffer;

 btCollisionObject::serialize(&rbd->m_collisionObjectData, serializer);

 m_invInertiaTensorWorld.serialize(rbd->m_invInertiaTensorWorld);
 m_linearVelocity.serialize(rbd->m_linearVelocity);
 m_angularVelocity.serialize(rbd->m_angularVelocity);
 rbd->m_inverseMass = m_inverseMass;
 m_angularFactor.serialize(rbd->m_angularFactor);
 m_linearFactor.serialize(rbd->m_linearFactor);
 m_gravity.serialize(rbd->m_gravity);
 m_gravity_acceleration.serialize(rbd->m_gravity_acceleration);
 m_invInertiaLocal.serialize(rbd->m_invInertiaLocal);
 m_totalForce.serialize(rbd->m_totalForce);
 m_totalTorque.serialize(rbd->m_totalTorque);
 rbd->m_linearDamping = m_linearDamping;
 rbd->m_angularDamping = m_angularDamping;
 rbd->m_additionalDamping = m_additionalDamping;
 rbd->m_additionalDampingFactor = m_additionalDampingFactor;
 rbd->m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;
 rbd->m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;
 rbd->m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;
 rbd->m_linearSleepingThreshold = m_linearSleepingThreshold;
 rbd->m_angularSleepingThreshold = m_angularSleepingThreshold;

 // Fill padding with zeros to appease msan.
#ifdef BT_USE_DOUBLE_PRECISION
 memset(rbd->m_padding, 0, sizeof(rbd->m_padding));
#endif

 return btRigidBodyDataName;
}



void btRigidBody::serializeSingleObject(class btSerializer* serializer) const
{
 btChunk* chunk = serializer->allocate(calculateSerializeBufferSize(), 1);
 const char* structType = serialize(chunk->m_oldPtr, serializer);
 serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, (void*)this);
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btSimpleDynamicsWorld.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"


/*
Make sure this dummy function never changes so that it
can be used by probes that are checking whether the
library is actually installed.
*/
extern "C"
{
 void btBulletDynamicsProbe();
 void btBulletDynamicsProbe() {}
}




btSimpleDynamicsWorld::btSimpleDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration)
 :btDynamicsWorld(dispatcher, pairCache, collisionConfiguration),
 m_constraintSolver(constraintSolver),
 m_ownsConstraintSolver(false),
 m_gravity(0, 0, -10)
{

}


btSimpleDynamicsWorld::~btSimpleDynamicsWorld()
{
 if (m_ownsConstraintSolver)
  btAlignedFree(m_constraintSolver);
}

int		btSimpleDynamicsWorld::stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep)
{
 (void)fixedTimeStep;
 (void)maxSubSteps;


 ///apply gravity, predict motion
 predictUnconstraintMotion(timeStep);

 btDispatcherInfo&	dispatchInfo = getDispatchInfo();
 dispatchInfo.m_timeStep = timeStep;
 dispatchInfo.m_stepCount = 0;
 dispatchInfo.m_debugDraw = getDebugDrawer();

 ///perform collision detection
 performDiscreteCollisionDetection();

 ///solve contact constraints
 int numManifolds = m_dispatcher1->getNumManifolds();
 if (numManifolds)
 {
  btPersistentManifold** manifoldPtr = ((btCollisionDispatcher*)m_dispatcher1)->getInternalManifoldPointer();

  btContactSolverInfo infoGlobal;
  infoGlobal.m_timeStep = timeStep;
  m_constraintSolver->prepareSolve(0, numManifolds);
  m_constraintSolver->solveGroup(&getCollisionObjectArray()[0], getNumCollisionObjects(), manifoldPtr, numManifolds, 0, 0, infoGlobal, m_debugDrawer, m_dispatcher1);
  m_constraintSolver->allSolved(infoGlobal, m_debugDrawer);
 }

 ///integrate transforms
 integrateTransforms(timeStep);

 updateAabbs();

 synchronizeMotionStates();

 clearForces();

 return 1;

}

void	btSimpleDynamicsWorld::clearForces()
{
 ///@todo: iterate over awake simulation islands!
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];

  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body)
  {
   body->clearForces();
  }
 }
}


void	btSimpleDynamicsWorld::setGravity(const btVector3& gravity)
{
 m_gravity = gravity;
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body)
  {
   body->setGravity(gravity);
  }
 }
}

btVector3 btSimpleDynamicsWorld::getGravity() const
{
 return m_gravity;
}

void	btSimpleDynamicsWorld::removeRigidBody(btRigidBody* body)
{
 btCollisionWorld::removeCollisionObject(body);
}

void	btSimpleDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
 btRigidBody* body = btRigidBody::upcast(collisionObject);
 if (body)
  removeRigidBody(body);
 else
  btCollisionWorld::removeCollisionObject(collisionObject);
}


void	btSimpleDynamicsWorld::addRigidBody(btRigidBody* body)
{
 body->setGravity(m_gravity);

 if (body->getCollisionShape())
 {
  addCollisionObject(body);
 }
}

void	btSimpleDynamicsWorld::addRigidBody(btRigidBody* body, int group, int mask)
{
 body->setGravity(m_gravity);

 if (body->getCollisionShape())
 {
  addCollisionObject(body, group, mask);
 }
}


void	btSimpleDynamicsWorld::debugDrawWorld()
{

}

void	btSimpleDynamicsWorld::addAction(btActionInterface* action)
{

}

void	btSimpleDynamicsWorld::removeAction(btActionInterface* action)
{

}


void	btSimpleDynamicsWorld::updateAabbs()
{
 btTransform predictedTrans;
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body)
  {
   if (body->isActive() && (!body->isStaticObject()))
   {
    btVector3 minAabb, maxAabb;
    colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
    btBroadphaseInterface* bp = getBroadphase();
    bp->setAabb(body->getBroadphaseHandle(), minAabb, maxAabb, m_dispatcher1);
   }
  }
 }
}

void	btSimpleDynamicsWorld::integrateTransforms(btScalar timeStep)
{
 btTransform predictedTrans;
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body)
  {
   if (body->isActive() && (!body->isStaticObject()))
   {
    body->predictIntegratedTransform(timeStep, predictedTrans);
    body->proceedToTransform(predictedTrans);
   }
  }
 }
}



void	btSimpleDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body)
  {
   if (!body->isStaticObject())
   {
    if (body->isActive())
    {
     body->applyGravity();
     body->integrateVelocities(timeStep);
     body->applyDamping(timeStep);
     body->predictIntegratedTransform(timeStep, body->getInterpolationWorldTransform());
    }
   }
  }
 }
}


void	btSimpleDynamicsWorld::synchronizeMotionStates()
{
 ///@todo: iterate over awake simulation islands!
 for (int i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  btRigidBody* body = btRigidBody::upcast(colObj);
  if (body && body->getMotionState())
  {
   if (body->getActivationState() != ISLAND_SLEEPING)
   {
    body->getMotionState()->setWorldTransform(body->getWorldTransform());
   }
  }
 }

}


void	btSimpleDynamicsWorld::setConstraintSolver(btConstraintSolver* solver)
{
 if (m_ownsConstraintSolver)
 {
  btAlignedFree(m_constraintSolver);
 }
 m_ownsConstraintSolver = false;
 m_constraintSolver = solver;
}

btConstraintSolver* btSimpleDynamicsWorld::getConstraintSolver()
{
 return m_constraintSolver;
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btScalar.h"
#include "LinearMath/btThreads.h"
#include "BulletDynamics/Dynamics/btSimulationIslandManagerMt.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

//#include <stdio.h>
#include "LinearMath/btQuickprof.h"


SIMD_FORCE_INLINE int calcBatchCost(int bodies, int manifolds, int constraints)
{
 // rough estimate of the cost of a batch, used for merging
 int batchCost = bodies + 8 * manifolds + 4 * constraints;
 return batchCost;
}


SIMD_FORCE_INLINE int calcBatchCost(const btSimulationIslandManagerMt::Island* island)
{
 return calcBatchCost(island->bodyArray.size(), island->manifoldArray.size(), island->constraintArray.size());
}


btSimulationIslandManagerMt::btSimulationIslandManagerMt()
{
 m_minimumSolverBatchSize = calcBatchCost(0, 128, 0);
 m_batchIslandMinBodyCount = 32;
 m_islandDispatch = parallelIslandDispatch;
 m_batchIsland = NULL;
}


btSimulationIslandManagerMt::~btSimulationIslandManagerMt()
{
 for (int i = 0; i < m_allocatedIslands.size(); ++i)
 {
  delete m_allocatedIslands[i];
 }
 m_allocatedIslands.resize(0);
 m_activeIslands.resize(0);
 m_freeIslands.resize(0);
}


/// function object that routes calls to operator<
class IslandBatchSizeSortPredicate
{
public:
 bool operator() (const btSimulationIslandManagerMt::Island* lhs, const btSimulationIslandManagerMt::Island* rhs) const
 {
  int lCost = calcBatchCost(lhs);
  int rCost = calcBatchCost(rhs);
  return lCost > rCost;
 }
};


class IslandBodyCapacitySortPredicate
{
public:
 bool operator() (const btSimulationIslandManagerMt::Island* lhs, const btSimulationIslandManagerMt::Island* rhs) const
 {
  return lhs->bodyArray.capacity() > rhs->bodyArray.capacity();
 }
};


void btSimulationIslandManagerMt::Island::append(const Island& other)
{
 // append bodies
 for (int i = 0; i < other.bodyArray.size(); ++i)
 {
  bodyArray.push_back(other.bodyArray[i]);
 }
 // append manifolds
 for (int i = 0; i < other.manifoldArray.size(); ++i)
 {
  manifoldArray.push_back(other.manifoldArray[i]);
 }
 // append constraints
 for (int i = 0; i < other.constraintArray.size(); ++i)
 {
  constraintArray.push_back(other.constraintArray[i]);
 }
}


bool btIsBodyInIsland(const btSimulationIslandManagerMt::Island& island, const btCollisionObject* obj)
{
 for (int i = 0; i < island.bodyArray.size(); ++i)
 {
  if (island.bodyArray[i] == obj)
  {
   return true;
  }
 }
 return false;
}


void btSimulationIslandManagerMt::initIslandPools()
{
 // reset island pools
 int numElem = getUnionFind().getNumElements();
 m_lookupIslandFromId.resize(numElem);
 for (int i = 0; i < m_lookupIslandFromId.size(); ++i)
 {
  m_lookupIslandFromId[i] = NULL;
 }
 m_activeIslands.resize(0);
 m_freeIslands.resize(0);
 // check whether allocated islands are sorted by body capacity (largest to smallest)
 int lastCapacity = 0;
 bool isSorted = true;
 for (int i = 0; i < m_allocatedIslands.size(); ++i)
 {
  Island* island = m_allocatedIslands[i];
  int cap = island->bodyArray.capacity();
  if (cap > lastCapacity)
  {
   isSorted = false;
   break;
  }
  lastCapacity = cap;
 }
 if (!isSorted)
 {
  m_allocatedIslands.quickSort(IslandBodyCapacitySortPredicate());
 }

 m_batchIsland = NULL;
 // mark all islands free (but avoid deallocation)
 for (int i = 0; i < m_allocatedIslands.size(); ++i)
 {
  Island* island = m_allocatedIslands[i];
  island->bodyArray.resize(0);
  island->manifoldArray.resize(0);
  island->constraintArray.resize(0);
  island->id = -1;
  island->isSleeping = true;
  m_freeIslands.push_back(island);
 }
}


btSimulationIslandManagerMt::Island* btSimulationIslandManagerMt::getIsland(int id)
{
 Island* island = m_lookupIslandFromId[id];
 if (island == NULL)
 {
  // search for existing island
  for (int i = 0; i < m_activeIslands.size(); ++i)
  {
   if (m_activeIslands[i]->id == id)
   {
    island = m_activeIslands[i];
    break;
   }
  }
  m_lookupIslandFromId[id] = island;
 }
 return island;
}


btSimulationIslandManagerMt::Island* btSimulationIslandManagerMt::allocateIsland(int id, int numBodies)
{
 Island* island = NULL;
 int allocSize = numBodies;
 if (numBodies < m_batchIslandMinBodyCount)
 {
  if (m_batchIsland)
  {
   island = m_batchIsland;
   m_lookupIslandFromId[id] = island;
   // if we've made a large enough batch,
   if (island->bodyArray.size() + numBodies >= m_batchIslandMinBodyCount)
   {
    // next time start a new batch
    m_batchIsland = NULL;
   }
   return island;
  }
  else
  {
   // need to allocate a batch island
   allocSize = m_batchIslandMinBodyCount * 2;
  }
 }
 btAlignedObjectArray<Island*>& freeIslands = m_freeIslands;

 // search for free island
 if (freeIslands.size() > 0)
 {
  // try to reuse a previously allocated island
  int iFound = freeIslands.size();
  // linear search for smallest island that can hold our bodies
  for (int i = freeIslands.size() - 1; i >= 0; --i)
  {
   if (freeIslands[i]->bodyArray.capacity() >= allocSize)
   {
    iFound = i;
    island = freeIslands[i];
    island->id = id;
    break;
   }
  }
  // if found, shrink array while maintaining ordering
  if (island)
  {
   int iDest = iFound;
   int iSrc = iDest + 1;
   while (iSrc < freeIslands.size())
   {
    freeIslands[iDest++] = freeIslands[iSrc++];
   }
   freeIslands.pop_back();
  }
 }
 if (island == NULL)
 {
  // no free island found, allocate
  island = new Island();  // TODO: change this to use the pool allocator
  island->id = id;
  island->bodyArray.reserve(allocSize);
  m_allocatedIslands.push_back(island);
 }
 m_lookupIslandFromId[id] = island;
 if (numBodies < m_batchIslandMinBodyCount)
 {
  m_batchIsland = island;
 }
 m_activeIslands.push_back(island);
 return island;
}


void btSimulationIslandManagerMt::buildIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld)
{

 BT_PROFILE("islandUnionFindAndQuickSort");

 btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

 //we are going to sort the unionfind array, and store the element id in the size
 //afterwards, we clean unionfind, to make sure no-one uses it anymore

 getUnionFind().sortIslands();
 int numElem = getUnionFind().getNumElements();

 int endIslandIndex = 1;
 int startIslandIndex;

 //update the sleeping state for bodies, if all are sleeping
 for (startIslandIndex = 0; startIslandIndex<numElem; startIslandIndex = endIslandIndex)
 {
  int islandId = getUnionFind().getElement(startIslandIndex).m_id;
  for (endIslandIndex = startIslandIndex + 1; (endIslandIndex<numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
  {
  }

  //int numSleeping = 0;

  bool allSleeping = true;

  int idx;
  for (idx = startIslandIndex; idx<endIslandIndex; idx++)
  {
   int i = getUnionFind().getElement(idx).m_sz;

   btCollisionObject* colObj0 = collisionObjects[i];
   if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
   {
    //				printf("error in island management\n");
   }

   btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));
   if (colObj0->getIslandTag() == islandId)
   {
    if (colObj0->getActivationState() == ACTIVE_TAG)
    {
     allSleeping = false;
    }
    if (colObj0->getActivationState() == DISABLE_DEACTIVATION)
    {
     allSleeping = false;
    }
   }
  }

  if (allSleeping)
  {
   int idx;
   for (idx = startIslandIndex; idx<endIslandIndex; idx++)
   {
    int i = getUnionFind().getElement(idx).m_sz;
    btCollisionObject* colObj0 = collisionObjects[i];
    if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
    {
     //					printf("error in island management\n");
    }

    btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

    if (colObj0->getIslandTag() == islandId)
    {
     colObj0->setActivationState(ISLAND_SLEEPING);
    }
   }
  }
  else
  {

   int idx;
   for (idx = startIslandIndex; idx<endIslandIndex; idx++)
   {
    int i = getUnionFind().getElement(idx).m_sz;

    btCollisionObject* colObj0 = collisionObjects[i];
    if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
    {
     //					printf("error in island management\n");
    }

    btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

    if (colObj0->getIslandTag() == islandId)
    {
     if (colObj0->getActivationState() == ISLAND_SLEEPING)
     {
      colObj0->setActivationState(WANTS_DEACTIVATION);
      colObj0->setDeactivationTime(0.f);
     }
    }
   }
  }
 }
}


void btSimulationIslandManagerMt::addBodiesToIslands(btCollisionWorld* collisionWorld)
{
 btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();
 int endIslandIndex = 1;
 int startIslandIndex;
 int numElem = getUnionFind().getNumElements();

 // create explicit islands and add bodies to each
 for (startIslandIndex = 0; startIslandIndex < numElem; startIslandIndex = endIslandIndex)
 {
  int islandId = getUnionFind().getElement(startIslandIndex).m_id;

  // find end index
  for (endIslandIndex = startIslandIndex; (endIslandIndex < numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
  {
  }
  // check if island is sleeping
  bool islandSleeping = true;
  for (int iElem = startIslandIndex; iElem < endIslandIndex; iElem++)
  {
   int i = getUnionFind().getElement(iElem).m_sz;
   btCollisionObject* colObj = collisionObjects[i];
   if (colObj->isActive())
   {
    islandSleeping = false;
   }
  }
  if (!islandSleeping)
  {
   // want to count the number of bodies before allocating the island to optimize memory usage of the Island structures
   int numBodies = endIslandIndex - startIslandIndex;
   Island* island = allocateIsland(islandId, numBodies);
   island->isSleeping = false;

   // add bodies to island
   for (int iElem = startIslandIndex; iElem < endIslandIndex; iElem++)
   {
    int i = getUnionFind().getElement(iElem).m_sz;
    btCollisionObject* colObj = collisionObjects[i];
    island->bodyArray.push_back(colObj);
   }
  }
 }

}


void btSimulationIslandManagerMt::addManifoldsToIslands(btDispatcher* dispatcher)
{
 // walk all the manifolds, activating bodies touched by kinematic objects, and add each manifold to its Island
 int maxNumManifolds = dispatcher->getNumManifolds();
 for (int i = 0; i < maxNumManifolds; i++)
 {
  btPersistentManifold* manifold = dispatcher->getManifoldByIndexInternal(i);

  const btCollisionObject* colObj0 = static_cast<const btCollisionObject*>(manifold->getBody0());
  const btCollisionObject* colObj1 = static_cast<const btCollisionObject*>(manifold->getBody1());

  ///@todo: check sleeping conditions!
  if (((colObj0) && colObj0->getActivationState() != ISLAND_SLEEPING) ||
   ((colObj1) && colObj1->getActivationState() != ISLAND_SLEEPING))
  {

   //kinematic objects don't merge islands, but wake up all connected objects
   if (colObj0->isKinematicObject() && colObj0->getActivationState() != ISLAND_SLEEPING)
   {
    if (colObj0->hasContactResponse())
     colObj1->activate();
   }
   if (colObj1->isKinematicObject() && colObj1->getActivationState() != ISLAND_SLEEPING)
   {
    if (colObj1->hasContactResponse())
     colObj0->activate();
   }
   //filtering for response
   if (dispatcher->needsResponse(colObj0, colObj1))
   {
    // scatter manifolds into various islands
    int islandId = getIslandId(manifold);
    // if island not sleeping,
    if (Island* island = getIsland(islandId))
    {
     island->manifoldArray.push_back(manifold);
    }
   }
  }
 }
}


void btSimulationIslandManagerMt::addConstraintsToIslands(btAlignedObjectArray<btTypedConstraint*>& constraints)
{
 // walk constraints
 for (int i = 0; i < constraints.size(); i++)
 {
  // scatter constraints into various islands
  btTypedConstraint* constraint = constraints[i];
  if (constraint->isEnabled())
  {
   int islandId = btGetConstraintIslandId(constraint);
   // if island is not sleeping,
   if (Island* island = getIsland(islandId))
   {
    island->constraintArray.push_back(constraint);
   }
  }
 }
}


void btSimulationIslandManagerMt::mergeIslands()
{
 // sort islands in order of decreasing batch size
 m_activeIslands.quickSort(IslandBatchSizeSortPredicate());

 // merge small islands to satisfy minimum batch size
 // find first small batch island
 int destIslandIndex = m_activeIslands.size();
 for (int i = 0; i < m_activeIslands.size(); ++i)
 {
  Island* island = m_activeIslands[i];
  int batchSize = calcBatchCost(island);
  if (batchSize < m_minimumSolverBatchSize)
  {
   destIslandIndex = i;
   break;
  }
 }
 int lastIndex = m_activeIslands.size() - 1;
 while (destIslandIndex < lastIndex)
 {
  // merge islands from the back of the list
  Island* island = m_activeIslands[destIslandIndex];
  int numBodies = island->bodyArray.size();
  int numManifolds = island->manifoldArray.size();
  int numConstraints = island->constraintArray.size();
  int firstIndex = lastIndex;
  // figure out how many islands we want to merge and find out how many bodies, manifolds and constraints we will have
  while (true)
  {
   Island* src = m_activeIslands[firstIndex];
   numBodies += src->bodyArray.size();
   numManifolds += src->manifoldArray.size();
   numConstraints += src->constraintArray.size();
   int batchCost = calcBatchCost(numBodies, numManifolds, numConstraints);
   if (batchCost >= m_minimumSolverBatchSize)
   {
    break;
   }
   if (firstIndex - 1 == destIslandIndex)
   {
    break;
   }
   firstIndex--;
  }
  // reserve space for these pointers to minimize reallocation
  island->bodyArray.reserve(numBodies);
  island->manifoldArray.reserve(numManifolds);
  island->constraintArray.reserve(numConstraints);
  // merge islands
  for (int i = firstIndex; i <= lastIndex; ++i)
  {
   island->append(*m_activeIslands[i]);
  }
  // shrink array to exclude the islands that were merged from
  m_activeIslands.resize(firstIndex);
  lastIndex = firstIndex - 1;
  destIslandIndex++;
 }
}


void btSimulationIslandManagerMt::serialIslandDispatch(btAlignedObjectArray<Island*>* islandsPtr, IslandCallback* callback)
{
 BT_PROFILE("serialIslandDispatch");
 // serial dispatch
 btAlignedObjectArray<Island*>& islands = *islandsPtr;
 for (int i = 0; i < islands.size(); ++i)
 {
  Island* island = islands[i];
  btPersistentManifold** manifolds = island->manifoldArray.size() ? &island->manifoldArray[0] : NULL;
  btTypedConstraint** constraintsPtr = island->constraintArray.size() ? &island->constraintArray[0] : NULL;
  callback->processIsland(&island->bodyArray[0],
   island->bodyArray.size(),
   manifolds,
   island->manifoldArray.size(),
   constraintsPtr,
   island->constraintArray.size(),
   island->id
  );
 }
}

struct UpdateIslandDispatcher : public btIParallelForBody
{
 btAlignedObjectArray<btSimulationIslandManagerMt::Island*>* islandsPtr;
 btSimulationIslandManagerMt::IslandCallback* callback;

 void forLoop(int iBegin, int iEnd) const BT_OVERRIDE
 {
  for (int i = iBegin; i < iEnd; ++i)
  {
   btSimulationIslandManagerMt::Island* island = (*islandsPtr)[i];
   btPersistentManifold** manifolds = island->manifoldArray.size() ? &island->manifoldArray[0] : NULL;
   btTypedConstraint** constraintsPtr = island->constraintArray.size() ? &island->constraintArray[0] : NULL;
   callback->processIsland(&island->bodyArray[0],
    island->bodyArray.size(),
    manifolds,
    island->manifoldArray.size(),
    constraintsPtr,
    island->constraintArray.size(),
    island->id
   );
  }
 }
};

void btSimulationIslandManagerMt::parallelIslandDispatch(btAlignedObjectArray<Island*>* islandsPtr, IslandCallback* callback)
{
 BT_PROFILE("parallelIslandDispatch");
 int grainSize = 1;  // iterations per task
 UpdateIslandDispatcher dispatcher;
 dispatcher.islandsPtr = islandsPtr;
 dispatcher.callback = callback;
 btParallelFor(0, islandsPtr->size(), grainSize, dispatcher);
}


///@todo: this is random access, it can be walked 'cache friendly'!
void btSimulationIslandManagerMt::buildAndProcessIslands(btDispatcher* dispatcher,
 btCollisionWorld* collisionWorld,
 btAlignedObjectArray<btTypedConstraint*>& constraints,
 IslandCallback* callback
)
{
 btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

 buildIslands(dispatcher, collisionWorld);

 BT_PROFILE("processIslands");

 if (!getSplitIslands())
 {
  btPersistentManifold** manifolds = dispatcher->getInternalManifoldPointer();
  int maxNumManifolds = dispatcher->getNumManifolds();

  for (int i = 0; i < maxNumManifolds; i++)
  {
   btPersistentManifold* manifold = manifolds[i];

   const btCollisionObject* colObj0 = static_cast<const btCollisionObject*>(manifold->getBody0());
   const btCollisionObject* colObj1 = static_cast<const btCollisionObject*>(manifold->getBody1());

   ///@todo: check sleeping conditions!
   if (((colObj0) && colObj0->getActivationState() != ISLAND_SLEEPING) ||
    ((colObj1) && colObj1->getActivationState() != ISLAND_SLEEPING))
   {

    //kinematic objects don't merge islands, but wake up all connected objects
    if (colObj0->isKinematicObject() && colObj0->getActivationState() != ISLAND_SLEEPING)
    {
     if (colObj0->hasContactResponse())
      colObj1->activate();
    }
    if (colObj1->isKinematicObject() && colObj1->getActivationState() != ISLAND_SLEEPING)
    {
     if (colObj1->hasContactResponse())
      colObj0->activate();
    }
   }
  }
  btTypedConstraint** constraintsPtr = constraints.size() ? &constraints[0] : NULL;
  callback->processIsland(&collisionObjects[0],
   collisionObjects.size(),
   manifolds,
   maxNumManifolds,
   constraintsPtr,
   constraints.size(),
   -1
  );
 }
 else
 {
  initIslandPools();

  //traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
  addBodiesToIslands(collisionWorld);
  addManifoldsToIslands(dispatcher);
  addConstraintsToIslands(constraints);

  // m_activeIslands array should now contain all non-sleeping Islands, and each Island should
  // have all the necessary bodies, manifolds and constraints.

  // if we want to merge islands with small batch counts,
  if (m_minimumSolverBatchSize > 1)
  {
   mergeIslands();
  }
  // dispatch islands to solver
  m_islandDispatch(&m_activeIslands, callback);
 }
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///btDbvtBroadphase implementation by Nathanael Presson

#include "BulletCollision/BroadphaseCollision/btDbvtBroadphase.h"
#include "LinearMath/btThreads.h"

//
// Profiling
//

#if DBVT_BP_PROFILE||DBVT_BP_ENABLE_BENCHMARK
#include <stdio.h>
#endif

#if DBVT_BP_PROFILE
struct	ProfileScope
{
 __forceinline ProfileScope(btClock& clock, unsigned long& value) :
  m_clock(&clock), m_value(&value), m_base(clock.getTimeMicroseconds())
 {
 }
 __forceinline ~ProfileScope()
 {
  (*m_value) += m_clock->getTimeMicroseconds() - m_base;
 }
 btClock*		m_clock;
 unsigned long*	m_value;
 unsigned long	m_base;
};
#define	SPC(_value_)	ProfileScope	spc_scope(m_clock,_value_)
#else
#define	SPC(_value_)
#endif

//
// Helpers
//

//
template <typename T>
static inline void	listappend(T* item, T*& list)
{
 item->links[0] = 0;
 item->links[1] = list;
 if (list) list->links[0] = item;
 list = item;
}

//
template <typename T>
static inline void	listremove(T* item, T*& list)
{
 if (item->links[0]) item->links[0]->links[1] = item->links[1]; else list = item->links[1];
 if (item->links[1]) item->links[1]->links[0] = item->links[0];
}

//
template <typename T>
static inline int	listcount(T* root)
{
 int	n = 0;
 while (root) { ++n; root = root->links[1]; }
 return(n);
}

//
template <typename T>
static inline void	clear(T& value)
{
 static const struct ZeroDummy : T {} zerodummy;
 value = zerodummy;
}

//
// Colliders
//

/* Tree collider	*/
struct	btDbvtTreeCollider : btDbvt::ICollide
{
 btDbvtBroadphase*	pbp;
 btDbvtProxy*		proxy;
 btDbvtTreeCollider(btDbvtBroadphase* p) : pbp(p) {}
 void	Process(const btDbvtNode* na, const btDbvtNode* nb)
 {
  if (na != nb)
  {
   btDbvtProxy*	pa = (btDbvtProxy*)na->data;
   btDbvtProxy*	pb = (btDbvtProxy*)nb->data;
#if DBVT_BP_SORTPAIRS
   if (pa->m_uniqueId>pb->m_uniqueId)
    btSwap(pa, pb);
#endif
   pbp->m_paircache->addOverlappingPair(pa, pb);
   ++pbp->m_newpairs;
  }
 }
 void	Process(const btDbvtNode* n)
 {
  Process(n, proxy->leaf);
 }
};

//
// btDbvtBroadphase
//

//
btDbvtBroadphase::btDbvtBroadphase(btOverlappingPairCache* paircache)
{
 m_deferedcollide = false;
 m_needcleanup = true;
 m_releasepaircache = (paircache != 0) ? false : true;
 m_prediction = 0;
 m_stageCurrent = 0;
 m_fixedleft = 0;
 m_fupdates = 1;
 m_dupdates = 0;
 m_cupdates = 10;
 m_newpairs = 1;
 m_updates_call = 0;
 m_updates_done = 0;
 m_updates_ratio = 0;
 m_paircache = paircache ? paircache : new(btAlignedAlloc(sizeof(btHashedOverlappingPairCache), 16)) btHashedOverlappingPairCache();
 m_gid = 0;
 m_pid = 0;
 m_cid = 0;
 for (int i = 0; i <= STAGECOUNT; ++i)
 {
  m_stageRoots[i] = 0;
 }
#if BT_THREADSAFE
 m_rayTestStacks.resize(BT_MAX_THREAD_COUNT);
#else
 m_rayTestStacks.resize(1);
#endif
#if DBVT_BP_PROFILE
 clear(m_profiling);
#endif
}

//
btDbvtBroadphase::~btDbvtBroadphase()
{
 if (m_releasepaircache)
 {
  m_paircache->~btOverlappingPairCache();
  btAlignedFree(m_paircache);
 }
}

//
btBroadphaseProxy*				btDbvtBroadphase::createProxy(const btVector3& aabbMin,
 const btVector3& aabbMax,
 int /*shapeType*/,
 void* userPtr,
 int collisionFilterGroup,
 int collisionFilterMask,
 btDispatcher* /*dispatcher*/)
{
 btDbvtProxy*		proxy = new(btAlignedAlloc(sizeof(btDbvtProxy), 16)) btDbvtProxy(aabbMin, aabbMax, userPtr,
  collisionFilterGroup,
  collisionFilterMask);

 btDbvtAabbMm aabb = btDbvtVolume::FromMM(aabbMin, aabbMax);

 //bproxy->aabb			=	btDbvtVolume::FromMM(aabbMin,aabbMax);
 proxy->stage = m_stageCurrent;
 proxy->m_uniqueId = ++m_gid;
 proxy->leaf = m_sets[0].insert(aabb, proxy);
 listappend(proxy, m_stageRoots[m_stageCurrent]);
 if (!m_deferedcollide)
 {
  btDbvtTreeCollider	collider(this);
  collider.proxy = proxy;
  m_sets[0].collideTV(m_sets[0].m_root, aabb, collider);
  m_sets[1].collideTV(m_sets[1].m_root, aabb, collider);
 }
 return(proxy);
}

//
void							btDbvtBroadphase::destroyProxy(btBroadphaseProxy* absproxy,
 btDispatcher* dispatcher)
{
 btDbvtProxy*	proxy = (btDbvtProxy*)absproxy;
 if (proxy->stage == STAGECOUNT)
  m_sets[1].remove(proxy->leaf);
 else
  m_sets[0].remove(proxy->leaf);
 listremove(proxy, m_stageRoots[proxy->stage]);
 m_paircache->removeOverlappingPairsContainingProxy(proxy, dispatcher);
 btAlignedFree(proxy);
 m_needcleanup = true;
}

void	btDbvtBroadphase::getAabb(btBroadphaseProxy* absproxy, btVector3& aabbMin, btVector3& aabbMax) const
{
 btDbvtProxy*						proxy = (btDbvtProxy*)absproxy;
 aabbMin = proxy->m_aabbMin;
 aabbMax = proxy->m_aabbMax;
}

struct	BroadphaseRayTesterbtDbvt : btDbvt::ICollide
{
 btBroadphaseRayCallback& m_rayCallback;
 BroadphaseRayTesterbtDbvt(btBroadphaseRayCallback& orgCallback)
  :m_rayCallback(orgCallback)
 {
 }
 void					Process(const btDbvtNode* leaf)
 {
  btDbvtProxy*	proxy = (btDbvtProxy*)leaf->data;
  m_rayCallback.process(proxy);
 }
};

void	btDbvtBroadphase::rayTest(const btVector3& rayFrom, const btVector3& rayTo, btBroadphaseRayCallback& rayCallback, const btVector3& aabbMin, const btVector3& aabbMax)
{
 BroadphaseRayTesterbtDbvt callback(rayCallback);
 btAlignedObjectArray<const btDbvtNode*>* stack = &m_rayTestStacks[0];
#if BT_THREADSAFE
 // for this function to be threadsafe, each thread must have a separate copy
 // of this stack.  This could be thread-local static to avoid dynamic allocations,
 // instead of just a local.
 int threadIndex = btGetCurrentThreadIndex();
 btAlignedObjectArray<const btDbvtNode*> localStack;
 if (threadIndex < m_rayTestStacks.size())
 {
  // use per-thread preallocated stack if possible to avoid dynamic allocations
  stack = &m_rayTestStacks[threadIndex];
 }
 else
 {
  stack = &localStack;
 }
#endif

 m_sets[0].rayTestInternal(m_sets[0].m_root,
  rayFrom,
  rayTo,
  rayCallback.m_rayDirectionInverse,
  rayCallback.m_signs,
  rayCallback.m_lambda_max,
  aabbMin,
  aabbMax,
  *stack,
  callback);

 m_sets[1].rayTestInternal(m_sets[1].m_root,
  rayFrom,
  rayTo,
  rayCallback.m_rayDirectionInverse,
  rayCallback.m_signs,
  rayCallback.m_lambda_max,
  aabbMin,
  aabbMax,
  *stack,
  callback);

}


struct	BroadphaseAabbTesterbtDbvt : btDbvt::ICollide
{
 btBroadphaseAabbCallback& m_aabbCallback;
 BroadphaseAabbTesterbtDbvt(btBroadphaseAabbCallback& orgCallback)
  :m_aabbCallback(orgCallback)
 {
 }
 void					Process(const btDbvtNode* leaf)
 {
  btDbvtProxy*	proxy = (btDbvtProxy*)leaf->data;
  m_aabbCallback.process(proxy);
 }
};

void	btDbvtBroadphase::aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& aabbCallback)
{
 BroadphaseAabbTesterbtDbvt callback(aabbCallback);

 const ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds = btDbvtVolume::FromMM(aabbMin, aabbMax);
 //process all children, that overlap with  the given AABB bounds
 m_sets[0].collideTV(m_sets[0].m_root, bounds, callback);
 m_sets[1].collideTV(m_sets[1].m_root, bounds, callback);

}



//
void							btDbvtBroadphase::setAabb(btBroadphaseProxy* absproxy,
 const btVector3& aabbMin,
 const btVector3& aabbMax,
 btDispatcher* /*dispatcher*/)
{
 btDbvtProxy*						proxy = (btDbvtProxy*)absproxy;
 ATTRIBUTE_ALIGNED16(btDbvtVolume)	aabb = btDbvtVolume::FromMM(aabbMin, aabbMax);
#if DBVT_BP_PREVENTFALSEUPDATE
 if (NotEqual(aabb, proxy->leaf->volume))
#endif
 {
  bool	docollide = false;
  if (proxy->stage == STAGECOUNT)
  {/* fixed -> dynamic set	*/
   m_sets[1].remove(proxy->leaf);
   proxy->leaf = m_sets[0].insert(aabb, proxy);
   docollide = true;
  }
  else
  {/* dynamic set				*/
   ++m_updates_call;
   if (Intersect(proxy->leaf->volume, aabb))
   {/* Moving				*/

    const btVector3	delta = aabbMin - proxy->m_aabbMin;
    btVector3		velocity(((proxy->m_aabbMax - proxy->m_aabbMin) / 2)*m_prediction);
    if (delta[0]<0) velocity[0] = -velocity[0];
    if (delta[1]<0) velocity[1] = -velocity[1];
    if (delta[2]<0) velocity[2] = -velocity[2];
    if (
#ifdef DBVT_BP_MARGIN				
     m_sets[0].update(proxy->leaf, aabb, velocity, DBVT_BP_MARGIN)
#else
     m_sets[0].update(proxy->leaf, aabb, velocity)
#endif
     )
    {
     ++m_updates_done;
     docollide = true;
    }
   }
   else
   {/* Teleporting			*/
    m_sets[0].update(proxy->leaf, aabb);
    ++m_updates_done;
    docollide = true;
   }
  }
  listremove(proxy, m_stageRoots[proxy->stage]);
  proxy->m_aabbMin = aabbMin;
  proxy->m_aabbMax = aabbMax;
  proxy->stage = m_stageCurrent;
  listappend(proxy, m_stageRoots[m_stageCurrent]);
  if (docollide)
  {
   m_needcleanup = true;
   if (!m_deferedcollide)
   {
    btDbvtTreeCollider	collider(this);
    m_sets[1].collideTTpersistentStack(m_sets[1].m_root, proxy->leaf, collider);
    m_sets[0].collideTTpersistentStack(m_sets[0].m_root, proxy->leaf, collider);
   }
  }
 }
}


//
void							btDbvtBroadphase::setAabbForceUpdate(btBroadphaseProxy* absproxy,
 const btVector3& aabbMin,
 const btVector3& aabbMax,
 btDispatcher* /*dispatcher*/)
{
 btDbvtProxy*						proxy = (btDbvtProxy*)absproxy;
 ATTRIBUTE_ALIGNED16(btDbvtVolume)	aabb = btDbvtVolume::FromMM(aabbMin, aabbMax);
 bool	docollide = false;
 if (proxy->stage == STAGECOUNT)
 {/* fixed -> dynamic set	*/
  m_sets[1].remove(proxy->leaf);
  proxy->leaf = m_sets[0].insert(aabb, proxy);
  docollide = true;
 }
 else
 {/* dynamic set				*/
  ++m_updates_call;
  /* Teleporting			*/
  m_sets[0].update(proxy->leaf, aabb);
  ++m_updates_done;
  docollide = true;
 }
 listremove(proxy, m_stageRoots[proxy->stage]);
 proxy->m_aabbMin = aabbMin;
 proxy->m_aabbMax = aabbMax;
 proxy->stage = m_stageCurrent;
 listappend(proxy, m_stageRoots[m_stageCurrent]);
 if (docollide)
 {
  m_needcleanup = true;
  if (!m_deferedcollide)
  {
   btDbvtTreeCollider	collider(this);
   m_sets[1].collideTTpersistentStack(m_sets[1].m_root, proxy->leaf, collider);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, proxy->leaf, collider);
  }
 }
}

//
void							btDbvtBroadphase::calculateOverlappingPairs(btDispatcher* dispatcher)
{
 collide(dispatcher);
#if DBVT_BP_PROFILE
 if (0 == (m_pid%DBVT_BP_PROFILING_RATE))
 {
  printf("fixed(%u) dynamics(%u) pairs(%u)\r\n", m_sets[1].m_leaves, m_sets[0].m_leaves, m_paircache->getNumOverlappingPairs());
  unsigned int	total = m_profiling.m_total;
  if (total <= 0) total = 1;
  printf("ddcollide: %u%% (%uus)\r\n", (50 + m_profiling.m_ddcollide * 100) / total, m_profiling.m_ddcollide / DBVT_BP_PROFILING_RATE);
  printf("fdcollide: %u%% (%uus)\r\n", (50 + m_profiling.m_fdcollide * 100) / total, m_profiling.m_fdcollide / DBVT_BP_PROFILING_RATE);
  printf("cleanup:   %u%% (%uus)\r\n", (50 + m_profiling.m_cleanup * 100) / total, m_profiling.m_cleanup / DBVT_BP_PROFILING_RATE);
  printf("total:     %uus\r\n", total / DBVT_BP_PROFILING_RATE);
  const unsigned long	sum = m_profiling.m_ddcollide +
   m_profiling.m_fdcollide +
   m_profiling.m_cleanup;
  printf("leaked: %u%% (%uus)\r\n", 100 - ((50 + sum * 100) / total), (total - sum) / DBVT_BP_PROFILING_RATE);
  printf("job counts: %u%%\r\n", (m_profiling.m_jobcount * 100) / ((m_sets[0].m_leaves + m_sets[1].m_leaves)*DBVT_BP_PROFILING_RATE));
  clear(m_profiling);
  m_clock.reset();
 }
#endif

 performDeferredRemoval(dispatcher);

}

void btDbvtBroadphase::performDeferredRemoval(btDispatcher* dispatcher)
{

 if (m_paircache->hasDeferredRemoval())
 {

  btBroadphasePairArray&	overlappingPairArray = m_paircache->getOverlappingPairArray();

  //perform a sort, to find duplicates and to sort 'invalid' pairs to the end
  overlappingPairArray.quickSort(btBroadphasePairSortPredicate());

  int invalidPair = 0;


  int i;

  btBroadphasePair previousPair;
  previousPair.m_pProxy0 = 0;
  previousPair.m_pProxy1 = 0;
  previousPair.m_algorithm = 0;


  for (i = 0; i<overlappingPairArray.size(); i++)
  {

   btBroadphasePair& pair = overlappingPairArray[i];

   bool isDuplicate = (pair == previousPair);

   previousPair = pair;

   bool needsRemoval = false;

   if (!isDuplicate)
   {
    //important to perform AABB check that is consistent with the broadphase
    btDbvtProxy*		pa = (btDbvtProxy*)pair.m_pProxy0;
    btDbvtProxy*		pb = (btDbvtProxy*)pair.m_pProxy1;
    bool hasOverlap = Intersect(pa->leaf->volume, pb->leaf->volume);

    if (hasOverlap)
    {
     needsRemoval = false;
    }
    else
    {
     needsRemoval = true;
    }
   }
   else
   {
    //remove duplicate
    needsRemoval = true;
    //should have no algorithm
    btAssert(!pair.m_algorithm);
   }

   if (needsRemoval)
   {
    m_paircache->cleanOverlappingPair(pair, dispatcher);

    pair.m_pProxy0 = 0;
    pair.m_pProxy1 = 0;
    invalidPair++;
   }

  }

  //perform a sort, to sort 'invalid' pairs to the end
  overlappingPairArray.quickSort(btBroadphasePairSortPredicate());
  overlappingPairArray.resize(overlappingPairArray.size() - invalidPair);
 }
}

//
void							btDbvtBroadphase::collide(btDispatcher* dispatcher)
{
 /*printf("---------------------------------------------------------\n");
 printf("m_sets[0].m_leaves=%d\n",m_sets[0].m_leaves);
 printf("m_sets[1].m_leaves=%d\n",m_sets[1].m_leaves);
 printf("numPairs = %d\n",getOverlappingPairCache()->getNumOverlappingPairs());
 {
 int i;
 for (i=0;i<getOverlappingPairCache()->getNumOverlappingPairs();i++)
 {
 printf("pair[%d]=(%d,%d),",i,getOverlappingPairCache()->getOverlappingPairArray()[i].m_pProxy0->getUid(),
 getOverlappingPairCache()->getOverlappingPairArray()[i].m_pProxy1->getUid());
 }
 printf("\n");
 }
 */



 SPC(m_profiling.m_total);
 /* optimize				*/
 m_sets[0].optimizeIncremental(1 + (m_sets[0].m_leaves*m_dupdates) / 100);
 if (m_fixedleft)
 {
  const int count = 1 + (m_sets[1].m_leaves*m_fupdates) / 100;
  m_sets[1].optimizeIncremental(1 + (m_sets[1].m_leaves*m_fupdates) / 100);
  m_fixedleft = btMax<int>(0, m_fixedleft - count);
 }
 /* dynamic -> fixed set	*/
 m_stageCurrent = (m_stageCurrent + 1) % STAGECOUNT;
 btDbvtProxy*	current = m_stageRoots[m_stageCurrent];
 if (current)
 {
#if DBVT_BP_ACCURATESLEEPING
  btDbvtTreeCollider	collider(this);
#endif
  do {
   btDbvtProxy*	next = current->links[1];
   listremove(current, m_stageRoots[current->stage]);
   listappend(current, m_stageRoots[STAGECOUNT]);
#if DBVT_BP_ACCURATESLEEPING
   m_paircache->removeOverlappingPairsContainingProxy(current, dispatcher);
   collider.proxy = current;
   btDbvt::collideTV(m_sets[0].m_root, current->aabb, collider);
   btDbvt::collideTV(m_sets[1].m_root, current->aabb, collider);
#endif
   m_sets[0].remove(current->leaf);
   ATTRIBUTE_ALIGNED16(btDbvtVolume)	curAabb = btDbvtVolume::FromMM(current->m_aabbMin, current->m_aabbMax);
   current->leaf = m_sets[1].insert(curAabb, current);
   current->stage = STAGECOUNT;
   current = next;
  } while (current);
  m_fixedleft = m_sets[1].m_leaves;
  m_needcleanup = true;
 }
 /* collide dynamics		*/
 {
  btDbvtTreeCollider	collider(this);
  if (m_deferedcollide)
  {
   SPC(m_profiling.m_fdcollide);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, m_sets[1].m_root, collider);
  }
  if (m_deferedcollide)
  {
   SPC(m_profiling.m_ddcollide);
   m_sets[0].collideTTpersistentStack(m_sets[0].m_root, m_sets[0].m_root, collider);
  }
 }
 /* clean up				*/
 if (m_needcleanup)
 {
  SPC(m_profiling.m_cleanup);
  btBroadphasePairArray&	pairs = m_paircache->getOverlappingPairArray();
  if (pairs.size()>0)
  {

   int			ni = btMin(pairs.size(), btMax<int>(m_newpairs, (pairs.size()*m_cupdates) / 100));
   for (int i = 0; i<ni; ++i)
   {
    btBroadphasePair&	p = pairs[(m_cid + i) % pairs.size()];
    btDbvtProxy*		pa = (btDbvtProxy*)p.m_pProxy0;
    btDbvtProxy*		pb = (btDbvtProxy*)p.m_pProxy1;
    if (!Intersect(pa->leaf->volume, pb->leaf->volume))
    {
#if DBVT_BP_SORTPAIRS
     if (pa->m_uniqueId>pb->m_uniqueId)
      btSwap(pa, pb);
#endif
     m_paircache->removeOverlappingPair(pa, pb, dispatcher);
     --ni; --i;
    }
   }
   if (pairs.size()>0) m_cid = (m_cid + ni) % pairs.size(); else m_cid = 0;
  }
 }
 ++m_pid;
 m_newpairs = 1;
 m_needcleanup = false;
 if (m_updates_call>0)
 {
  m_updates_ratio = m_updates_done / (btScalar)m_updates_call;
 }
 else
 {
  m_updates_ratio = 0;
 }
 m_updates_done /= 2;
 m_updates_call /= 2;
}

//
void							btDbvtBroadphase::optimize()
{
 m_sets[0].optimizeTopDown();
 m_sets[1].optimizeTopDown();
}

//
btOverlappingPairCache*			btDbvtBroadphase::getOverlappingPairCache()
{
 return(m_paircache);
}

//
const btOverlappingPairCache*	btDbvtBroadphase::getOverlappingPairCache() const
{
 return(m_paircache);
}

//
void							btDbvtBroadphase::getBroadphaseAabb(btVector3& aabbMin, btVector3& aabbMax) const
{

 ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds;

 if (!m_sets[0].empty())
  if (!m_sets[1].empty())	Merge(m_sets[0].m_root->volume,
   m_sets[1].m_root->volume, bounds);
  else
   bounds = m_sets[0].m_root->volume;
 else if (!m_sets[1].empty())	bounds = m_sets[1].m_root->volume;
 else
  bounds = btDbvtVolume::FromCR(btVector3(0, 0, 0), 0);
 aabbMin = bounds.Mins();
 aabbMax = bounds.Maxs();
}

void btDbvtBroadphase::resetPool(btDispatcher* dispatcher)
{

 int totalObjects = m_sets[0].m_leaves + m_sets[1].m_leaves;
 if (!totalObjects)
 {
  //reset internal dynamic tree data structures
  m_sets[0].clear();
  m_sets[1].clear();

  m_deferedcollide = false;
  m_needcleanup = true;
  m_stageCurrent = 0;
  m_fixedleft = 0;
  m_fupdates = 1;
  m_dupdates = 0;
  m_cupdates = 10;
  m_newpairs = 1;
  m_updates_call = 0;
  m_updates_done = 0;
  m_updates_ratio = 0;

  m_gid = 0;
  m_pid = 0;
  m_cid = 0;
  for (int i = 0; i <= STAGECOUNT; ++i)
  {
   m_stageRoots[i] = 0;
  }
 }
}

//
void							btDbvtBroadphase::printStats()
{}

//
#if DBVT_BP_ENABLE_BENCHMARK

struct	btBroadphaseBenchmark
{
 struct	Experiment
 {
  const char*			name;
  int					object_count;
  int					update_count;
  int					spawn_count;
  int					iterations;
  btScalar			speed;
  btScalar			amplitude;
 };
 struct	Object
 {
  btVector3			center;
  btVector3			extents;
  btBroadphaseProxy*	proxy;
  btScalar			time;
  void				update(btScalar speed, btScalar amplitude, btBroadphaseInterface* pbi)
  {
   time += speed;
   center[0] = btCos(time*(btScalar)2.17)*amplitude +
    btSin(time)*amplitude / 2;
   center[1] = btCos(time*(btScalar)1.38)*amplitude +
    btSin(time)*amplitude;
   center[2] = btSin(time*(btScalar)0.777)*amplitude;
   pbi->setAabb(proxy, center - extents, center + extents, 0);
  }
 };
 static int		UnsignedRand(int range = RAND_MAX - 1) { return(rand() % (range + 1)); }
 static btScalar	UnitRand() { return(UnsignedRand(16384) / (btScalar)16384); }
 static void		OutputTime(const char* name, btClock& c, unsigned count = 0)
 {
  const unsigned long	us = c.getTimeMicroseconds();
  const unsigned long	ms = (us + 500) / 1000;
  const btScalar		sec = us / (btScalar)(1000 * 1000);
  if (count>0)
   printf("%s : %u us (%u ms), %.2f/s\r\n", name, us, ms, count / sec);
  else
   printf("%s : %u us (%u ms)\r\n", name, us, ms);
 }
};

void							btDbvtBroadphase::benchmark(btBroadphaseInterface* pbi)
{
 static const btBroadphaseBenchmark::Experiment		experiments[] =
 {
  { "1024o.10%",1024,10,0,8192,(btScalar)0.005,(btScalar)100 },
  /*{"4096o.10%",4096,10,0,8192,(btScalar)0.005,(btScalar)100},
  {"8192o.10%",8192,10,0,8192,(btScalar)0.005,(btScalar)100},*/
 };
 static const int										nexperiments = sizeof(experiments) / sizeof(experiments[0]);
 btAlignedObjectArray<btBroadphaseBenchmark::Object*>	objects;
 btClock													wallclock;
 /* Begin			*/
 for (int iexp = 0; iexp<nexperiments; ++iexp)
 {
  const btBroadphaseBenchmark::Experiment&	experiment = experiments[iexp];
  const int									object_count = experiment.object_count;
  const int									update_count = (object_count*experiment.update_count) / 100;
  const int									spawn_count = (object_count*experiment.spawn_count) / 100;
  const btScalar								speed = experiment.speed;
  const btScalar								amplitude = experiment.amplitude;
  printf("Experiment #%u '%s':\r\n", iexp, experiment.name);
  printf("\tObjects: %u\r\n", object_count);
  printf("\tUpdate: %u\r\n", update_count);
  printf("\tSpawn: %u\r\n", spawn_count);
  printf("\tSpeed: %f\r\n", speed);
  printf("\tAmplitude: %f\r\n", amplitude);
  srand(180673);
  /* Create objects	*/
  wallclock.reset();
  objects.reserve(object_count);
  for (int i = 0; i<object_count; ++i)
  {
   btBroadphaseBenchmark::Object*	po = new btBroadphaseBenchmark::Object();
   po->center[0] = btBroadphaseBenchmark::UnitRand() * 50;
   po->center[1] = btBroadphaseBenchmark::UnitRand() * 50;
   po->center[2] = btBroadphaseBenchmark::UnitRand() * 50;
   po->extents[0] = btBroadphaseBenchmark::UnitRand() * 2 + 2;
   po->extents[1] = btBroadphaseBenchmark::UnitRand() * 2 + 2;
   po->extents[2] = btBroadphaseBenchmark::UnitRand() * 2 + 2;
   po->time = btBroadphaseBenchmark::UnitRand() * 2000;
   po->proxy = pbi->createProxy(po->center - po->extents, po->center + po->extents, 0, po, 1, 1, 0, 0);
   objects.push_back(po);
  }
  btBroadphaseBenchmark::OutputTime("\tInitialization", wallclock);
  /* First update		*/
  wallclock.reset();
  for (int i = 0; i<objects.size(); ++i)
  {
   objects[i]->update(speed, amplitude, pbi);
  }
  btBroadphaseBenchmark::OutputTime("\tFirst update", wallclock);
  /* Updates			*/
  wallclock.reset();
  for (int i = 0; i<experiment.iterations; ++i)
  {
   for (int j = 0; j<update_count; ++j)
   {
    objects[j]->update(speed, amplitude, pbi);
   }
   pbi->calculateOverlappingPairs(0);
  }
  btBroadphaseBenchmark::OutputTime("\tUpdate", wallclock, experiment.iterations);
  /* Clean up			*/
  wallclock.reset();
  for (int i = 0; i<objects.size(); ++i)
  {
   pbi->destroyProxy(objects[i]->proxy, 0);
   delete objects[i];
  }
  objects.resize(0);
  btBroadphaseBenchmark::OutputTime("\tRelease", wallclock);
 }

}
#else
void							btDbvtBroadphase::benchmark(btBroadphaseInterface*)
{}
#endif

#if DBVT_BP_PROFILE
#undef	SPC
#endif

/*************************************************************************
*                                                                       *
* Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.       *
* All rights reserved.  Email: russ@q12.org   Web: www.q12.org          *
*                                                                       *
* This library is free software; you can redistribute it and/or         *
* modify it under the terms of EITHER:                                  *
*   (1) The GNU Lesser General Public License as published by the Free  *
*       Software Foundation; either version 2.1 of the License, or (at  *
*       your option) any later version. The text of the GNU Lesser      *
*       General Public License is included with this library in the     *
*       file LICENSE.TXT.                                               *
*   (2) The BSD-style license that is included with this library in     *
*       the file LICENSE-BSD.TXT.                                       *
*                                                                       *
* This library is distributed in the hope that it will be useful,       *
* but WITHOUT ANY WARRANTY; without even the implied warranty of        *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *
* LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *
*                                                                       *
*************************************************************************/

/*


THE ALGORITHM
-------------

solve A*x = b+w, with x and w subject to certain LCP conditions.
each x(i),w(i) must lie on one of the three line segments in the following
diagram. each line segment corresponds to one index set :

w(i)
/|\      |           :
|       |           :
|       |i in N     :
w>0 |       |state[i]=0 :
|       |           :
|       |           :  i in C
w=0 +       +-----------------------+
|                   :           |
|                   :           |
w<0 |                   :           |i in N
|                   :           |state[i]=1
|                   :           |
|                   :           |
+-------|-----------|-----------|----------> x(i)
lo           0           hi

the Dantzig algorithm proceeds as follows:
for i=1:n
* if (x(i),w(i)) is not on the line, push x(i) and w(i) positive or
negative towards the line. as this is done, the other (x(j),w(j))
for j<i are constrained to be on the line. if any (x,w) reaches the
end of a line segment then it is switched between index sets.
* i is added to the appropriate index set depending on what line segment
it hits.

we restrict lo(i) <= 0 and hi(i) >= 0. this makes the algorithm a bit
simpler, because the starting point for x(i),w(i) is always on the dotted
line x=0 and x will only ever increase in one direction, so it can only hit
two out of the three line segments.


NOTES
-----

this is an implementation of "lcp_dantzig2_ldlt.m" and "lcp_dantzig_lohi.m".
the implementation is split into an LCP problem object (btLCP) and an LCP
driver function. most optimization occurs in the btLCP object.

a naive implementation of the algorithm requires either a lot of data motion
or a lot of permutation-array lookup, because we are constantly re-ordering
rows and columns. to avoid this and make a more optimized algorithm, a
non-trivial data structure is used to represent the matrix A (this is
implemented in the fast version of the btLCP object).

during execution of this algorithm, some indexes in A are clamped (set C),
some are non-clamped (set N), and some are "don't care" (where x=0).
A,x,b,w (and other problem vectors) are permuted such that the clamped
indexes are first, the unclamped indexes are next, and the don't-care
indexes are last. this permutation is recorded in the array `p'.
initially p = 0..n-1, and as the rows and columns of A,x,b,w are swapped,
the corresponding elements of p are swapped.

because the C and N elements are grouped together in the rows of A, we can do
lots of work with a fast dot product function. if A,x,etc were not permuted
and we only had a permutation array, then those dot products would be much
slower as we would have a permutation array lookup in some inner loops.

A is accessed through an array of row pointers, so that element (i,j) of the
permuted matrix is A[i][j]. this makes row swapping fast. for column swapping
we still have to actually move the data.

during execution of this algorithm we maintain an L*D*L' factorization of
the clamped submatrix of A (call it `AC') which is the top left nC*nC
submatrix of A. there are two ways we could arrange the rows/columns in AC.

(1) AC is always permuted such that L*D*L' = AC. this causes a problem
when a row/column is removed from C, because then all the rows/columns of A
between the deleted index and the end of C need to be rotated downward.
this results in a lot of data motion and slows things down.
(2) L*D*L' is actually a factorization of a *permutation* of AC (which is
itself a permutation of the underlying A). this is what we do - the
permutation is recorded in the vector C. call this permutation A[C,C].
when a row/column is removed from C, all we have to do is swap two
rows/columns and manipulate C.

*/


#include "BulletDynamics/MLCPSolvers/btDantzigLCP.h"

#include <string.h>//memcpy

bool s_error = false;

//***************************************************************************
// code generation parameters


#define btLCP_FAST		// use fast btLCP object

// option 1 : matrix row pointers (less data copying)
#define BTROWPTRS
#define BTATYPE btScalar **
#define BTAROW(i) (m_A[i])

// option 2 : no matrix row pointers (slightly faster inner loops)
//#define NOROWPTRS
//#define BTATYPE btScalar *
//#define BTAROW(i) (m_A+(i)*m_nskip)

#define BTNUB_OPTIMIZATIONS



/* solve L*X=B, with B containing 1 right hand sides.
* L is an n*n lower triangular matrix with ones on the diagonal.
* L is stored by rows and its leading dimension is lskip.
* B is an n*1 matrix that contains the right hand sides.
* B is stored by columns and its leading dimension is also lskip.
* B is overwritten with X.
* this processes blocks of 2*2.
* if this is in the factorizer source file, n must be a multiple of 2.
*/

static void btSolveL1_1(const btScalar *L, btScalar *B, int n, int lskip1)
{
 /* declare variables - Z matrix, p and q vectors, etc */
 btScalar Z11, m11, Z21, m21, p1, q1, p2, *ex;
 const btScalar *ell;
 int i, j;
 /* compute all 2 x 1 blocks of X */
 for (i = 0; i < n; i += 2) {
  /* compute all 2 x 1 block of X, from rows i..i+2-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  Z21 = 0;
  ell = L + i*lskip1;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 2; j >= 0; j -= 2) {
   /* compute outer product and add it to the Z matrix */
   p1 = ell[0];
   q1 = ex[0];
   m11 = p1 * q1;
   p2 = ell[lskip1];
   m21 = p2 * q1;
   Z11 += m11;
   Z21 += m21;
   /* compute outer product and add it to the Z matrix */
   p1 = ell[1];
   q1 = ex[1];
   m11 = p1 * q1;
   p2 = ell[1 + lskip1];
   m21 = p2 * q1;
   /* advance pointers */
   ell += 2;
   ex += 2;
   Z11 += m11;
   Z21 += m21;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 2;
  for (; j > 0; j--) {
   /* compute outer product and add it to the Z matrix */
   p1 = ell[0];
   q1 = ex[0];
   m11 = p1 * q1;
   p2 = ell[lskip1];
   m21 = p2 * q1;
   /* advance pointers */
   ell += 1;
   ex += 1;
   Z11 += m11;
   Z21 += m21;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
  p1 = ell[lskip1];
  Z21 = ex[1] - Z21 - p1*Z11;
  ex[1] = Z21;
  /* end of outer loop */
 }
}

/* solve L*X=B, with B containing 2 right hand sides.
* L is an n*n lower triangular matrix with ones on the diagonal.
* L is stored by rows and its leading dimension is lskip.
* B is an n*2 matrix that contains the right hand sides.
* B is stored by columns and its leading dimension is also lskip.
* B is overwritten with X.
* this processes blocks of 2*2.
* if this is in the factorizer source file, n must be a multiple of 2.
*/

static void btSolveL1_2(const btScalar *L, btScalar *B, int n, int lskip1)
{
 /* declare variables - Z matrix, p and q vectors, etc */
 btScalar Z11, m11, Z12, m12, Z21, m21, Z22, m22, p1, q1, p2, q2, *ex;
 const btScalar *ell;
 int i, j;
 /* compute all 2 x 2 blocks of X */
 for (i = 0; i < n; i += 2) {
  /* compute all 2 x 2 block of X, from rows i..i+2-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  Z12 = 0;
  Z21 = 0;
  Z22 = 0;
  ell = L + i*lskip1;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 2; j >= 0; j -= 2) {
   /* compute outer product and add it to the Z matrix */
   p1 = ell[0];
   q1 = ex[0];
   m11 = p1 * q1;
   q2 = ex[lskip1];
   m12 = p1 * q2;
   p2 = ell[lskip1];
   m21 = p2 * q1;
   m22 = p2 * q2;
   Z11 += m11;
   Z12 += m12;
   Z21 += m21;
   Z22 += m22;
   /* compute outer product and add it to the Z matrix */
   p1 = ell[1];
   q1 = ex[1];
   m11 = p1 * q1;
   q2 = ex[1 + lskip1];
   m12 = p1 * q2;
   p2 = ell[1 + lskip1];
   m21 = p2 * q1;
   m22 = p2 * q2;
   /* advance pointers */
   ell += 2;
   ex += 2;
   Z11 += m11;
   Z12 += m12;
   Z21 += m21;
   Z22 += m22;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 2;
  for (; j > 0; j--) {
   /* compute outer product and add it to the Z matrix */
   p1 = ell[0];
   q1 = ex[0];
   m11 = p1 * q1;
   q2 = ex[lskip1];
   m12 = p1 * q2;
   p2 = ell[lskip1];
   m21 = p2 * q1;
   m22 = p2 * q2;
   /* advance pointers */
   ell += 1;
   ex += 1;
   Z11 += m11;
   Z12 += m12;
   Z21 += m21;
   Z22 += m22;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
  Z12 = ex[lskip1] - Z12;
  ex[lskip1] = Z12;
  p1 = ell[lskip1];
  Z21 = ex[1] - Z21 - p1*Z11;
  ex[1] = Z21;
  Z22 = ex[1 + lskip1] - Z22 - p1*Z12;
  ex[1 + lskip1] = Z22;
  /* end of outer loop */
 }
}


void btFactorLDLT(btScalar *A, btScalar *d, int n, int nskip1)
{
 int i, j;
 btScalar sum, *ell, *dee, dd, p1, p2, q1, q2, Z11, m11, Z21, m21, Z22, m22;
 if (n < 1) return;

 for (i = 0; i <= n - 2; i += 2) {
  /* solve L*(D*l)=a, l is scaled elements in 2 x i block at A(i,0) */
  btSolveL1_2(A, A + i*nskip1, i, nskip1);
  /* scale the elements in a 2 x i block at A(i,0), and also */
  /* compute Z = the outer product matrix that we'll need. */
  Z11 = 0;
  Z21 = 0;
  Z22 = 0;
  ell = A + i*nskip1;
  dee = d;
  for (j = i - 6; j >= 0; j -= 6) {
   p1 = ell[0];
   p2 = ell[nskip1];
   dd = dee[0];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[0] = q1;
   ell[nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   p1 = ell[1];
   p2 = ell[1 + nskip1];
   dd = dee[1];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[1] = q1;
   ell[1 + nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   p1 = ell[2];
   p2 = ell[2 + nskip1];
   dd = dee[2];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[2] = q1;
   ell[2 + nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   p1 = ell[3];
   p2 = ell[3 + nskip1];
   dd = dee[3];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[3] = q1;
   ell[3 + nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   p1 = ell[4];
   p2 = ell[4 + nskip1];
   dd = dee[4];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[4] = q1;
   ell[4 + nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   p1 = ell[5];
   p2 = ell[5 + nskip1];
   dd = dee[5];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[5] = q1;
   ell[5 + nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   ell += 6;
   dee += 6;
  }
  /* compute left-over iterations */
  j += 6;
  for (; j > 0; j--) {
   p1 = ell[0];
   p2 = ell[nskip1];
   dd = dee[0];
   q1 = p1*dd;
   q2 = p2*dd;
   ell[0] = q1;
   ell[nskip1] = q2;
   m11 = p1*q1;
   m21 = p2*q1;
   m22 = p2*q2;
   Z11 += m11;
   Z21 += m21;
   Z22 += m22;
   ell++;
   dee++;
  }
  /* solve for diagonal 2 x 2 block at A(i,i) */
  Z11 = ell[0] - Z11;
  Z21 = ell[nskip1] - Z21;
  Z22 = ell[1 + nskip1] - Z22;
  dee = d + i;
  /* factorize 2 x 2 block Z,dee */
  /* factorize row 1 */
  dee[0] = btRecip(Z11);
  /* factorize row 2 */
  sum = 0;
  q1 = Z21;
  q2 = q1 * dee[0];
  Z21 = q2;
  sum += q1*q2;
  dee[1] = btRecip(Z22 - sum);
  /* done factorizing 2 x 2 block */
  ell[nskip1] = Z21;
 }
 /* compute the (less than 2) rows at the bottom */
 switch (n - i) {
 case 0:
  break;

 case 1:
  btSolveL1_1(A, A + i*nskip1, i, nskip1);
  /* scale the elements in a 1 x i block at A(i,0), and also */
  /* compute Z = the outer product matrix that we'll need. */
  Z11 = 0;
  ell = A + i*nskip1;
  dee = d;
  for (j = i - 6; j >= 0; j -= 6) {
   p1 = ell[0];
   dd = dee[0];
   q1 = p1*dd;
   ell[0] = q1;
   m11 = p1*q1;
   Z11 += m11;
   p1 = ell[1];
   dd = dee[1];
   q1 = p1*dd;
   ell[1] = q1;
   m11 = p1*q1;
   Z11 += m11;
   p1 = ell[2];
   dd = dee[2];
   q1 = p1*dd;
   ell[2] = q1;
   m11 = p1*q1;
   Z11 += m11;
   p1 = ell[3];
   dd = dee[3];
   q1 = p1*dd;
   ell[3] = q1;
   m11 = p1*q1;
   Z11 += m11;
   p1 = ell[4];
   dd = dee[4];
   q1 = p1*dd;
   ell[4] = q1;
   m11 = p1*q1;
   Z11 += m11;
   p1 = ell[5];
   dd = dee[5];
   q1 = p1*dd;
   ell[5] = q1;
   m11 = p1*q1;
   Z11 += m11;
   ell += 6;
   dee += 6;
  }
  /* compute left-over iterations */
  j += 6;
  for (; j > 0; j--) {
   p1 = ell[0];
   dd = dee[0];
   q1 = p1*dd;
   ell[0] = q1;
   m11 = p1*q1;
   Z11 += m11;
   ell++;
   dee++;
  }
  /* solve for diagonal 1 x 1 block at A(i,i) */
  Z11 = ell[0] - Z11;
  dee = d + i;
  /* factorize 1 x 1 block Z,dee */
  /* factorize row 1 */
  dee[0] = btRecip(Z11);
  /* done factorizing 1 x 1 block */
  break;

  //default: *((char*)0)=0;  /* this should never happen! */
 }
}

/* solve L*X=B, with B containing 1 right hand sides.
* L is an n*n lower triangular matrix with ones on the diagonal.
* L is stored by rows and its leading dimension is lskip.
* B is an n*1 matrix that contains the right hand sides.
* B is stored by columns and its leading dimension is also lskip.
* B is overwritten with X.
* this processes blocks of 4*4.
* if this is in the factorizer source file, n must be a multiple of 4.
*/

void btSolveL1(const btScalar *L, btScalar *B, int n, int lskip1)
{
 /* declare variables - Z matrix, p and q vectors, etc */
 btScalar Z11, Z21, Z31, Z41, p1, q1, p2, p3, p4, *ex;
 const btScalar *ell;
 int lskip2, lskip3, i, j;
 /* compute lskip values */
 lskip2 = 2 * lskip1;
 lskip3 = 3 * lskip1;
 /* compute all 4 x 1 blocks of X */
 for (i = 0; i <= n - 4; i += 4) {
  /* compute all 4 x 1 block of X, from rows i..i+4-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  Z21 = 0;
  Z31 = 0;
  Z41 = 0;
  ell = L + i*lskip1;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 12; j >= 0; j -= 12) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   p2 = ell[lskip1];
   p3 = ell[lskip2];
   p4 = ell[lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[1];
   q1 = ex[1];
   p2 = ell[1 + lskip1];
   p3 = ell[1 + lskip2];
   p4 = ell[1 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[2];
   q1 = ex[2];
   p2 = ell[2 + lskip1];
   p3 = ell[2 + lskip2];
   p4 = ell[2 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[3];
   q1 = ex[3];
   p2 = ell[3 + lskip1];
   p3 = ell[3 + lskip2];
   p4 = ell[3 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[4];
   q1 = ex[4];
   p2 = ell[4 + lskip1];
   p3 = ell[4 + lskip2];
   p4 = ell[4 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[5];
   q1 = ex[5];
   p2 = ell[5 + lskip1];
   p3 = ell[5 + lskip2];
   p4 = ell[5 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[6];
   q1 = ex[6];
   p2 = ell[6 + lskip1];
   p3 = ell[6 + lskip2];
   p4 = ell[6 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[7];
   q1 = ex[7];
   p2 = ell[7 + lskip1];
   p3 = ell[7 + lskip2];
   p4 = ell[7 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[8];
   q1 = ex[8];
   p2 = ell[8 + lskip1];
   p3 = ell[8 + lskip2];
   p4 = ell[8 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[9];
   q1 = ex[9];
   p2 = ell[9 + lskip1];
   p3 = ell[9 + lskip2];
   p4 = ell[9 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[10];
   q1 = ex[10];
   p2 = ell[10 + lskip1];
   p3 = ell[10 + lskip2];
   p4 = ell[10 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* load p and q values */
   p1 = ell[11];
   q1 = ex[11];
   p2 = ell[11 + lskip1];
   p3 = ell[11 + lskip2];
   p4 = ell[11 + lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* advance pointers */
   ell += 12;
   ex += 12;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 12;
  for (; j > 0; j--) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   p2 = ell[lskip1];
   p3 = ell[lskip2];
   p4 = ell[lskip3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   Z21 += p2 * q1;
   Z31 += p3 * q1;
   Z41 += p4 * q1;
   /* advance pointers */
   ell += 1;
   ex += 1;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
  p1 = ell[lskip1];
  Z21 = ex[1] - Z21 - p1*Z11;
  ex[1] = Z21;
  p1 = ell[lskip2];
  p2 = ell[1 + lskip2];
  Z31 = ex[2] - Z31 - p1*Z11 - p2*Z21;
  ex[2] = Z31;
  p1 = ell[lskip3];
  p2 = ell[1 + lskip3];
  p3 = ell[2 + lskip3];
  Z41 = ex[3] - Z41 - p1*Z11 - p2*Z21 - p3*Z31;
  ex[3] = Z41;
  /* end of outer loop */
 }
 /* compute rows at end that are not a multiple of block size */
 for (; i < n; i++) {
  /* compute all 1 x 1 block of X, from rows i..i+1-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  ell = L + i*lskip1;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 12; j >= 0; j -= 12) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[1];
   q1 = ex[1];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[2];
   q1 = ex[2];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[3];
   q1 = ex[3];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[4];
   q1 = ex[4];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[5];
   q1 = ex[5];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[6];
   q1 = ex[6];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[7];
   q1 = ex[7];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[8];
   q1 = ex[8];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[9];
   q1 = ex[9];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[10];
   q1 = ex[10];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* load p and q values */
   p1 = ell[11];
   q1 = ex[11];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* advance pointers */
   ell += 12;
   ex += 12;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 12;
  for (; j > 0; j--) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   /* compute outer product and add it to the Z matrix */
   Z11 += p1 * q1;
   /* advance pointers */
   ell += 1;
   ex += 1;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
 }
}

/* solve L^T * x=b, with b containing 1 right hand side.
* L is an n*n lower triangular matrix with ones on the diagonal.
* L is stored by rows and its leading dimension is lskip.
* b is an n*1 matrix that contains the right hand side.
* b is overwritten with x.
* this processes blocks of 4.
*/

void btSolveL1T(const btScalar *L, btScalar *B, int n, int lskip1)
{
 /* declare variables - Z matrix, p and q vectors, etc */
 btScalar Z11, m11, Z21, m21, Z31, m31, Z41, m41, p1, q1, p2, p3, p4, *ex;
 const btScalar *ell;
 int lskip2, i, j;
 //  int lskip3;
 /* special handling for L and B because we're solving L1 *transpose* */
 L = L + (n - 1)*(lskip1 + 1);
 B = B + n - 1;
 lskip1 = -lskip1;
 /* compute lskip values */
 lskip2 = 2 * lskip1;
 //lskip3 = 3*lskip1;
 /* compute all 4 x 1 blocks of X */
 for (i = 0; i <= n - 4; i += 4) {
  /* compute all 4 x 1 block of X, from rows i..i+4-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  Z21 = 0;
  Z31 = 0;
  Z41 = 0;
  ell = L - i;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 4; j >= 0; j -= 4) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   p2 = ell[-1];
   p3 = ell[-2];
   p4 = ell[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   m21 = p2 * q1;
   m31 = p3 * q1;
   m41 = p4 * q1;
   ell += lskip1;
   Z11 += m11;
   Z21 += m21;
   Z31 += m31;
   Z41 += m41;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-1];
   p2 = ell[-1];
   p3 = ell[-2];
   p4 = ell[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   m21 = p2 * q1;
   m31 = p3 * q1;
   m41 = p4 * q1;
   ell += lskip1;
   Z11 += m11;
   Z21 += m21;
   Z31 += m31;
   Z41 += m41;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-2];
   p2 = ell[-1];
   p3 = ell[-2];
   p4 = ell[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   m21 = p2 * q1;
   m31 = p3 * q1;
   m41 = p4 * q1;
   ell += lskip1;
   Z11 += m11;
   Z21 += m21;
   Z31 += m31;
   Z41 += m41;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-3];
   p2 = ell[-1];
   p3 = ell[-2];
   p4 = ell[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   m21 = p2 * q1;
   m31 = p3 * q1;
   m41 = p4 * q1;
   ell += lskip1;
   ex -= 4;
   Z11 += m11;
   Z21 += m21;
   Z31 += m31;
   Z41 += m41;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 4;
  for (; j > 0; j--) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   p2 = ell[-1];
   p3 = ell[-2];
   p4 = ell[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   m21 = p2 * q1;
   m31 = p3 * q1;
   m41 = p4 * q1;
   ell += lskip1;
   ex -= 1;
   Z11 += m11;
   Z21 += m21;
   Z31 += m31;
   Z41 += m41;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
  p1 = ell[-1];
  Z21 = ex[-1] - Z21 - p1*Z11;
  ex[-1] = Z21;
  p1 = ell[-2];
  p2 = ell[-2 + lskip1];
  Z31 = ex[-2] - Z31 - p1*Z11 - p2*Z21;
  ex[-2] = Z31;
  p1 = ell[-3];
  p2 = ell[-3 + lskip1];
  p3 = ell[-3 + lskip2];
  Z41 = ex[-3] - Z41 - p1*Z11 - p2*Z21 - p3*Z31;
  ex[-3] = Z41;
  /* end of outer loop */
 }
 /* compute rows at end that are not a multiple of block size */
 for (; i < n; i++) {
  /* compute all 1 x 1 block of X, from rows i..i+1-1 */
  /* set the Z matrix to 0 */
  Z11 = 0;
  ell = L - i;
  ex = B;
  /* the inner loop that computes outer products and adds them to Z */
  for (j = i - 4; j >= 0; j -= 4) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   ell += lskip1;
   Z11 += m11;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-1];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   ell += lskip1;
   Z11 += m11;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-2];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   ell += lskip1;
   Z11 += m11;
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[-3];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   ell += lskip1;
   ex -= 4;
   Z11 += m11;
   /* end of inner loop */
  }
  /* compute left-over iterations */
  j += 4;
  for (; j > 0; j--) {
   /* load p and q values */
   p1 = ell[0];
   q1 = ex[0];
   /* compute outer product and add it to the Z matrix */
   m11 = p1 * q1;
   ell += lskip1;
   ex -= 1;
   Z11 += m11;
  }
  /* finish computing the X(i) block */
  Z11 = ex[0] - Z11;
  ex[0] = Z11;
 }
}



void btVectorScale(btScalar *a, const btScalar *d, int n)
{
 btAssert(a && d && n >= 0);
 for (int i = 0; i<n; i++) {
  a[i] *= d[i];
 }
}

void btSolveLDLT(const btScalar *L, const btScalar *d, btScalar *b, int n, int nskip)
{
 btAssert(L && d && b && n > 0 && nskip >= n);
 btSolveL1(L, b, n, nskip);
 btVectorScale(b, d, n);
 btSolveL1T(L, b, n, nskip);
}



//***************************************************************************

// swap row/column i1 with i2 in the n*n matrix A. the leading dimension of
// A is nskip. this only references and swaps the lower triangle.
// if `do_fast_row_swaps' is nonzero and row pointers are being used, then
// rows will be swapped by exchanging row pointers. otherwise the data will
// be copied.

static void btSwapRowsAndCols(BTATYPE A, int n, int i1, int i2, int nskip,
 int do_fast_row_swaps)
{
 btAssert(A && n > 0 && i1 >= 0 && i2 >= 0 && i1 < n && i2 < n &&
  nskip >= n && i1 < i2);

# ifdef BTROWPTRS
 btScalar *A_i1 = A[i1];
 btScalar *A_i2 = A[i2];
 for (int i = i1 + 1; i<i2; ++i) {
  btScalar *A_i_i1 = A[i] + i1;
  A_i1[i] = *A_i_i1;
  *A_i_i1 = A_i2[i];
 }
 A_i1[i2] = A_i1[i1];
 A_i1[i1] = A_i2[i1];
 A_i2[i1] = A_i2[i2];
 // swap rows, by swapping row pointers
 if (do_fast_row_swaps) {
  A[i1] = A_i2;
  A[i2] = A_i1;
 }
 else {
  // Only swap till i2 column to match A plain storage variant.
  for (int k = 0; k <= i2; ++k) {
   btScalar tmp = A_i1[k];
   A_i1[k] = A_i2[k];
   A_i2[k] = tmp;
  }
 }
 // swap columns the hard way
 for (int j = i2 + 1; j<n; ++j) {
  btScalar *A_j = A[j];
  btScalar tmp = A_j[i1];
  A_j[i1] = A_j[i2];
  A_j[i2] = tmp;
 }
# else
 btScalar *A_i1 = A + i1*nskip;
 btScalar *A_i2 = A + i2*nskip;
 for (int k = 0; k < i1; ++k) {
  btScalar tmp = A_i1[k];
  A_i1[k] = A_i2[k];
  A_i2[k] = tmp;
 }
 btScalar *A_i = A_i1 + nskip;
 for (int i = i1 + 1; i<i2; A_i += nskip, ++i) {
  btScalar tmp = A_i2[i];
  A_i2[i] = A_i[i1];
  A_i[i1] = tmp;
 }
 {
  btScalar tmp = A_i1[i1];
  A_i1[i1] = A_i2[i2];
  A_i2[i2] = tmp;
 }
 btScalar *A_j = A_i2 + nskip;
 for (int j = i2 + 1; j<n; A_j += nskip, ++j) {
  btScalar tmp = A_j[i1];
  A_j[i1] = A_j[i2];
  A_j[i2] = tmp;
 }
# endif
}


// swap two indexes in the n*n LCP problem. i1 must be <= i2.

static void btSwapProblem(BTATYPE A, btScalar *x, btScalar *b, btScalar *w, btScalar *lo,
 btScalar *hi, int *p, bool *state, int *findex,
 int n, int i1, int i2, int nskip,
 int do_fast_row_swaps)
{
 btScalar tmpr;
 int tmpi;
 bool tmpb;
 btAssert(n>0 && i1 >= 0 && i2 >= 0 && i1 < n && i2 < n && nskip >= n && i1 <= i2);
 if (i1 == i2) return;

 btSwapRowsAndCols(A, n, i1, i2, nskip, do_fast_row_swaps);

 tmpr = x[i1];
 x[i1] = x[i2];
 x[i2] = tmpr;

 tmpr = b[i1];
 b[i1] = b[i2];
 b[i2] = tmpr;

 tmpr = w[i1];
 w[i1] = w[i2];
 w[i2] = tmpr;

 tmpr = lo[i1];
 lo[i1] = lo[i2];
 lo[i2] = tmpr;

 tmpr = hi[i1];
 hi[i1] = hi[i2];
 hi[i2] = tmpr;

 tmpi = p[i1];
 p[i1] = p[i2];
 p[i2] = tmpi;

 tmpb = state[i1];
 state[i1] = state[i2];
 state[i2] = tmpb;

 if (findex) {
  tmpi = findex[i1];
  findex[i1] = findex[i2];
  findex[i2] = tmpi;
 }
}




//***************************************************************************
// btLCP manipulator object. this represents an n*n LCP problem.
//
// two index sets C and N are kept. each set holds a subset of
// the variable indexes 0..n-1. an index can only be in one set.
// initially both sets are empty.
//
// the index set C is special: solutions to A(C,C)\A(C,i) can be generated.

//***************************************************************************
// fast implementation of btLCP. see the above definition of btLCP for
// interface comments.
//
// `p' records the permutation of A,x,b,w,etc. p is initially 1:n and is
// permuted as the other vectors/matrices are permuted.
//
// A,x,b,w,lo,hi,state,findex,p,c are permuted such that sets C,N have
// contiguous indexes. the don't-care indexes follow N.
//
// an L*D*L' factorization is maintained of A(C,C), and whenever indexes are
// added or removed from the set C the factorization is updated.
// thus L*D*L'=A[C,C], i.e. a permuted top left nC*nC submatrix of A.
// the leading dimension of the matrix L is always `nskip'.
//
// at the start there may be other indexes that are unbounded but are not
// included in `nub'. btLCP will permute the matrix so that absolutely all
// unbounded vectors are at the start. thus there may be some initial
// permutation.
//
// the algorithms here assume certain patterns, particularly with respect to
// index transfer.

#ifdef btLCP_FAST

struct btLCP
{
 const int m_n;
 const int m_nskip;
 int m_nub;
 int m_nC, m_nN;				// size of each index set
 BTATYPE const m_A;				// A rows
 btScalar *const m_x, *const m_b, *const m_w, *const m_lo, *const m_hi;	// permuted LCP problem data
 btScalar *const m_L, *const m_d;				// L*D*L' factorization of set C
 btScalar *const m_Dell, *const m_ell, *const m_tmp;
 bool *const m_state;
 int *const m_findex, *const m_p, *const m_C;

 btLCP(int _n, int _nskip, int _nub, btScalar *_Adata, btScalar *_x, btScalar *_b, btScalar *_w,
  btScalar *_lo, btScalar *_hi, btScalar *l, btScalar *_d,
  btScalar *_Dell, btScalar *_ell, btScalar *_tmp,
  bool *_state, int *_findex, int *p, int *c, btScalar **Arows);
 int getNub() const { return m_nub; }
 void transfer_i_to_C(int i);
 void transfer_i_to_N(int i) { m_nN++; }			// because we can assume C and N span 1:i-1
 void transfer_i_from_N_to_C(int i);
 void transfer_i_from_C_to_N(int i, btAlignedObjectArray<btScalar>& scratch);
 int numC() const { return m_nC; }
 int numN() const { return m_nN; }
 int indexC(int i) const { return i; }
 int indexN(int i) const { return i + m_nC; }
 btScalar Aii(int i) const { return BTAROW(i)[i]; }
 btScalar AiC_times_qC(int i, btScalar *q) const { return btLargeDot(BTAROW(i), q, m_nC); }
 btScalar AiN_times_qN(int i, btScalar *q) const { return btLargeDot(BTAROW(i) + m_nC, q + m_nC, m_nN); }
 void pN_equals_ANC_times_qC(btScalar *p, btScalar *q);
 void pN_plusequals_ANi(btScalar *p, int i, int sign = 1);
 void pC_plusequals_s_times_qC(btScalar *p, btScalar s, btScalar *q);
 void pN_plusequals_s_times_qN(btScalar *p, btScalar s, btScalar *q);
 void solve1(btScalar *a, int i, int dir = 1, int only_transfer = 0);
 void unpermute();
};


btLCP::btLCP(int _n, int _nskip, int _nub, btScalar *_Adata, btScalar *_x, btScalar *_b, btScalar *_w,
 btScalar *_lo, btScalar *_hi, btScalar *l, btScalar *_d,
 btScalar *_Dell, btScalar *_ell, btScalar *_tmp,
 bool *_state, int *_findex, int *p, int *c, btScalar **Arows) :
 m_n(_n), m_nskip(_nskip), m_nub(_nub), m_nC(0), m_nN(0),
# ifdef BTROWPTRS
 m_A(Arows),
#else
 m_A(_Adata),
#endif
 m_x(_x), m_b(_b), m_w(_w), m_lo(_lo), m_hi(_hi),
 m_L(l), m_d(_d), m_Dell(_Dell), m_ell(_ell), m_tmp(_tmp),
 m_state(_state), m_findex(_findex), m_p(p), m_C(c)
{
 {
  btSetZero(m_x, m_n);
 }

 {
# ifdef BTROWPTRS
  // make matrix row pointers
  btScalar *aptr = _Adata;
  BTATYPE A = m_A;
  const int n = m_n, nskip = m_nskip;
  for (int k = 0; k<n; aptr += nskip, ++k) A[k] = aptr;
# endif
 }

 {
  int *p = m_p;
  const int n = m_n;
  for (int k = 0; k<n; ++k) p[k] = k;		// initially unpermuted
 }

 /*
 // for testing, we can do some random swaps in the area i > nub
 {
 const int n = m_n;
 const int nub = m_nub;
 if (nub < n) {
 for (int k=0; k<100; k++) {
 int i1,i2;
 do {
 i1 = dRandInt(n-nub)+nub;
 i2 = dRandInt(n-nub)+nub;
 }
 while (i1 > i2);
 //printf ("--> %d %d\n",i1,i2);
 btSwapProblem (m_A,m_x,m_b,m_w,m_lo,m_hi,m_p,m_state,m_findex,n,i1,i2,m_nskip,0);
 }
 }
 */

 // permute the problem so that *all* the unbounded variables are at the
 // start, i.e. look for unbounded variables not included in `nub'. we can
 // potentially push up `nub' this way and get a bigger initial factorization.
 // note that when we swap rows/cols here we must not just swap row pointers,
 // as the initial factorization relies on the data being all in one chunk.
 // variables that have findex >= 0 are *not* considered to be unbounded even
 // if lo=-inf and hi=inf - this is because these limits may change during the
 // solution process.

 {
  int *findex = m_findex;
  btScalar *lo = m_lo, *hi = m_hi;
  const int n = m_n;
  for (int k = m_nub; k<n; ++k) {
   if (findex && findex[k] >= 0) continue;
   if (lo[k] == -BT_INFINITY && hi[k] == BT_INFINITY) {
    btSwapProblem(m_A, m_x, m_b, m_w, lo, hi, m_p, m_state, findex, n, m_nub, k, m_nskip, 0);
    m_nub++;
   }
  }
 }

 // if there are unbounded variables at the start, factorize A up to that
 // point and solve for x. this puts all indexes 0..nub-1 into C.
 if (m_nub > 0) {
  const int nub = m_nub;
  {
   btScalar *Lrow = m_L;
   const int nskip = m_nskip;
   for (int j = 0; j<nub; Lrow += nskip, ++j) memcpy(Lrow, BTAROW(j), (j + 1) * sizeof(btScalar));
  }
  btFactorLDLT(m_L, m_d, nub, m_nskip);
  memcpy(m_x, m_b, nub * sizeof(btScalar));
  btSolveLDLT(m_L, m_d, m_x, nub, m_nskip);
  btSetZero(m_w, nub);
  {
   int *C = m_C;
   for (int k = 0; k<nub; ++k) C[k] = k;
  }
  m_nC = nub;
 }

 // permute the indexes > nub such that all findex variables are at the end
 if (m_findex) {
  const int nub = m_nub;
  int *findex = m_findex;
  int num_at_end = 0;
  for (int k = m_n - 1; k >= nub; k--) {
   if (findex[k] >= 0) {
    btSwapProblem(m_A, m_x, m_b, m_w, m_lo, m_hi, m_p, m_state, findex, m_n, k, m_n - 1 - num_at_end, m_nskip, 1);
    num_at_end++;
   }
  }
 }

 // print info about indexes
 /*
 {
 const int n = m_n;
 const int nub = m_nub;
 for (int k=0; k<n; k++) {
 if (k<nub) printf ("C");
 else if (m_lo[k]==-BT_INFINITY && m_hi[k]==BT_INFINITY) printf ("c");
 else printf (".");
 }
 printf ("\n");
 }
 */
}


void btLCP::transfer_i_to_C(int i)
{
 {
  if (m_nC > 0) {
   // ell,Dell were computed by solve1(). note, ell = D \ L1solve (L,A(i,C))
   {
    const int nC = m_nC;
    btScalar *const Ltgt = m_L + nC*m_nskip, *ell = m_ell;
    for (int j = 0; j<nC; ++j) Ltgt[j] = ell[j];
   }
   const int nC = m_nC;
   m_d[nC] = btRecip(BTAROW(i)[i] - btLargeDot(m_ell, m_Dell, nC));
  }
  else {
   m_d[0] = btRecip(BTAROW(i)[i]);
  }

  btSwapProblem(m_A, m_x, m_b, m_w, m_lo, m_hi, m_p, m_state, m_findex, m_n, m_nC, i, m_nskip, 1);

  const int nC = m_nC;
  m_C[nC] = nC;
  m_nC = nC + 1; // nC value is outdated after this line
 }

}


void btLCP::transfer_i_from_N_to_C(int i)
{
 {
  if (m_nC > 0) {
   {
    btScalar *const aptr = BTAROW(i);
    btScalar *Dell = m_Dell;
    const int *C = m_C;
#   ifdef BTNUB_OPTIMIZATIONS
    // if nub>0, initial part of aptr unpermuted
    const int nub = m_nub;
    int j = 0;
    for (; j<nub; ++j) Dell[j] = aptr[j];
    const int nC = m_nC;
    for (; j<nC; ++j) Dell[j] = aptr[C[j]];
#   else
    const int nC = m_nC;
    for (int j = 0; j<nC; ++j) Dell[j] = aptr[C[j]];
#   endif
   }
   btSolveL1(m_L, m_Dell, m_nC, m_nskip);
   {
    const int nC = m_nC;
    btScalar *const Ltgt = m_L + nC*m_nskip;
    btScalar *ell = m_ell, *Dell = m_Dell, *d = m_d;
    for (int j = 0; j<nC; ++j) Ltgt[j] = ell[j] = Dell[j] * d[j];
   }
   const int nC = m_nC;
   m_d[nC] = btRecip(BTAROW(i)[i] - btLargeDot(m_ell, m_Dell, nC));
  }
  else {
   m_d[0] = btRecip(BTAROW(i)[i]);
  }

  btSwapProblem(m_A, m_x, m_b, m_w, m_lo, m_hi, m_p, m_state, m_findex, m_n, m_nC, i, m_nskip, 1);

  const int nC = m_nC;
  m_C[nC] = nC;
  m_nN--;
  m_nC = nC + 1; // nC value is outdated after this line
 }

 // @@@ TO DO LATER
 // if we just finish here then we'll go back and re-solve for
 // delta_x. but actually we can be more efficient and incrementally
 // update delta_x here. but if we do this, we wont have ell and Dell
 // to use in updating the factorization later.

}

void btRemoveRowCol(btScalar *A, int n, int nskip, int r)
{
 btAssert(A && n > 0 && nskip >= n && r >= 0 && r < n);
 if (r >= n - 1) return;
 if (r > 0) {
  {
   const size_t move_size = (n - r - 1) * sizeof(btScalar);
   btScalar *Adst = A + r;
   for (int i = 0; i<r; Adst += nskip, ++i) {
    btScalar *Asrc = Adst + 1;
    memmove(Adst, Asrc, move_size);
   }
  }
  {
   const size_t cpy_size = r * sizeof(btScalar);
   btScalar *Adst = A + r * nskip;
   for (int i = r; i<(n - 1); ++i) {
    btScalar *Asrc = Adst + nskip;
    memcpy(Adst, Asrc, cpy_size);
    Adst = Asrc;
   }
  }
 }
 {
  const size_t cpy_size = (n - r - 1) * sizeof(btScalar);
  btScalar *Adst = A + r * (nskip + 1);
  for (int i = r; i<(n - 1); ++i) {
   btScalar *Asrc = Adst + (nskip + 1);
   memcpy(Adst, Asrc, cpy_size);
   Adst = Asrc - 1;
  }
 }
}




void btLDLTAddTL(btScalar *L, btScalar *d, const btScalar *a, int n, int nskip, btAlignedObjectArray<btScalar>& scratch)
{
 btAssert(L && d && a && n > 0 && nskip >= n);

 if (n < 2) return;
 scratch.resize(2 * nskip);
 btScalar *W1 = &scratch[0];

 btScalar *W2 = W1 + nskip;

 W1[0] = btScalar(0.0);
 W2[0] = btScalar(0.0);
 for (int j = 1; j<n; ++j) {
  W1[j] = W2[j] = (btScalar)(a[j] * SIMDSQRT12);
 }
 btScalar W11 = (btScalar)((btScalar(0.5)*a[0] + 1)*SIMDSQRT12);
 btScalar W21 = (btScalar)((btScalar(0.5)*a[0] - 1)*SIMDSQRT12);

 btScalar alpha1 = btScalar(1.0);
 btScalar alpha2 = btScalar(1.0);

 {
  btScalar dee = d[0];
  btScalar alphanew = alpha1 + (W11*W11)*dee;
  btAssert(alphanew != btScalar(0.0));
  dee /= alphanew;
  btScalar gamma1 = W11 * dee;
  dee *= alpha1;
  alpha1 = alphanew;
  alphanew = alpha2 - (W21*W21)*dee;
  dee /= alphanew;
  //btScalar gamma2 = W21 * dee;
  alpha2 = alphanew;
  btScalar k1 = btScalar(1.0) - W21*gamma1;
  btScalar k2 = W21*gamma1*W11 - W21;
  btScalar *ll = L + nskip;
  for (int p = 1; p<n; ll += nskip, ++p) {
   btScalar Wp = W1[p];
   btScalar ell = *ll;
   W1[p] = Wp - W11*ell;
   W2[p] = k1*Wp + k2*ell;
  }
 }

 btScalar *ll = L + (nskip + 1);
 for (int j = 1; j<n; ll += nskip + 1, ++j) {
  btScalar k1 = W1[j];
  btScalar k2 = W2[j];

  btScalar dee = d[j];
  btScalar alphanew = alpha1 + (k1*k1)*dee;
  btAssert(alphanew != btScalar(0.0));
  dee /= alphanew;
  btScalar gamma1 = k1 * dee;
  dee *= alpha1;
  alpha1 = alphanew;
  alphanew = alpha2 - (k2*k2)*dee;
  dee /= alphanew;
  btScalar gamma2 = k2 * dee;
  dee *= alpha2;
  d[j] = dee;
  alpha2 = alphanew;

  btScalar *l = ll + nskip;
  for (int p = j + 1; p<n; l += nskip, ++p) {
   btScalar ell = *l;
   btScalar Wp = W1[p] - k1 * ell;
   ell += gamma1 * Wp;
   W1[p] = Wp;
   Wp = W2[p] - k2 * ell;
   ell -= gamma2 * Wp;
   W2[p] = Wp;
   *l = ell;
  }
 }
}


#define _BTGETA(i,j) (A[i][j])
//#define _GETA(i,j) (A[(i)*nskip+(j)])
#define BTGETA(i,j) ((i > j) ? _BTGETA(i,j) : _BTGETA(j,i))

inline size_t btEstimateLDLTAddTLTmpbufSize(int nskip)
{
 return nskip * 2 * sizeof(btScalar);
}


void btLDLTRemove(btScalar **A, const int *p, btScalar *L, btScalar *d,
 int n1, int n2, int r, int nskip, btAlignedObjectArray<btScalar>& scratch)
{
 btAssert(A && p && L && d && n1 > 0 && n2 > 0 && r >= 0 && r < n2 &&
  n1 >= n2 && nskip >= n1);
#ifdef BT_DEBUG
 for (int i = 0; i<n2; ++i)
  btAssert(p[i] >= 0 && p[i] < n1);
#endif

 if (r == n2 - 1) {
  return;		// deleting last row/col is easy
 }
 else {
  size_t LDLTAddTL_size = btEstimateLDLTAddTLTmpbufSize(nskip);
  btAssert(LDLTAddTL_size % sizeof(btScalar) == 0);
  scratch.resize(nskip * 2 + n2);
  btScalar *tmp = &scratch[0];
  if (r == 0) {
   btScalar *a = (btScalar *)((char *)tmp + LDLTAddTL_size);
   const int p_0 = p[0];
   for (int i = 0; i<n2; ++i) {
    a[i] = -BTGETA(p[i], p_0);
   }
   a[0] += btScalar(1.0);
   btLDLTAddTL(L, d, a, n2, nskip, scratch);
  }
  else {
   btScalar *t = (btScalar *)((char *)tmp + LDLTAddTL_size);
   {
    btScalar *Lcurr = L + r*nskip;
    for (int i = 0; i<r; ++Lcurr, ++i) {
     btAssert(d[i] != btScalar(0.0));
     t[i] = *Lcurr / d[i];
    }
   }
   btScalar *a = t + r;
   {
    btScalar *Lcurr = L + r*nskip;
    const int *pp_r = p + r, p_r = *pp_r;
    const int n2_minus_r = n2 - r;
    for (int i = 0; i<n2_minus_r; Lcurr += nskip, ++i) {
     a[i] = btLargeDot(Lcurr, t, r) - BTGETA(pp_r[i], p_r);
    }
   }
   a[0] += btScalar(1.0);
   btLDLTAddTL(L + r*nskip + r, d + r, a, n2 - r, nskip, scratch);
  }
 }

 // snip out row/column r from L and d
 btRemoveRowCol(L, n2, nskip, r);
 if (r < (n2 - 1)) memmove(d + r, d + r + 1, (n2 - r - 1) * sizeof(btScalar));
}


void btLCP::transfer_i_from_C_to_N(int i, btAlignedObjectArray<btScalar>& scratch)
{
 {
  int *C = m_C;
  // remove a row/column from the factorization, and adjust the
  // indexes (black magic!)
  int last_idx = -1;
  const int nC = m_nC;
  int j = 0;
  for (; j<nC; ++j) {
   if (C[j] == nC - 1) {
    last_idx = j;
   }
   if (C[j] == i) {
    btLDLTRemove(m_A, C, m_L, m_d, m_n, nC, j, m_nskip, scratch);
    int k;
    if (last_idx == -1) {
     for (k = j + 1; k<nC; ++k) {
      if (C[k] == nC - 1) {
       break;
      }
     }
     btAssert(k < nC);
    }
    else {
     k = last_idx;
    }
    C[k] = C[j];
    if (j < (nC - 1)) memmove(C + j, C + j + 1, (nC - j - 1) * sizeof(int));
    break;
   }
  }
  btAssert(j < nC);

  btSwapProblem(m_A, m_x, m_b, m_w, m_lo, m_hi, m_p, m_state, m_findex, m_n, i, nC - 1, m_nskip, 1);

  m_nN++;
  m_nC = nC - 1; // nC value is outdated after this line
 }

}


void btLCP::pN_equals_ANC_times_qC(btScalar *p, btScalar *q)
{
 // we could try to make this matrix-vector multiplication faster using
 // outer product matrix tricks, e.g. with the dMultidotX() functions.
 // but i tried it and it actually made things slower on random 100x100
 // problems because of the overhead involved. so we'll stick with the
 // simple method for now.
 const int nC = m_nC;
 btScalar *ptgt = p + nC;
 const int nN = m_nN;
 for (int i = 0; i<nN; ++i) {
  ptgt[i] = btLargeDot(BTAROW(i + nC), q, nC);
 }
}


void btLCP::pN_plusequals_ANi(btScalar *p, int i, int sign)
{
 const int nC = m_nC;
 btScalar *aptr = BTAROW(i) + nC;
 btScalar *ptgt = p + nC;
 if (sign > 0) {
  const int nN = m_nN;
  for (int j = 0; j<nN; ++j) ptgt[j] += aptr[j];
 }
 else {
  const int nN = m_nN;
  for (int j = 0; j<nN; ++j) ptgt[j] -= aptr[j];
 }
}

void btLCP::pC_plusequals_s_times_qC(btScalar *p, btScalar s, btScalar *q)
{
 const int nC = m_nC;
 for (int i = 0; i<nC; ++i) {
  p[i] += s*q[i];
 }
}

void btLCP::pN_plusequals_s_times_qN(btScalar *p, btScalar s, btScalar *q)
{
 const int nC = m_nC;
 btScalar *ptgt = p + nC, *qsrc = q + nC;
 const int nN = m_nN;
 for (int i = 0; i<nN; ++i) {
  ptgt[i] += s*qsrc[i];
 }
}

void btLCP::solve1(btScalar *a, int i, int dir, int only_transfer)
{
 // the `Dell' and `ell' that are computed here are saved. if index i is
 // later added to the factorization then they can be reused.
 //
 // @@@ question: do we need to solve for entire delta_x??? yes, but
 //     only if an x goes below 0 during the step.

 if (m_nC > 0) {
  {
   btScalar *Dell = m_Dell;
   int *C = m_C;
   btScalar *aptr = BTAROW(i);
#   ifdef BTNUB_OPTIMIZATIONS
   // if nub>0, initial part of aptr[] is guaranteed unpermuted
   const int nub = m_nub;
   int j = 0;
   for (; j<nub; ++j) Dell[j] = aptr[j];
   const int nC = m_nC;
   for (; j<nC; ++j) Dell[j] = aptr[C[j]];
#   else
   const int nC = m_nC;
   for (int j = 0; j<nC; ++j) Dell[j] = aptr[C[j]];
#   endif
  }
  btSolveL1(m_L, m_Dell, m_nC, m_nskip);
  {
   btScalar *ell = m_ell, *Dell = m_Dell, *d = m_d;
   const int nC = m_nC;
   for (int j = 0; j<nC; ++j) ell[j] = Dell[j] * d[j];
  }

  if (!only_transfer) {
   btScalar *tmp = m_tmp, *ell = m_ell;
   {
    const int nC = m_nC;
    for (int j = 0; j<nC; ++j) tmp[j] = ell[j];
   }
   btSolveL1T(m_L, tmp, m_nC, m_nskip);
   if (dir > 0) {
    int *C = m_C;
    btScalar *tmp = m_tmp;
    const int nC = m_nC;
    for (int j = 0; j<nC; ++j) a[C[j]] = -tmp[j];
   }
   else {
    int *C = m_C;
    btScalar *tmp = m_tmp;
    const int nC = m_nC;
    for (int j = 0; j<nC; ++j) a[C[j]] = tmp[j];
   }
  }
 }
}


void btLCP::unpermute()
{
 // now we have to un-permute x and w
 {
  memcpy(m_tmp, m_x, m_n * sizeof(btScalar));
  btScalar *x = m_x, *tmp = m_tmp;
  const int *p = m_p;
  const int n = m_n;
  for (int j = 0; j<n; ++j) x[p[j]] = tmp[j];
 }
 {
  memcpy(m_tmp, m_w, m_n * sizeof(btScalar));
  btScalar *w = m_w, *tmp = m_tmp;
  const int *p = m_p;
  const int n = m_n;
  for (int j = 0; j<n; ++j) w[p[j]] = tmp[j];
 }
}

#endif // btLCP_FAST


//***************************************************************************
// an optimized Dantzig LCP driver routine for the lo-hi LCP problem.

bool btSolveDantzigLCP(int n, btScalar *A, btScalar *x, btScalar *b,
 btScalar* outer_w, int nub, btScalar *lo, btScalar *hi, int *findex, btDantzigScratchMemory& scratchMem)
{
 s_error = false;

 //	printf("btSolveDantzigLCP n=%d\n",n);
 btAssert(n>0 && A && x && b && lo && hi && nub >= 0 && nub <= n);
 btAssert(outer_w);

#ifdef BT_DEBUG
 {
  // check restrictions on lo and hi
  for (int k = 0; k<n; ++k)
   btAssert(lo[k] <= 0 && hi[k] >= 0);
 }
# endif


 // if all the variables are unbounded then we can just factor, solve,
 // and return
 if (nub >= n)
 {


  int nskip = (n);
  btFactorLDLT(A, outer_w, n, nskip);
  btSolveLDLT(A, outer_w, b, n, nskip);
  memcpy(x, b, n * sizeof(btScalar));

  return !s_error;
 }

 const int nskip = (n);
 scratchMem.L.resize(n*nskip);

 scratchMem.d.resize(n);

 btScalar *w = outer_w;
 scratchMem.delta_w.resize(n);
 scratchMem.delta_x.resize(n);
 scratchMem.Dell.resize(n);
 scratchMem.ell.resize(n);
 scratchMem.Arows.resize(n);
 scratchMem.p.resize(n);
 scratchMem.C.resize(n);

 // for i in N, state[i] is 0 if x(i)==lo(i) or 1 if x(i)==hi(i)
 scratchMem.state.resize(n);


 // create LCP object. note that tmp is set to delta_w to save space, this
 // optimization relies on knowledge of how tmp is used, so be careful!
 btLCP lcp(n, nskip, nub, A, x, b, w, lo, hi, &scratchMem.L[0], &scratchMem.d[0], &scratchMem.Dell[0], &scratchMem.ell[0], &scratchMem.delta_w[0], &scratchMem.state[0], findex, &scratchMem.p[0], &scratchMem.C[0], &scratchMem.Arows[0]);
 int adj_nub = lcp.getNub();

 // loop over all indexes adj_nub..n-1. for index i, if x(i),w(i) satisfy the
 // LCP conditions then i is added to the appropriate index set. otherwise
 // x(i),w(i) is driven either +ve or -ve to force it to the valid region.
 // as we drive x(i), x(C) is also adjusted to keep w(C) at zero.
 // while driving x(i) we maintain the LCP conditions on the other variables
 // 0..i-1. we do this by watching out for other x(i),w(i) values going
 // outside the valid region, and then switching them between index sets
 // when that happens.

 bool hit_first_friction_index = false;
 for (int i = adj_nub; i<n; ++i)
 {
  s_error = false;
  // the index i is the driving index and indexes i+1..n-1 are "dont care",
  // i.e. when we make changes to the system those x's will be zero and we
  // don't care what happens to those w's. in other words, we only consider
  // an (i+1)*(i+1) sub-problem of A*x=b+w.

  // if we've hit the first friction index, we have to compute the lo and
  // hi values based on the values of x already computed. we have been
  // permuting the indexes, so the values stored in the findex vector are
  // no longer valid. thus we have to temporarily unpermute the x vector. 
  // for the purposes of this computation, 0*infinity = 0 ... so if the
  // contact constraint's normal force is 0, there should be no tangential
  // force applied.

  if (!hit_first_friction_index && findex && findex[i] >= 0) {
   // un-permute x into delta_w, which is not being used at the moment
   for (int j = 0; j<n; ++j) scratchMem.delta_w[scratchMem.p[j]] = x[j];

   // set lo and hi values
   for (int k = i; k<n; ++k) {
    btScalar wfk = scratchMem.delta_w[findex[k]];
    if (wfk == 0) {
     hi[k] = 0;
     lo[k] = 0;
    }
    else {
     hi[k] = btFabs(hi[k] * wfk);
     lo[k] = -hi[k];
    }
   }
   hit_first_friction_index = true;
  }

  // thus far we have not even been computing the w values for indexes
  // greater than i, so compute w[i] now.
  w[i] = lcp.AiC_times_qC(i, x) + lcp.AiN_times_qN(i, x) - b[i];

  // if lo=hi=0 (which can happen for tangential friction when normals are
  // 0) then the index will be assigned to set N with some state. however,
  // set C's line has zero size, so the index will always remain in set N.
  // with the "normal" switching logic, if w changed sign then the index
  // would have to switch to set C and then back to set N with an inverted
  // state. this is pointless, and also computationally expensive. to
  // prevent this from happening, we use the rule that indexes with lo=hi=0
  // will never be checked for set changes. this means that the state for
  // these indexes may be incorrect, but that doesn't matter.

  // see if x(i),w(i) is in a valid region
  if (lo[i] == 0 && w[i] >= 0) {
   lcp.transfer_i_to_N(i);
   scratchMem.state[i] = false;
  }
  else if (hi[i] == 0 && w[i] <= 0) {
   lcp.transfer_i_to_N(i);
   scratchMem.state[i] = true;
  }
  else if (w[i] == 0) {
   // this is a degenerate case. by the time we get to this test we know
   // that lo != 0, which means that lo < 0 as lo is not allowed to be +ve,
   // and similarly that hi > 0. this means that the line segment
   // corresponding to set C is at least finite in extent, and we are on it.
   // NOTE: we must call lcp.solve1() before lcp.transfer_i_to_C()
   lcp.solve1(&scratchMem.delta_x[0], i, 0, 1);

   lcp.transfer_i_to_C(i);
  }
  else {
   // we must push x(i) and w(i)
   for (;;) {
    int dir;
    btScalar dirf;
    // find direction to push on x(i)
    if (w[i] <= 0) {
     dir = 1;
     dirf = btScalar(1.0);
    }
    else {
     dir = -1;
     dirf = btScalar(-1.0);
    }

    // compute: delta_x(C) = -dir*A(C,C)\A(C,i)
    lcp.solve1(&scratchMem.delta_x[0], i, dir);

    // note that delta_x[i] = dirf, but we wont bother to set it

    // compute: delta_w = A*delta_x ... note we only care about
    // delta_w(N) and delta_w(i), the rest is ignored
    lcp.pN_equals_ANC_times_qC(&scratchMem.delta_w[0], &scratchMem.delta_x[0]);
    lcp.pN_plusequals_ANi(&scratchMem.delta_w[0], i, dir);
    scratchMem.delta_w[i] = lcp.AiC_times_qC(i, &scratchMem.delta_x[0]) + lcp.Aii(i)*dirf;

    // find largest step we can take (size=s), either to drive x(i),w(i)
    // to the valid LCP region or to drive an already-valid variable
    // outside the valid region.

    int cmd = 1;		// index switching command
    int si = 0;		// si = index to switch if cmd>3
    btScalar s = -w[i] / scratchMem.delta_w[i];
    if (dir > 0) {
     if (hi[i] < BT_INFINITY) {
      btScalar s2 = (hi[i] - x[i])*dirf;	// was (hi[i]-x[i])/dirf	// step to x(i)=hi(i)
      if (s2 < s) {
       s = s2;
       cmd = 3;
      }
     }
    }
    else {
     if (lo[i] > -BT_INFINITY) {
      btScalar s2 = (lo[i] - x[i])*dirf;	// was (lo[i]-x[i])/dirf	// step to x(i)=lo(i)
      if (s2 < s) {
       s = s2;
       cmd = 2;
      }
     }
    }

    {
     const int numN = lcp.numN();
     for (int k = 0; k < numN; ++k) {
      const int indexN_k = lcp.indexN(k);
      if (!scratchMem.state[indexN_k] ? scratchMem.delta_w[indexN_k] < 0 : scratchMem.delta_w[indexN_k] > 0) {
       // don't bother checking if lo=hi=0
       if (lo[indexN_k] == 0 && hi[indexN_k] == 0) continue;
       btScalar s2 = -w[indexN_k] / scratchMem.delta_w[indexN_k];
       if (s2 < s) {
        s = s2;
        cmd = 4;
        si = indexN_k;
       }
      }
     }
    }

    {
     const int numC = lcp.numC();
     for (int k = adj_nub; k < numC; ++k) {
      const int indexC_k = lcp.indexC(k);
      if (scratchMem.delta_x[indexC_k] < 0 && lo[indexC_k] > -BT_INFINITY) {
       btScalar s2 = (lo[indexC_k] - x[indexC_k]) / scratchMem.delta_x[indexC_k];
       if (s2 < s) {
        s = s2;
        cmd = 5;
        si = indexC_k;
       }
      }
      if (scratchMem.delta_x[indexC_k] > 0 && hi[indexC_k] < BT_INFINITY) {
       btScalar s2 = (hi[indexC_k] - x[indexC_k]) / scratchMem.delta_x[indexC_k];
       if (s2 < s) {
        s = s2;
        cmd = 6;
        si = indexC_k;
       }
      }
     }
    }

    //static char* cmdstring[8] = {0,"->C","->NL","->NH","N->C",
    //			     "C->NL","C->NH"};
    //printf ("cmd=%d (%s), si=%d\n",cmd,cmdstring[cmd],(cmd>3) ? si : i);

    // if s <= 0 then we've got a problem. if we just keep going then
    // we're going to get stuck in an infinite loop. instead, just cross
    // our fingers and exit with the current solution.
    if (s <= btScalar(0.0))
    {
     //          printf("LCP internal error, s <= 0 (s=%.4e)",(double)s);
     if (i < n) {
      btSetZero(x + i, n - i);
      btSetZero(w + i, n - i);
     }
     s_error = true;
     break;
    }

    // apply x = x + s * delta_x
    lcp.pC_plusequals_s_times_qC(x, s, &scratchMem.delta_x[0]);
    x[i] += s * dirf;

    // apply w = w + s * delta_w
    lcp.pN_plusequals_s_times_qN(w, s, &scratchMem.delta_w[0]);
    w[i] += s * scratchMem.delta_w[i];

    //        void *tmpbuf;
    // switch indexes between sets if necessary
    switch (cmd) {
    case 1:		// done
     w[i] = 0;
     lcp.transfer_i_to_C(i);
     break;
    case 2:		// done
     x[i] = lo[i];
     scratchMem.state[i] = false;
     lcp.transfer_i_to_N(i);
     break;
    case 3:		// done
     x[i] = hi[i];
     scratchMem.state[i] = true;
     lcp.transfer_i_to_N(i);
     break;
    case 4:		// keep going
     w[si] = 0;
     lcp.transfer_i_from_N_to_C(si);
     break;
    case 5:		// keep going
     x[si] = lo[si];
     scratchMem.state[si] = false;
     lcp.transfer_i_from_C_to_N(si, scratchMem.m_scratch);
     break;
    case 6:		// keep going
     x[si] = hi[si];
     scratchMem.state[si] = true;
     lcp.transfer_i_from_C_to_N(si, scratchMem.m_scratch);
     break;
    }

    if (cmd <= 3) break;
   } // for (;;)
  } // else

  if (s_error)
  {
   break;
  }
 } // for (int i=adj_nub; i<n; ++i)

 lcp.unpermute();


 return !s_error;
}

/* Copyright (C) 2004-2013 MBSim Development Team

Code was converted for the Bullet Continuous Collision Detection and Physics Library

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//The original version is here
//https://code.google.com/p/mbsim-env/source/browse/trunk/kernel/mbsim/numerics/linear_complementarity_problem/lemke_algorithm.cc
//This file is re-distributed under the ZLib license, with permission of the original author
//Math library was replaced from fmatvec to a the file src/LinearMath/btMatrixX.h
//STL/std::vector replaced by btAlignedObjectArray



#include "BulletDynamics/MLCPSolvers/btLemkeAlgorithm.h"

#undef BT_DEBUG_OSTREAM
#ifdef BT_DEBUG_OSTREAM
using namespace std;
#endif //BT_DEBUG_OSTREAM

btScalar btMachEps()
{
 static bool calculated = false;
 static btScalar machEps = btScalar(1.);
 if (!calculated)
 {
  do {
   machEps /= btScalar(2.0);
   // If next epsilon yields 1, then break, because current
   // epsilon is the machine epsilon.
  } while ((btScalar)(1.0 + (machEps / btScalar(2.0))) != btScalar(1.0));
  //		printf( "\nCalculated Machine epsilon: %G\n", machEps );
  calculated = true;
 }
 return machEps;
}

btScalar btEpsRoot() {

 static btScalar epsroot = 0.;
 static bool alreadyCalculated = false;

 if (!alreadyCalculated) {
  epsroot = btSqrt(btMachEps());
  alreadyCalculated = true;
 }
 return epsroot;
}



btVectorXu btLemkeAlgorithm::solve(unsigned int maxloops /* = 0*/)
{


 steps = 0;

 int dim = m_q.size();
#ifdef BT_DEBUG_OSTREAM
 if (DEBUGLEVEL >= 1) {
  cout << "Dimension = " << dim << endl;
 }
#endif //BT_DEBUG_OSTREAM

 btVectorXu solutionVector(2 * dim);
 solutionVector.setZero();

 //, INIT, 0.);

 btMatrixXu ident(dim, dim);
 ident.setIdentity();
#ifdef BT_DEBUG_OSTREAM
 cout << m_M << std::endl;
#endif

 btMatrixXu mNeg = m_M.negative();

 btMatrixXu A(dim, 2 * dim + 2);
 //
 A.setSubMatrix(0, 0, dim - 1, dim - 1, ident);
 A.setSubMatrix(0, dim, dim - 1, 2 * dim - 1, mNeg);
 A.setSubMatrix(0, 2 * dim, dim - 1, 2 * dim, -1.f);
 A.setSubMatrix(0, 2 * dim + 1, dim - 1, 2 * dim + 1, m_q);

#ifdef BT_DEBUG_OSTREAM
 cout << A << std::endl;
#endif //BT_DEBUG_OSTREAM


 //   btVectorXu q_;
 //   q_ >> A(0, 2 * dim + 1, dim - 1, 2 * dim + 1);

 btAlignedObjectArray<int> basis;
 //At first, all w-values are in the basis
 for (int i = 0; i < dim; i++)
  basis.push_back(i);

 int pivotRowIndex = -1;
 btScalar minValue = 1e30f;
 bool greaterZero = true;
 for (int i = 0; i<dim; i++)
 {
  btScalar v = A(i, 2 * dim + 1);
  if (v<minValue)
  {
   minValue = v;
   pivotRowIndex = i;
  }
  if (v<0)
   greaterZero = false;
 }



 //  int pivotRowIndex = q_.minIndex();//minIndex(q_);     // first row is that with lowest q-value
 int z0Row = pivotRowIndex;           // remember the col of z0 for ending algorithm afterwards
 int pivotColIndex = 2 * dim;         // first col is that of z0

#ifdef BT_DEBUG_OSTREAM
 if (DEBUGLEVEL >= 3)
 {
  //  cout << "A: " << A << endl;
  cout << "pivotRowIndex " << pivotRowIndex << endl;
  cout << "pivotColIndex " << pivotColIndex << endl;
  cout << "Basis: ";
  for (int i = 0; i < basis.size(); i++)
   cout << basis[i] << " ";
  cout << endl;
 }
#endif //BT_DEBUG_OSTREAM

 if (!greaterZero)
 {

  if (maxloops == 0) {
   maxloops = 100;
   //        maxloops = UINT_MAX; //TODO: not a really nice way, problem is: maxloops should be 2^dim (=1<<dim), but this could exceed UINT_MAX and thus the result would be 0 and therefore the lemke algorithm wouldn't start but probably would find a solution within less then UINT_MAX steps. Therefore this constant is used as a upper border right now...
  }

  /*start looping*/
  for (steps = 0; steps < maxloops; steps++) {

   GaussJordanEliminationStep(A, pivotRowIndex, pivotColIndex, basis);
#ifdef BT_DEBUG_OSTREAM
   if (DEBUGLEVEL >= 3) {
    //  cout << "A: " << A << endl;
    cout << "pivotRowIndex " << pivotRowIndex << endl;
    cout << "pivotColIndex " << pivotColIndex << endl;
    cout << "Basis: ";
    for (int i = 0; i < basis.size(); i++)
     cout << basis[i] << " ";
    cout << endl;
   }
#endif //BT_DEBUG_OSTREAM

   int pivotColIndexOld = pivotColIndex;

   /*find new column index */
   if (basis[pivotRowIndex] < dim) //if a w-value left the basis get in the correspondent z-value
    pivotColIndex = basis[pivotRowIndex] + dim;
   else
    //else do it the other way round and get in the corresponding w-value
    pivotColIndex = basis[pivotRowIndex] - dim;

   /*the column becomes part of the basis*/
   basis[pivotRowIndex] = pivotColIndexOld;

   pivotRowIndex = findLexicographicMinimum(A, pivotColIndex);

   if (z0Row == pivotRowIndex) { //if z0 leaves the basis the solution is found --> one last elimination step is necessary
    GaussJordanEliminationStep(A, pivotRowIndex, pivotColIndex, basis);
    basis[pivotRowIndex] = pivotColIndex; //update basis
    break;
   }

  }
#ifdef BT_DEBUG_OSTREAM
  if (DEBUGLEVEL >= 1) {
   cout << "Number of loops: " << steps << endl;
   cout << "Number of maximal loops: " << maxloops << endl;
  }
#endif //BT_DEBUG_OSTREAM

  if (!validBasis(basis)) {
   info = -1;
#ifdef BT_DEBUG_OSTREAM
   if (DEBUGLEVEL >= 1)
    cerr << "Lemke-Algorithm ended with Ray-Termination (no valid solution)." << endl;
#endif //BT_DEBUG_OSTREAM

   return solutionVector;
  }

 }
#ifdef BT_DEBUG_OSTREAM
 if (DEBUGLEVEL >= 2) {
  // cout << "A: " << A << endl;
  cout << "pivotRowIndex " << pivotRowIndex << endl;
  cout << "pivotColIndex " << pivotColIndex << endl;
 }
#endif //BT_DEBUG_OSTREAM

 for (int i = 0; i < basis.size(); i++)
 {
  solutionVector[basis[i]] = A(i, 2 * dim + 1);//q_[i];
 }

 info = 0;

 return solutionVector;
}

int btLemkeAlgorithm::findLexicographicMinimum(const btMatrixXu& A, const int & pivotColIndex) {
 int RowIndex = 0;
 int dim = A.rows();
 btAlignedObjectArray<btVectorXu> Rows;
 for (int row = 0; row < dim; row++)
 {

  btVectorXu vec(dim + 1);
  vec.setZero();//, INIT, 0.)
  Rows.push_back(vec);
  btScalar a = A(row, pivotColIndex);
  if (a > 0) {
   Rows[row][0] = A(row, 2 * dim + 1) / a;
   Rows[row][1] = A(row, 2 * dim) / a;
   for (int j = 2; j < dim + 1; j++)
    Rows[row][j] = A(row, j - 1) / a;

#ifdef BT_DEBUG_OSTREAM
   //		if (DEBUGLEVEL) {
   //	  cout << "Rows(" << row << ") = " << Rows[row] << endl;
   // }
#endif 
  }
 }

 for (int i = 0; i < Rows.size(); i++)
 {
  if (Rows[i].nrm2() > 0.) {

   int j = 0;
   for (; j < Rows.size(); j++)
   {
    if (i != j)
    {
     if (Rows[j].nrm2() > 0.)
     {
      btVectorXu test(dim + 1);
      for (int ii = 0; ii<dim + 1; ii++)
      {
       test[ii] = Rows[j][ii] - Rows[i][ii];
      }

      //=Rows[j] - Rows[i]
      if (!LexicographicPositive(test))
       break;
     }
    }
   }

   if (j == Rows.size())
   {
    RowIndex += i;
    break;
   }
  }
 }

 return RowIndex;
}

bool btLemkeAlgorithm::LexicographicPositive(const btVectorXu & v)
{
 int i = 0;
 //  if (DEBUGLEVEL)
 //  cout << "v " << v << endl;

 while (i < v.size() - 1 && fabs(v[i]) < btMachEps())
  i++;
 if (v[i] > 0)
  return true;

 return false;
}

void btLemkeAlgorithm::GaussJordanEliminationStep(btMatrixXu& A, int pivotRowIndex, int pivotColumnIndex, const btAlignedObjectArray<int>& basis)
{

 btScalar a = -1 / A(pivotRowIndex, pivotColumnIndex);
#ifdef BT_DEBUG_OSTREAM
 cout << A << std::endl;
#endif

 for (int i = 0; i < A.rows(); i++)
 {
  if (i != pivotRowIndex)
  {
   for (int j = 0; j < A.cols(); j++)
   {
    if (j != pivotColumnIndex)
    {
     btScalar v = A(i, j);
     v += A(pivotRowIndex, j) * A(i, pivotColumnIndex) * a;
     A.setElem(i, j, v);
    }
   }
  }
 }

#ifdef BT_DEBUG_OSTREAM
 cout << A << std::endl;
#endif //BT_DEBUG_OSTREAM
 for (int i = 0; i < A.cols(); i++)
 {
  A.mulElem(pivotRowIndex, i, -a);
 }
#ifdef BT_DEBUG_OSTREAM
 cout << A << std::endl;
#endif //#ifdef BT_DEBUG_OSTREAM

 for (int i = 0; i < A.rows(); i++)
 {
  if (i != pivotRowIndex)
  {
   A.setElem(i, pivotColumnIndex, 0);
  }
 }
#ifdef BT_DEBUG_OSTREAM
 cout << A << std::endl;
#endif //#ifdef BT_DEBUG_OSTREAM
}

bool btLemkeAlgorithm::greaterZero(const btVectorXu & vector)
{
 bool isGreater = true;
 for (int i = 0; i < vector.size(); i++) {
  if (vector[i] < 0) {
   isGreater = false;
   break;
  }
 }

 return isGreater;
}

bool btLemkeAlgorithm::validBasis(const btAlignedObjectArray<int>& basis)
{
 bool isValid = true;
 for (int i = 0; i < basis.size(); i++) {
  if (basis[i] >= basis.size() * 2) { //then z0 is in the base
   isValid = false;
   break;
  }
 }

 return isValid;
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
///original version written by Erwin Coumans, October 2013

#include "BulletDynamics/MLCPSolvers/btMLCPSolver.h"
#include "LinearMath/btMatrixX.h"
#include "LinearMath/btQuickprof.h"
#include "BulletDynamics/MLCPSolvers/btSolveProjectedGaussSeidel.h"


btMLCPSolver::btMLCPSolver(btMLCPSolverInterface* solver)
 :m_solver(solver),
 m_fallback(0)
{
}

btMLCPSolver::~btMLCPSolver()
{
}

bool gUseMatrixMultiply = false;
bool interleaveContactAndFriction = false;

btScalar btMLCPSolver::solveGroupCacheFriendlySetup(btCollisionObject** bodies, int numBodiesUnUsed, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySetup(bodies, numBodiesUnUsed, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

 {
  BT_PROFILE("gather constraint data");

  int numFrictionPerContact = m_tmpSolverContactConstraintPool.size() == m_tmpSolverContactFrictionConstraintPool.size() ? 1 : 2;


  //	int numBodies = m_tmpSolverBodyPool.size();
  m_allConstraintPtrArray.resize(0);
  m_limitDependencies.resize(m_tmpSolverNonContactConstraintPool.size() + m_tmpSolverContactConstraintPool.size() + m_tmpSolverContactFrictionConstraintPool.size());
  btAssert(m_limitDependencies.size() == m_tmpSolverNonContactConstraintPool.size() + m_tmpSolverContactConstraintPool.size() + m_tmpSolverContactFrictionConstraintPool.size());
  //	printf("m_limitDependencies.size() = %d\n",m_limitDependencies.size());

  int dindex = 0;
  for (int i = 0; i<m_tmpSolverNonContactConstraintPool.size(); i++)
  {
   m_allConstraintPtrArray.push_back(&m_tmpSolverNonContactConstraintPool[i]);
   m_limitDependencies[dindex++] = -1;
  }

  ///The btSequentialImpulseConstraintSolver moves all friction constraints at the very end, we can also interleave them instead

  int firstContactConstraintOffset = dindex;

  if (interleaveContactAndFriction)
  {
   for (int i = 0; i<m_tmpSolverContactConstraintPool.size(); i++)
   {
    m_allConstraintPtrArray.push_back(&m_tmpSolverContactConstraintPool[i]);
    m_limitDependencies[dindex++] = -1;
    m_allConstraintPtrArray.push_back(&m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact]);
    int findex = (m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact].m_frictionIndex*(1 + numFrictionPerContact));
    m_limitDependencies[dindex++] = findex + firstContactConstraintOffset;
    if (numFrictionPerContact == 2)
    {
     m_allConstraintPtrArray.push_back(&m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact + 1]);
     m_limitDependencies[dindex++] = findex + firstContactConstraintOffset;
    }
   }
  }
  else
  {
   for (int i = 0; i<m_tmpSolverContactConstraintPool.size(); i++)
   {
    m_allConstraintPtrArray.push_back(&m_tmpSolverContactConstraintPool[i]);
    m_limitDependencies[dindex++] = -1;
   }
   for (int i = 0; i<m_tmpSolverContactFrictionConstraintPool.size(); i++)
   {
    m_allConstraintPtrArray.push_back(&m_tmpSolverContactFrictionConstraintPool[i]);
    m_limitDependencies[dindex++] = m_tmpSolverContactFrictionConstraintPool[i].m_frictionIndex + firstContactConstraintOffset;
   }

  }


  if (!m_allConstraintPtrArray.size())
  {
   m_A.resize(0, 0);
   m_b.resize(0);
   m_x.resize(0);
   m_lo.resize(0);
   m_hi.resize(0);
   return 0.f;
  }
 }


 if (gUseMatrixMultiply)
 {
  BT_PROFILE("createMLCP");
  createMLCP(infoGlobal);
 }
 else
 {
  BT_PROFILE("createMLCPFast");
  createMLCPFast(infoGlobal);
 }

 return 0.f;
}

bool btMLCPSolver::solveMLCP(const btContactSolverInfo& infoGlobal)
{
 bool result = true;

 if (m_A.rows() == 0)
  return true;

 //if using split impulse, we solve 2 separate (M)LCPs
 if (infoGlobal.m_splitImpulse)
 {
  btMatrixXu Acopy = m_A;
  btAlignedObjectArray<int> limitDependenciesCopy = m_limitDependencies;
  //		printf("solve first LCP\n");
  result = m_solver->solveMLCP(m_A, m_b, m_x, m_lo, m_hi, m_limitDependencies, infoGlobal.m_numIterations);
  if (result)
   result = m_solver->solveMLCP(Acopy, m_bSplit, m_xSplit, m_lo, m_hi, limitDependenciesCopy, infoGlobal.m_numIterations);

 }
 else
 {
  result = m_solver->solveMLCP(m_A, m_b, m_x, m_lo, m_hi, m_limitDependencies, infoGlobal.m_numIterations);
 }
 return result;
}

struct btJointNode
{
 int jointIndex;     // pointer to enclosing dxJoint object
 int otherBodyIndex;       // *other* body this joint is connected to
 int nextJointNodeIndex;//-1 for null
 int constraintRowIndex;
};



void btMLCPSolver::createMLCPFast(const btContactSolverInfo& infoGlobal)
{
 int numContactRows = interleaveContactAndFriction ? 3 : 1;

 int numConstraintRows = m_allConstraintPtrArray.size();
 int n = numConstraintRows;
 {
  BT_PROFILE("init b (rhs)");
  m_b.resize(numConstraintRows);
  m_bSplit.resize(numConstraintRows);
  m_b.setZero();
  m_bSplit.setZero();
  for (int i = 0; i<numConstraintRows; i++)
  {
   btScalar jacDiag = m_allConstraintPtrArray[i]->m_jacDiagABInv;
   if (!btFuzzyZero(jacDiag))
   {
    btScalar rhs = m_allConstraintPtrArray[i]->m_rhs;
    btScalar rhsPenetration = m_allConstraintPtrArray[i]->m_rhsPenetration;
    m_b[i] = rhs / jacDiag;
    m_bSplit[i] = rhsPenetration / jacDiag;
   }

  }
 }

 //	btScalar* w = 0;
 //	int nub = 0;

 m_lo.resize(numConstraintRows);
 m_hi.resize(numConstraintRows);

 {
  BT_PROFILE("init lo/ho");

  for (int i = 0; i<numConstraintRows; i++)
  {
   if (0)//m_limitDependencies[i]>=0)
   {
    m_lo[i] = -BT_INFINITY;
    m_hi[i] = BT_INFINITY;
   }
   else
   {
    m_lo[i] = m_allConstraintPtrArray[i]->m_lowerLimit;
    m_hi[i] = m_allConstraintPtrArray[i]->m_upperLimit;
   }
  }
 }

 //
 int m = m_allConstraintPtrArray.size();

 int numBodies = m_tmpSolverBodyPool.size();
 btAlignedObjectArray<int> bodyJointNodeArray;
 {
  BT_PROFILE("bodyJointNodeArray.resize");
  bodyJointNodeArray.resize(numBodies, -1);
 }
 btAlignedObjectArray<btJointNode> jointNodeArray;
 {
  BT_PROFILE("jointNodeArray.reserve");
  jointNodeArray.reserve(2 * m_allConstraintPtrArray.size());
 }

 btMatrixXu& J3 = m_scratchJ3;
 {
  BT_PROFILE("J3.resize");
  J3.resize(2 * m, 8);
 }
 btMatrixXu& JinvM3 = m_scratchJInvM3;
 {
  BT_PROFILE("JinvM3.resize/setZero");

  JinvM3.resize(2 * m, 8);
  JinvM3.setZero();
  J3.setZero();
 }
 int cur = 0;
 int rowOffset = 0;
 btAlignedObjectArray<int>& ofs = m_scratchOfs;
 {
  BT_PROFILE("ofs resize");
  ofs.resize(0);
  ofs.resizeNoInitialize(m_allConstraintPtrArray.size());
 }
 {
  BT_PROFILE("Compute J and JinvM");
  int c = 0;

  int numRows = 0;

  for (int i = 0; i<m_allConstraintPtrArray.size(); i += numRows, c++)
  {
   ofs[c] = rowOffset;
   int sbA = m_allConstraintPtrArray[i]->m_solverBodyIdA;
   int sbB = m_allConstraintPtrArray[i]->m_solverBodyIdB;
   btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
   btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;

   numRows = i<m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[c].m_numConstraintRows : numContactRows;
   if (orgBodyA)
   {
    {
     int slotA = -1;
     //find free jointNode slot for sbA
     slotA = jointNodeArray.size();
     jointNodeArray.expand();//NonInitializing();
     int prevSlot = bodyJointNodeArray[sbA];
     bodyJointNodeArray[sbA] = slotA;
     jointNodeArray[slotA].nextJointNodeIndex = prevSlot;
     jointNodeArray[slotA].jointIndex = c;
     jointNodeArray[slotA].constraintRowIndex = i;
     jointNodeArray[slotA].otherBodyIndex = orgBodyB ? sbB : -1;
    }
    for (int row = 0; row<numRows; row++, cur++)
    {
     btVector3 normalInvMass = m_allConstraintPtrArray[i + row]->m_contactNormal1 *		orgBodyA->getInvMass();
     btVector3 relPosCrossNormalInvInertia = m_allConstraintPtrArray[i + row]->m_relpos1CrossNormal *	orgBodyA->getInvInertiaTensorWorld();

     for (int r = 0; r<3; r++)
     {
      J3.setElem(cur, r, m_allConstraintPtrArray[i + row]->m_contactNormal1[r]);
      J3.setElem(cur, r + 4, m_allConstraintPtrArray[i + row]->m_relpos1CrossNormal[r]);
      JinvM3.setElem(cur, r, normalInvMass[r]);
      JinvM3.setElem(cur, r + 4, relPosCrossNormalInvInertia[r]);
     }
     J3.setElem(cur, 3, 0);
     JinvM3.setElem(cur, 3, 0);
     J3.setElem(cur, 7, 0);
     JinvM3.setElem(cur, 7, 0);
    }
   }
   else
   {
    cur += numRows;
   }
   if (orgBodyB)
   {

    {
     int slotB = -1;
     //find free jointNode slot for sbA
     slotB = jointNodeArray.size();
     jointNodeArray.expand();//NonInitializing();
     int prevSlot = bodyJointNodeArray[sbB];
     bodyJointNodeArray[sbB] = slotB;
     jointNodeArray[slotB].nextJointNodeIndex = prevSlot;
     jointNodeArray[slotB].jointIndex = c;
     jointNodeArray[slotB].otherBodyIndex = orgBodyA ? sbA : -1;
     jointNodeArray[slotB].constraintRowIndex = i;
    }

    for (int row = 0; row<numRows; row++, cur++)
    {
     btVector3 normalInvMassB = m_allConstraintPtrArray[i + row]->m_contactNormal2*orgBodyB->getInvMass();
     btVector3 relPosInvInertiaB = m_allConstraintPtrArray[i + row]->m_relpos2CrossNormal * orgBodyB->getInvInertiaTensorWorld();

     for (int r = 0; r<3; r++)
     {
      J3.setElem(cur, r, m_allConstraintPtrArray[i + row]->m_contactNormal2[r]);
      J3.setElem(cur, r + 4, m_allConstraintPtrArray[i + row]->m_relpos2CrossNormal[r]);
      JinvM3.setElem(cur, r, normalInvMassB[r]);
      JinvM3.setElem(cur, r + 4, relPosInvInertiaB[r]);
     }
     J3.setElem(cur, 3, 0);
     JinvM3.setElem(cur, 3, 0);
     J3.setElem(cur, 7, 0);
     JinvM3.setElem(cur, 7, 0);
    }
   }
   else
   {
    cur += numRows;
   }
   rowOffset += numRows;

  }

 }


 //compute JinvM = J*invM.
 const btScalar* JinvM = JinvM3.getBufferPointer();

 const btScalar* Jptr = J3.getBufferPointer();
 {
  BT_PROFILE("m_A.resize");
  m_A.resize(n, n);
 }

 {
  BT_PROFILE("m_A.setZero");
  m_A.setZero();
 }
 int c = 0;
 {
  int numRows = 0;
  BT_PROFILE("Compute A");
  for (int i = 0; i<m_allConstraintPtrArray.size(); i += numRows, c++)
  {
   int row__ = ofs[c];
   int sbA = m_allConstraintPtrArray[i]->m_solverBodyIdA;
   int sbB = m_allConstraintPtrArray[i]->m_solverBodyIdB;
   //	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
   //	btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;

   numRows = i<m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[c].m_numConstraintRows : numContactRows;

   const btScalar *JinvMrow = JinvM + 2 * 8 * (size_t)row__;

   {
    int startJointNodeA = bodyJointNodeArray[sbA];
    while (startJointNodeA >= 0)
    {
     int j0 = jointNodeArray[startJointNodeA].jointIndex;
     int cr0 = jointNodeArray[startJointNodeA].constraintRowIndex;
     if (j0<c)
     {

      int numRowsOther = cr0 < m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[j0].m_numConstraintRows : numContactRows;
      size_t ofsother = (m_allConstraintPtrArray[cr0]->m_solverBodyIdB == sbA) ? 8 * numRowsOther : 0;
      //printf("%d joint i %d and j0: %d: ",count++,i,j0);
      m_A.multiplyAdd2_p8r(JinvMrow,
       Jptr + 2 * 8 * (size_t)ofs[j0] + ofsother, numRows, numRowsOther, row__, ofs[j0]);
     }
     startJointNodeA = jointNodeArray[startJointNodeA].nextJointNodeIndex;
    }
   }

   {
    int startJointNodeB = bodyJointNodeArray[sbB];
    while (startJointNodeB >= 0)
    {
     int j1 = jointNodeArray[startJointNodeB].jointIndex;
     int cj1 = jointNodeArray[startJointNodeB].constraintRowIndex;

     if (j1<c)
     {
      int numRowsOther = cj1 < m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[j1].m_numConstraintRows : numContactRows;
      size_t ofsother = (m_allConstraintPtrArray[cj1]->m_solverBodyIdB == sbB) ? 8 * numRowsOther : 0;
      m_A.multiplyAdd2_p8r(JinvMrow + 8 * (size_t)numRows,
       Jptr + 2 * 8 * (size_t)ofs[j1] + ofsother, numRows, numRowsOther, row__, ofs[j1]);
     }
     startJointNodeB = jointNodeArray[startJointNodeB].nextJointNodeIndex;
    }
   }
  }

  {
   BT_PROFILE("compute diagonal");
   // compute diagonal blocks of m_A

   int  row__ = 0;
   int numJointRows = m_allConstraintPtrArray.size();

   int jj = 0;
   for (; row__<numJointRows;)
   {

    //int sbA = m_allConstraintPtrArray[row__]->m_solverBodyIdA;
    int sbB = m_allConstraintPtrArray[row__]->m_solverBodyIdB;
    //	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
    btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;


    const unsigned int infom = row__ < m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[jj].m_numConstraintRows : numContactRows;

    const btScalar *JinvMrow = JinvM + 2 * 8 * (size_t)row__;
    const btScalar *Jrow = Jptr + 2 * 8 * (size_t)row__;
    m_A.multiply2_p8r(JinvMrow, Jrow, infom, infom, row__, row__);
    if (orgBodyB)
    {
     m_A.multiplyAdd2_p8r(JinvMrow + 8 * (size_t)infom, Jrow + 8 * (size_t)infom, infom, infom, row__, row__);
    }
    row__ += infom;
    jj++;
   }
  }
 }

 if (1)
 {
  // add cfm to the diagonal of m_A
  for (int i = 0; i<m_A.rows(); ++i)
  {
   m_A.setElem(i, i, m_A(i, i) + infoGlobal.m_globalCfm / infoGlobal.m_timeStep);
  }
 }

 ///fill the upper triangle of the matrix, to make it symmetric
 {
  BT_PROFILE("fill the upper triangle ");
  m_A.copyLowerToUpperTriangle();
 }

 {
  BT_PROFILE("resize/init x");
  m_x.resize(numConstraintRows);
  m_xSplit.resize(numConstraintRows);

  if (infoGlobal.m_solverMode&SOLVER_USE_WARMSTARTING)
  {
   for (int i = 0; i<m_allConstraintPtrArray.size(); i++)
   {
    const btSolverConstraint& c = *m_allConstraintPtrArray[i];
    m_x[i] = c.m_appliedImpulse;
    m_xSplit[i] = c.m_appliedPushImpulse;
   }
  }
  else
  {
   m_x.setZero();
   m_xSplit.setZero();
  }
 }

}

void btMLCPSolver::createMLCP(const btContactSolverInfo& infoGlobal)
{
 int numBodies = this->m_tmpSolverBodyPool.size();
 int numConstraintRows = m_allConstraintPtrArray.size();

 m_b.resize(numConstraintRows);
 if (infoGlobal.m_splitImpulse)
  m_bSplit.resize(numConstraintRows);

 m_bSplit.setZero();
 m_b.setZero();

 for (int i = 0; i<numConstraintRows; i++)
 {
  if (m_allConstraintPtrArray[i]->m_jacDiagABInv)
  {
   m_b[i] = m_allConstraintPtrArray[i]->m_rhs / m_allConstraintPtrArray[i]->m_jacDiagABInv;
   if (infoGlobal.m_splitImpulse)
    m_bSplit[i] = m_allConstraintPtrArray[i]->m_rhsPenetration / m_allConstraintPtrArray[i]->m_jacDiagABInv;
  }
 }

 btMatrixXu& Minv = m_scratchMInv;
 Minv.resize(6 * numBodies, 6 * numBodies);
 Minv.setZero();
 for (int i = 0; i<numBodies; i++)
 {
  const btSolverBody& rb = m_tmpSolverBodyPool[i];
  const btVector3& invMass = rb.m_invMass;
  setElem(Minv, i * 6 + 0, i * 6 + 0, invMass[0]);
  setElem(Minv, i * 6 + 1, i * 6 + 1, invMass[1]);
  setElem(Minv, i * 6 + 2, i * 6 + 2, invMass[2]);
  btRigidBody* orgBody = m_tmpSolverBodyPool[i].m_originalBody;

  for (int r = 0; r<3; r++)
   for (int c = 0; c<3; c++)
    setElem(Minv, i * 6 + 3 + r, i * 6 + 3 + c, orgBody ? orgBody->getInvInertiaTensorWorld()[r][c] : 0);
 }

 btMatrixXu& J = m_scratchJ;
 J.resize(numConstraintRows, 6 * numBodies);
 J.setZero();

 m_lo.resize(numConstraintRows);
 m_hi.resize(numConstraintRows);

 for (int i = 0; i<numConstraintRows; i++)
 {

  m_lo[i] = m_allConstraintPtrArray[i]->m_lowerLimit;
  m_hi[i] = m_allConstraintPtrArray[i]->m_upperLimit;

  int bodyIndex0 = m_allConstraintPtrArray[i]->m_solverBodyIdA;
  int bodyIndex1 = m_allConstraintPtrArray[i]->m_solverBodyIdB;
  if (m_tmpSolverBodyPool[bodyIndex0].m_originalBody)
  {
   setElem(J, i, 6 * bodyIndex0 + 0, m_allConstraintPtrArray[i]->m_contactNormal1[0]);
   setElem(J, i, 6 * bodyIndex0 + 1, m_allConstraintPtrArray[i]->m_contactNormal1[1]);
   setElem(J, i, 6 * bodyIndex0 + 2, m_allConstraintPtrArray[i]->m_contactNormal1[2]);
   setElem(J, i, 6 * bodyIndex0 + 3, m_allConstraintPtrArray[i]->m_relpos1CrossNormal[0]);
   setElem(J, i, 6 * bodyIndex0 + 4, m_allConstraintPtrArray[i]->m_relpos1CrossNormal[1]);
   setElem(J, i, 6 * bodyIndex0 + 5, m_allConstraintPtrArray[i]->m_relpos1CrossNormal[2]);
  }
  if (m_tmpSolverBodyPool[bodyIndex1].m_originalBody)
  {
   setElem(J, i, 6 * bodyIndex1 + 0, m_allConstraintPtrArray[i]->m_contactNormal2[0]);
   setElem(J, i, 6 * bodyIndex1 + 1, m_allConstraintPtrArray[i]->m_contactNormal2[1]);
   setElem(J, i, 6 * bodyIndex1 + 2, m_allConstraintPtrArray[i]->m_contactNormal2[2]);
   setElem(J, i, 6 * bodyIndex1 + 3, m_allConstraintPtrArray[i]->m_relpos2CrossNormal[0]);
   setElem(J, i, 6 * bodyIndex1 + 4, m_allConstraintPtrArray[i]->m_relpos2CrossNormal[1]);
   setElem(J, i, 6 * bodyIndex1 + 5, m_allConstraintPtrArray[i]->m_relpos2CrossNormal[2]);
  }
 }

 btMatrixXu& J_transpose = m_scratchJTranspose;
 J_transpose = J.transpose();

 btMatrixXu& tmp = m_scratchTmp;

 {
  {
   BT_PROFILE("J*Minv");
   tmp = J*Minv;

  }
  {
   BT_PROFILE("J*tmp");
   m_A = tmp*J_transpose;
  }
 }

 if (1)
 {
  // add cfm to the diagonal of m_A
  for (int i = 0; i<m_A.rows(); ++i)
  {
   m_A.setElem(i, i, m_A(i, i) + infoGlobal.m_globalCfm / infoGlobal.m_timeStep);
  }
 }

 m_x.resize(numConstraintRows);
 if (infoGlobal.m_splitImpulse)
  m_xSplit.resize(numConstraintRows);
 //	m_x.setZero();

 for (int i = 0; i<m_allConstraintPtrArray.size(); i++)
 {
  const btSolverConstraint& c = *m_allConstraintPtrArray[i];
  m_x[i] = c.m_appliedImpulse;
  if (infoGlobal.m_splitImpulse)
   m_xSplit[i] = c.m_appliedPushImpulse;
 }

}


btScalar btMLCPSolver::solveGroupCacheFriendlyIterations(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
 bool result = true;
 {
  BT_PROFILE("solveMLCP");
  //		printf("m_A(%d,%d)\n", m_A.rows(),m_A.cols());
  result = solveMLCP(infoGlobal);
 }

 //check if solution is valid, and otherwise fallback to btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations
 if (result)
 {
  BT_PROFILE("process MLCP results");
  for (int i = 0; i<m_allConstraintPtrArray.size(); i++)
  {
   {
    btSolverConstraint& c = *m_allConstraintPtrArray[i];
    int sbA = c.m_solverBodyIdA;
    int sbB = c.m_solverBodyIdB;
    //btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
    //	btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;

    btSolverBody& solverBodyA = m_tmpSolverBodyPool[sbA];
    btSolverBody& solverBodyB = m_tmpSolverBodyPool[sbB];

    {
     btScalar deltaImpulse = m_x[i] - c.m_appliedImpulse;
     c.m_appliedImpulse = m_x[i];
     solverBodyA.internalApplyImpulse(c.m_contactNormal1*solverBodyA.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
     solverBodyB.internalApplyImpulse(c.m_contactNormal2*solverBodyB.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
    }

    if (infoGlobal.m_splitImpulse)
    {
     btScalar deltaImpulse = m_xSplit[i] - c.m_appliedPushImpulse;
     solverBodyA.internalApplyPushImpulse(c.m_contactNormal1*solverBodyA.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
     solverBodyB.internalApplyPushImpulse(c.m_contactNormal2*solverBodyB.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
     c.m_appliedPushImpulse = m_xSplit[i];
    }

   }
  }
 }
 else
 {
  //	printf("m_fallback = %d\n",m_fallback);
  m_fallback++;
  btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);
 }

 return 0.f;
}

/*
* Copyright (c) 2005 Erwin Coumans http://continuousphysics.com/Bullet/
*
* Permission to use, copy, modify, distribute and sell this software
* and its documentation for any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erwin Coumans makes no representations about the suitability
* of this software for any purpose.
* It is provided "as is" without express or implied warranty.
*/

#include "LinearMath/btVector3.h"
#include "BulletDynamics/Vehicle/btRaycastVehicle.h"

#include "BulletDynamics/ConstraintSolver/btSolve2LinearConstraint.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "LinearMath/btQuaternion.h"
#include "BulletDynamics/Dynamics/btDynamicsWorld.h"
#include "BulletDynamics/Vehicle/btVehicleRaycaster.h"
#include "BulletDynamics/Vehicle/btWheelInfo.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btIDebugDraw.h"
#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"

#define ROLLING_INFLUENCE_FIX


btRigidBody& btActionInterface::getFixedBody()
{
 static btRigidBody s_fixed(0, 0, 0);
 s_fixed.setMassProps(btScalar(0.), btVector3(btScalar(0.), btScalar(0.), btScalar(0.)));
 return s_fixed;
}

btRaycastVehicle::btRaycastVehicle(const btVehicleTuning& tuning, btRigidBody* chassis, btVehicleRaycaster* raycaster)
 :m_vehicleRaycaster(raycaster),
 m_pitchControl(btScalar(0.))
{
 m_chassisBody = chassis;
 m_indexRightAxis = 0;
 m_indexUpAxis = 2;
 m_indexForwardAxis = 1;
 defaultInit(tuning);
}


void btRaycastVehicle::defaultInit(const btVehicleTuning& tuning)
{
 (void)tuning;
 m_currentVehicleSpeedKmHour = btScalar(0.);
 m_steeringValue = btScalar(0.);

}



btRaycastVehicle::~btRaycastVehicle()
{
}


//
// basically most of the code is general for 2 or 4 wheel vehicles, but some of it needs to be reviewed
//
btWheelInfo&	btRaycastVehicle::addWheel(const btVector3& connectionPointCS, const btVector3& wheelDirectionCS0, const btVector3& wheelAxleCS, btScalar suspensionRestLength, btScalar wheelRadius, const btVehicleTuning& tuning, bool isFrontWheel)
{

 btWheelInfoConstructionInfo ci;

 ci.m_chassisConnectionCS = connectionPointCS;
 ci.m_wheelDirectionCS = wheelDirectionCS0;
 ci.m_wheelAxleCS = wheelAxleCS;
 ci.m_suspensionRestLength = suspensionRestLength;
 ci.m_wheelRadius = wheelRadius;
 ci.m_suspensionStiffness = tuning.m_suspensionStiffness;
 ci.m_wheelsDampingCompression = tuning.m_suspensionCompression;
 ci.m_wheelsDampingRelaxation = tuning.m_suspensionDamping;
 ci.m_frictionSlip = tuning.m_frictionSlip;
 ci.m_bIsFrontWheel = isFrontWheel;
 ci.m_maxSuspensionTravelCm = tuning.m_maxSuspensionTravelCm;
 ci.m_maxSuspensionForce = tuning.m_maxSuspensionForce;

 m_wheelInfo.push_back(btWheelInfo(ci));

 btWheelInfo& wheel = m_wheelInfo[getNumWheels() - 1];

 updateWheelTransformsWS(wheel, false);
 updateWheelTransform(getNumWheels() - 1, false);
 return wheel;
}




const btTransform&	btRaycastVehicle::getWheelTransformWS(int wheelIndex) const
{
 btAssert(wheelIndex < getNumWheels());
 const btWheelInfo& wheel = m_wheelInfo[wheelIndex];
 return wheel.m_worldTransform;

}

void	btRaycastVehicle::updateWheelTransform(int wheelIndex, bool interpolatedTransform)
{

 btWheelInfo& wheel = m_wheelInfo[wheelIndex];
 updateWheelTransformsWS(wheel, interpolatedTransform);
 btVector3 up = -wheel.m_raycastInfo.m_wheelDirectionWS;
 const btVector3& right = wheel.m_raycastInfo.m_wheelAxleWS;
 btVector3 fwd = up.cross(right);
 fwd = fwd.normalize();
 //	up = right.cross(fwd);
 //	up.normalize();

 //rotate around steering over de wheelAxleWS
 btScalar steering = wheel.m_steering;

 btQuaternion steeringOrn(up, steering);//wheel.m_steering);
 btMatrix3x3 steeringMat(steeringOrn);

 btQuaternion rotatingOrn(right, -wheel.m_rotation);
 btMatrix3x3 rotatingMat(rotatingOrn);

 btMatrix3x3 basis2(
  right[0], fwd[0], up[0],
  right[1], fwd[1], up[1],
  right[2], fwd[2], up[2]
 );

 wheel.m_worldTransform.setBasis(steeringMat * rotatingMat * basis2);
 wheel.m_worldTransform.setOrigin(
  wheel.m_raycastInfo.m_hardPointWS + wheel.m_raycastInfo.m_wheelDirectionWS * wheel.m_raycastInfo.m_suspensionLength
 );
}

void btRaycastVehicle::resetSuspension()
{

 int i;
 for (i = 0; i<m_wheelInfo.size(); i++)
 {
  btWheelInfo& wheel = m_wheelInfo[i];
  wheel.m_raycastInfo.m_suspensionLength = wheel.getSuspensionRestLength();
  wheel.m_suspensionRelativeVelocity = btScalar(0.0);

  wheel.m_raycastInfo.m_contactNormalWS = -wheel.m_raycastInfo.m_wheelDirectionWS;
  //wheel_info.setContactFriction(btScalar(0.0));
  wheel.m_clippedInvContactDotSuspension = btScalar(1.0);
 }
}

void	btRaycastVehicle::updateWheelTransformsWS(btWheelInfo& wheel, bool interpolatedTransform)
{
 wheel.m_raycastInfo.m_isInContact = false;

 btTransform chassisTrans = getChassisWorldTransform();
 if (interpolatedTransform && (getRigidBody()->getMotionState()))
 {
  getRigidBody()->getMotionState()->getWorldTransform(chassisTrans);
 }

 wheel.m_raycastInfo.m_hardPointWS = chassisTrans(wheel.m_chassisConnectionPointCS);
 wheel.m_raycastInfo.m_wheelDirectionWS = chassisTrans.getBasis() *  wheel.m_wheelDirectionCS;
 wheel.m_raycastInfo.m_wheelAxleWS = chassisTrans.getBasis() * wheel.m_wheelAxleCS;
}

btScalar btRaycastVehicle::rayCast(btWheelInfo& wheel)
{
 updateWheelTransformsWS(wheel, false);


 btScalar depth = -1;

 btScalar raylen = wheel.getSuspensionRestLength() + wheel.m_wheelsRadius;

 btVector3 rayvector = wheel.m_raycastInfo.m_wheelDirectionWS * (raylen);
 const btVector3& source = wheel.m_raycastInfo.m_hardPointWS;
 wheel.m_raycastInfo.m_contactPointWS = source + rayvector;
 const btVector3& target = wheel.m_raycastInfo.m_contactPointWS;

 btScalar param = btScalar(0.);

 btVehicleRaycaster::btVehicleRaycasterResult	rayResults;

 btAssert(m_vehicleRaycaster);

 void* object = m_vehicleRaycaster->castRay(source, target, rayResults);

 wheel.m_raycastInfo.m_groundObject = 0;

 if (object)
 {
  param = rayResults.m_distFraction;
  depth = raylen * rayResults.m_distFraction;
  wheel.m_raycastInfo.m_contactNormalWS = rayResults.m_hitNormalInWorld;
  wheel.m_raycastInfo.m_isInContact = true;

  wheel.m_raycastInfo.m_groundObject = &getFixedBody();///@todo for driving on dynamic/movable objects!;
                                                       //wheel.m_raycastInfo.m_groundObject = object;


  btScalar hitDistance = param*raylen;
  wheel.m_raycastInfo.m_suspensionLength = hitDistance - wheel.m_wheelsRadius;
  //clamp on max suspension travel

  btScalar  minSuspensionLength = wheel.getSuspensionRestLength() - wheel.m_maxSuspensionTravelCm*btScalar(0.01);
  btScalar maxSuspensionLength = wheel.getSuspensionRestLength() + wheel.m_maxSuspensionTravelCm*btScalar(0.01);
  if (wheel.m_raycastInfo.m_suspensionLength < minSuspensionLength)
  {
   wheel.m_raycastInfo.m_suspensionLength = minSuspensionLength;
  }
  if (wheel.m_raycastInfo.m_suspensionLength > maxSuspensionLength)
  {
   wheel.m_raycastInfo.m_suspensionLength = maxSuspensionLength;
  }

  wheel.m_raycastInfo.m_contactPointWS = rayResults.m_hitPointInWorld;

  btScalar denominator = wheel.m_raycastInfo.m_contactNormalWS.dot(wheel.m_raycastInfo.m_wheelDirectionWS);

  btVector3 chassis_velocity_at_contactPoint;
  btVector3 relpos = wheel.m_raycastInfo.m_contactPointWS - getRigidBody()->getCenterOfMassPosition();

  chassis_velocity_at_contactPoint = getRigidBody()->getVelocityInLocalPoint(relpos);

  btScalar projVel = wheel.m_raycastInfo.m_contactNormalWS.dot(chassis_velocity_at_contactPoint);

  if (denominator >= btScalar(-0.1))
  {
   wheel.m_suspensionRelativeVelocity = btScalar(0.0);
   wheel.m_clippedInvContactDotSuspension = btScalar(1.0) / btScalar(0.1);
  }
  else
  {
   btScalar inv = btScalar(-1.) / denominator;
   wheel.m_suspensionRelativeVelocity = projVel * inv;
   wheel.m_clippedInvContactDotSuspension = inv;
  }

 }
 else
 {
  //put wheel info as in rest position
  wheel.m_raycastInfo.m_suspensionLength = wheel.getSuspensionRestLength();
  wheel.m_suspensionRelativeVelocity = btScalar(0.0);
  wheel.m_raycastInfo.m_contactNormalWS = -wheel.m_raycastInfo.m_wheelDirectionWS;
  wheel.m_clippedInvContactDotSuspension = btScalar(1.0);
 }

 return depth;
}


const btTransform& btRaycastVehicle::getChassisWorldTransform() const
{
 /*if (getRigidBody()->getMotionState())
 {
 btTransform chassisWorldTrans;
 getRigidBody()->getMotionState()->getWorldTransform(chassisWorldTrans);
 return chassisWorldTrans;
 }
 */


 return getRigidBody()->getCenterOfMassTransform();
}


void btRaycastVehicle::updateVehicle(btScalar step)
{
 {
  for (int i = 0; i<getNumWheels(); i++)
  {
   updateWheelTransform(i, false);
  }
 }


 m_currentVehicleSpeedKmHour = btScalar(3.6) * getRigidBody()->getLinearVelocity().length();

 const btTransform& chassisTrans = getChassisWorldTransform();

 btVector3 forwardW(
  chassisTrans.getBasis()[0][m_indexForwardAxis],
  chassisTrans.getBasis()[1][m_indexForwardAxis],
  chassisTrans.getBasis()[2][m_indexForwardAxis]);

 if (forwardW.dot(getRigidBody()->getLinearVelocity()) < btScalar(0.))
 {
  m_currentVehicleSpeedKmHour *= btScalar(-1.);
 }

 //
 // simulate suspension
 //

 int i = 0;
 for (i = 0; i<m_wheelInfo.size(); i++)
 {
  //btScalar depth; 
  //depth = 
  rayCast(m_wheelInfo[i]);
 }

 updateSuspension(step);


 for (i = 0; i<m_wheelInfo.size(); i++)
 {
  //apply suspension force
  btWheelInfo& wheel = m_wheelInfo[i];

  btScalar suspensionForce = wheel.m_wheelsSuspensionForce;

  if (suspensionForce > wheel.m_maxSuspensionForce)
  {
   suspensionForce = wheel.m_maxSuspensionForce;
  }
  btVector3 impulse = wheel.m_raycastInfo.m_contactNormalWS * suspensionForce * step;
  btVector3 relpos = wheel.m_raycastInfo.m_contactPointWS - getRigidBody()->getCenterOfMassPosition();

  getRigidBody()->applyImpulse(impulse, relpos);

 }



 updateFriction(step);


 for (i = 0; i<m_wheelInfo.size(); i++)
 {
  btWheelInfo& wheel = m_wheelInfo[i];
  btVector3 relpos = wheel.m_raycastInfo.m_hardPointWS - getRigidBody()->getCenterOfMassPosition();
  btVector3 vel = getRigidBody()->getVelocityInLocalPoint(relpos);

  if (wheel.m_raycastInfo.m_isInContact)
  {
   const btTransform&	chassisWorldTransform = getChassisWorldTransform();

   btVector3 fwd(
    chassisWorldTransform.getBasis()[0][m_indexForwardAxis],
    chassisWorldTransform.getBasis()[1][m_indexForwardAxis],
    chassisWorldTransform.getBasis()[2][m_indexForwardAxis]);

   btScalar proj = fwd.dot(wheel.m_raycastInfo.m_contactNormalWS);
   fwd -= wheel.m_raycastInfo.m_contactNormalWS * proj;

   btScalar proj2 = fwd.dot(vel);

   wheel.m_deltaRotation = (proj2 * step) / (wheel.m_wheelsRadius);
   wheel.m_rotation += wheel.m_deltaRotation;

  }
  else
  {
   wheel.m_rotation += wheel.m_deltaRotation;
  }

  wheel.m_deltaRotation *= btScalar(0.99);//damping of rotation when not in contact

 }



}


void	btRaycastVehicle::setSteeringValue(btScalar steering, int wheel)
{
 btAssert(wheel >= 0 && wheel < getNumWheels());

 btWheelInfo& wheelInfo = getWheelInfo(wheel);
 wheelInfo.m_steering = steering;
}



btScalar	btRaycastVehicle::getSteeringValue(int wheel) const
{
 return getWheelInfo(wheel).m_steering;
}


void	btRaycastVehicle::applyEngineForce(btScalar force, int wheel)
{
 btAssert(wheel >= 0 && wheel < getNumWheels());
 btWheelInfo& wheelInfo = getWheelInfo(wheel);
 wheelInfo.m_engineForce = force;
}


const btWheelInfo&	btRaycastVehicle::getWheelInfo(int index) const
{
 btAssert((index >= 0) && (index < 	getNumWheels()));

 return m_wheelInfo[index];
}

btWheelInfo&	btRaycastVehicle::getWheelInfo(int index)
{
 btAssert((index >= 0) && (index < 	getNumWheels()));

 return m_wheelInfo[index];
}

void btRaycastVehicle::setBrake(btScalar brake, int wheelIndex)
{
 btAssert((wheelIndex >= 0) && (wheelIndex < 	getNumWheels()));
 getWheelInfo(wheelIndex).m_brake = brake;
}


void	btRaycastVehicle::updateSuspension(btScalar deltaTime)
{
 (void)deltaTime;

 btScalar chassisMass = btScalar(1.) / m_chassisBody->getInvMass();

 for (int w_it = 0; w_it<getNumWheels(); w_it++)
 {
  btWheelInfo &wheel_info = m_wheelInfo[w_it];

  if (wheel_info.m_raycastInfo.m_isInContact)
  {
   btScalar force;
   //	Spring
   {
    btScalar	susp_length = wheel_info.getSuspensionRestLength();
    btScalar	current_length = wheel_info.m_raycastInfo.m_suspensionLength;

    btScalar length_diff = (susp_length - current_length);

    force = wheel_info.m_suspensionStiffness
     * length_diff * wheel_info.m_clippedInvContactDotSuspension;
   }

   // Damper
   {
    btScalar projected_rel_vel = wheel_info.m_suspensionRelativeVelocity;
    {
     btScalar	susp_damping;
     if (projected_rel_vel < btScalar(0.0))
     {
      susp_damping = wheel_info.m_wheelsDampingCompression;
     }
     else
     {
      susp_damping = wheel_info.m_wheelsDampingRelaxation;
     }
     force -= susp_damping * projected_rel_vel;
    }
   }

   // RESULT
   wheel_info.m_wheelsSuspensionForce = force * chassisMass;
   if (wheel_info.m_wheelsSuspensionForce < btScalar(0.))
   {
    wheel_info.m_wheelsSuspensionForce = btScalar(0.);
   }
  }
  else
  {
   wheel_info.m_wheelsSuspensionForce = btScalar(0.0);
  }
 }

}


struct btWheelContactPoint
{
 btRigidBody* m_body0;
 btRigidBody* m_body1;
 btVector3	m_frictionPositionWorld;
 btVector3	m_frictionDirectionWorld;
 btScalar	m_jacDiagABInv;
 btScalar	m_maxImpulse;


 btWheelContactPoint(btRigidBody* body0, btRigidBody* body1, const btVector3& frictionPosWorld, const btVector3& frictionDirectionWorld, btScalar maxImpulse)
  :m_body0(body0),
  m_body1(body1),
  m_frictionPositionWorld(frictionPosWorld),
  m_frictionDirectionWorld(frictionDirectionWorld),
  m_maxImpulse(maxImpulse)
 {
  btScalar denom0 = body0->computeImpulseDenominator(frictionPosWorld, frictionDirectionWorld);
  btScalar denom1 = body1->computeImpulseDenominator(frictionPosWorld, frictionDirectionWorld);
  btScalar	relaxation = 1.f;
  m_jacDiagABInv = relaxation / (denom0 + denom1);
 }



};

btScalar calcRollingFriction(btWheelContactPoint& contactPoint);
btScalar calcRollingFriction(btWheelContactPoint& contactPoint)
{

 btScalar j1 = 0.f;

 const btVector3& contactPosWorld = contactPoint.m_frictionPositionWorld;

 btVector3 rel_pos1 = contactPosWorld - contactPoint.m_body0->getCenterOfMassPosition();
 btVector3 rel_pos2 = contactPosWorld - contactPoint.m_body1->getCenterOfMassPosition();

 btScalar maxImpulse = contactPoint.m_maxImpulse;

 btVector3 vel1 = contactPoint.m_body0->getVelocityInLocalPoint(rel_pos1);
 btVector3 vel2 = contactPoint.m_body1->getVelocityInLocalPoint(rel_pos2);
 btVector3 vel = vel1 - vel2;

 btScalar vrel = contactPoint.m_frictionDirectionWorld.dot(vel);

 // calculate j that moves us to zero relative velocity
 j1 = -vrel * contactPoint.m_jacDiagABInv;
 btSetMin(j1, maxImpulse);
 btSetMax(j1, -maxImpulse);

 return j1;
}




btScalar sideFrictionStiffness2 = btScalar(1.0);
void	btRaycastVehicle::updateFriction(btScalar	timeStep)
{

 //calculate the impulse, so that the wheels don't move sidewards
 int numWheel = getNumWheels();
 if (!numWheel)
  return;

 m_forwardWS.resize(numWheel);
 m_axle.resize(numWheel);
 m_forwardImpulse.resize(numWheel);
 m_sideImpulse.resize(numWheel);

 int numWheelsOnGround = 0;


 //collapse all those loops into one!
 for (int i = 0; i<getNumWheels(); i++)
 {
  btWheelInfo& wheelInfo = m_wheelInfo[i];
  class btRigidBody* groundObject = (class btRigidBody*) wheelInfo.m_raycastInfo.m_groundObject;
  if (groundObject)
   numWheelsOnGround++;
  m_sideImpulse[i] = btScalar(0.);
  m_forwardImpulse[i] = btScalar(0.);

 }

 {

  for (int i = 0; i<getNumWheels(); i++)
  {

   btWheelInfo& wheelInfo = m_wheelInfo[i];

   class btRigidBody* groundObject = (class btRigidBody*) wheelInfo.m_raycastInfo.m_groundObject;

   if (groundObject)
   {

    const btTransform& wheelTrans = getWheelTransformWS(i);

    btMatrix3x3 wheelBasis0 = wheelTrans.getBasis();
    m_axle[i] = btVector3(
     wheelBasis0[0][m_indexRightAxis],
     wheelBasis0[1][m_indexRightAxis],
     wheelBasis0[2][m_indexRightAxis]);

    const btVector3& surfNormalWS = wheelInfo.m_raycastInfo.m_contactNormalWS;
    btScalar proj = m_axle[i].dot(surfNormalWS);
    m_axle[i] -= surfNormalWS * proj;
    m_axle[i] = m_axle[i].normalize();

    m_forwardWS[i] = surfNormalWS.cross(m_axle[i]);
    m_forwardWS[i].normalize();


    resolveSingleBilateral(*m_chassisBody, wheelInfo.m_raycastInfo.m_contactPointWS,
     *groundObject, wheelInfo.m_raycastInfo.m_contactPointWS,
     btScalar(0.), m_axle[i], m_sideImpulse[i], timeStep);

    m_sideImpulse[i] *= sideFrictionStiffness2;

   }


  }
 }

 btScalar sideFactor = btScalar(1.);
 btScalar fwdFactor = 0.5;

 bool sliding = false;
 {
  for (int wheel = 0; wheel <getNumWheels(); wheel++)
  {
   btWheelInfo& wheelInfo = m_wheelInfo[wheel];
   class btRigidBody* groundObject = (class btRigidBody*) wheelInfo.m_raycastInfo.m_groundObject;

   btScalar	rollingFriction = 0.f;

   if (groundObject)
   {
    if (wheelInfo.m_engineForce != 0.f)
    {
     rollingFriction = wheelInfo.m_engineForce* timeStep;
    }
    else
    {
     btScalar defaultRollingFrictionImpulse = 0.f;
     btScalar maxImpulse = wheelInfo.m_brake ? wheelInfo.m_brake : defaultRollingFrictionImpulse;
     btWheelContactPoint contactPt(m_chassisBody, groundObject, wheelInfo.m_raycastInfo.m_contactPointWS, m_forwardWS[wheel], maxImpulse);
     rollingFriction = calcRollingFriction(contactPt);
    }
   }

   //switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)




   m_forwardImpulse[wheel] = btScalar(0.);
   m_wheelInfo[wheel].m_skidInfo = btScalar(1.);

   if (groundObject)
   {
    m_wheelInfo[wheel].m_skidInfo = btScalar(1.);

    btScalar maximp = wheelInfo.m_wheelsSuspensionForce * timeStep * wheelInfo.m_frictionSlip;
    btScalar maximpSide = maximp;

    btScalar maximpSquared = maximp * maximpSide;


    m_forwardImpulse[wheel] = rollingFriction;//wheelInfo.m_engineForce* timeStep;

    btScalar x = (m_forwardImpulse[wheel]) * fwdFactor;
    btScalar y = (m_sideImpulse[wheel]) * sideFactor;

    btScalar impulseSquared = (x*x + y*y);

    if (impulseSquared > maximpSquared)
    {
     sliding = true;

     btScalar factor = maximp / btSqrt(impulseSquared);

     m_wheelInfo[wheel].m_skidInfo *= factor;
    }
   }

  }
 }




 if (sliding)
 {
  for (int wheel = 0; wheel < getNumWheels(); wheel++)
  {
   if (m_sideImpulse[wheel] != btScalar(0.))
   {
    if (m_wheelInfo[wheel].m_skidInfo< btScalar(1.))
    {
     m_forwardImpulse[wheel] *= m_wheelInfo[wheel].m_skidInfo;
     m_sideImpulse[wheel] *= m_wheelInfo[wheel].m_skidInfo;
    }
   }
  }
 }

 // apply the impulses
 {
  for (int wheel = 0; wheel<getNumWheels(); wheel++)
  {
   btWheelInfo& wheelInfo = m_wheelInfo[wheel];

   btVector3 rel_pos = wheelInfo.m_raycastInfo.m_contactPointWS -
    m_chassisBody->getCenterOfMassPosition();

   if (m_forwardImpulse[wheel] != btScalar(0.))
   {
    m_chassisBody->applyImpulse(m_forwardWS[wheel] * (m_forwardImpulse[wheel]), rel_pos);
   }
   if (m_sideImpulse[wheel] != btScalar(0.))
   {
    class btRigidBody* groundObject = (class btRigidBody*) m_wheelInfo[wheel].m_raycastInfo.m_groundObject;

    btVector3 rel_pos2 = wheelInfo.m_raycastInfo.m_contactPointWS -
     groundObject->getCenterOfMassPosition();


    btVector3 sideImp = m_axle[wheel] * m_sideImpulse[wheel];

#if defined ROLLING_INFLUENCE_FIX // fix. It only worked if car's up was along Y - VT.
    btVector3 vChassisWorldUp = getRigidBody()->getCenterOfMassTransform().getBasis().getColumn(m_indexUpAxis);
    rel_pos -= vChassisWorldUp * (vChassisWorldUp.dot(rel_pos) * (1.f - wheelInfo.m_rollInfluence));
#else
    rel_pos[m_indexUpAxis] *= wheelInfo.m_rollInfluence;
#endif
    m_chassisBody->applyImpulse(sideImp, rel_pos);

    //apply friction impulse on the ground
    groundObject->applyImpulse(-sideImp, rel_pos2);
   }
  }
 }


}



void	btRaycastVehicle::debugDraw(btIDebugDraw* debugDrawer)
{

 for (int v = 0; v<this->getNumWheels(); v++)
 {
  btVector3 wheelColor(0, 1, 1);
  if (getWheelInfo(v).m_raycastInfo.m_isInContact)
  {
   wheelColor.setValue(0, 0, 1);
  }
  else
  {
   wheelColor.setValue(1, 0, 1);
  }

  btVector3 wheelPosWS = getWheelInfo(v).m_worldTransform.getOrigin();

  btVector3 axle = btVector3(
   getWheelInfo(v).m_worldTransform.getBasis()[0][getRightAxis()],
   getWheelInfo(v).m_worldTransform.getBasis()[1][getRightAxis()],
   getWheelInfo(v).m_worldTransform.getBasis()[2][getRightAxis()]);

  //debug wheels (cylinders)
  debugDrawer->drawLine(wheelPosWS, wheelPosWS + axle, wheelColor);
  debugDrawer->drawLine(wheelPosWS, getWheelInfo(v).m_raycastInfo.m_contactPointWS, wheelColor);

 }
}


void* btDefaultVehicleRaycaster::castRay(const btVector3& from, const btVector3& to, btVehicleRaycasterResult& result)
{
 //	RayResultCallback& resultCallback;

 btCollisionWorld::ClosestRayResultCallback rayCallback(from, to);

 m_dynamicsWorld->rayTest(from, to, rayCallback);

 if (rayCallback.hasHit())
 {

  const btRigidBody* body = btRigidBody::upcast(rayCallback.m_collisionObject);
  if (body && body->hasContactResponse())
  {
   result.m_hitPointInWorld = rayCallback.m_hitPointWorld;
   result.m_hitNormalInWorld = rayCallback.m_hitNormalWorld;
   result.m_hitNormalInWorld.normalize();
   result.m_distFraction = rayCallback.m_closestHitFraction;
   return (void*)body;
  }
 }
 return 0;
}

/*
* Copyright (c) 2005 Erwin Coumans http://continuousphysics.com/Bullet/
*
* Permission to use, copy, modify, distribute and sell this software
* and its documentation for any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erwin Coumans makes no representations about the suitability
* of this software for any purpose.
* It is provided "as is" without express or implied warranty.
*/
#include "BulletDynamics/Vehicle/btWheelInfo.h"
#include "BulletDynamics/Dynamics/btRigidBody.h" // for pointvelocity


btScalar btWheelInfo::getSuspensionRestLength() const
{

 return m_suspensionRestLength1;

}

void	btWheelInfo::updateWheel(const btRigidBody& chassis, RaycastInfo& raycastInfo)
{
 (void)raycastInfo;


 if (m_raycastInfo.m_isInContact)

 {
  btScalar	project = m_raycastInfo.m_contactNormalWS.dot(m_raycastInfo.m_wheelDirectionWS);
  btVector3	 chassis_velocity_at_contactPoint;
  btVector3 relpos = m_raycastInfo.m_contactPointWS - chassis.getCenterOfMassPosition();
  chassis_velocity_at_contactPoint = chassis.getVelocityInLocalPoint(relpos);
  btScalar projVel = m_raycastInfo.m_contactNormalWS.dot(chassis_velocity_at_contactPoint);
  if (project >= btScalar(-0.1))
  {
   m_suspensionRelativeVelocity = btScalar(0.0);
   m_clippedInvContactDotSuspension = btScalar(1.0) / btScalar(0.1);
  }
  else
  {
   btScalar inv = btScalar(-1.) / project;
   m_suspensionRelativeVelocity = projVel * inv;
   m_clippedInvContactDotSuspension = inv;
  }

 }

 else	// Not in contact : position wheel in a nice (rest length) position
 {
  m_raycastInfo.m_suspensionLength = this->getSuspensionRestLength();
  m_suspensionRelativeVelocity = btScalar(0.0);
  m_raycastInfo.m_contactNormalWS = -m_raycastInfo.m_wheelDirectionWS;
  m_clippedInvContactDotSuspension = btScalar(1.0);
 }
}

/*
bParse
Copyright (c) 2006-2010 Erwin Coumans  http://gamekit.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "Bullet3Serialize/Bullet2FileLoader/b3BulletFile.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Defines.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3DNA.h"

#if !defined( __CELLOS_LV2__) && !defined(__MWERKS__)
#include <memory.h>
#endif
#include <string.h>


// 32 && 64 bit versions
#ifdef B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
#ifdef _WIN64
extern char b3s_bulletDNAstr64[];
extern int b3s_bulletDNAlen64;
#else
extern char b3s_bulletDNAstr[];
extern int b3s_bulletDNAlen;
#endif //_WIN64
#else//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES

extern char b3s_bulletDNAstr64[];
extern int b3s_bulletDNAlen64;
extern char b3s_bulletDNAstr[];
extern int b3s_bulletDNAlen;

#endif //B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES

using namespace bParse;

b3BulletFile::b3BulletFile()
 :bFile("", "BULLET ")
{
 mMemoryDNA = new bDNA(); //this memory gets released in the bFile::~bFile destructor,@todo not consistent with the rule 'who allocates it, has to deallocate it"

 m_DnaCopy = 0;


#ifdef B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
#ifdef _WIN64
 m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen64, 16);
 memcpy(m_DnaCopy, b3s_bulletDNAstr64, b3s_bulletDNAlen64);
 mMemoryDNA->init(m_DnaCopy, b3s_bulletDNAlen64);
#else//_WIN64
 m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen, 16);
 memcpy(m_DnaCopy, b3s_bulletDNAstr, b3s_bulletDNAlen);
 mMemoryDNA->init(m_DnaCopy, b3s_bulletDNAlen);
#endif//_WIN64
#else//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
 if (VOID_IS_8)
 {
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen64, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr64, b3s_bulletDNAlen64);
  mMemoryDNA->init(m_DnaCopy, b3s_bulletDNAlen64);
 }
 else
 {
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr, b3s_bulletDNAlen);
  mMemoryDNA->init(m_DnaCopy, b3s_bulletDNAlen);
 }
#endif//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
}



b3BulletFile::b3BulletFile(const char* fileName)
 :bFile(fileName, "BULLET ")
{
 m_DnaCopy = 0;
}



b3BulletFile::b3BulletFile(char *memoryBuffer, int len)
 :bFile(memoryBuffer, len, "BULLET ")
{
 m_DnaCopy = 0;
}


b3BulletFile::~b3BulletFile()
{
 if (m_DnaCopy)
  b3AlignedFree(m_DnaCopy);


 while (m_dataBlocks.size())
 {
  char* dataBlock = m_dataBlocks[m_dataBlocks.size() - 1];
  delete[] dataBlock;
  m_dataBlocks.pop_back();
 }

}



// ----------------------------------------------------- //
void b3BulletFile::parseData()
{
 //	printf ("Building datablocks");
 //	printf ("Chunk size = %d",CHUNK_HEADER_LEN);
 //	printf ("File chunk size = %d",ChunkUtils::getOffset(mFlags));

 const bool brokenDNA = (mFlags&FD_BROKEN_DNA) != 0;

 //const bool swap = (mFlags&FD_ENDIAN_SWAP)!=0;


 mDataStart = 12;

 char *dataPtr = mFileBuffer + mDataStart;

 bChunkInd dataChunk;
 dataChunk.code = 0;


 //dataPtr += ChunkUtils::getNextBlock(&dataChunk, dataPtr, mFlags);
 int seek = getNextBlock(&dataChunk, dataPtr, mFlags);


 if (mFlags &FD_ENDIAN_SWAP)
  swapLen(dataPtr);

 //dataPtr += ChunkUtils::getOffset(mFlags);
 char *dataPtrHead = 0;

 while (dataChunk.code != B3_DNA1)
 {
  if (!brokenDNA || (dataChunk.code != B3_QUANTIZED_BVH_CODE))
  {

   // one behind
   if (dataChunk.code == B3_SDNA) break;
   //if (dataChunk.code == DNA1) break;

   // same as (BHEAD+DATA dependency)
   dataPtrHead = dataPtr + ChunkUtils::getOffset(mFlags);
   if (dataChunk.dna_nr >= 0)
   {
    char *id = readStruct(dataPtrHead, dataChunk);

    // lookup maps
    if (id)
    {
     m_chunkPtrPtrMap.insert(dataChunk.oldPtr, dataChunk);
     mLibPointers.insert(dataChunk.oldPtr, (bStructHandle*)id);

     m_chunks.push_back(dataChunk);
     // block it
     //bListBasePtr *listID = mMain->getListBasePtr(dataChunk.code);
     //if (listID)
     //	listID->push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_SOFTBODY_CODE)
    {
     m_softBodies.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_RIGIDBODY_CODE)
    {
     m_rigidBodies.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_DYNAMICSWORLD_CODE)
    {
     m_dynamicsWorldInfo.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_CONSTRAINT_CODE)
    {
     m_constraints.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_QUANTIZED_BVH_CODE)
    {
     m_bvhs.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_TRIANLGE_INFO_MAP)
    {
     m_triangleInfoMaps.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_COLLISIONOBJECT_CODE)
    {
     m_collisionObjects.push_back((bStructHandle*)id);
    }

    if (dataChunk.code == B3_SHAPE_CODE)
    {
     m_collisionShapes.push_back((bStructHandle*)id);
    }

    //		if (dataChunk.code == GLOB)
    //		{
    //			m_glob = (bStructHandle*) id;
    //		}
   }
   else
   {
    //printf("unknown chunk\n");

    mLibPointers.insert(dataChunk.oldPtr, (bStructHandle*)dataPtrHead);
   }
  }
  else
  {
   printf("skipping B3_QUANTIZED_BVH_CODE due to broken DNA\n");
  }


  dataPtr += seek;

  seek = getNextBlock(&dataChunk, dataPtr, mFlags);
  if (mFlags &FD_ENDIAN_SWAP)
   swapLen(dataPtr);

  if (seek < 0)
   break;
 }

}

void	b3BulletFile::addDataBlock(char* dataBlock)
{
 m_dataBlocks.push_back(dataBlock);

}




void	b3BulletFile::writeDNA(FILE* fp)
{

 bChunkInd dataChunk;
 dataChunk.code = B3_DNA1;
 dataChunk.dna_nr = 0;
 dataChunk.nr = 1;
#ifdef B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES	
 if (VOID_IS_8)
 {
#ifdef _WIN64
  dataChunk.len = b3s_bulletDNAlen64;
  dataChunk.oldPtr = b3s_bulletDNAstr64;
  fwrite(&dataChunk, sizeof(bChunkInd), 1, fp);
  fwrite(b3s_bulletDNAstr64, b3s_bulletDNAlen64, 1, fp);
#else
  b3Assert(0);
#endif
 }
 else
 {
#ifndef _WIN64
  dataChunk.len = b3s_bulletDNAlen;
  dataChunk.oldPtr = b3s_bulletDNAstr;
  fwrite(&dataChunk, sizeof(bChunkInd), 1, fp);
  fwrite(b3s_bulletDNAstr, b3s_bulletDNAlen, 1, fp);
#else//_WIN64
  b3Assert(0);
#endif//_WIN64
 }
#else//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
 if (VOID_IS_8)
 {
  dataChunk.len = b3s_bulletDNAlen64;
  dataChunk.oldPtr = b3s_bulletDNAstr64;
  fwrite(&dataChunk, sizeof(bChunkInd), 1, fp);
  fwrite(b3s_bulletDNAstr64, b3s_bulletDNAlen64, 1, fp);
 }
 else
 {
  dataChunk.len = b3s_bulletDNAlen;
  dataChunk.oldPtr = b3s_bulletDNAstr;
  fwrite(&dataChunk, sizeof(bChunkInd), 1, fp);
  fwrite(b3s_bulletDNAstr, b3s_bulletDNAlen, 1, fp);
 }
#endif//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
}


void	b3BulletFile::parse(int verboseMode)
{
#ifdef B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
 if (VOID_IS_8)
 {
#ifdef _WIN64

  if (m_DnaCopy)
   delete m_DnaCopy;
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen64, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr64, b3s_bulletDNAlen64);
  parseInternal(verboseMode, (char*)b3s_bulletDNAstr64, b3s_bulletDNAlen64);
#else
  b3Assert(0);
#endif
 }
 else
 {
#ifndef _WIN64

  if (m_DnaCopy)
   delete m_DnaCopy;
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr, b3s_bulletDNAlen);
  parseInternal(verboseMode, m_DnaCopy, b3s_bulletDNAlen);
#else
  b3Assert(0);
#endif
 }
#else//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
 if (VOID_IS_8)
 {
  if (m_DnaCopy)
   delete m_DnaCopy;
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen64, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr64, b3s_bulletDNAlen64);
  parseInternal(verboseMode, m_DnaCopy, b3s_bulletDNAlen64);
 }
 else
 {
  if (m_DnaCopy)
   delete m_DnaCopy;
  m_DnaCopy = (char*)b3AlignedAlloc(b3s_bulletDNAlen, 16);
  memcpy(m_DnaCopy, b3s_bulletDNAstr, b3s_bulletDNAlen);
  parseInternal(verboseMode, m_DnaCopy, b3s_bulletDNAlen);
 }
#endif//B3_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES

 //the parsing will convert to cpu endian
 mFlags &= ~FD_ENDIAN_SWAP;

 int littleEndian = 1;
 littleEndian = ((char*)&littleEndian)[0];

 mFileBuffer[8] = littleEndian ? 'v' : 'V';

}

// experimental
int		b3BulletFile::write(const char* fileName, bool fixupPointers)
{
 FILE *fp = fopen(fileName, "wb");
 if (fp)
 {
  char header[B3_SIZEOFBLENDERHEADER];
  memcpy(header, m_headerString, 7);
  int endian = 1;
  endian = ((char*)&endian)[0];

  if (endian)
  {
   header[7] = '_';
  }
  else
  {
   header[7] = '-';
  }
  if (VOID_IS_8)
  {
   header[8] = 'V';
  }
  else
  {
   header[8] = 'v';
  }

  header[9] = '2';
  header[10] = '7';
  header[11] = '5';

  fwrite(header, B3_SIZEOFBLENDERHEADER, 1, fp);

  writeChunks(fp, fixupPointers);

  writeDNA(fp);

  fclose(fp);

 }
 else
 {
  printf("Error: cannot open file %s for writing\n", fileName);
  return 0;
 }
 return 1;
}



void	b3BulletFile::addStruct(const	char* structType, void* data, int len, void* oldPtr, int code)
{

 bParse::bChunkInd dataChunk;
 dataChunk.code = code;
 dataChunk.nr = 1;
 dataChunk.len = len;
 dataChunk.dna_nr = mMemoryDNA->getReverseType(structType);
 dataChunk.oldPtr = oldPtr;

 ///Perform structure size validation
 short* structInfo = mMemoryDNA->getStruct(dataChunk.dna_nr);
 int elemBytes;
 elemBytes = mMemoryDNA->getLength(structInfo[0]);
 //	int elemBytes = mMemoryDNA->getElementSize(structInfo[0],structInfo[1]);
 assert(len == elemBytes);

 mLibPointers.insert(dataChunk.oldPtr, (bStructHandle*)data);
 m_chunks.push_back(dataChunk);
}
/*
bParse
Copyright (c) 2006-2009 Charlie C & Erwin Coumans  http://gamekit.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "Bullet3Serialize/Bullet2FileLoader/b3Chunk.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Defines.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3File.h"

#if !defined( __CELLOS_LV2__) && !defined(__MWERKS__)
#include <memory.h>
#endif
#include <string.h>


using namespace bParse;


// ----------------------------------------------------- //
short ChunkUtils::swapShort(short sht)
{
 B3_SWITCH_SHORT(sht);
 return sht;
}

// ----------------------------------------------------- //
int ChunkUtils::swapInt(int inte)
{
 B3_SWITCH_INT(inte);
 return inte;
}

// ----------------------------------------------------- //
b3Long64 ChunkUtils::swapLong64(b3Long64 lng)
{
 B3_SWITCH_LONGINT(lng);
 return lng;
}

// ----------------------------------------------------- //
int ChunkUtils::getOffset(int flags)
{
 // if the file is saved in a
 // different format, get the
 // file's chunk size
 int res = CHUNK_HEADER_LEN;

 if (VOID_IS_8)
 {
  if (flags &FD_BITS_VARIES)
   res = sizeof(bChunkPtr4);
 }
 else
 {
  if (flags &FD_BITS_VARIES)
   res = sizeof(bChunkPtr8);
 }
 return res;
}





//eof
/*
bParse
Copyright (c) 2006-2009 Charlie C & Erwin Coumans  http://gamekit.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include <assert.h>

#include "Bullet3Serialize/Bullet2FileLoader/b3DNA.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Chunk.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

//this define will force traversal of structures, to check backward (and forward) compatibility
//#define TEST_BACKWARD_FORWARD_COMPATIBILITY


using namespace bParse;


// ----------------------------------------------------- //
bDNA::bDNA()
 : mPtrLen(0)
{
 // --
}

// ----------------------------------------------------- //
bDNA::~bDNA()
{
 // --
}

// ----------------------------------------------------- //
bool bDNA::lessThan(bDNA *file)
{
 return (m_Names.size() < file->m_Names.size());
}

// ----------------------------------------------------- //
char *bDNA::getName(int ind)
{
 assert(ind <= (int)m_Names.size());
 return m_Names[ind].m_name;
}


// ----------------------------------------------------- //
char *bDNA::getType(int ind)
{
 assert(ind <= (int)mTypes.size());
 return mTypes[ind];
}


// ----------------------------------------------------- //
short *bDNA::getStruct(int ind)
{
 assert(ind <= (int)mStructs.size());
 return mStructs[ind];
}


// ----------------------------------------------------- //
short bDNA::getLength(int ind)
{
 assert(ind <= (int)mTlens.size());
 return mTlens[ind];
}


// ----------------------------------------------------- //
int bDNA::getReverseType(short type)
{

 int* intPtr = mStructReverse.find(type);
 if (intPtr)
  return *intPtr;

 return -1;
}

// ----------------------------------------------------- //
int bDNA::getReverseType(const char *type)
{

 b3HashString key(type);
 int* valuePtr = mTypeLookup.find(key);
 if (valuePtr)
  return *valuePtr;

 return -1;
}

// ----------------------------------------------------- //
int bDNA::getNumStructs()
{
 return (int)mStructs.size();
}

// ----------------------------------------------------- //
bool bDNA::flagNotEqual(int dna_nr)
{
 assert(dna_nr <= (int)mCMPFlags.size());
 return mCMPFlags[dna_nr] == FDF_STRUCT_NEQU;
}

// ----------------------------------------------------- //
bool bDNA::flagEqual(int dna_nr)
{
 assert(dna_nr <= (int)mCMPFlags.size());
 int flag = mCMPFlags[dna_nr];
 return  flag == FDF_STRUCT_EQU;
}

// ----------------------------------------------------- //
bool bDNA::flagNone(int dna_nr)
{
 assert(dna_nr <= (int)mCMPFlags.size());
 return mCMPFlags[dna_nr] == FDF_NONE;
}

// ----------------------------------------------------- //
int bDNA::getPointerSize()
{
 return mPtrLen;
}

// ----------------------------------------------------- //
void bDNA::initRecurseCmpFlags(int iter)
{
 // iter is FDF_STRUCT_NEQU

 short *oldStrc = mStructs[iter];
 short type = oldStrc[0];

 for (int i = 0; i<(int)mStructs.size(); i++)
 {
  if (i != iter && mCMPFlags[i] == FDF_STRUCT_EQU)
  {
   short *curStruct = mStructs[i];
   int eleLen = curStruct[1];
   curStruct += 2;

   for (int j = 0; j<eleLen; j++, curStruct += 2)
   {
    if (curStruct[0] == type)
    {
     //char *name = m_Names[curStruct[1]].m_name;
     //if (name[0] != '*')
     if (m_Names[curStruct[1]].m_isPointer)
     {
      mCMPFlags[i] = FDF_STRUCT_NEQU;
      initRecurseCmpFlags(i);
     }
    }
   }
  }
 }
}

// ----------------------------------------------------- //
void bDNA::initCmpFlags(bDNA *memDNA)
{

 // compare the file to memory
 // this ptr should be the file data


 assert(!(m_Names.size() == 0));// && "SDNA empty!");
 mCMPFlags.resize(mStructs.size(), FDF_NONE);



 int i;
 for (i = 0; i<(int)mStructs.size(); i++)
 {
  short *oldStruct = mStructs[i];

  int oldLookup = getReverseType(oldStruct[0]);
  if (oldLookup == -1)
  {
   mCMPFlags[i] = FDF_NONE;
   continue;
  }
  //char* typeName = mTypes[oldStruct[0]];

  //#define SLOW_FORWARD_COMPATIBLE 1
#ifdef SLOW_FORWARD_COMPATIBLE
  char* typeName = mTypes[oldLookup];
  int newLookup = memDNA->getReverseType(typeName);
  if (newLookup == -1)
  {
   mCMPFlags[i] = FDF_NONE;
   continue;
  }
  short *curStruct = memDNA->mStructs[newLookup];
#else
  // memory for file

  if (oldLookup < memDNA->mStructs.size())
  {
   short *curStruct = memDNA->mStructs[oldLookup];
#endif	



   // rebuild...
   mCMPFlags[i] = FDF_STRUCT_NEQU;

#ifndef TEST_BACKWARD_FORWARD_COMPATIBILITY

   if (curStruct[1] == oldStruct[1])
   {
    // type len same ...
    if (mTlens[oldStruct[0]] == memDNA->mTlens[curStruct[0]])
    {
     bool isSame = true;
     int elementLength = oldStruct[1];


     curStruct += 2;
     oldStruct += 2;


     for (int j = 0; j<elementLength; j++, curStruct += 2, oldStruct += 2)
     {
      // type the same
      //const char* typeFileDNA = mTypes[oldStruct[0]];
      //const char* typeMemDNA = mTypes[curStruct[0]];
      if (strcmp(mTypes[oldStruct[0]], memDNA->mTypes[curStruct[0]]) != 0)
      {
       isSame = false;
       break;
      }

      // name the same
      if (strcmp(m_Names[oldStruct[1]].m_name, memDNA->m_Names[curStruct[1]].m_name) != 0)
      {
       isSame = false;
       break;
      }
     }
     // flag valid ==
     if (isSame)
      mCMPFlags[i] = FDF_STRUCT_EQU;
    }
   }
#endif
  }
 }





 // recurse in
 for (i = 0; i<(int)mStructs.size(); i++)
 {
  if (mCMPFlags[i] == FDF_STRUCT_NEQU)
   initRecurseCmpFlags(i);
 }
}




static int name_is_array(char* name, int* dim1, int* dim2) {
 int len = strlen(name);
 /*fprintf(stderr,"[%s]",name);*/
 /*if (len >= 1) {
 if (name[len-1] != ']')
 return 1;
 }
 return 0;*/
 char *bp;
 int num;
 if (dim1) {
  *dim1 = 1;
 }
 if (dim2) {
  *dim2 = 1;
 }
 bp = strchr(name, '[');
 if (!bp) {
  return 0;
 }
 num = 0;
 while (++bp < name + len - 1) {
  const char c = *bp;
  if (c == ']') {
   break;
  }
  if (c <= '9' && c >= '0') {
   num *= 10;
   num += (c - '0');
  }
  else {
   printf("array parse error.\n");
   return 0;
  }
 }
 if (dim2) {
  *dim2 = num;
 }

 /* find second dim, if any. */
 bp = strchr(bp, '[');
 if (!bp) {
  return 1; /* at least we got the first dim. */
 }
 num = 0;
 while (++bp < name + len - 1) {
  const char c = *bp;
  if (c == ']') {
   break;
  }
  if (c <= '9' && c >= '0') {
   num *= 10;
   num += (c - '0');
  }
  else {
   printf("array2 parse error.\n");
   return 1;
  }
 }
 if (dim1) {
  if (dim2) {
   *dim1 = *dim2;
   *dim2 = num;
  }
  else {
   *dim1 = num;
  }
 }

 return 1;
}


// ----------------------------------------------------- //
void bDNA::init(char *data, int len, bool swap)
{
 int *intPtr = 0; short *shtPtr = 0;
 char *cp = 0; int dataLen = 0;
 //long nr=0;
 intPtr = (int*)data;

 /*
 SDNA (4 bytes) (magic number)
 NAME (4 bytes)
 <nr> (4 bytes) amount of names (int)
 <string>
 <string>
 */

 if (strncmp(data, "SDNA", 4) == 0)
 {
  // skip ++ NAME
  intPtr++; intPtr++;
 }



 // Parse names
 if (swap)
 {
  *intPtr = ChunkUtils::swapInt(*intPtr);
 }
 dataLen = *intPtr;
 intPtr++;

 cp = (char*)intPtr;
 int i;
 for (i = 0; i<dataLen; i++)
 {
  bNameInfo info;
  info.m_name = cp;
  info.m_isPointer = (info.m_name[0] == '*') || (info.m_name[1] == '*');
  name_is_array(info.m_name, &info.m_dim0, &info.m_dim1);
  m_Names.push_back(info);
  while (*cp)cp++;
  cp++;
 }


 cp = b3AlignPointer(cp, 4);


 /*
 TYPE (4 bytes)
 <nr> amount of types (int)
 <string>
 <string>
 */

 intPtr = (int*)cp;
 assert(strncmp(cp, "TYPE", 4) == 0); intPtr++;

 if (swap)
 {
  *intPtr = ChunkUtils::swapInt(*intPtr);
 }
 dataLen = *intPtr;
 intPtr++;

 cp = (char*)intPtr;
 for (i = 0; i<dataLen; i++)
 {
  mTypes.push_back(cp);
  while (*cp)cp++;
  cp++;
 }


 cp = b3AlignPointer(cp, 4);

 /*
 TLEN (4 bytes)
 <len> (short) the lengths of types
 <len>
 */

 // Parse type lens
 intPtr = (int*)cp;
 assert(strncmp(cp, "TLEN", 4) == 0); intPtr++;

 dataLen = (int)mTypes.size();

 shtPtr = (short*)intPtr;
 for (i = 0; i<dataLen; i++, shtPtr++)
 {
  if (swap)
   shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
  mTlens.push_back(shtPtr[0]);
 }

 if (dataLen & 1) shtPtr++;

 /*
 STRC (4 bytes)
 <nr> amount of structs (int)
 <typenr>
 <nr_of_elems>
 <typenr>
 <namenr>
 <typenr>
 <namenr>
 */

 intPtr = (int*)shtPtr;
 cp = (char*)intPtr;
 assert(strncmp(cp, "STRC", 4) == 0); intPtr++;

 if (swap)
 {
  *intPtr = ChunkUtils::swapInt(*intPtr);
 }
 dataLen = *intPtr;
 intPtr++;


 shtPtr = (short*)intPtr;
 for (i = 0; i<dataLen; i++)
 {
  mStructs.push_back(shtPtr);
  if (swap)
  {
   shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
   shtPtr[1] = ChunkUtils::swapShort(shtPtr[1]);

   int len = shtPtr[1];
   shtPtr += 2;

   for (int a = 0; a<len; a++, shtPtr += 2)
   {
    shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
    shtPtr[1] = ChunkUtils::swapShort(shtPtr[1]);
   }
  }
  else
   shtPtr += (2 * shtPtr[1]) + 2;
 }


 // build reverse lookups
 for (i = 0; i<(int)mStructs.size(); i++)
 {
  short *strc = mStructs.at(i);
  if (!mPtrLen && strcmp(mTypes[strc[0]], "ListBase") == 0)
  {
   mPtrLen = mTlens[strc[0]] / 2;
  }

  mStructReverse.insert(strc[0], i);
  mTypeLookup.insert(b3HashString(mTypes[strc[0]]), i);
 }
}


// ----------------------------------------------------- //
int bDNA::getArraySize(char* string)
{
 int ret = 1;
 int len = strlen(string);


 char* next = 0;
 for (int i = 0; i<len; i++)
 {
  char c = string[i];

  if (c == '[')
   next = &string[i + 1];
  else if (c == ']')
   if (next)
    ret *= atoi(next);
 }

 //	print (string << ' ' << ret);
 return ret;
}


void bDNA::dumpTypeDefinitions()
{
 int i;

 int numTypes = mTypes.size();

 for (i = 0; i<numTypes; i++)
 {

 }

 for (i = 0; i<(int)mStructs.size(); i++)
 {
  int totalBytes = 0;
  short *oldStruct = mStructs[i];

  int oldLookup = getReverseType(oldStruct[0]);
  if (oldLookup == -1)
  {
   mCMPFlags[i] = FDF_NONE;
   continue;
  }

  short* newStruct = mStructs[oldLookup];
  char* typeName = mTypes[newStruct[0]];
  printf("%3d: %s ", i, typeName);

  //char *name = mNames[oldStruct[1]];
  int len = oldStruct[1];
  printf(" (%d fields) ", len);
  oldStruct += 2;

  printf("{");
  int j;
  for (j = 0; j<len; ++j, oldStruct += 2) {
   const char* name = m_Names[oldStruct[1]].m_name;
   printf("%s %s", mTypes[oldStruct[0]], name);
   int elemNumBytes = 0;
   int arrayDimensions = getArraySizeNew(oldStruct[1]);

   if (m_Names[oldStruct[1]].m_isPointer)
   {
    elemNumBytes = VOID_IS_8 ? 8 : 4;
   }
   else
   {
    elemNumBytes = getLength(oldStruct[0]);
   }
   printf(" /* %d bytes */", elemNumBytes*arrayDimensions);

   if (j == len - 1) {
    printf(";}");
   }
   else {
    printf("; ");
   }
   totalBytes += elemNumBytes*arrayDimensions;
  }
  printf("\ntotalBytes=%d\n\n", totalBytes);

 }



#if 0
 /* dump out display of types and their sizes */
 for (i = 0; i<bf->types_count; ++i) {
  /* if (!bf->types[i].is_struct)*/
  {
   printf("%3d: sizeof(%s%s)=%d",
    i,
    bf->types[i].is_struct ? "struct " : "atomic ",
    bf->types[i].name, bf->types[i].size);
   if (bf->types[i].is_struct) {
    int j;
    printf(", %d fields: { ", bf->types[i].fieldtypes_count);
    for (j = 0; j<bf->types[i].fieldtypes_count; ++j) {
     printf("%s %s",
      bf->types[bf->types[i].fieldtypes[j]].name,
      bf->names[bf->types[i].fieldnames[j]]);
     if (j == bf->types[i].fieldtypes_count - 1) {
      printf(";}");
     }
     else {
      printf("; ");
     }
    }
   }
   printf("\n\n");

  }
 }
#endif

}




//eof


/*
bParse
Copyright (c) 2006-2009 Charlie C & Erwin Coumans  http://gamekit.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "Bullet3Serialize/Bullet2FileLoader/b3File.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Common.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Chunk.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3DNA.h"
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "Bullet3Serialize/Bullet2FileLoader/b3Defines.h"
#include "Bullet3Serialize/Bullet2FileLoader/b3Serializer.h"
#include "Bullet3Common/b3AlignedAllocator.h"
#include "Bullet3Common/b3MinMax.h"

#define B3_SIZEOFBLENDERHEADER 12
#define MAX_ARRAY_LENGTH 512
using namespace bParse;
#define MAX_STRLEN 1024

const char* getCleanName(const char* memName, char* buffer)
{
 int slen = strlen(memName);
 assert(slen<MAX_STRLEN);
 slen = b3Min(slen, MAX_STRLEN);
 for (int i = 0; i<slen; i++)
 {
  if (memName[i] == ']' || memName[i] == '[')
  {
   buffer[i] = 0;//'_';
  }
  else
  {
   buffer[i] = memName[i];
  }
 }
 buffer[slen] = 0;
 return buffer;
}



// ----------------------------------------------------- //
bFile::bFile(const char *filename, const char headerString[7])
 : mOwnsBuffer(true),
 mFileBuffer(0),
 mFileLen(0),
 mVersion(0),
 mDataStart(0),
 mFileDNA(0),
 mMemoryDNA(0),
 mFlags(FD_INVALID)
{
 for (int i = 0; i<7; i++)
 {
  m_headerString[i] = headerString[i];
 }

 FILE *fp = fopen(filename, "rb");
 if (fp)
 {
  fseek(fp, 0L, SEEK_END);
  mFileLen = ftell(fp);
  fseek(fp, 0L, SEEK_SET);

  mFileBuffer = (char*)malloc(mFileLen + 1);
  int bytesRead;
  bytesRead = fread(mFileBuffer, mFileLen, 1, fp);

  fclose(fp);

  //
  parseHeader();

 }
}

// ----------------------------------------------------- //
bFile::bFile(char *memoryBuffer, int len, const char headerString[7])
 : mOwnsBuffer(false),
 mFileBuffer(0),
 mFileLen(0),
 mVersion(0),
 mDataStart(0),
 mFileDNA(0),
 mMemoryDNA(0),
 mFlags(FD_INVALID)
{
 for (int i = 0; i<7; i++)
 {
  m_headerString[i] = headerString[i];
 }
 mFileBuffer = memoryBuffer;
 mFileLen = len;

 parseHeader();

}


// ----------------------------------------------------- //
bFile::~bFile()
{
 if (mOwnsBuffer && mFileBuffer)
 {
  free(mFileBuffer);
  mFileBuffer = 0;
 }


 delete mMemoryDNA;
 delete mFileDNA;
}





// ----------------------------------------------------- //
void bFile::parseHeader()
{
 if (!mFileLen || !mFileBuffer)
  return;

 char *blenderBuf = mFileBuffer;
 char header[B3_SIZEOFBLENDERHEADER + 1];
 memcpy(header, blenderBuf, B3_SIZEOFBLENDERHEADER);
 header[B3_SIZEOFBLENDERHEADER] = '\0';

 if (strncmp(header, m_headerString, 6) != 0)
 {
  memcpy(header, m_headerString, B3_SIZEOFBLENDERHEADER);
  return;
 }

 if (header[6] == 'd')
 {
  mFlags |= FD_DOUBLE_PRECISION;
 }

 char *ver = header + 9;
 mVersion = atoi(ver);
 if (mVersion <= 241)
 {
  //printf("Warning, %d not fully tested : <= 242\n", mVersion);
 }

 int littleEndian = 1;
 littleEndian = ((char*)&littleEndian)[0];

 // swap ptr sizes...
 if (header[7] == '-')
 {
  mFlags |= FD_FILE_64;
  if (!VOID_IS_8)
   mFlags |= FD_BITS_VARIES;
 }
 else if (VOID_IS_8) mFlags |= FD_BITS_VARIES;

 // swap endian...
 if (header[8] == 'V')
 {
  if (littleEndian == 1)
   mFlags |= FD_ENDIAN_SWAP;
 }
 else
  if (littleEndian == 0)
   mFlags |= FD_ENDIAN_SWAP;


 mFlags |= FD_OK;
}

// ----------------------------------------------------- //
bool bFile::ok()
{
 return (mFlags &FD_OK) != 0;
}

// ----------------------------------------------------- //
void bFile::parseInternal(int verboseMode, char* memDna, int memDnaLength)
{
 if ((mFlags &FD_OK) == 0)
  return;

 char *blenderData = mFileBuffer;
 bChunkInd dna;
 dna.oldPtr = 0;

 char *tempBuffer = blenderData;
 for (int i = 0; i<mFileLen; i++)
 {
  // looking for the data's starting position
  // and the start of SDNA decls

  if (!mDataStart && strncmp(tempBuffer, "REND", 4) == 0)
   mDataStart = i;

  if (strncmp(tempBuffer, "DNA1", 4) == 0)
  {
   // read the DNA1 block and extract SDNA
   if (getNextBlock(&dna, tempBuffer, mFlags) > 0)
   {
    if (strncmp((tempBuffer + ChunkUtils::getOffset(mFlags)), "SDNANAME", 8) == 0)
     dna.oldPtr = (tempBuffer + ChunkUtils::getOffset(mFlags));
    else dna.oldPtr = 0;
   }
   else dna.oldPtr = 0;
  }
  // Some Bullet files are missing the DNA1 block
  // In Blender it's DNA1 + ChunkUtils::getOffset() + SDNA + NAME
  // In Bullet tests its SDNA + NAME
  else if (strncmp(tempBuffer, "SDNANAME", 8) == 0)
  {
   dna.oldPtr = blenderData + i;
   dna.len = mFileLen - i;

   // Also no REND block, so exit now.
   if (mVersion == 276) break;
  }

  if (mDataStart && dna.oldPtr) break;
  tempBuffer++;
 }
 if (!dna.oldPtr || !dna.len)
 {
  //printf("Failed to find DNA1+SDNA pair\n");
  mFlags &= ~FD_OK;
  return;
 }


 mFileDNA = new bDNA();


 ///mFileDNA->init will convert part of DNA file endianness to current CPU endianness if necessary
 mFileDNA->init((char*)dna.oldPtr, dna.len, (mFlags & FD_ENDIAN_SWAP) != 0);


 if (mVersion == 276)
 {
  int i;
  for (i = 0; i<mFileDNA->getNumNames(); i++)
  {
   if (strcmp(mFileDNA->getName(i), "int") == 0)
   {
    mFlags |= FD_BROKEN_DNA;
   }
  }
  if ((mFlags&FD_BROKEN_DNA) != 0)
  {
   //printf("warning: fixing some broken DNA version\n");
  }
 }



 if (verboseMode & FD_VERBOSE_DUMP_DNA_TYPE_DEFINITIONS)
  mFileDNA->dumpTypeDefinitions();

 mMemoryDNA = new bDNA();
 int littleEndian = 1;
 littleEndian = ((char*)&littleEndian)[0];

 mMemoryDNA->init(memDna, memDnaLength, littleEndian == 0);




 ///@todo we need a better version check, add version/sub version info from FileGlobal into memory DNA/header files
 if (mMemoryDNA->getNumNames() != mFileDNA->getNumNames())
 {
  mFlags |= FD_VERSION_VARIES;
  //printf ("Warning, file DNA is different than built in, performance is reduced. Best to re-export file with a matching version/platform");
 }

 // as long as it kept up to date it will be ok!!
 if (mMemoryDNA->lessThan(mFileDNA))
 {
  //printf ("Warning, file DNA is newer than built in.");
 }


 mFileDNA->initCmpFlags(mMemoryDNA);

 parseData();

 resolvePointers(verboseMode);

 updateOldPointers();


}



// ----------------------------------------------------- //
void bFile::swap(char *head, bChunkInd& dataChunk, bool ignoreEndianFlag)
{
 char *data = head;
 short *strc = mFileDNA->getStruct(dataChunk.dna_nr);



 const char s[] = "SoftBodyMaterialData";
 int szs = sizeof(s);
 if (strncmp((char*)&dataChunk.code, "ARAY", 4) == 0)
 {
  short *oldStruct = mFileDNA->getStruct(dataChunk.dna_nr);
  char *oldType = mFileDNA->getType(oldStruct[0]);
  if (strncmp(oldType, s, szs) == 0)
  {
   return;
  }
 }


 int len = mFileDNA->getLength(strc[0]);

 for (int i = 0; i<dataChunk.nr; i++)
 {
  swapStruct(dataChunk.dna_nr, data, ignoreEndianFlag);
  data += len;
 }
}

void bFile::swapLen(char *dataPtr)
{
 const bool VOID_IS_8 = ((sizeof(void*) == 8));
 if (VOID_IS_8)
 {
  if (mFlags &FD_BITS_VARIES)
  {
   bChunkPtr4*c = (bChunkPtr4*)dataPtr;
   if ((c->code & 0xFFFF) == 0)
    c->code >>= 16;
   B3_SWITCH_INT(c->len);
   B3_SWITCH_INT(c->dna_nr);
   B3_SWITCH_INT(c->nr);
  }
  else
  {
   bChunkPtr8* c = (bChunkPtr8*)dataPtr;
   if ((c->code & 0xFFFF) == 0)
    c->code >>= 16;
   B3_SWITCH_INT(c->len);
   B3_SWITCH_INT(c->dna_nr);
   B3_SWITCH_INT(c->nr);

  }
 }
 else
 {
  if (mFlags &FD_BITS_VARIES)
  {
   bChunkPtr8*c = (bChunkPtr8*)dataPtr;
   if ((c->code & 0xFFFF) == 0)
    c->code >>= 16;
   B3_SWITCH_INT(c->len);
   B3_SWITCH_INT(c->dna_nr);
   B3_SWITCH_INT(c->nr);

  }
  else
  {
   bChunkPtr4* c = (bChunkPtr4*)dataPtr;
   if ((c->code & 0xFFFF) == 0)
    c->code >>= 16;
   B3_SWITCH_INT(c->len);

   B3_SWITCH_INT(c->dna_nr);
   B3_SWITCH_INT(c->nr);

  }
 }

}


void bFile::swapDNA(char* ptr)
{
 bool swap = ((mFlags & FD_ENDIAN_SWAP) != 0);

 char* data = &ptr[20];
 //	void bDNA::init(char *data, int len, bool swap)
 int *intPtr = 0; short *shtPtr = 0;
 char *cp = 0; int dataLen = 0;
 //long nr=0;
 intPtr = (int*)data;

 /*
 SDNA (4 bytes) (magic number)
 NAME (4 bytes)
 <nr> (4 bytes) amount of names (int)
 <string>
 <string>
 */

 if (strncmp(data, "SDNA", 4) == 0)
 {
  // skip ++ NAME
  intPtr++; intPtr++;
 }



 // Parse names
 if (swap)
  dataLen = ChunkUtils::swapInt(*intPtr);
 else
  dataLen = *intPtr;

 *intPtr = ChunkUtils::swapInt(*intPtr);
 intPtr++;

 cp = (char*)intPtr;
 int i;
 for (i = 0; i<dataLen; i++)
 {
  while (*cp)cp++;
  cp++;
 }


 cp = b3AlignPointer(cp, 4);

 /*
 TYPE (4 bytes)
 <nr> amount of types (int)
 <string>
 <string>
 */

 intPtr = (int*)cp;
 assert(strncmp(cp, "TYPE", 4) == 0); intPtr++;

 if (swap)
  dataLen = ChunkUtils::swapInt(*intPtr);
 else
  dataLen = *intPtr;

 *intPtr = ChunkUtils::swapInt(*intPtr);

 intPtr++;

 cp = (char*)intPtr;
 for (i = 0; i<dataLen; i++)
 {
  while (*cp)cp++;
  cp++;
 }

 cp = b3AlignPointer(cp, 4);

 /*
 TLEN (4 bytes)
 <len> (short) the lengths of types
 <len>
 */

 // Parse type lens
 intPtr = (int*)cp;
 assert(strncmp(cp, "TLEN", 4) == 0); intPtr++;


 shtPtr = (short*)intPtr;
 for (i = 0; i<dataLen; i++, shtPtr++)
 {
  //??????if (swap)
  shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
 }

 if (dataLen & 1)
  shtPtr++;

 /*
 STRC (4 bytes)
 <nr> amount of structs (int)
 <typenr>
 <nr_of_elems>
 <typenr>
 <namenr>
 <typenr>
 <namenr>
 */

 intPtr = (int*)shtPtr;
 cp = (char*)intPtr;
 assert(strncmp(cp, "STRC", 4) == 0);
 intPtr++;

 if (swap)
  dataLen = ChunkUtils::swapInt(*intPtr);
 else
  dataLen = *intPtr;

 *intPtr = ChunkUtils::swapInt(*intPtr);

 intPtr++;


 shtPtr = (short*)intPtr;
 for (i = 0; i<dataLen; i++)
 {

  //if (swap)
  {
   int len = shtPtr[1];

   shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
   shtPtr[1] = ChunkUtils::swapShort(shtPtr[1]);

   shtPtr += 2;

   for (int a = 0; a<len; a++, shtPtr += 2)
   {
    shtPtr[0] = ChunkUtils::swapShort(shtPtr[0]);
    shtPtr[1] = ChunkUtils::swapShort(shtPtr[1]);
   }
  }
  //		else
  //			shtPtr+= (2*shtPtr[1])+2;
 }

}

void bFile::writeFile(const char* fileName)
{
 FILE* f = fopen(fileName, "wb");
 fwrite(mFileBuffer, 1, mFileLen, f);
 fclose(f);
}

void bFile::preSwap()
{

 //const bool brokenDNA = (mFlags&FD_BROKEN_DNA)!=0;
 //FD_ENDIAN_SWAP
 //byte 8 determines the endianness of the file, little (v) versus big (V)
 int littleEndian = 1;
 littleEndian = ((char*)&littleEndian)[0];


 if (mFileBuffer[8] == 'V')
 {
  mFileBuffer[8] = 'v';
 }
 else
 {
  mFileBuffer[8] = 'V';
 }






 mDataStart = 12;

 char *dataPtr = mFileBuffer + mDataStart;

 bChunkInd dataChunk;
 dataChunk.code = 0;
 bool ignoreEndianFlag = true;

 //we always want to swap here

 int seek = getNextBlock(&dataChunk, dataPtr, mFlags);
 //dataPtr += ChunkUtils::getOffset(mFlags);
 char *dataPtrHead = 0;

 while (1)
 {
  // one behind
  if (dataChunk.code == B3_SDNA || dataChunk.code == B3_DNA1 || dataChunk.code == B3_TYPE || dataChunk.code == B3_TLEN || dataChunk.code == B3_STRC)
  {

   swapDNA(dataPtr);
   break;
  }
  else
  {
   //if (dataChunk.code == DNA1) break;
   dataPtrHead = dataPtr + ChunkUtils::getOffset(mFlags);

   swapLen(dataPtr);
   if (dataChunk.dna_nr >= 0)
   {
    swap(dataPtrHead, dataChunk, ignoreEndianFlag);
   }
   else
   {
    //printf("unknown chunk\n");
   }
  }

  // next please!
  dataPtr += seek;

  seek = getNextBlock(&dataChunk, dataPtr, mFlags);
  if (seek < 0)
   break;
 }

 if (mFlags & FD_ENDIAN_SWAP)
 {
  mFlags &= ~FD_ENDIAN_SWAP;
 }
 else
 {
  mFlags |= FD_ENDIAN_SWAP;
 }



}


// ----------------------------------------------------- //
char* bFile::readStruct(char *head, bChunkInd&  dataChunk)
{
 bool ignoreEndianFlag = false;

 if (mFlags & FD_ENDIAN_SWAP)
  swap(head, dataChunk, ignoreEndianFlag);



 if (!mFileDNA->flagEqual(dataChunk.dna_nr))
 {
  // Ouch! need to rebuild the struct
  short *oldStruct, *curStruct;
  char *oldType, *newType;
  int oldLen, curLen, reverseOld;


  oldStruct = mFileDNA->getStruct(dataChunk.dna_nr);
  oldType = mFileDNA->getType(oldStruct[0]);

  oldLen = mFileDNA->getLength(oldStruct[0]);

  if ((mFlags&FD_BROKEN_DNA) != 0)
  {
   if ((strcmp(oldType, "b3QuantizedBvhNodeData") == 0) && oldLen == 20)
   {
    return 0;
   }
   if ((strcmp(oldType, "b3ShortIntIndexData") == 0))
   {
    int allocLen = 2;
    char *dataAlloc = new char[(dataChunk.nr*allocLen) + 1];
    memset(dataAlloc, 0, (dataChunk.nr*allocLen) + 1);
    short* dest = (short*)dataAlloc;
    const short* src = (short*)head;
    for (int i = 0; i<dataChunk.nr; i++)
    {
     dest[i] = src[i];
     if (mFlags &FD_ENDIAN_SWAP)
     {
      B3_SWITCH_SHORT(dest[i]);
     }
    }
    addDataBlock(dataAlloc);
    return dataAlloc;
   }
  }



  ///don't try to convert Link block data, just memcpy it. Other data can be converted.
  if (strcmp("Link", oldType) != 0)
  {
   reverseOld = mMemoryDNA->getReverseType(oldType);

   if ((reverseOld != -1))
   {
    // make sure it's here
    //assert(reverseOld!= -1 && "getReverseType() returned -1, struct required!");

    //
    curStruct = mMemoryDNA->getStruct(reverseOld);
    newType = mMemoryDNA->getType(curStruct[0]);
    curLen = mMemoryDNA->getLength(curStruct[0]);



    // make sure it's the same
    assert((strcmp(oldType, newType) == 0) && "internal error, struct mismatch!");


    // numBlocks * length

    int allocLen = (curLen);
    char *dataAlloc = new char[(dataChunk.nr*allocLen) + 1];
    memset(dataAlloc, 0, (dataChunk.nr*allocLen));

    // track allocated
    addDataBlock(dataAlloc);

    char *cur = dataAlloc;
    char *old = head;
    for (int block = 0; block<dataChunk.nr; block++)
    {
     bool fixupPointers = true;
     parseStruct(cur, old, dataChunk.dna_nr, reverseOld, fixupPointers);
     mLibPointers.insert(old, (bStructHandle*)cur);

     cur += curLen;
     old += oldLen;
    }
    return dataAlloc;
   }
  }
  else
  {
   //printf("Link found\n");
  }
 }
 else
 {
  //#define DEBUG_EQUAL_STRUCTS
#ifdef DEBUG_EQUAL_STRUCTS
  short *oldStruct;
  char *oldType;
  oldStruct = mFileDNA->getStruct(dataChunk.dna_nr);
  oldType = mFileDNA->getType(oldStruct[0]);
  printf("%s equal structure, just memcpy\n", oldType);
#endif //
 }


 char *dataAlloc = new char[(dataChunk.len) + 1];
 memset(dataAlloc, 0, dataChunk.len + 1);


 // track allocated
 addDataBlock(dataAlloc);

 memcpy(dataAlloc, head, dataChunk.len);
 return dataAlloc;

}


// ----------------------------------------------------- //
void bFile::parseStruct(char *strcPtr, char *dtPtr, int old_dna, int new_dna, bool fixupPointers)
{
 if (old_dna == -1) return;
 if (new_dna == -1) return;

 //disable this, because we need to fixup pointers/ListBase
 if (0)//mFileDNA->flagEqual(old_dna))
 {
  short *strc = mFileDNA->getStruct(old_dna);
  int len = mFileDNA->getLength(strc[0]);

  memcpy(strcPtr, dtPtr, len);
  return;
 }

 // Ok, now build the struct
 char *memType, *memName, *cpc, *cpo;
 short *fileStruct, *filePtrOld, *memoryStruct, *firstStruct;
 int elementLength, size, revType, old_nr, new_nr, fpLen;
 short firstStructType;


 // File to memory lookup
 memoryStruct = mMemoryDNA->getStruct(new_dna);
 fileStruct = mFileDNA->getStruct(old_dna);
 firstStruct = fileStruct;


 filePtrOld = fileStruct;
 firstStructType = mMemoryDNA->getStruct(0)[0];

 // Get number of elements
 elementLength = memoryStruct[1];
 memoryStruct += 2;

 cpc = strcPtr; cpo = 0;
 for (int ele = 0; ele<elementLength; ele++, memoryStruct += 2)
 {
  memType = mMemoryDNA->getType(memoryStruct[0]);
  memName = mMemoryDNA->getName(memoryStruct[1]);


  size = mMemoryDNA->getElementSize(memoryStruct[0], memoryStruct[1]);
  revType = mMemoryDNA->getReverseType(memoryStruct[0]);

  if (revType != -1 && memoryStruct[0] >= firstStructType && memName[0] != '*')
  {
   cpo = getFileElement(firstStruct, memName, memType, dtPtr, &filePtrOld);
   if (cpo)
   {
    int arrayLen = mFileDNA->getArraySizeNew(filePtrOld[1]);
    old_nr = mFileDNA->getReverseType(memType);
    new_nr = revType;
    fpLen = mFileDNA->getElementSize(filePtrOld[0], filePtrOld[1]);
    if (arrayLen == 1)
    {
     parseStruct(cpc, cpo, old_nr, new_nr, fixupPointers);
    }
    else
    {
     char* tmpCpc = cpc;
     char* tmpCpo = cpo;

     for (int i = 0; i<arrayLen; i++)
     {
      parseStruct(tmpCpc, tmpCpo, old_nr, new_nr, fixupPointers);
      tmpCpc += size / arrayLen;
      tmpCpo += fpLen / arrayLen;
     }
    }
    cpc += size;
    cpo += fpLen;
   }
   else
    cpc += size;
  }
  else
  {
   getMatchingFileDNA(fileStruct, memName, memType, cpc, dtPtr, fixupPointers);
   cpc += size;
  }

 }
}


// ----------------------------------------------------- //
static void getElement(int arrayLen, const char *cur, const char *old, char *oldPtr, char *curData)
{
#define b3GetEle(value, current, type, cast, size, ptr)\
	if (strcmp(current, type)==0)\
	{\
		value = (*(cast*)ptr);\
		ptr += size;\
	}

#define b3SetEle(value, current, type, cast, size, ptr)\
	if (strcmp(current, type)==0)\
	{\
		(*(cast*)ptr) = (cast)value;\
		ptr += size;\
	}
 double value = 0.0;

 for (int i = 0; i<arrayLen; i++)
 {
  b3GetEle(value, old, "char", char, sizeof(char), oldPtr);
  b3SetEle(value, cur, "char", char, sizeof(char), curData);
  b3GetEle(value, old, "short", short, sizeof(short), oldPtr);
  b3SetEle(value, cur, "short", short, sizeof(short), curData);
  b3GetEle(value, old, "ushort", unsigned short, sizeof(unsigned short), oldPtr);
  b3SetEle(value, cur, "ushort", unsigned short, sizeof(unsigned short), curData);
  b3GetEle(value, old, "int", int, sizeof(int), oldPtr);
  b3SetEle(value, cur, "int", int, sizeof(int), curData);
  b3GetEle(value, old, "long", int, sizeof(int), oldPtr);
  b3SetEle(value, cur, "long", int, sizeof(int), curData);
  b3GetEle(value, old, "float", float, sizeof(float), oldPtr);
  b3SetEle(value, cur, "float", float, sizeof(float), curData);
  b3GetEle(value, old, "double", double, sizeof(double), oldPtr);
  b3SetEle(value, cur, "double", double, sizeof(double), curData);
 }
}


// ----------------------------------------------------- //
void bFile::swapData(char *data, short type, int arraySize, bool ignoreEndianFlag)
{
 if (ignoreEndianFlag || (mFlags &FD_ENDIAN_SWAP))
 {
  if (type == 2 || type == 3)
  {
   short *sp = (short*)data;
   for (int i = 0; i<arraySize; i++)
   {
    sp[0] = ChunkUtils::swapShort(sp[0]);
    sp++;
   }
  }
  if (type>3 && type <8)
  {
   char c;
   char *cp = data;
   for (int i = 0; i<arraySize; i++)
   {
    c = cp[0];
    cp[0] = cp[3];
    cp[3] = c;
    c = cp[1];
    cp[1] = cp[2];
    cp[2] = c;
    cp += 4;
   }
  }
 }
}



void bFile::safeSwapPtr(char *dst, const char *src)
{
 int ptrFile = mFileDNA->getPointerSize();
 int ptrMem = mMemoryDNA->getPointerSize();

 if (!src && !dst)
  return;


 if (ptrFile == ptrMem)
 {
  memcpy(dst, src, ptrMem);
 }
 else if (ptrMem == 4 && ptrFile == 8)
 {
  b3PointerUid* oldPtr = (b3PointerUid*)src;
  b3PointerUid* newPtr = (b3PointerUid*)dst;

  if (oldPtr->m_uniqueIds[0] == oldPtr->m_uniqueIds[1])
  {
   //Bullet stores the 32bit unique ID in both upper and lower part of 64bit pointers
   //so it can be used to distinguish between .blend and .bullet
   newPtr->m_uniqueIds[0] = oldPtr->m_uniqueIds[0];
  }
  else
  {
   //deal with pointers the Blender .blend style way, see
   //readfile.c in the Blender source tree
   b3Long64 longValue = *((b3Long64*)src);
   //endian swap for 64bit pointer otherwise truncation will fail due to trailing zeros
   if (mFlags & FD_ENDIAN_SWAP)
    B3_SWITCH_LONGINT(longValue);
   *((int*)dst) = (int)(longValue >> 3);
  }

 }
 else if (ptrMem == 8 && ptrFile == 4)
 {
  b3PointerUid* oldPtr = (b3PointerUid*)src;
  b3PointerUid* newPtr = (b3PointerUid*)dst;
  if (oldPtr->m_uniqueIds[0] == oldPtr->m_uniqueIds[1])
  {
   newPtr->m_uniqueIds[0] = oldPtr->m_uniqueIds[0];
   newPtr->m_uniqueIds[1] = 0;
  }
  else
  {
   *((b3Long64*)dst) = *((int*)src);
  }
 }
 else
 {
  printf("%d %d\n", ptrFile, ptrMem);
  assert(0 && "Invalid pointer len");
 }


}


// ----------------------------------------------------- //
void bFile::getMatchingFileDNA(short* dna_addr, const char* lookupName, const char* lookupType, char *strcData, char *data, bool fixupPointers)
{
 // find the matching memory dna data
 // to the file being loaded. Fill the
 // memory with the file data...

 int len = dna_addr[1];
 dna_addr += 2;

 for (int i = 0; i<len; i++, dna_addr += 2)
 {
  const char* type = mFileDNA->getType(dna_addr[0]);
  const char* name = mFileDNA->getName(dna_addr[1]);



  int eleLen = mFileDNA->getElementSize(dna_addr[0], dna_addr[1]);

  if ((mFlags&FD_BROKEN_DNA) != 0)
  {
   if ((strcmp(type, "short") == 0) && (strcmp(name, "int") == 0))
   {
    eleLen = 0;
   }
  }

  if (strcmp(lookupName, name) == 0)
  {
   //int arrayLenold = mFileDNA->getArraySize((char*)name.c_str());
   int arrayLen = mFileDNA->getArraySizeNew(dna_addr[1]);
   //assert(arrayLenold == arrayLen);

   if (name[0] == '*')
   {
    // cast pointers
    int ptrFile = mFileDNA->getPointerSize();
    int ptrMem = mMemoryDNA->getPointerSize();
    safeSwapPtr(strcData, data);

    if (fixupPointers)
    {
     if (arrayLen > 1)
     {
      //void **sarray = (void**)strcData;
      //void **darray = (void**)data;

      char *cpc, *cpo;
      cpc = (char*)strcData;
      cpo = (char*)data;

      for (int a = 0; a<arrayLen; a++)
      {
       safeSwapPtr(cpc, cpo);
       m_pointerFixupArray.push_back(cpc);
       cpc += ptrMem;
       cpo += ptrFile;
      }
     }
     else
     {
      if (name[1] == '*')
       m_pointerPtrFixupArray.push_back(strcData);
      else
       m_pointerFixupArray.push_back(strcData);
     }
    }
    else
    {
     //					printf("skipped %s %s : %x\n",type.c_str(),name.c_str(),strcData);
    }

   }

   else if (strcmp(type, lookupType) == 0)
    memcpy(strcData, data, eleLen);
   else
    getElement(arrayLen, lookupType, type, data, strcData);

   // --
   return;
  }
  data += eleLen;
 }
}


// ----------------------------------------------------- //
char* bFile::getFileElement(short *firstStruct, char *lookupName, char *lookupType, char *data, short **foundPos)
{
 short *old = firstStruct;//mFileDNA->getStruct(old_nr);
 int elementLength = old[1];
 old += 2;

 for (int i = 0; i<elementLength; i++, old += 2)
 {
  char* type = mFileDNA->getType(old[0]);
  char* name = mFileDNA->getName(old[1]);
  int len = mFileDNA->getElementSize(old[0], old[1]);

  if (strcmp(lookupName, name) == 0)
  {
   if (strcmp(type, lookupType) == 0)
   {
    if (foundPos)
     *foundPos = old;
    return data;
   }
   return 0;
  }
  data += len;
 }
 return 0;
}


// ----------------------------------------------------- //
void bFile::swapStruct(int dna_nr, char *data, bool ignoreEndianFlag)
{
 if (dna_nr == -1) return;

 short *strc = mFileDNA->getStruct(dna_nr);
 //short *firstStrc = strc;

 int elementLen = strc[1];
 strc += 2;

 short first = mFileDNA->getStruct(0)[0];

 char *buf = data;
 for (int i = 0; i<elementLen; i++, strc += 2)
 {
  char *type = mFileDNA->getType(strc[0]);
  char *name = mFileDNA->getName(strc[1]);

  int size = mFileDNA->getElementSize(strc[0], strc[1]);
  if (strc[0] >= first && name[0] != '*')
  {
   int old_nr = mFileDNA->getReverseType(type);
   int arrayLen = mFileDNA->getArraySizeNew(strc[1]);
   if (arrayLen == 1)
   {
    swapStruct(old_nr, buf, ignoreEndianFlag);
   }
   else
   {
    char* tmpBuf = buf;
    for (int i = 0; i<arrayLen; i++)
    {
     swapStruct(old_nr, tmpBuf, ignoreEndianFlag);
     tmpBuf += size / arrayLen;
    }
   }
  }
  else
  {
   //int arrayLenOld = mFileDNA->getArraySize(name);
   int arrayLen = mFileDNA->getArraySizeNew(strc[1]);
   //assert(arrayLenOld == arrayLen);
   swapData(buf, strc[0], arrayLen, ignoreEndianFlag);
  }
  buf += size;
 }
}

void bFile::resolvePointersMismatch()
{
 //	printf("resolvePointersStructMismatch\n");

 int i;

 for (i = 0; i< m_pointerFixupArray.size(); i++)
 {
  char* cur = m_pointerFixupArray.at(i);
  void** ptrptr = (void**)cur;
  void* ptr = *ptrptr;
  ptr = findLibPointer(ptr);
  if (ptr)
  {
   //printf("Fixup pointer!\n");
   *(ptrptr) = ptr;
  }
  else
  {
   //			printf("pointer not found: %x\n",cur);
  }
 }


 for (i = 0; i<m_pointerPtrFixupArray.size(); i++)
 {
  char* cur = m_pointerPtrFixupArray.at(i);
  void** ptrptr = (void**)cur;

  bChunkInd *block = m_chunkPtrPtrMap.find(*ptrptr);
  if (block)
  {
   int ptrMem = mMemoryDNA->getPointerSize();
   int ptrFile = mFileDNA->getPointerSize();


   int blockLen = block->len / ptrFile;

   void *onptr = findLibPointer(*ptrptr);
   if (onptr)
   {
    char *newPtr = new char[blockLen * ptrMem];
    addDataBlock(newPtr);
    memset(newPtr, 0, blockLen * ptrMem);

    void **onarray = (void**)onptr;
    char *oldPtr = (char*)onarray;

    int p = 0;
    while (blockLen-- > 0)
    {
     b3PointerUid dp = { { 0 } };
     safeSwapPtr((char*)dp.m_uniqueIds, oldPtr);

     void **tptr = (void**)(newPtr + p * ptrMem);
     *tptr = findLibPointer(dp.m_ptr);

     oldPtr += ptrFile;
     ++p;
    }

    *ptrptr = newPtr;
   }
  }
 }
}


///this loop only works fine if the Blender DNA structure of the file matches the headerfiles
void bFile::resolvePointersChunk(const bChunkInd& dataChunk, int verboseMode)
{
 bParse::bDNA* fileDna = mFileDNA ? mFileDNA : mMemoryDNA;

 short int* oldStruct = fileDna->getStruct(dataChunk.dna_nr);
 short oldLen = fileDna->getLength(oldStruct[0]);
 //char* structType = fileDna->getType(oldStruct[0]);

 char* cur = (char*)findLibPointer(dataChunk.oldPtr);
 for (int block = 0; block<dataChunk.nr; block++)
 {
  resolvePointersStructRecursive(cur, dataChunk.dna_nr, verboseMode, 1);
  cur += oldLen;
 }
}


int bFile::resolvePointersStructRecursive(char *strcPtr, int dna_nr, int verboseMode, int recursion)
{

 bParse::bDNA* fileDna = mFileDNA ? mFileDNA : mMemoryDNA;

 char* memType;
 char* memName;
 short	firstStructType = fileDna->getStruct(0)[0];


 char* elemPtr = strcPtr;

 short int* oldStruct = fileDna->getStruct(dna_nr);

 int elementLength = oldStruct[1];
 oldStruct += 2;

 int totalSize = 0;

 for (int ele = 0; ele<elementLength; ele++, oldStruct += 2)
 {

  memType = fileDna->getType(oldStruct[0]);
  memName = fileDna->getName(oldStruct[1]);



  int arrayLen = fileDna->getArraySizeNew(oldStruct[1]);
  if (memName[0] == '*')
  {
   if (arrayLen > 1)
   {
    void **array = (void**)elemPtr;
    for (int a = 0; a<arrayLen; a++)
    {
     if (verboseMode & FD_VERBOSE_EXPORT_XML)
     {
      for (int i = 0; i<recursion; i++)
      {
       printf("  ");
      }
      //skip the *
      printf("<%s type=\"pointer\"> ", &memName[1]);
      printf("%p ", array[a]);
      printf("</%s>\n", &memName[1]);
     }

     array[a] = findLibPointer(array[a]);
    }
   }
   else
   {
    void** ptrptr = (void**)elemPtr;
    void* ptr = *ptrptr;
    if (verboseMode & FD_VERBOSE_EXPORT_XML)
    {
     for (int i = 0; i<recursion; i++)
     {
      printf("  ");
     }
     printf("<%s type=\"pointer\"> ", &memName[1]);
     printf("%p ", ptr);
     printf("</%s>\n", &memName[1]);
    }
    ptr = findLibPointer(ptr);

    if (ptr)
    {
     //				printf("Fixup pointer at 0x%x from 0x%x to 0x%x!\n",ptrptr,*ptrptr,ptr);
     *(ptrptr) = ptr;
     if (memName[1] == '*' && ptrptr && *ptrptr)
     {
      // This	will only work if the given	**array	is continuous
      void **array = (void**)*(ptrptr);
      void *np = array[0];
      int	n = 0;
      while (np)
      {
       np = findLibPointer(array[n]);
       if (np) array[n] = np;
       n++;
      }
     }
    }
    else
    {
     //				printf("Cannot fixup pointer at 0x%x from 0x%x to 0x%x!\n",ptrptr,*ptrptr,ptr);
    }
   }
  }
  else
  {
   int revType = fileDna->getReverseType(oldStruct[0]);
   if (oldStruct[0] >= firstStructType) //revType != -1 &&
   {
    char cleanName[MAX_STRLEN];
    getCleanName(memName, cleanName);

    int arrayLen = fileDna->getArraySizeNew(oldStruct[1]);
    int byteOffset = 0;

    if (verboseMode & FD_VERBOSE_EXPORT_XML)
    {
     for (int i = 0; i<recursion; i++)
     {
      printf("  ");
     }

     if (arrayLen>1)
     {
      printf("<%s type=\"%s\" count=%d>\n", cleanName, memType, arrayLen);
     }
     else
     {
      printf("<%s type=\"%s\">\n", cleanName, memType);
     }
    }

    for (int i = 0; i<arrayLen; i++)
    {
     byteOffset += resolvePointersStructRecursive(elemPtr + byteOffset, revType, verboseMode, recursion + 1);
    }
    if (verboseMode & FD_VERBOSE_EXPORT_XML)
    {
     for (int i = 0; i<recursion; i++)
     {
      printf("  ");
     }
     printf("</%s>\n", cleanName);
    }
   }
   else
   {
    //export a simple type
    if (verboseMode & FD_VERBOSE_EXPORT_XML)
    {

     if (arrayLen>MAX_ARRAY_LENGTH)
     {
      printf("too long\n");
     }
     else
     {
      //printf("%s %s\n",memType,memName);

      bool isIntegerType = (strcmp(memType, "char") == 0) || (strcmp(memType, "int") == 0) || (strcmp(memType, "short") == 0);

      if (isIntegerType)
      {
       const char* newtype = "int";
       int dbarray[MAX_ARRAY_LENGTH];
       int* dbPtr = 0;
       char* tmp = elemPtr;
       dbPtr = &dbarray[0];
       if (dbPtr)
       {
        char cleanName[MAX_STRLEN];
        getCleanName(memName, cleanName);

        int i;
        getElement(arrayLen, newtype, memType, tmp, (char*)dbPtr);
        for (i = 0; i<recursion; i++)
         printf("  ");
        if (arrayLen == 1)
         printf("<%s type=\"%s\">", cleanName, memType);
        else
         printf("<%s type=\"%s\" count=%d>", cleanName, memType, arrayLen);
        for (i = 0; i<arrayLen; i++)
         printf(" %d ", dbPtr[i]);
        printf("</%s>\n", cleanName);
       }
      }
      else
      {
       const char* newtype = "double";
       double dbarray[MAX_ARRAY_LENGTH];
       double* dbPtr = 0;
       char* tmp = elemPtr;
       dbPtr = &dbarray[0];
       if (dbPtr)
       {
        int i;
        getElement(arrayLen, newtype, memType, tmp, (char*)dbPtr);
        for (i = 0; i<recursion; i++)
         printf("  ");
        char cleanName[MAX_STRLEN];
        getCleanName(memName, cleanName);

        if (arrayLen == 1)
        {
         printf("<%s type=\"%s\">", memName, memType);
        }
        else
        {
         printf("<%s type=\"%s\" count=%d>", cleanName, memType, arrayLen);
        }
        for (i = 0; i<arrayLen; i++)
         printf(" %f ", dbPtr[i]);
        printf("</%s>\n", cleanName);
       }
      }
     }

    }
   }
  }

  int size = fileDna->getElementSize(oldStruct[0], oldStruct[1]);
  totalSize += size;
  elemPtr += size;

 }

 return totalSize;
}


///Resolve pointers replaces the original pointers in structures, and linked lists by the new in-memory structures
void bFile::resolvePointers(int verboseMode)
{
 bParse::bDNA* fileDna = mFileDNA ? mFileDNA : mMemoryDNA;

 //char *dataPtr = mFileBuffer+mDataStart;

 if (1) //mFlags & (FD_BITS_VARIES | FD_VERSION_VARIES))
 {
  resolvePointersMismatch();
 }

 {

  if (verboseMode & FD_VERBOSE_EXPORT_XML)
  {
   printf("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
   int numitems = m_chunks.size();
   printf("<bullet_physics version=%d itemcount = %d>\n", b3GetVersion(), numitems);
  }
  for (int i = 0; i<m_chunks.size(); i++)
  {
   const bChunkInd& dataChunk = m_chunks.at(i);

   if (!mFileDNA || fileDna->flagEqual(dataChunk.dna_nr))
   {
    //dataChunk.len
    short int* oldStruct = fileDna->getStruct(dataChunk.dna_nr);
    char* oldType = fileDna->getType(oldStruct[0]);

    if (verboseMode & FD_VERBOSE_EXPORT_XML)
     printf(" <%s pointer=%p>\n", oldType, dataChunk.oldPtr);

    resolvePointersChunk(dataChunk, verboseMode);

    if (verboseMode & FD_VERBOSE_EXPORT_XML)
     printf(" </%s>\n", oldType);
   }
   else
   {
    //printf("skipping mStruct\n");
   }
  }
  if (verboseMode & FD_VERBOSE_EXPORT_XML)
  {
   printf("</bullet_physics>\n");
  }
 }


}


// ----------------------------------------------------- //
void* bFile::findLibPointer(void *ptr)
{

 bStructHandle** ptrptr = getLibPointers().find(ptr);
 if (ptrptr)
  return *ptrptr;
 return 0;
}


void	bFile::updateOldPointers()
{
 int i;

 for (i = 0; i<m_chunks.size(); i++)
 {
  bChunkInd& dataChunk = m_chunks[i];
  dataChunk.oldPtr = findLibPointer(dataChunk.oldPtr);
 }
}
void	bFile::dumpChunks(bParse::bDNA* dna)
{
 int i;

 for (i = 0; i<m_chunks.size(); i++)
 {
  bChunkInd& dataChunk = m_chunks[i];
  char* codeptr = (char*)&dataChunk.code;
  char codestr[5] = { codeptr[0],codeptr[1],codeptr[2],codeptr[3],0 };

  short* newStruct = dna->getStruct(dataChunk.dna_nr);
  char* typeName = dna->getType(newStruct[0]);
  printf("%3d: %s  ", i, typeName);

  printf("code=%s  ", codestr);

  printf("ptr=%p  ", dataChunk.oldPtr);
  printf("len=%d  ", dataChunk.len);
  printf("nr=%d  ", dataChunk.nr);
  if (dataChunk.nr != 1)
  {
   printf("not 1\n");
  }
  printf("\n");




 }

#if 0
 IDFinderData ifd;
 ifd.success = 0;
 ifd.IDname = NULL;
 ifd.just_print_it = 1;
 for (i = 0; i<bf->m_blocks.size(); ++i)
 {
  BlendBlock* bb = bf->m_blocks[i];
  printf("tag='%s'\tptr=%p\ttype=%s\t[%4d]", bb->tag, bb, bf->types[bb->type_index].name, bb->m_array_entries_.size());
  block_ID_finder(bb, bf, &ifd);
  printf("\n");
 }
#endif

}


void	bFile::writeChunks(FILE* fp, bool fixupPointers)
{
 bParse::bDNA* fileDna = mFileDNA ? mFileDNA : mMemoryDNA;

 for (int i = 0; i<m_chunks.size(); i++)
 {
  bChunkInd& dataChunk = m_chunks.at(i);

  // Ouch! need to rebuild the struct
  short *oldStruct, *curStruct;
  char *oldType, *newType;
  int oldLen, curLen, reverseOld;

  oldStruct = fileDna->getStruct(dataChunk.dna_nr);
  oldType = fileDna->getType(oldStruct[0]);
  oldLen = fileDna->getLength(oldStruct[0]);
  ///don't try to convert Link block data, just memcpy it. Other data can be converted.
  reverseOld = mMemoryDNA->getReverseType(oldType);


  if ((reverseOld != -1))
  {
   // make sure it's here
   //assert(reverseOld!= -1 && "getReverseType() returned -1, struct required!");
   //
   curStruct = mMemoryDNA->getStruct(reverseOld);
   newType = mMemoryDNA->getType(curStruct[0]);
   // make sure it's the same
   assert((strcmp(oldType, newType) == 0) && "internal error, struct mismatch!");


   curLen = mMemoryDNA->getLength(curStruct[0]);
   dataChunk.dna_nr = reverseOld;
   if (strcmp("Link", oldType) != 0)
   {
    dataChunk.len = curLen * dataChunk.nr;
   }
   else
   {
    //				printf("keep length of link = %d\n",dataChunk.len);
   }

   //write the structure header
   fwrite(&dataChunk, sizeof(bChunkInd), 1, fp);



   short int* curStruct1;
   curStruct1 = mMemoryDNA->getStruct(dataChunk.dna_nr);
   assert(curStruct1 == curStruct);

   char* cur = fixupPointers ? (char*)findLibPointer(dataChunk.oldPtr) : (char*)dataChunk.oldPtr;

   //write the actual contents of the structure(s)
   fwrite(cur, dataChunk.len, 1, fp);
  }
  else
  {
   printf("serious error, struct mismatch: don't write\n");
  }
 }

}


// ----------------------------------------------------- //
int bFile::getNextBlock(bChunkInd *dataChunk, const char *dataPtr, const int flags)
{
 bool swap = false;
 bool varies = false;

 if (flags &FD_ENDIAN_SWAP)
  swap = true;
 if (flags &FD_BITS_VARIES)
  varies = true;

 if (VOID_IS_8)
 {
  if (varies)
  {
   bChunkPtr4 head;
   memcpy(&head, dataPtr, sizeof(bChunkPtr4));


   bChunkPtr8 chunk;

   chunk.code = head.code;
   chunk.len = head.len;
   chunk.m_uniqueInts[0] = head.m_uniqueInt;
   chunk.m_uniqueInts[1] = 0;
   chunk.dna_nr = head.dna_nr;
   chunk.nr = head.nr;

   if (swap)
   {
    if ((chunk.code & 0xFFFF) == 0)
     chunk.code >>= 16;

    B3_SWITCH_INT(chunk.len);
    B3_SWITCH_INT(chunk.dna_nr);
    B3_SWITCH_INT(chunk.nr);
   }


   memcpy(dataChunk, &chunk, sizeof(bChunkInd));
  }
  else
  {
   bChunkPtr8 c;
   memcpy(&c, dataPtr, sizeof(bChunkPtr8));

   if (swap)
   {
    if ((c.code & 0xFFFF) == 0)
     c.code >>= 16;

    B3_SWITCH_INT(c.len);
    B3_SWITCH_INT(c.dna_nr);
    B3_SWITCH_INT(c.nr);
   }

   memcpy(dataChunk, &c, sizeof(bChunkInd));
  }
 }
 else
 {
  if (varies)
  {
   bChunkPtr8 head;
   memcpy(&head, dataPtr, sizeof(bChunkPtr8));


   bChunkPtr4 chunk;
   chunk.code = head.code;
   chunk.len = head.len;

   if (head.m_uniqueInts[0] == head.m_uniqueInts[1])
   {
    chunk.m_uniqueInt = head.m_uniqueInts[0];
   }
   else
   {
    b3Long64 oldPtr = 0;
    memcpy(&oldPtr, &head.m_uniqueInts[0], 8);
    if (swap)
     B3_SWITCH_LONGINT(oldPtr);
    chunk.m_uniqueInt = (int)(oldPtr >> 3);
   }


   chunk.dna_nr = head.dna_nr;
   chunk.nr = head.nr;

   if (swap)
   {
    if ((chunk.code & 0xFFFF) == 0)
     chunk.code >>= 16;

    B3_SWITCH_INT(chunk.len);
    B3_SWITCH_INT(chunk.dna_nr);
    B3_SWITCH_INT(chunk.nr);
   }

   memcpy(dataChunk, &chunk, sizeof(bChunkInd));
  }
  else
  {
   bChunkPtr4 c;
   memcpy(&c, dataPtr, sizeof(bChunkPtr4));

   if (swap)
   {
    if ((c.code & 0xFFFF) == 0)
     c.code >>= 16;

    B3_SWITCH_INT(c.len);
    B3_SWITCH_INT(c.dna_nr);
    B3_SWITCH_INT(c.nr);
   }
   memcpy(dataChunk, &c, sizeof(bChunkInd));
  }
 }

 if (dataChunk->len < 0)
  return -1;

#if 0
 print("----------");
 print(dataChunk->code);
 print(dataChunk->len);
 print(dataChunk->old);
 print(dataChunk->dna_nr);
 print(dataChunk->nr);
#endif
 return (dataChunk->len + ChunkUtils::getOffset(flags));
}



//eof
char b3s_bulletDNAstr[] = {
 char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(63),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
 char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
 char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
 char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
 char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
 char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
 char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
 char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
 char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
 char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
 char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
 char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
 char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
 char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
 char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
 char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
 char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
 char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
 char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
 char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
 char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
 char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
 char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
 char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
 char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
 char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
 char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
 char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
 char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
 char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
 char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
 char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
 char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
 char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
 char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
 char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
 char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
 char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
 char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
 char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
 char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
 char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
 char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
 char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
 char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
 char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
 char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
 char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),
 char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),
 char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),
 char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),
 char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),
 char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),
 char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),
 char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),
 char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),
 char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),
 char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),
 char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),
 char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(103),char(105),
 char(109),char(112),char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),
 char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),
 char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),
 char(108),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),
 char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),
 char(42),char(109),char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),
 char(42),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),
 char(95),char(114),char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),
 char(109),char(95),char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),
 char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),
 char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),
 char(114),char(111),char(99),char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),
 char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),
 char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(99),char(100),
 char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(109),char(95),
 char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),char(114),char(105),char(99),char(116),
 char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(108),char(97),char(103),char(115),
 char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),char(95),char(99),char(111),char(109),char(112),
 char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),char(111),char(110),
 char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),char(97),char(108),char(84),char(121),char(112),
 char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(87),char(105),char(116),char(104),
 char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),char(109),char(95),char(103),char(114),char(97),char(118),
 char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),
 char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(84),char(101),
 char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(86),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),
 char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(103),char(114),
 char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(0),char(109),
 char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),char(97),char(108),char(0),char(109),char(95),char(116),
 char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(84),char(111),char(114),
 char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(109),char(95),
 char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),
 char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),
 char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),
 char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),
 char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),
 char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),
 char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
 char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(101),char(101),char(112),
 char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
 char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
 char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(82),char(111),char(119),char(115),char(0),
 char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),char(114),char(98),char(66),char(0),char(109),char(95),
 char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),
 char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),
 char(101),char(100),char(98),char(97),char(99),char(107),char(0),char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),
 char(108),char(115),char(101),char(0),char(109),char(95),char(100),char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),
 char(100),char(105),char(115),char(97),char(98),char(108),char(101),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),
 char(119),char(101),char(101),char(110),char(76),char(105),char(110),char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),
 char(118),char(101),char(114),char(114),char(105),char(100),char(101),char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),
 char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),
 char(117),char(108),char(115),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),
 char(97),char(98),char(108),char(101),char(100),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(65),char(0),char(109),char(95),
 char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),char(97),char(109),char(101),char(0),
 char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(82),char(101),char(102),char(101),
 char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),char(114),char(103),char(101),char(116),
 char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
 char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(109),char(105),char(116),
 char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),char(97),char(99),char(116),char(111),
 char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),char(99),char(116),char(111),char(114),
 char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),
 char(103),char(83),char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),
 char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),
 char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),
 char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),
 char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),
 char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),
 char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),
 char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),
 char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),
 char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(91),char(54),char(93),char(0),char(109),char(95),char(116),char(97),
 char(117),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),
 char(114),char(111),char(114),char(82),char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),
 char(95),char(101),char(114),char(112),char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),
 char(67),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),
 char(110),char(101),char(116),char(114),char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),
 char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),
 char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),
 char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),
 char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),
 char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),
 char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),
 char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),
 char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),
 char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(118),char(111),
 char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(116),
 char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),
 char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(118),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),char(109),char(117),char(108),char(97),char(116),char(101),char(100),
 char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),char(108),char(0),char(109),char(95),char(97),char(114),char(101),
 char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),
 char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(76),char(101),char(110),char(103),char(116),char(104),
 char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
 char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(65),char(114),char(101),char(97),char(0),
 char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),
 char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),
 char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),
 char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(0),char(109),
 char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(97),char(101),char(114),char(111),char(77),char(111),char(100),
 char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),char(101),char(0),char(109),char(95),char(100),char(114),char(97),
 char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),char(101),char(115),char(115),char(117),char(114),char(101),char(0),
 char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),char(110),char(97),char(109),char(105),char(99),char(70),char(114),
 char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),char(77),char(97),char(116),char(99),char(104),char(0),char(109),
 char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),
 char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
 char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(72),char(97),char(114),
 char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),
 char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),
 char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),
 char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),
 char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
 char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),
 char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),
 char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(116),char(105),char(109),char(101),
 char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(73),char(116),char(101),char(114),
 char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(73),char(116),char(101),
 char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),char(102),char(116),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(101),char(0),
 char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
 char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),char(116),char(115),char(0),char(109),char(95),char(110),char(117),
 char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(87),char(101),char(105),char(103),
 char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(98),char(102),char(114),char(97),char(109),
 char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(108),char(111),char(99),
 char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),char(118),char(105),char(109),char(112),char(117),char(108),char(115),
 char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),
 char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(114),
 char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(0),char(42),
 char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(114),char(97),char(109),char(101),char(82),
 char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
 char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(105),char(109),
 char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
 char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(97),char(109),char(112),char(105),char(110),char(103),
 char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(97),char(109),char(112),char(105),
 char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(120),char(83),
 char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),
 char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),
 char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(105),char(110),char(115),char(65),
 char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(100),char(101),char(0),char(109),char(95),char(99),char(108),
 char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(0),
 char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),char(102),char(115),char(91),char(50),char(93),char(0),char(109),
 char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(100),char(101),char(108),char(101),char(116),
 char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(91),char(50),char(93),char(0),char(109),
 char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(116),char(121),
 char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(112),char(111),
 char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(42),char(109),char(95),
 char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),char(115),char(0),char(42),char(109),char(95),char(102),char(97),
 char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(42),char(109),
 char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(115),
 char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(116),char(101),
 char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),char(110),char(107),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(84),char(101),char(116),char(114),char(97),char(104),char(101),
 char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(74),char(111),char(105),char(110),
 char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(84),char(89),char(80),char(69),char(76),char(0),char(0),char(0),
 char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),
 char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),
 char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),
 char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),
 char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),
 char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),
 char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),
 char(105),char(120),char(51),char(120),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),
 char(114),char(105),char(120),char(51),char(120),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),
 char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(66),char(118),char(104),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),
 char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),
 char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
 char(110),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),
 char(108),char(97),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),
 char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),
 char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(104),char(111),char(114),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(104),char(111),char(114),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),
 char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),
 char(101),char(114),char(102),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),
 char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),
 char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),
 char(99),char(97),char(108),char(101),char(100),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),
 char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),
 char(112),char(101),char(67),char(104),char(105),char(108),char(100),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),
 char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),
 char(101),char(114),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),
 char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),
 char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),char(112),char(97),char(99),char(116),char(77),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),
 char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),
 char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),
 char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),
 char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),
 char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),
 char(100),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
 char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),
 char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
 char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
 char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
 char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),
 char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),
 char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),
 char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),
 char(121),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),
 char(110),char(107),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),
 char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),
 char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
 char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(0),char(0),
 char(84),char(76),char(69),char(78),char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),
 char(8),char(0),char(0),char(0),char(12),char(0),char(36),char(0),char(8),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
 char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(84),char(0),char(-124),char(0),char(12),char(0),char(52),char(0),char(52),char(0),
 char(20),char(0),char(64),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(32),char(0),char(28),char(0),char(60),char(0),char(56),char(0),
 char(76),char(0),char(76),char(0),char(24),char(0),char(60),char(0),char(60),char(0),char(16),char(0),char(64),char(0),char(68),char(0),char(-48),char(1),char(0),char(1),
 char(-72),char(0),char(-104),char(0),char(104),char(0),char(88),char(0),char(-24),char(1),char(-96),char(3),char(8),char(0),char(52),char(0),char(0),char(0),char(84),char(0),
 char(116),char(0),char(92),char(1),char(-36),char(0),char(-44),char(0),char(-4),char(0),char(92),char(1),char(-52),char(0),char(16),char(0),char(100),char(0),char(20),char(0),
 char(36),char(0),char(100),char(0),char(92),char(0),char(104),char(0),char(-64),char(0),char(92),char(1),char(104),char(0),char(-84),char(1),char(83),char(84),char(82),char(67),
 char(65),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),char(9),char(0),char(2),char(0),
 char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),char(12),char(0),char(2),char(0),
 char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(14),char(0),char(1),char(0),
 char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(16),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
 char(17),char(0),char(2),char(0),char(15),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(18),char(0),char(2),char(0),char(16),char(0),char(10),char(0),
 char(14),char(0),char(11),char(0),char(19),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
 char(2),char(0),char(15),char(0),char(20),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
 char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(21),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
 char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
 char(22),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(23),char(0),char(12),char(0),
 char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
 char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(20),char(0),char(30),char(0),char(22),char(0),char(31),char(0),char(19),char(0),char(32),char(0),
 char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(24),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
 char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
 char(21),char(0),char(30),char(0),char(22),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(19),char(0),char(32),char(0),
 char(25),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(26),char(0),char(5),char(0),
 char(25),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
 char(27),char(0),char(5),char(0),char(25),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
 char(4),char(0),char(44),char(0),char(28),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(29),char(0),char(4),char(0),
 char(27),char(0),char(47),char(0),char(28),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(30),char(0),char(1),char(0),
 char(4),char(0),char(50),char(0),char(31),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(32),char(0),char(2),char(0),
 char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(33),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
 char(34),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(30),char(0),char(56),char(0),char(32),char(0),char(57),char(0),
 char(33),char(0),char(58),char(0),char(31),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(35),char(0),char(4),char(0),
 char(34),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(36),char(0),char(7),char(0),
 char(25),char(0),char(38),char(0),char(35),char(0),char(65),char(0),char(23),char(0),char(66),char(0),char(24),char(0),char(67),char(0),char(37),char(0),char(68),char(0),
 char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(38),char(0),char(2),char(0),char(36),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
 char(39),char(0),char(4),char(0),char(17),char(0),char(71),char(0),char(25),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
 char(40),char(0),char(4),char(0),char(25),char(0),char(38),char(0),char(39),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
 char(41),char(0),char(3),char(0),char(27),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(42),char(0),char(3),char(0),
 char(27),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(43),char(0),char(4),char(0),char(4),char(0),char(78),char(0),
 char(7),char(0),char(79),char(0),char(7),char(0),char(80),char(0),char(7),char(0),char(81),char(0),char(37),char(0),char(14),char(0),char(4),char(0),char(82),char(0),
 char(4),char(0),char(83),char(0),char(43),char(0),char(84),char(0),char(4),char(0),char(85),char(0),char(7),char(0),char(86),char(0),char(7),char(0),char(87),char(0),
 char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),char(7),char(0),char(90),char(0),char(4),char(0),char(91),char(0),char(4),char(0),char(92),char(0),
 char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(5),char(0),char(25),char(0),char(38),char(0),
 char(35),char(0),char(65),char(0),char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(95),char(0),char(45),char(0),char(5),char(0),
 char(27),char(0),char(47),char(0),char(13),char(0),char(96),char(0),char(14),char(0),char(97),char(0),char(4),char(0),char(98),char(0),char(0),char(0),char(99),char(0),
 char(46),char(0),char(25),char(0),char(9),char(0),char(100),char(0),char(9),char(0),char(101),char(0),char(25),char(0),char(102),char(0),char(0),char(0),char(35),char(0),
 char(18),char(0),char(103),char(0),char(18),char(0),char(104),char(0),char(14),char(0),char(105),char(0),char(14),char(0),char(106),char(0),char(14),char(0),char(107),char(0),
 char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(111),char(0),char(8),char(0),char(112),char(0),
 char(8),char(0),char(113),char(0),char(8),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(4),char(0),char(116),char(0),char(4),char(0),char(117),char(0),
 char(4),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),
 char(0),char(0),char(37),char(0),char(47),char(0),char(25),char(0),char(9),char(0),char(100),char(0),char(9),char(0),char(101),char(0),char(25),char(0),char(102),char(0),
 char(0),char(0),char(35),char(0),char(17),char(0),char(103),char(0),char(17),char(0),char(104),char(0),char(13),char(0),char(105),char(0),char(13),char(0),char(106),char(0),
 char(13),char(0),char(107),char(0),char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(7),char(0),char(110),char(0),char(7),char(0),char(111),char(0),
 char(7),char(0),char(112),char(0),char(7),char(0),char(113),char(0),char(7),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(4),char(0),char(116),char(0),
 char(4),char(0),char(117),char(0),char(4),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),
 char(4),char(0),char(122),char(0),char(0),char(0),char(37),char(0),char(48),char(0),char(2),char(0),char(49),char(0),char(123),char(0),char(14),char(0),char(124),char(0),
 char(50),char(0),char(2),char(0),char(51),char(0),char(123),char(0),char(13),char(0),char(124),char(0),char(52),char(0),char(21),char(0),char(47),char(0),char(125),char(0),
 char(15),char(0),char(126),char(0),char(13),char(0),char(127),char(0),char(13),char(0),char(-128),char(0),char(13),char(0),char(-127),char(0),char(13),char(0),char(-126),char(0),
 char(13),char(0),char(124),char(0),char(13),char(0),char(-125),char(0),char(13),char(0),char(-124),char(0),char(13),char(0),char(-123),char(0),char(13),char(0),char(-122),char(0),
 char(7),char(0),char(-121),char(0),char(7),char(0),char(-120),char(0),char(7),char(0),char(-119),char(0),char(7),char(0),char(-118),char(0),char(7),char(0),char(-117),char(0),
 char(7),char(0),char(-116),char(0),char(7),char(0),char(-115),char(0),char(7),char(0),char(-114),char(0),char(7),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),
 char(53),char(0),char(22),char(0),char(46),char(0),char(125),char(0),char(16),char(0),char(126),char(0),char(14),char(0),char(127),char(0),char(14),char(0),char(-128),char(0),
 char(14),char(0),char(-127),char(0),char(14),char(0),char(-126),char(0),char(14),char(0),char(124),char(0),char(14),char(0),char(-125),char(0),char(14),char(0),char(-124),char(0),
 char(14),char(0),char(-123),char(0),char(14),char(0),char(-122),char(0),char(8),char(0),char(-121),char(0),char(8),char(0),char(-120),char(0),char(8),char(0),char(-119),char(0),
 char(8),char(0),char(-118),char(0),char(8),char(0),char(-117),char(0),char(8),char(0),char(-116),char(0),char(8),char(0),char(-115),char(0),char(8),char(0),char(-114),char(0),
 char(8),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(2),char(0),char(4),char(0),char(-111),char(0),
 char(4),char(0),char(-110),char(0),char(55),char(0),char(13),char(0),char(56),char(0),char(-109),char(0),char(56),char(0),char(-108),char(0),char(0),char(0),char(35),char(0),
 char(4),char(0),char(-107),char(0),char(4),char(0),char(-106),char(0),char(4),char(0),char(-105),char(0),char(4),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),
 char(7),char(0),char(-102),char(0),char(4),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),char(7),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),
 char(57),char(0),char(3),char(0),char(55),char(0),char(-97),char(0),char(13),char(0),char(-96),char(0),char(13),char(0),char(-95),char(0),char(58),char(0),char(3),char(0),
 char(55),char(0),char(-97),char(0),char(14),char(0),char(-96),char(0),char(14),char(0),char(-95),char(0),char(59),char(0),char(13),char(0),char(55),char(0),char(-97),char(0),
 char(18),char(0),char(-94),char(0),char(18),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),
 char(7),char(0),char(-89),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-87),char(0),char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),
 char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(60),char(0),char(13),char(0),char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),
 char(17),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),char(7),char(0),char(-89),char(0),
 char(7),char(0),char(-88),char(0),char(7),char(0),char(-87),char(0),char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),
 char(7),char(0),char(-83),char(0),char(61),char(0),char(11),char(0),char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),
 char(7),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),
 char(7),char(0),char(-83),char(0),char(7),char(0),char(-79),char(0),char(0),char(0),char(21),char(0),char(62),char(0),char(9),char(0),char(55),char(0),char(-97),char(0),
 char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),char(13),char(0),char(-78),char(0),char(13),char(0),char(-77),char(0),char(13),char(0),char(-76),char(0),
 char(13),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(63),char(0),char(5),char(0),char(62),char(0),char(-72),char(0),
 char(4),char(0),char(-71),char(0),char(7),char(0),char(-70),char(0),char(7),char(0),char(-69),char(0),char(7),char(0),char(-68),char(0),char(64),char(0),char(9),char(0),
 char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
 char(7),char(0),char(-76),char(0),char(7),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(49),char(0),char(22),char(0),
 char(8),char(0),char(-67),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(-66),char(0),char(8),char(0),char(112),char(0),
 char(8),char(0),char(-65),char(0),char(8),char(0),char(-64),char(0),char(8),char(0),char(-63),char(0),char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),
 char(8),char(0),char(-60),char(0),char(8),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),
 char(8),char(0),char(-55),char(0),char(4),char(0),char(-54),char(0),char(4),char(0),char(-53),char(0),char(4),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),
 char(4),char(0),char(-50),char(0),char(0),char(0),char(37),char(0),char(51),char(0),char(22),char(0),char(7),char(0),char(-67),char(0),char(7),char(0),char(-79),char(0),
 char(7),char(0),char(110),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(112),char(0),char(7),char(0),char(-65),char(0),char(7),char(0),char(-64),char(0),
 char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),char(7),char(0),char(-59),char(0),
 char(7),char(0),char(-58),char(0),char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(4),char(0),char(-54),char(0),
 char(4),char(0),char(-53),char(0),char(4),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(0),char(0),char(37),char(0),
 char(65),char(0),char(4),char(0),char(7),char(0),char(-49),char(0),char(7),char(0),char(-48),char(0),char(7),char(0),char(-47),char(0),char(4),char(0),char(78),char(0),
 char(66),char(0),char(10),char(0),char(65),char(0),char(-46),char(0),char(13),char(0),char(-45),char(0),char(13),char(0),char(-44),char(0),char(13),char(0),char(-43),char(0),
 char(13),char(0),char(-42),char(0),char(13),char(0),char(-41),char(0),char(7),char(0),char(-121),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
 char(4),char(0),char(53),char(0),char(67),char(0),char(4),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),
 char(4),char(0),char(-36),char(0),char(68),char(0),char(4),char(0),char(13),char(0),char(-41),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-35),char(0),
 char(7),char(0),char(-34),char(0),char(69),char(0),char(7),char(0),char(13),char(0),char(-33),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-32),char(0),
 char(7),char(0),char(-31),char(0),char(7),char(0),char(-30),char(0),char(7),char(0),char(-29),char(0),char(4),char(0),char(53),char(0),char(70),char(0),char(6),char(0),
 char(15),char(0),char(-28),char(0),char(13),char(0),char(-30),char(0),char(13),char(0),char(-27),char(0),char(56),char(0),char(-26),char(0),char(4),char(0),char(-25),char(0),
 char(7),char(0),char(-29),char(0),char(71),char(0),char(26),char(0),char(4),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),char(7),char(0),char(-79),char(0),
 char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-19),char(0),char(7),char(0),char(-18),char(0),
 char(7),char(0),char(-17),char(0),char(7),char(0),char(-16),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),
 char(7),char(0),char(-12),char(0),char(7),char(0),char(-11),char(0),char(7),char(0),char(-10),char(0),char(7),char(0),char(-9),char(0),char(7),char(0),char(-8),char(0),
 char(7),char(0),char(-7),char(0),char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(4),char(0),char(-4),char(0),char(4),char(0),char(-3),char(0),
 char(4),char(0),char(-2),char(0),char(4),char(0),char(-1),char(0),char(4),char(0),char(117),char(0),char(72),char(0),char(12),char(0),char(15),char(0),char(0),char(1),
 char(15),char(0),char(1),char(1),char(15),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(7),char(0),char(5),char(1),
 char(4),char(0),char(6),char(1),char(4),char(0),char(7),char(1),char(4),char(0),char(8),char(1),char(4),char(0),char(9),char(1),char(7),char(0),char(-31),char(0),
 char(4),char(0),char(53),char(0),char(73),char(0),char(27),char(0),char(17),char(0),char(10),char(1),char(15),char(0),char(11),char(1),char(15),char(0),char(12),char(1),
 char(13),char(0),char(3),char(1),char(13),char(0),char(13),char(1),char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),
 char(13),char(0),char(17),char(1),char(4),char(0),char(18),char(1),char(7),char(0),char(19),char(1),char(4),char(0),char(20),char(1),char(4),char(0),char(21),char(1),
 char(4),char(0),char(22),char(1),char(7),char(0),char(23),char(1),char(7),char(0),char(24),char(1),char(4),char(0),char(25),char(1),char(4),char(0),char(26),char(1),
 char(7),char(0),char(27),char(1),char(7),char(0),char(28),char(1),char(7),char(0),char(29),char(1),char(7),char(0),char(30),char(1),char(7),char(0),char(31),char(1),
 char(7),char(0),char(32),char(1),char(4),char(0),char(33),char(1),char(4),char(0),char(34),char(1),char(4),char(0),char(35),char(1),char(74),char(0),char(12),char(0),
 char(9),char(0),char(36),char(1),char(9),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(7),char(0),char(39),char(1),char(7),char(0),char(-63),char(0),
 char(7),char(0),char(40),char(1),char(4),char(0),char(41),char(1),char(13),char(0),char(42),char(1),char(4),char(0),char(43),char(1),char(4),char(0),char(44),char(1),
 char(4),char(0),char(45),char(1),char(4),char(0),char(53),char(0),char(75),char(0),char(19),char(0),char(47),char(0),char(125),char(0),char(72),char(0),char(46),char(1),
 char(65),char(0),char(47),char(1),char(66),char(0),char(48),char(1),char(67),char(0),char(49),char(1),char(68),char(0),char(50),char(1),char(69),char(0),char(51),char(1),
 char(70),char(0),char(52),char(1),char(73),char(0),char(53),char(1),char(74),char(0),char(54),char(1),char(4),char(0),char(55),char(1),char(4),char(0),char(21),char(1),
 char(4),char(0),char(56),char(1),char(4),char(0),char(57),char(1),char(4),char(0),char(58),char(1),char(4),char(0),char(59),char(1),char(4),char(0),char(60),char(1),
 char(4),char(0),char(61),char(1),char(71),char(0),char(62),char(1), };
int b3s_bulletDNAlen = sizeof(b3s_bulletDNAstr);
char b3s_bulletDNAstr64[] = {
 char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(63),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
 char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
 char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
 char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
 char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
 char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
 char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
 char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
 char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
 char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
 char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
 char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
 char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
 char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
 char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
 char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
 char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
 char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
 char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
 char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
 char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
 char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
 char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
 char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
 char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
 char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
 char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
 char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
 char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
 char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
 char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
 char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
 char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
 char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
 char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
 char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
 char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
 char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
 char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
 char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
 char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
 char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
 char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
 char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
 char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
 char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
 char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
 char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
 char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
 char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
 char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
 char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
 char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
 char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
 char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),
 char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),
 char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),
 char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),
 char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),
 char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),
 char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),
 char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),
 char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),
 char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),
 char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),
 char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),
 char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),
 char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(103),char(105),
 char(109),char(112),char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),
 char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),
 char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),
 char(108),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),
 char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),
 char(42),char(109),char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),
 char(42),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),
 char(95),char(114),char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),
 char(109),char(95),char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),
 char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),
 char(111),char(110),char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),
 char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),
 char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),
 char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),
 char(114),char(111),char(99),char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),
 char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),
 char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),
 char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(99),char(100),
 char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(109),char(95),
 char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),char(114),char(105),char(99),char(116),
 char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(108),char(97),char(103),char(115),
 char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),char(95),char(99),char(111),char(109),char(112),
 char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),char(111),char(110),
 char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),char(97),char(108),char(84),char(121),char(112),
 char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(87),char(105),char(116),char(104),
 char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),char(109),char(95),char(103),char(114),char(97),char(118),
 char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),
 char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(84),char(101),
 char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(86),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),
 char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(103),char(114),
 char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(0),char(109),
 char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),char(97),char(108),char(0),char(109),char(95),char(116),
 char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(84),char(111),char(114),
 char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(109),char(95),
 char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(110),char(103),char(117),
 char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),
 char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),
 char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),
 char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),
 char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),
 char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),
 char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
 char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(101),char(101),char(112),
 char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
 char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),
 char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
 char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(82),char(111),char(119),char(115),char(0),
 char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),char(114),char(98),char(66),char(0),char(109),char(95),
 char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),
 char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),
 char(101),char(100),char(98),char(97),char(99),char(107),char(0),char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),
 char(108),char(115),char(101),char(0),char(109),char(95),char(100),char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),
 char(100),char(105),char(115),char(97),char(98),char(108),char(101),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),
 char(119),char(101),char(101),char(110),char(76),char(105),char(110),char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),
 char(118),char(101),char(114),char(114),char(105),char(100),char(101),char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),
 char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),
 char(117),char(108),char(115),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),
 char(97),char(98),char(108),char(101),char(100),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(65),char(0),char(109),char(95),
 char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),char(97),char(109),char(101),char(0),
 char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(82),char(101),char(102),char(101),
 char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
 char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),char(103),char(117),char(108),char(97),
 char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),char(114),char(103),char(101),char(116),
 char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),char(116),char(111),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
 char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(109),char(105),char(116),
 char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),char(97),char(99),char(116),char(111),
 char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),char(99),char(116),char(111),char(114),
 char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),
 char(103),char(83),char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),
 char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),
 char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),
 char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),
 char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),
 char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),
 char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),
 char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),
 char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),
 char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),
 char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(91),char(54),char(93),char(0),char(109),char(95),char(116),char(97),
 char(117),char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),
 char(114),char(111),char(114),char(82),char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),
 char(95),char(101),char(114),char(112),char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),
 char(67),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),
 char(110),char(101),char(116),char(114),char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),
 char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),
 char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),
 char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),
 char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),
 char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),
 char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),
 char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),
 char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
 char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),
 char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),
 char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),
 char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(118),char(111),
 char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(116),
 char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),
 char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(118),char(101),
 char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),char(109),char(117),char(108),char(97),char(116),char(101),char(100),
 char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),char(108),char(0),char(109),char(95),char(97),char(114),char(101),
 char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),
 char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(76),char(101),char(110),char(103),char(116),char(104),
 char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
 char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(65),char(114),char(101),char(97),char(0),
 char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),
 char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),
 char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),
 char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(0),char(109),
 char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(97),char(101),char(114),char(111),char(77),char(111),char(100),
 char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),char(101),char(0),char(109),char(95),char(100),char(114),char(97),
 char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),char(101),char(115),char(115),char(117),char(114),char(101),char(0),
 char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),char(110),char(97),char(109),char(105),char(99),char(70),char(114),
 char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),char(77),char(97),char(116),char(99),char(104),char(0),char(109),
 char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),
 char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
 char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(72),char(97),char(114),
 char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),
 char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),
 char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),
 char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),
 char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(67),
 char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
 char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),
 char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),
 char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),
 char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(116),char(105),char(109),char(101),
 char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(73),char(116),char(101),char(114),
 char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(73),char(116),char(101),
 char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),char(102),char(116),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(116),char(101),char(114),char(97),
 char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(101),char(0),
 char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
 char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),char(116),char(115),char(0),char(109),char(95),char(110),char(117),
 char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(87),char(101),char(105),char(103),
 char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(98),char(102),char(114),char(97),char(109),
 char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(108),char(111),char(99),
 char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),char(118),char(105),char(109),char(112),char(117),char(108),char(115),
 char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),
 char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(114),
 char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(0),char(42),
 char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(114),char(97),char(109),char(101),char(82),
 char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
 char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(105),char(109),
 char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
 char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(97),char(109),char(112),char(105),char(110),char(103),
 char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),char(100),char(97),char(109),char(112),char(105),
 char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(120),char(83),
 char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),
 char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),char(109),char(112),char(117),char(108),
 char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(105),char(110),char(115),char(65),
 char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(100),char(101),char(0),char(109),char(95),char(99),char(108),
 char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(0),
 char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),char(102),char(115),char(91),char(50),char(93),char(0),char(109),
 char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(100),char(101),char(108),char(101),char(116),
 char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(91),char(50),char(93),char(0),char(109),
 char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(116),char(121),
 char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(112),char(111),
 char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(42),char(109),char(95),
 char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),char(115),char(0),char(42),char(109),char(95),char(102),char(97),
 char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(42),char(109),
 char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(115),
 char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(116),char(101),
 char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),char(110),char(107),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(84),char(101),char(116),char(114),char(97),char(104),char(101),
 char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(109),char(95),char(110),
 char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(74),char(111),char(105),char(110),
 char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(84),char(89),char(80),char(69),char(76),char(0),char(0),char(0),
 char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),
 char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),
 char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),
 char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),
 char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),
 char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),
 char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),
 char(105),char(120),char(51),char(120),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),
 char(114),char(105),char(120),char(51),char(120),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),
 char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(66),char(118),char(104),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),
 char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),
 char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),
 char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
 char(110),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),
 char(108),char(97),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),
 char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),
 char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(104),char(111),char(114),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(104),char(111),char(114),char(116),char(73),char(110),char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),
 char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),
 char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),
 char(101),char(114),char(102),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),
 char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),
 char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),
 char(99),char(97),char(108),char(101),char(100),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),
 char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),
 char(112),char(101),char(67),char(104),char(105),char(108),char(100),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),
 char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),
 char(101),char(114),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),
 char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),
 char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),char(112),char(97),char(99),char(116),char(77),
 char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),
 char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),
 char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),
 char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),
 char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),
 char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),
 char(100),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
 char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),
 char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),
 char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),
 char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),
 char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
 char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
 char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
 char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
 char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
 char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),
 char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),
 char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),
 char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),
 char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),
 char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),
 char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),
 char(121),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),
 char(110),char(107),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),
 char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),
 char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),
 char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
 char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
 char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(0),char(0),
 char(84),char(76),char(69),char(78),char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),
 char(8),char(0),char(0),char(0),char(16),char(0),char(48),char(0),char(16),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
 char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(96),char(0),char(-112),char(0),char(16),char(0),char(56),char(0),char(56),char(0),
 char(20),char(0),char(72),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(56),char(0),char(32),char(0),char(80),char(0),char(72),char(0),
 char(96),char(0),char(80),char(0),char(32),char(0),char(64),char(0),char(64),char(0),char(16),char(0),char(72),char(0),char(80),char(0),char(-32),char(1),char(16),char(1),
 char(-72),char(0),char(-104),char(0),char(104),char(0),char(88),char(0),char(-8),char(1),char(-80),char(3),char(8),char(0),char(64),char(0),char(0),char(0),char(96),char(0),
 char(-128),char(0),char(104),char(1),char(-24),char(0),char(-32),char(0),char(8),char(1),char(104),char(1),char(-40),char(0),char(16),char(0),char(104),char(0),char(24),char(0),
 char(40),char(0),char(104),char(0),char(96),char(0),char(104),char(0),char(-56),char(0),char(104),char(1),char(112),char(0),char(-32),char(1),char(83),char(84),char(82),char(67),
 char(65),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),char(9),char(0),char(2),char(0),
 char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),char(12),char(0),char(2),char(0),
 char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(14),char(0),char(1),char(0),
 char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(16),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
 char(17),char(0),char(2),char(0),char(15),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(18),char(0),char(2),char(0),char(16),char(0),char(10),char(0),
 char(14),char(0),char(11),char(0),char(19),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
 char(2),char(0),char(15),char(0),char(20),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
 char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(21),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
 char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
 char(22),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(23),char(0),char(12),char(0),
 char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
 char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(20),char(0),char(30),char(0),char(22),char(0),char(31),char(0),char(19),char(0),char(32),char(0),
 char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(24),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
 char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
 char(21),char(0),char(30),char(0),char(22),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(19),char(0),char(32),char(0),
 char(25),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(26),char(0),char(5),char(0),
 char(25),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
 char(27),char(0),char(5),char(0),char(25),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
 char(4),char(0),char(44),char(0),char(28),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(29),char(0),char(4),char(0),
 char(27),char(0),char(47),char(0),char(28),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(30),char(0),char(1),char(0),
 char(4),char(0),char(50),char(0),char(31),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(32),char(0),char(2),char(0),
 char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(33),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
 char(34),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(30),char(0),char(56),char(0),char(32),char(0),char(57),char(0),
 char(33),char(0),char(58),char(0),char(31),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(35),char(0),char(4),char(0),
 char(34),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(36),char(0),char(7),char(0),
 char(25),char(0),char(38),char(0),char(35),char(0),char(65),char(0),char(23),char(0),char(66),char(0),char(24),char(0),char(67),char(0),char(37),char(0),char(68),char(0),
 char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(38),char(0),char(2),char(0),char(36),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
 char(39),char(0),char(4),char(0),char(17),char(0),char(71),char(0),char(25),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
 char(40),char(0),char(4),char(0),char(25),char(0),char(38),char(0),char(39),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
 char(41),char(0),char(3),char(0),char(27),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(42),char(0),char(3),char(0),
 char(27),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(43),char(0),char(4),char(0),char(4),char(0),char(78),char(0),
 char(7),char(0),char(79),char(0),char(7),char(0),char(80),char(0),char(7),char(0),char(81),char(0),char(37),char(0),char(14),char(0),char(4),char(0),char(82),char(0),
 char(4),char(0),char(83),char(0),char(43),char(0),char(84),char(0),char(4),char(0),char(85),char(0),char(7),char(0),char(86),char(0),char(7),char(0),char(87),char(0),
 char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),char(7),char(0),char(90),char(0),char(4),char(0),char(91),char(0),char(4),char(0),char(92),char(0),
 char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(5),char(0),char(25),char(0),char(38),char(0),
 char(35),char(0),char(65),char(0),char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(95),char(0),char(45),char(0),char(5),char(0),
 char(27),char(0),char(47),char(0),char(13),char(0),char(96),char(0),char(14),char(0),char(97),char(0),char(4),char(0),char(98),char(0),char(0),char(0),char(99),char(0),
 char(46),char(0),char(25),char(0),char(9),char(0),char(100),char(0),char(9),char(0),char(101),char(0),char(25),char(0),char(102),char(0),char(0),char(0),char(35),char(0),
 char(18),char(0),char(103),char(0),char(18),char(0),char(104),char(0),char(14),char(0),char(105),char(0),char(14),char(0),char(106),char(0),char(14),char(0),char(107),char(0),
 char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(111),char(0),char(8),char(0),char(112),char(0),
 char(8),char(0),char(113),char(0),char(8),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(4),char(0),char(116),char(0),char(4),char(0),char(117),char(0),
 char(4),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),char(4),char(0),char(122),char(0),
 char(0),char(0),char(37),char(0),char(47),char(0),char(25),char(0),char(9),char(0),char(100),char(0),char(9),char(0),char(101),char(0),char(25),char(0),char(102),char(0),
 char(0),char(0),char(35),char(0),char(17),char(0),char(103),char(0),char(17),char(0),char(104),char(0),char(13),char(0),char(105),char(0),char(13),char(0),char(106),char(0),
 char(13),char(0),char(107),char(0),char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(7),char(0),char(110),char(0),char(7),char(0),char(111),char(0),
 char(7),char(0),char(112),char(0),char(7),char(0),char(113),char(0),char(7),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(4),char(0),char(116),char(0),
 char(4),char(0),char(117),char(0),char(4),char(0),char(118),char(0),char(4),char(0),char(119),char(0),char(4),char(0),char(120),char(0),char(4),char(0),char(121),char(0),
 char(4),char(0),char(122),char(0),char(0),char(0),char(37),char(0),char(48),char(0),char(2),char(0),char(49),char(0),char(123),char(0),char(14),char(0),char(124),char(0),
 char(50),char(0),char(2),char(0),char(51),char(0),char(123),char(0),char(13),char(0),char(124),char(0),char(52),char(0),char(21),char(0),char(47),char(0),char(125),char(0),
 char(15),char(0),char(126),char(0),char(13),char(0),char(127),char(0),char(13),char(0),char(-128),char(0),char(13),char(0),char(-127),char(0),char(13),char(0),char(-126),char(0),
 char(13),char(0),char(124),char(0),char(13),char(0),char(-125),char(0),char(13),char(0),char(-124),char(0),char(13),char(0),char(-123),char(0),char(13),char(0),char(-122),char(0),
 char(7),char(0),char(-121),char(0),char(7),char(0),char(-120),char(0),char(7),char(0),char(-119),char(0),char(7),char(0),char(-118),char(0),char(7),char(0),char(-117),char(0),
 char(7),char(0),char(-116),char(0),char(7),char(0),char(-115),char(0),char(7),char(0),char(-114),char(0),char(7),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),
 char(53),char(0),char(22),char(0),char(46),char(0),char(125),char(0),char(16),char(0),char(126),char(0),char(14),char(0),char(127),char(0),char(14),char(0),char(-128),char(0),
 char(14),char(0),char(-127),char(0),char(14),char(0),char(-126),char(0),char(14),char(0),char(124),char(0),char(14),char(0),char(-125),char(0),char(14),char(0),char(-124),char(0),
 char(14),char(0),char(-123),char(0),char(14),char(0),char(-122),char(0),char(8),char(0),char(-121),char(0),char(8),char(0),char(-120),char(0),char(8),char(0),char(-119),char(0),
 char(8),char(0),char(-118),char(0),char(8),char(0),char(-117),char(0),char(8),char(0),char(-116),char(0),char(8),char(0),char(-115),char(0),char(8),char(0),char(-114),char(0),
 char(8),char(0),char(-113),char(0),char(4),char(0),char(-112),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(2),char(0),char(4),char(0),char(-111),char(0),
 char(4),char(0),char(-110),char(0),char(55),char(0),char(13),char(0),char(56),char(0),char(-109),char(0),char(56),char(0),char(-108),char(0),char(0),char(0),char(35),char(0),
 char(4),char(0),char(-107),char(0),char(4),char(0),char(-106),char(0),char(4),char(0),char(-105),char(0),char(4),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),
 char(7),char(0),char(-102),char(0),char(4),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),char(7),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),
 char(57),char(0),char(3),char(0),char(55),char(0),char(-97),char(0),char(13),char(0),char(-96),char(0),char(13),char(0),char(-95),char(0),char(58),char(0),char(3),char(0),
 char(55),char(0),char(-97),char(0),char(14),char(0),char(-96),char(0),char(14),char(0),char(-95),char(0),char(59),char(0),char(13),char(0),char(55),char(0),char(-97),char(0),
 char(18),char(0),char(-94),char(0),char(18),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),
 char(7),char(0),char(-89),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-87),char(0),char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),
 char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(60),char(0),char(13),char(0),char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),
 char(17),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(4),char(0),char(-90),char(0),char(7),char(0),char(-89),char(0),
 char(7),char(0),char(-88),char(0),char(7),char(0),char(-87),char(0),char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),
 char(7),char(0),char(-83),char(0),char(61),char(0),char(11),char(0),char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),
 char(7),char(0),char(-82),char(0),char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),
 char(7),char(0),char(-83),char(0),char(7),char(0),char(-79),char(0),char(0),char(0),char(21),char(0),char(62),char(0),char(9),char(0),char(55),char(0),char(-97),char(0),
 char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),char(13),char(0),char(-78),char(0),char(13),char(0),char(-77),char(0),char(13),char(0),char(-76),char(0),
 char(13),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(63),char(0),char(5),char(0),char(62),char(0),char(-72),char(0),
 char(4),char(0),char(-71),char(0),char(7),char(0),char(-70),char(0),char(7),char(0),char(-69),char(0),char(7),char(0),char(-68),char(0),char(64),char(0),char(9),char(0),
 char(55),char(0),char(-97),char(0),char(17),char(0),char(-94),char(0),char(17),char(0),char(-93),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
 char(7),char(0),char(-76),char(0),char(7),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(49),char(0),char(22),char(0),
 char(8),char(0),char(-67),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(110),char(0),char(8),char(0),char(-66),char(0),char(8),char(0),char(112),char(0),
 char(8),char(0),char(-65),char(0),char(8),char(0),char(-64),char(0),char(8),char(0),char(-63),char(0),char(8),char(0),char(-62),char(0),char(8),char(0),char(-61),char(0),
 char(8),char(0),char(-60),char(0),char(8),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),
 char(8),char(0),char(-55),char(0),char(4),char(0),char(-54),char(0),char(4),char(0),char(-53),char(0),char(4),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),
 char(4),char(0),char(-50),char(0),char(0),char(0),char(37),char(0),char(51),char(0),char(22),char(0),char(7),char(0),char(-67),char(0),char(7),char(0),char(-79),char(0),
 char(7),char(0),char(110),char(0),char(7),char(0),char(-66),char(0),char(7),char(0),char(112),char(0),char(7),char(0),char(-65),char(0),char(7),char(0),char(-64),char(0),
 char(7),char(0),char(-63),char(0),char(7),char(0),char(-62),char(0),char(7),char(0),char(-61),char(0),char(7),char(0),char(-60),char(0),char(7),char(0),char(-59),char(0),
 char(7),char(0),char(-58),char(0),char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(4),char(0),char(-54),char(0),
 char(4),char(0),char(-53),char(0),char(4),char(0),char(-52),char(0),char(4),char(0),char(-51),char(0),char(4),char(0),char(-50),char(0),char(0),char(0),char(37),char(0),
 char(65),char(0),char(4),char(0),char(7),char(0),char(-49),char(0),char(7),char(0),char(-48),char(0),char(7),char(0),char(-47),char(0),char(4),char(0),char(78),char(0),
 char(66),char(0),char(10),char(0),char(65),char(0),char(-46),char(0),char(13),char(0),char(-45),char(0),char(13),char(0),char(-44),char(0),char(13),char(0),char(-43),char(0),
 char(13),char(0),char(-42),char(0),char(13),char(0),char(-41),char(0),char(7),char(0),char(-121),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
 char(4),char(0),char(53),char(0),char(67),char(0),char(4),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),
 char(4),char(0),char(-36),char(0),char(68),char(0),char(4),char(0),char(13),char(0),char(-41),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-35),char(0),
 char(7),char(0),char(-34),char(0),char(69),char(0),char(7),char(0),char(13),char(0),char(-33),char(0),char(65),char(0),char(-46),char(0),char(4),char(0),char(-32),char(0),
 char(7),char(0),char(-31),char(0),char(7),char(0),char(-30),char(0),char(7),char(0),char(-29),char(0),char(4),char(0),char(53),char(0),char(70),char(0),char(6),char(0),
 char(15),char(0),char(-28),char(0),char(13),char(0),char(-30),char(0),char(13),char(0),char(-27),char(0),char(56),char(0),char(-26),char(0),char(4),char(0),char(-25),char(0),
 char(7),char(0),char(-29),char(0),char(71),char(0),char(26),char(0),char(4),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),char(7),char(0),char(-79),char(0),
 char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-19),char(0),char(7),char(0),char(-18),char(0),
 char(7),char(0),char(-17),char(0),char(7),char(0),char(-16),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),
 char(7),char(0),char(-12),char(0),char(7),char(0),char(-11),char(0),char(7),char(0),char(-10),char(0),char(7),char(0),char(-9),char(0),char(7),char(0),char(-8),char(0),
 char(7),char(0),char(-7),char(0),char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(4),char(0),char(-4),char(0),char(4),char(0),char(-3),char(0),
 char(4),char(0),char(-2),char(0),char(4),char(0),char(-1),char(0),char(4),char(0),char(117),char(0),char(72),char(0),char(12),char(0),char(15),char(0),char(0),char(1),
 char(15),char(0),char(1),char(1),char(15),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(7),char(0),char(5),char(1),
 char(4),char(0),char(6),char(1),char(4),char(0),char(7),char(1),char(4),char(0),char(8),char(1),char(4),char(0),char(9),char(1),char(7),char(0),char(-31),char(0),
 char(4),char(0),char(53),char(0),char(73),char(0),char(27),char(0),char(17),char(0),char(10),char(1),char(15),char(0),char(11),char(1),char(15),char(0),char(12),char(1),
 char(13),char(0),char(3),char(1),char(13),char(0),char(13),char(1),char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),
 char(13),char(0),char(17),char(1),char(4),char(0),char(18),char(1),char(7),char(0),char(19),char(1),char(4),char(0),char(20),char(1),char(4),char(0),char(21),char(1),
 char(4),char(0),char(22),char(1),char(7),char(0),char(23),char(1),char(7),char(0),char(24),char(1),char(4),char(0),char(25),char(1),char(4),char(0),char(26),char(1),
 char(7),char(0),char(27),char(1),char(7),char(0),char(28),char(1),char(7),char(0),char(29),char(1),char(7),char(0),char(30),char(1),char(7),char(0),char(31),char(1),
 char(7),char(0),char(32),char(1),char(4),char(0),char(33),char(1),char(4),char(0),char(34),char(1),char(4),char(0),char(35),char(1),char(74),char(0),char(12),char(0),
 char(9),char(0),char(36),char(1),char(9),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(7),char(0),char(39),char(1),char(7),char(0),char(-63),char(0),
 char(7),char(0),char(40),char(1),char(4),char(0),char(41),char(1),char(13),char(0),char(42),char(1),char(4),char(0),char(43),char(1),char(4),char(0),char(44),char(1),
 char(4),char(0),char(45),char(1),char(4),char(0),char(53),char(0),char(75),char(0),char(19),char(0),char(47),char(0),char(125),char(0),char(72),char(0),char(46),char(1),
 char(65),char(0),char(47),char(1),char(66),char(0),char(48),char(1),char(67),char(0),char(49),char(1),char(68),char(0),char(50),char(1),char(69),char(0),char(51),char(1),
 char(70),char(0),char(52),char(1),char(73),char(0),char(53),char(1),char(74),char(0),char(54),char(1),char(4),char(0),char(55),char(1),char(4),char(0),char(21),char(1),
 char(4),char(0),char(56),char(1),char(4),char(0),char(57),char(1),char(4),char(0),char(58),char(1),char(4),char(0),char(59),char(1),char(4),char(0),char(60),char(1),
 char(4),char(0),char(61),char(1),char(71),char(0),char(62),char(1), };
int b3s_bulletDNAlen64 = sizeof(b3s_bulletDNAstr64);

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"

#include "BulletSoftBody/btDefaultSoftBodySolver.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletSoftBody/btSoftBody.h"


btDefaultSoftBodySolver::btDefaultSoftBodySolver()
{
 // Initial we will clearly need to update solver constants
 // For now this is global for the cloths linked with this solver - we should probably make this body specific 
 // for performance in future once we understand more clearly when constants need to be updated
 m_updateSolverConstants = true;
}

btDefaultSoftBodySolver::~btDefaultSoftBodySolver()
{
}

// In this case the data is already in the soft bodies so there is no need for us to do anything
void btDefaultSoftBodySolver::copyBackToSoftBodies(bool bMove)
{

}

void btDefaultSoftBodySolver::optimize(btAlignedObjectArray< btSoftBody * > &softBodies, bool forceUpdate)
{
 m_softBodySet.copyFromArray(softBodies);
}

void btDefaultSoftBodySolver::updateSoftBodies()
{
 for (int i = 0; i < m_softBodySet.size(); i++)
 {
  btSoftBody*	psb = (btSoftBody*)m_softBodySet[i];
  if (psb->isActive())
  {
   psb->integrateMotion();
  }
 }
} // updateSoftBodies

bool btDefaultSoftBodySolver::checkInitialized()
{
 return true;
}

void btDefaultSoftBodySolver::solveConstraints(float solverdt)
{
 // Solve constraints for non-solver softbodies
 for (int i = 0; i < m_softBodySet.size(); ++i)
 {
  btSoftBody*	psb = static_cast<btSoftBody*>(m_softBodySet[i]);
  if (psb->isActive())
  {
   psb->solveConstraints();
  }
 }
} // btDefaultSoftBodySolver::solveConstraints


void btDefaultSoftBodySolver::copySoftBodyToVertexBuffer(const btSoftBody *const softBody, btVertexBufferDescriptor *vertexBuffer)
{
 // Currently only support CPU output buffers
 // TODO: check for DX11 buffers. Take all offsets into the same DX11 buffer
 // and use them together on a single kernel call if possible by setting up a
 // per-cloth target buffer array for the copy kernel.

 if (vertexBuffer->getBufferType() == btVertexBufferDescriptor::CPU_BUFFER)
 {
  const btAlignedObjectArray<btSoftBody::Node> &clothVertices(softBody->m_nodes);
  int numVertices = clothVertices.size();

  const btCPUVertexBufferDescriptor *cpuVertexBuffer = static_cast< btCPUVertexBufferDescriptor* >(vertexBuffer);
  float *basePointer = cpuVertexBuffer->getBasePointer();

  if (vertexBuffer->hasVertexPositions())
  {
   const int vertexOffset = cpuVertexBuffer->getVertexOffset();
   const int vertexStride = cpuVertexBuffer->getVertexStride();
   float *vertexPointer = basePointer + vertexOffset;

   for (int vertexIndex = 0; vertexIndex < numVertices; ++vertexIndex)
   {
    btVector3 position = clothVertices[vertexIndex].m_x;
    *(vertexPointer + 0) = (float)position.getX();
    *(vertexPointer + 1) = (float)position.getY();
    *(vertexPointer + 2) = (float)position.getZ();
    vertexPointer += vertexStride;
   }
  }
  if (vertexBuffer->hasNormals())
  {
   const int normalOffset = cpuVertexBuffer->getNormalOffset();
   const int normalStride = cpuVertexBuffer->getNormalStride();
   float *normalPointer = basePointer + normalOffset;

   for (int vertexIndex = 0; vertexIndex < numVertices; ++vertexIndex)
   {
    btVector3 normal = clothVertices[vertexIndex].m_n;
    *(normalPointer + 0) = (float)normal.getX();
    *(normalPointer + 1) = (float)normal.getY();
    *(normalPointer + 2) = (float)normal.getZ();
    normalPointer += normalStride;
   }
  }
 }
} // btDefaultSoftBodySolver::copySoftBodyToVertexBuffer

void btDefaultSoftBodySolver::processCollision(btSoftBody* softBody, btSoftBody* otherSoftBody)
{
 softBody->defaultCollisionHandler(otherSoftBody);
}

// For the default solver just leave the soft body to do its collision processing
void btDefaultSoftBodySolver::processCollision(btSoftBody *softBody, const btCollisionObjectWrapper* collisionObjectWrap)
{
 softBody->defaultCollisionHandler(collisionObjectWrap);
} // btDefaultSoftBodySolver::processCollision


void btDefaultSoftBodySolver::predictMotion(float timeStep)
{
 for (int i = 0; i < m_softBodySet.size(); ++i)
 {
  btSoftBody*	psb = m_softBodySet[i];

  if (psb->isActive())
  {
   psb->predictMotion(timeStep);
  }
 }
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
///btSoftBody implementation by Nathanael Presson

#include "BulletSoftBody/btSoftBodyInternals.h"
#include "BulletSoftBody/btSoftBodySolvers.h"
#include "BulletSoftBody/btSoftBodyData.h"
#include "LinearMath/btSerializer.h"
#include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"
#include "BulletDynamics/Featherstone/btMultiBodyConstraint.h"


//
btSoftBody::btSoftBody(btSoftBodyWorldInfo*	worldInfo, int node_count, const btVector3* x, const btScalar* m)
 :m_softBodySolver(0), m_worldInfo(worldInfo)
{
 /* Init		*/
 initDefaults();

 /* Default material	*/
 Material*	pm = appendMaterial();
 pm->m_kLST = 1;
 pm->m_kAST = 1;
 pm->m_kVST = 1;
 pm->m_flags = fMaterial::Default;

 /* Nodes			*/
 const btScalar		margin = getCollisionShape()->getMargin();
 m_nodes.resize(node_count);
 for (int i = 0, ni = node_count; i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  ZeroInitialize(n);
  n.m_x = x ? *x++ : btVector3(0, 0, 0);
  n.m_q = n.m_x;
  n.m_im = m ? *m++ : 1;
  n.m_im = n.m_im>0 ? 1 / n.m_im : 0;
  n.m_leaf = m_ndbvt.insert(btDbvtVolume::FromCR(n.m_x, margin), &n);
  n.m_material = pm;
 }
 updateBounds();

}

btSoftBody::btSoftBody(btSoftBodyWorldInfo*	worldInfo)
 :m_worldInfo(worldInfo)
{
 initDefaults();
}


void	btSoftBody::initDefaults()
{
 m_internalType = CO_SOFT_BODY;
 m_cfg.aeromodel = eAeroModel::V_Point;
 m_cfg.kVCF = 1;
 m_cfg.kDG = 0;
 m_cfg.kLF = 0;
 m_cfg.kDP = 0;
 m_cfg.kPR = 0;
 m_cfg.kVC = 0;
 m_cfg.kDF = (btScalar)0.2;
 m_cfg.kMT = 0;
 m_cfg.kCHR = (btScalar)1.0;
 m_cfg.kKHR = (btScalar)0.1;
 m_cfg.kSHR = (btScalar)1.0;
 m_cfg.kAHR = (btScalar)0.7;
 m_cfg.kSRHR_CL = (btScalar)0.1;
 m_cfg.kSKHR_CL = (btScalar)1;
 m_cfg.kSSHR_CL = (btScalar)0.5;
 m_cfg.kSR_SPLT_CL = (btScalar)0.5;
 m_cfg.kSK_SPLT_CL = (btScalar)0.5;
 m_cfg.kSS_SPLT_CL = (btScalar)0.5;
 m_cfg.maxvolume = (btScalar)1;
 m_cfg.timescale = 1;
 m_cfg.viterations = 0;
 m_cfg.piterations = 1;
 m_cfg.diterations = 0;
 m_cfg.citerations = 4;
 m_cfg.collisions = fCollision::Default;
 m_pose.m_bvolume = false;
 m_pose.m_bframe = false;
 m_pose.m_volume = 0;
 m_pose.m_com = btVector3(0, 0, 0);
 m_pose.m_rot.setIdentity();
 m_pose.m_scl.setIdentity();
 m_tag = 0;
 m_timeacc = 0;
 m_bUpdateRtCst = true;
 m_bounds[0] = btVector3(0, 0, 0);
 m_bounds[1] = btVector3(0, 0, 0);
 m_worldTransform.setIdentity();
 setSolver(eSolverPresets::Positions);

 /* Collision shape	*/
 ///for now, create a collision shape internally
 m_collisionShape = new btSoftBodyCollisionShape(this);
 m_collisionShape->setMargin(0.25f);

 m_initialWorldTransform.setIdentity();

 m_windVelocity = btVector3(0, 0, 0);
 m_restLengthScale = btScalar(1.0);
}

//
btSoftBody::~btSoftBody()
{
 //for now, delete the internal shape
 delete m_collisionShape;
 int i;

 releaseClusters();
 for (i = 0; i<m_materials.size(); ++i)
  btAlignedFree(m_materials[i]);
 for (i = 0; i<m_joints.size(); ++i)
  btAlignedFree(m_joints[i]);
}

//
bool			btSoftBody::checkLink(int node0, int node1) const
{
 return(checkLink(&m_nodes[node0], &m_nodes[node1]));
}

//
bool			btSoftBody::checkLink(const Node* node0, const Node* node1) const
{
 const Node*	n[] = { node0,node1 };
 for (int i = 0, ni = m_links.size(); i<ni; ++i)
 {
  const Link&	l = m_links[i];
  if ((l.m_n[0] == n[0] && l.m_n[1] == n[1]) ||
   (l.m_n[0] == n[1] && l.m_n[1] == n[0]))
  {
   return(true);
  }
 }
 return(false);
}

//
bool			btSoftBody::checkFace(int node0, int node1, int node2) const
{
 const Node*	n[] = { &m_nodes[node0],
  &m_nodes[node1],
  &m_nodes[node2] };
 for (int i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  const Face&	f = m_faces[i];
  int			c = 0;
  for (int j = 0; j<3; ++j)
  {
   if ((f.m_n[j] == n[0]) ||
    (f.m_n[j] == n[1]) ||
    (f.m_n[j] == n[2])) c |= 1 << j; else break;
  }
  if (c == 7) return(true);
 }
 return(false);
}

//
btSoftBody::Material*		btSoftBody::appendMaterial()
{
 Material*	pm = new(btAlignedAlloc(sizeof(Material), 16)) Material();
 if (m_materials.size()>0)
  *pm = *m_materials[0];
 else
  ZeroInitialize(*pm);
 m_materials.push_back(pm);
 return(pm);
}

//
void			btSoftBody::appendNote(const char* text,
 const btVector3& o,
 const btVector4& c,
 Node* n0,
 Node* n1,
 Node* n2,
 Node* n3)
{
 Note	n;
 ZeroInitialize(n);
 n.m_rank = 0;
 n.m_text = text;
 n.m_offset = o;
 n.m_coords[0] = c.x();
 n.m_coords[1] = c.y();
 n.m_coords[2] = c.z();
 n.m_coords[3] = c.w();
 n.m_nodes[0] = n0; n.m_rank += n0 ? 1 : 0;
 n.m_nodes[1] = n1; n.m_rank += n1 ? 1 : 0;
 n.m_nodes[2] = n2; n.m_rank += n2 ? 1 : 0;
 n.m_nodes[3] = n3; n.m_rank += n3 ? 1 : 0;
 m_notes.push_back(n);
}

//
void			btSoftBody::appendNote(const char* text,
 const btVector3& o,
 Node* feature)
{
 appendNote(text, o, btVector4(1, 0, 0, 0), feature);
}

//
void			btSoftBody::appendNote(const char* text,
 const btVector3& o,
 Link* feature)
{
 static const btScalar	w = 1 / (btScalar)2;
 appendNote(text, o, btVector4(w, w, 0, 0), feature->m_n[0],
  feature->m_n[1]);
}

//
void			btSoftBody::appendNote(const char* text,
 const btVector3& o,
 Face* feature)
{
 static const btScalar	w = 1 / (btScalar)3;
 appendNote(text, o, btVector4(w, w, w, 0), feature->m_n[0],
  feature->m_n[1],
  feature->m_n[2]);
}

//
void			btSoftBody::appendNode(const btVector3& x, btScalar m)
{
 if (m_nodes.capacity() == m_nodes.size())
 {
  pointersToIndices();
  m_nodes.reserve(m_nodes.size() * 2 + 1);
  indicesToPointers();
 }
 const btScalar	margin = getCollisionShape()->getMargin();
 m_nodes.push_back(Node());
 Node&			n = m_nodes[m_nodes.size() - 1];
 ZeroInitialize(n);
 n.m_x = x;
 n.m_q = n.m_x;
 n.m_im = m>0 ? 1 / m : 0;
 n.m_material = m_materials[0];
 n.m_leaf = m_ndbvt.insert(btDbvtVolume::FromCR(n.m_x, margin), &n);
}

//
void			btSoftBody::appendLink(int model, Material* mat)
{
 Link	l;
 if (model >= 0)
  l = m_links[model];
 else
 {
  ZeroInitialize(l); l.m_material = mat ? mat : m_materials[0];
 }
 m_links.push_back(l);
}

//
void			btSoftBody::appendLink(int node0,
 int node1,
 Material* mat,
 bool bcheckexist)
{
 appendLink(&m_nodes[node0], &m_nodes[node1], mat, bcheckexist);
}

//
void			btSoftBody::appendLink(Node* node0,
 Node* node1,
 Material* mat,
 bool bcheckexist)
{
 if ((!bcheckexist) || (!checkLink(node0, node1)))
 {
  appendLink(-1, mat);
  Link&	l = m_links[m_links.size() - 1];
  l.m_n[0] = node0;
  l.m_n[1] = node1;
  l.m_rl = (l.m_n[0]->m_x - l.m_n[1]->m_x).length();
  m_bUpdateRtCst = true;
 }
}

//
void			btSoftBody::appendFace(int model, Material* mat)
{
 Face	f;
 if (model >= 0)
 {
  f = m_faces[model];
 }
 else
 {
  ZeroInitialize(f); f.m_material = mat ? mat : m_materials[0];
 }
 m_faces.push_back(f);
}

//
void			btSoftBody::appendFace(int node0, int node1, int node2, Material* mat)
{
 if (node0 == node1)
  return;
 if (node1 == node2)
  return;
 if (node2 == node0)
  return;

 appendFace(-1, mat);
 Face&	f = m_faces[m_faces.size() - 1];
 btAssert(node0 != node1);
 btAssert(node1 != node2);
 btAssert(node2 != node0);
 f.m_n[0] = &m_nodes[node0];
 f.m_n[1] = &m_nodes[node1];
 f.m_n[2] = &m_nodes[node2];
 f.m_ra = AreaOf(f.m_n[0]->m_x,
  f.m_n[1]->m_x,
  f.m_n[2]->m_x);
 m_bUpdateRtCst = true;
}

//
void			btSoftBody::appendTetra(int model, Material* mat)
{
 Tetra	t;
 if (model >= 0)
  t = m_tetras[model];
 else
 {
  ZeroInitialize(t); t.m_material = mat ? mat : m_materials[0];
 }
 m_tetras.push_back(t);
}

//
void			btSoftBody::appendTetra(int node0,
 int node1,
 int node2,
 int node3,
 Material* mat)
{
 appendTetra(-1, mat);
 Tetra&	t = m_tetras[m_tetras.size() - 1];
 t.m_n[0] = &m_nodes[node0];
 t.m_n[1] = &m_nodes[node1];
 t.m_n[2] = &m_nodes[node2];
 t.m_n[3] = &m_nodes[node3];
 t.m_rv = VolumeOf(t.m_n[0]->m_x, t.m_n[1]->m_x, t.m_n[2]->m_x, t.m_n[3]->m_x);
 m_bUpdateRtCst = true;
}

//

void			btSoftBody::appendAnchor(int node, btRigidBody* body, bool disableCollisionBetweenLinkedBodies, btScalar influence)
{
 btVector3 local = body->getWorldTransform().inverse()*m_nodes[node].m_x;
 appendAnchor(node, body, local, disableCollisionBetweenLinkedBodies, influence);
}

//
void			btSoftBody::appendAnchor(int node, btRigidBody* body, const btVector3& localPivot, bool disableCollisionBetweenLinkedBodies, btScalar influence)
{
 if (disableCollisionBetweenLinkedBodies)
 {
  if (m_collisionDisabledObjects.findLinearSearch(body) == m_collisionDisabledObjects.size())
  {
   m_collisionDisabledObjects.push_back(body);
  }
 }

 Anchor	a;
 a.m_node = &m_nodes[node];
 a.m_body = body;
 a.m_local = localPivot;
 a.m_node->m_battach = 1;
 a.m_influence = influence;
 m_anchors.push_back(a);
}

//
void			btSoftBody::appendLinearJoint(const LJoint::Specs& specs, Cluster* body0, Body body1)
{
 LJoint*		pj = new(btAlignedAlloc(sizeof(LJoint), 16)) LJoint();
 pj->m_bodies[0] = body0;
 pj->m_bodies[1] = body1;
 pj->m_refs[0] = pj->m_bodies[0].xform().inverse()*specs.position;
 pj->m_refs[1] = pj->m_bodies[1].xform().inverse()*specs.position;
 pj->m_cfm = specs.cfm;
 pj->m_erp = specs.erp;
 pj->m_split = specs.split;
 m_joints.push_back(pj);
}

//
void			btSoftBody::appendLinearJoint(const LJoint::Specs& specs, Body body)
{
 appendLinearJoint(specs, m_clusters[0], body);
}

//
void			btSoftBody::appendLinearJoint(const LJoint::Specs& specs, btSoftBody* body)
{
 appendLinearJoint(specs, m_clusters[0], body->m_clusters[0]);
}

//
void			btSoftBody::appendAngularJoint(const AJoint::Specs& specs, Cluster* body0, Body body1)
{
 AJoint*		pj = new(btAlignedAlloc(sizeof(AJoint), 16)) AJoint();
 pj->m_bodies[0] = body0;
 pj->m_bodies[1] = body1;
 pj->m_refs[0] = pj->m_bodies[0].xform().inverse().getBasis()*specs.axis;
 pj->m_refs[1] = pj->m_bodies[1].xform().inverse().getBasis()*specs.axis;
 pj->m_cfm = specs.cfm;
 pj->m_erp = specs.erp;
 pj->m_split = specs.split;
 pj->m_icontrol = specs.icontrol;
 m_joints.push_back(pj);
}

//
void			btSoftBody::appendAngularJoint(const AJoint::Specs& specs, Body body)
{
 appendAngularJoint(specs, m_clusters[0], body);
}

//
void			btSoftBody::appendAngularJoint(const AJoint::Specs& specs, btSoftBody* body)
{
 appendAngularJoint(specs, m_clusters[0], body->m_clusters[0]);
}

//
void			btSoftBody::addForce(const btVector3& force)
{
 for (int i = 0, ni = m_nodes.size(); i<ni; ++i) addForce(force, i);
}

//
void			btSoftBody::addForce(const btVector3& force, int node)
{
 Node&	n = m_nodes[node];
 if (n.m_im>0)
 {
  n.m_f += force;
 }
}

void			btSoftBody::addAeroForceToNode(const btVector3& windVelocity, int nodeIndex)
{
 btAssert(nodeIndex >= 0 && nodeIndex < m_nodes.size());

 const btScalar dt = m_sst.sdt;
 const btScalar kLF = m_cfg.kLF;
 const btScalar kDG = m_cfg.kDG;
 //const btScalar kPR = m_cfg.kPR;
 //const btScalar kVC = m_cfg.kVC;
 const bool as_lift = kLF>0;
 const bool as_drag = kDG>0;
 const bool as_aero = as_lift || as_drag;
 const bool as_vaero = as_aero && (m_cfg.aeromodel < btSoftBody::eAeroModel::F_TwoSided);

 Node& n = m_nodes[nodeIndex];

 if (n.m_im>0)
 {
  btSoftBody::sMedium	medium;

  EvaluateMedium(m_worldInfo, n.m_x, medium);
  medium.m_velocity = windVelocity;
  medium.m_density = m_worldInfo->air_density;

  /* Aerodynamics			*/
  if (as_vaero)
  {
   const btVector3	rel_v = n.m_v - medium.m_velocity;
   const btScalar rel_v_len = rel_v.length();
   const btScalar	rel_v2 = rel_v.length2();

   if (rel_v2>SIMD_EPSILON)
   {
    const btVector3 rel_v_nrm = rel_v.normalized();
    btVector3	nrm = n.m_n;

    if (m_cfg.aeromodel == btSoftBody::eAeroModel::V_TwoSidedLiftDrag)
    {
     nrm *= (btScalar)((btDot(nrm, rel_v) < 0) ? -1 : +1);
     btVector3 fDrag(0, 0, 0);
     btVector3 fLift(0, 0, 0);

     btScalar n_dot_v = nrm.dot(rel_v_nrm);
     btScalar tri_area = 0.5f * n.m_area;

     fDrag = 0.5f * kDG * medium.m_density * rel_v2 * tri_area * n_dot_v * (-rel_v_nrm);

     // Check angle of attack
     // cos(10) = 0.98480
     if (0 < n_dot_v && n_dot_v < 0.98480f)
      fLift = 0.5f * kLF * medium.m_density * rel_v_len * tri_area * btSqrt(1.0f - n_dot_v*n_dot_v) * (nrm.cross(rel_v_nrm).cross(rel_v_nrm));

     // Check if the velocity change resulted by aero drag force exceeds the current velocity of the node.
     btVector3 del_v_by_fDrag = fDrag*n.m_im*m_sst.sdt;
     btScalar del_v_by_fDrag_len2 = del_v_by_fDrag.length2();
     btScalar v_len2 = n.m_v.length2();

     if (del_v_by_fDrag_len2 >= v_len2 && del_v_by_fDrag_len2 > 0)
     {
      btScalar del_v_by_fDrag_len = del_v_by_fDrag.length();
      btScalar v_len = n.m_v.length();
      fDrag *= btScalar(0.8)*(v_len / del_v_by_fDrag_len);
     }

     n.m_f += fDrag;
     n.m_f += fLift;
    }
    else if (m_cfg.aeromodel == btSoftBody::eAeroModel::V_Point || m_cfg.aeromodel == btSoftBody::eAeroModel::V_OneSided || m_cfg.aeromodel == btSoftBody::eAeroModel::V_TwoSided)
    {
     if (m_cfg.aeromodel == btSoftBody::eAeroModel::V_TwoSided)
      nrm *= (btScalar)((btDot(nrm, rel_v) < 0) ? -1 : +1);

     const btScalar dvn = btDot(rel_v, nrm);
     /* Compute forces	*/
     if (dvn>0)
     {
      btVector3		force(0, 0, 0);
      const btScalar	c0 = n.m_area * dvn * rel_v2 / 2;
      const btScalar	c1 = c0 * medium.m_density;
      force += nrm*(-c1*kLF);
      force += rel_v.normalized() * (-c1 * kDG);
      ApplyClampedForce(n, force, dt);
     }
    }
   }
  }
 }
}

void			btSoftBody::addAeroForceToFace(const btVector3& windVelocity, int faceIndex)
{
 const btScalar dt = m_sst.sdt;
 const btScalar kLF = m_cfg.kLF;
 const btScalar kDG = m_cfg.kDG;
 //	const btScalar kPR = m_cfg.kPR;
 //	const btScalar kVC = m_cfg.kVC;
 const bool as_lift = kLF>0;
 const bool as_drag = kDG>0;
 const bool as_aero = as_lift || as_drag;
 const bool as_faero = as_aero && (m_cfg.aeromodel >= btSoftBody::eAeroModel::F_TwoSided);

 if (as_faero)
 {
  btSoftBody::Face&	f = m_faces[faceIndex];

  btSoftBody::sMedium	medium;

  const btVector3	v = (f.m_n[0]->m_v + f.m_n[1]->m_v + f.m_n[2]->m_v) / 3;
  const btVector3	x = (f.m_n[0]->m_x + f.m_n[1]->m_x + f.m_n[2]->m_x) / 3;
  EvaluateMedium(m_worldInfo, x, medium);
  medium.m_velocity = windVelocity;
  medium.m_density = m_worldInfo->air_density;
  const btVector3	rel_v = v - medium.m_velocity;
  const btScalar rel_v_len = rel_v.length();
  const btScalar	rel_v2 = rel_v.length2();

  if (rel_v2>SIMD_EPSILON)
  {
   const btVector3 rel_v_nrm = rel_v.normalized();
   btVector3	nrm = f.m_normal;

   if (m_cfg.aeromodel == btSoftBody::eAeroModel::F_TwoSidedLiftDrag)
   {
    nrm *= (btScalar)((btDot(nrm, rel_v) < 0) ? -1 : +1);

    btVector3 fDrag(0, 0, 0);
    btVector3 fLift(0, 0, 0);

    btScalar n_dot_v = nrm.dot(rel_v_nrm);
    btScalar tri_area = 0.5f * f.m_ra;

    fDrag = 0.5f * kDG * medium.m_density * rel_v2 * tri_area * n_dot_v * (-rel_v_nrm);

    // Check angle of attack
    // cos(10) = 0.98480
    if (0 < n_dot_v && n_dot_v < 0.98480f)
     fLift = 0.5f * kLF * medium.m_density * rel_v_len * tri_area * btSqrt(1.0f - n_dot_v*n_dot_v) * (nrm.cross(rel_v_nrm).cross(rel_v_nrm));

    fDrag /= 3;
    fLift /= 3;

    for (int j = 0; j<3; ++j)
    {
     if (f.m_n[j]->m_im>0)
     {
      // Check if the velocity change resulted by aero drag force exceeds the current velocity of the node.
      btVector3 del_v_by_fDrag = fDrag*f.m_n[j]->m_im*m_sst.sdt;
      btScalar del_v_by_fDrag_len2 = del_v_by_fDrag.length2();
      btScalar v_len2 = f.m_n[j]->m_v.length2();

      if (del_v_by_fDrag_len2 >= v_len2 && del_v_by_fDrag_len2 > 0)
      {
       btScalar del_v_by_fDrag_len = del_v_by_fDrag.length();
       btScalar v_len = f.m_n[j]->m_v.length();
       fDrag *= btScalar(0.8)*(v_len / del_v_by_fDrag_len);
      }

      f.m_n[j]->m_f += fDrag;
      f.m_n[j]->m_f += fLift;
     }
    }
   }
   else if (m_cfg.aeromodel == btSoftBody::eAeroModel::F_OneSided || m_cfg.aeromodel == btSoftBody::eAeroModel::F_TwoSided)
   {
    if (m_cfg.aeromodel == btSoftBody::eAeroModel::F_TwoSided)
     nrm *= (btScalar)((btDot(nrm, rel_v) < 0) ? -1 : +1);

    const btScalar	dvn = btDot(rel_v, nrm);
    /* Compute forces	*/
    if (dvn>0)
    {
     btVector3		force(0, 0, 0);
     const btScalar	c0 = f.m_ra*dvn*rel_v2;
     const btScalar	c1 = c0*medium.m_density;
     force += nrm*(-c1*kLF);
     force += rel_v.normalized()*(-c1*kDG);
     force /= 3;
     for (int j = 0; j<3; ++j) ApplyClampedForce(*f.m_n[j], force, dt);
    }
   }
  }
 }

}

//
void			btSoftBody::addVelocity(const btVector3& velocity)
{
 for (int i = 0, ni = m_nodes.size(); i<ni; ++i) addVelocity(velocity, i);
}

/* Set velocity for the entire body										*/
void				btSoftBody::setVelocity(const btVector3& velocity)
{
 for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  if (n.m_im>0)
  {
   n.m_v = velocity;
  }
 }
}


//
void			btSoftBody::addVelocity(const btVector3& velocity, int node)
{
 Node&	n = m_nodes[node];
 if (n.m_im>0)
 {
  n.m_v += velocity;
 }
}

//
void			btSoftBody::setMass(int node, btScalar mass)
{
 m_nodes[node].m_im = mass>0 ? 1 / mass : 0;
 m_bUpdateRtCst = true;
}

//
btScalar		btSoftBody::getMass(int node) const
{
 return(m_nodes[node].m_im>0 ? 1 / m_nodes[node].m_im : 0);
}

//
btScalar		btSoftBody::getTotalMass() const
{
 btScalar	mass = 0;
 for (int i = 0; i<m_nodes.size(); ++i)
 {
  mass += getMass(i);
 }
 return(mass);
}

//
void			btSoftBody::setTotalMass(btScalar mass, bool fromfaces)
{
 int i;

 if (fromfaces)
 {

  for (i = 0; i<m_nodes.size(); ++i)
  {
   m_nodes[i].m_im = 0;
  }
  for (i = 0; i<m_faces.size(); ++i)
  {
   const Face&		f = m_faces[i];
   const btScalar	twicearea = AreaOf(f.m_n[0]->m_x,
    f.m_n[1]->m_x,
    f.m_n[2]->m_x);
   for (int j = 0; j<3; ++j)
   {
    f.m_n[j]->m_im += twicearea;
   }
  }
  for (i = 0; i<m_nodes.size(); ++i)
  {
   m_nodes[i].m_im = 1 / m_nodes[i].m_im;
  }
 }
 const btScalar	tm = getTotalMass();
 const btScalar	itm = 1 / tm;
 for (i = 0; i<m_nodes.size(); ++i)
 {
  m_nodes[i].m_im /= itm*mass;
 }
 m_bUpdateRtCst = true;
}

//
void			btSoftBody::setTotalDensity(btScalar density)
{
 setTotalMass(getVolume()*density, true);
}

//
void			btSoftBody::setVolumeMass(btScalar mass)
{
 btAlignedObjectArray<btScalar>	ranks;
 ranks.resize(m_nodes.size(), 0);
 int i;

 for (i = 0; i<m_nodes.size(); ++i)
 {
  m_nodes[i].m_im = 0;
 }
 for (i = 0; i<m_tetras.size(); ++i)
 {
  const Tetra& t = m_tetras[i];
  for (int j = 0; j<4; ++j)
  {
   t.m_n[j]->m_im += btFabs(t.m_rv);
   ranks[int(t.m_n[j] - &m_nodes[0])] += 1;
  }
 }
 for (i = 0; i<m_nodes.size(); ++i)
 {
  if (m_nodes[i].m_im>0)
  {
   m_nodes[i].m_im = ranks[i] / m_nodes[i].m_im;
  }
 }
 setTotalMass(mass, false);
}

//
void			btSoftBody::setVolumeDensity(btScalar density)
{
 btScalar	volume = 0;
 for (int i = 0; i<m_tetras.size(); ++i)
 {
  const Tetra& t = m_tetras[i];
  for (int j = 0; j<4; ++j)
  {
   volume += btFabs(t.m_rv);
  }
 }
 setVolumeMass(volume*density / 6);
}

//
void			btSoftBody::transform(const btTransform& trs)
{
 const btScalar	margin = getCollisionShape()->getMargin();
 ATTRIBUTE_ALIGNED16(btDbvtVolume)	vol;

 for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  n.m_x = trs*n.m_x;
  n.m_q = trs*n.m_q;
  n.m_n = trs.getBasis()*n.m_n;
  vol = btDbvtVolume::FromCR(n.m_x, margin);

  m_ndbvt.update(n.m_leaf, vol);
 }
 updateNormals();
 updateBounds();
 updateConstants();
 m_initialWorldTransform = trs;
}

//
void			btSoftBody::translate(const btVector3& trs)
{
 btTransform	t;
 t.setIdentity();
 t.setOrigin(trs);
 transform(t);
}

//
void			btSoftBody::rotate(const btQuaternion& rot)
{
 btTransform	t;
 t.setIdentity();
 t.setRotation(rot);
 transform(t);
}

//
void			btSoftBody::scale(const btVector3& scl)
{

 const btScalar	margin = getCollisionShape()->getMargin();
 ATTRIBUTE_ALIGNED16(btDbvtVolume)	vol;

 for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  n.m_x *= scl;
  n.m_q *= scl;
  vol = btDbvtVolume::FromCR(n.m_x, margin);
  m_ndbvt.update(n.m_leaf, vol);
 }
 updateNormals();
 updateBounds();
 updateConstants();
}

//
btScalar btSoftBody::getRestLengthScale()
{
 return m_restLengthScale;
}

//
void btSoftBody::setRestLengthScale(btScalar restLengthScale)
{
 for (int i = 0, ni = m_links.size(); i<ni; ++i)
 {
  Link&		l = m_links[i];
  l.m_rl = l.m_rl / m_restLengthScale * restLengthScale;
  l.m_c1 = l.m_rl*l.m_rl;
 }
 m_restLengthScale = restLengthScale;

 if (getActivationState() == ISLAND_SLEEPING)
  activate();
}

//
void			btSoftBody::setPose(bool bvolume, bool bframe)
{
 m_pose.m_bvolume = bvolume;
 m_pose.m_bframe = bframe;
 int i, ni;

 /* Weights		*/
 const btScalar	omass = getTotalMass();
 const btScalar	kmass = omass*m_nodes.size() * 1000;
 btScalar		tmass = omass;
 m_pose.m_wgh.resize(m_nodes.size());
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  if (m_nodes[i].m_im <= 0) tmass += kmass;
 }
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  m_pose.m_wgh[i] = n.m_im>0 ?
   1 / (m_nodes[i].m_im*tmass) :
   kmass / tmass;
 }
 /* Pos		*/
 const btVector3	com = evaluateCom();
 m_pose.m_pos.resize(m_nodes.size());
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  m_pose.m_pos[i] = m_nodes[i].m_x - com;
 }
 m_pose.m_volume = bvolume ? getVolume() : 0;
 m_pose.m_com = com;
 m_pose.m_rot.setIdentity();
 m_pose.m_scl.setIdentity();
 /* Aqq		*/
 m_pose.m_aqq[0] =
  m_pose.m_aqq[1] =
  m_pose.m_aqq[2] = btVector3(0, 0, 0);
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  const btVector3&	q = m_pose.m_pos[i];
  const btVector3		mq = m_pose.m_wgh[i] * q;
  m_pose.m_aqq[0] += mq.x()*q;
  m_pose.m_aqq[1] += mq.y()*q;
  m_pose.m_aqq[2] += mq.z()*q;
 }
 m_pose.m_aqq = m_pose.m_aqq.inverse();

 updateConstants();
}

void				btSoftBody::resetLinkRestLengths()
{
 for (int i = 0, ni = m_links.size(); i<ni; ++i)
 {
  Link& l = m_links[i];
  l.m_rl = (l.m_n[0]->m_x - l.m_n[1]->m_x).length();
  l.m_c1 = l.m_rl*l.m_rl;
 }
}

//
btScalar		btSoftBody::getVolume() const
{
 btScalar	vol = 0;
 if (m_nodes.size()>0)
 {
  int i, ni;

  const btVector3	org = m_nodes[0].m_x;
  for (i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   const Face&	f = m_faces[i];
   vol += btDot(f.m_n[0]->m_x - org, btCross(f.m_n[1]->m_x - org, f.m_n[2]->m_x - org));
  }
  vol /= (btScalar)6;
 }
 return(vol);
}

//
int				btSoftBody::clusterCount() const
{
 return(m_clusters.size());
}

//
btVector3		btSoftBody::clusterCom(const Cluster* cluster)
{
 btVector3		com(0, 0, 0);
 for (int i = 0, ni = cluster->m_nodes.size(); i<ni; ++i)
 {
  com += cluster->m_nodes[i]->m_x*cluster->m_masses[i];
 }
 return(com*cluster->m_imass);
}

//
btVector3		btSoftBody::clusterCom(int cluster) const
{
 return(clusterCom(m_clusters[cluster]));
}

//
btVector3		btSoftBody::clusterVelocity(const Cluster* cluster, const btVector3& rpos)
{
 return(cluster->m_lv + btCross(cluster->m_av, rpos));
}

//
void			btSoftBody::clusterVImpulse(Cluster* cluster, const btVector3& rpos, const btVector3& impulse)
{
 const btVector3	li = cluster->m_imass*impulse;
 const btVector3	ai = cluster->m_invwi*btCross(rpos, impulse);
 cluster->m_vimpulses[0] += li; cluster->m_lv += li;
 cluster->m_vimpulses[1] += ai; cluster->m_av += ai;
 cluster->m_nvimpulses++;
}

//
void			btSoftBody::clusterDImpulse(Cluster* cluster, const btVector3& rpos, const btVector3& impulse)
{
 const btVector3	li = cluster->m_imass*impulse;
 const btVector3	ai = cluster->m_invwi*btCross(rpos, impulse);
 cluster->m_dimpulses[0] += li;
 cluster->m_dimpulses[1] += ai;
 cluster->m_ndimpulses++;
}

//
void			btSoftBody::clusterImpulse(Cluster* cluster, const btVector3& rpos, const Impulse& impulse)
{
 if (impulse.m_asVelocity)	clusterVImpulse(cluster, rpos, impulse.m_velocity);
 if (impulse.m_asDrift)		clusterDImpulse(cluster, rpos, impulse.m_drift);
}

//
void			btSoftBody::clusterVAImpulse(Cluster* cluster, const btVector3& impulse)
{
 const btVector3	ai = cluster->m_invwi*impulse;
 cluster->m_vimpulses[1] += ai; cluster->m_av += ai;
 cluster->m_nvimpulses++;
}

//
void			btSoftBody::clusterDAImpulse(Cluster* cluster, const btVector3& impulse)
{
 const btVector3	ai = cluster->m_invwi*impulse;
 cluster->m_dimpulses[1] += ai;
 cluster->m_ndimpulses++;
}

//
void			btSoftBody::clusterAImpulse(Cluster* cluster, const Impulse& impulse)
{
 if (impulse.m_asVelocity)	clusterVAImpulse(cluster, impulse.m_velocity);
 if (impulse.m_asDrift)		clusterDAImpulse(cluster, impulse.m_drift);
}

//
void			btSoftBody::clusterDCImpulse(Cluster* cluster, const btVector3& impulse)
{
 cluster->m_dimpulses[0] += impulse*cluster->m_imass;
 cluster->m_ndimpulses++;
}

struct NodeLinks
{
 btAlignedObjectArray<int> m_links;
};



//
int				btSoftBody::generateBendingConstraints(int distance, Material* mat)
{
 int i, j;

 if (distance>1)
 {
  /* Build graph	*/
  const int		n = m_nodes.size();
  const unsigned	inf = (~(unsigned)0) >> 1;
  unsigned*		adj = new unsigned[n*n];


#define IDX(_x_,_y_)	((_y_)*n+(_x_))
  for (j = 0; j<n; ++j)
  {
   for (i = 0; i<n; ++i)
   {
    if (i != j)
    {
     adj[IDX(i, j)] = adj[IDX(j, i)] = inf;
    }
    else
    {
     adj[IDX(i, j)] = adj[IDX(j, i)] = 0;
    }
   }
  }
  for (i = 0; i<m_links.size(); ++i)
  {
   const int	ia = (int)(m_links[i].m_n[0] - &m_nodes[0]);
   const int	ib = (int)(m_links[i].m_n[1] - &m_nodes[0]);
   adj[IDX(ia, ib)] = 1;
   adj[IDX(ib, ia)] = 1;
  }


  //special optimized case for distance == 2
  if (distance == 2)
  {

   btAlignedObjectArray<NodeLinks> nodeLinks;


   /* Build node links */
   nodeLinks.resize(m_nodes.size());

   for (i = 0; i<m_links.size(); ++i)
   {
    const int	ia = (int)(m_links[i].m_n[0] - &m_nodes[0]);
    const int	ib = (int)(m_links[i].m_n[1] - &m_nodes[0]);
    if (nodeLinks[ia].m_links.findLinearSearch(ib) == nodeLinks[ia].m_links.size())
     nodeLinks[ia].m_links.push_back(ib);

    if (nodeLinks[ib].m_links.findLinearSearch(ia) == nodeLinks[ib].m_links.size())
     nodeLinks[ib].m_links.push_back(ia);
   }
   for (int ii = 0; ii<nodeLinks.size(); ii++)
   {
    int i = ii;

    for (int jj = 0; jj<nodeLinks[ii].m_links.size(); jj++)
    {
     int k = nodeLinks[ii].m_links[jj];
     for (int kk = 0; kk<nodeLinks[k].m_links.size(); kk++)
     {
      int j = nodeLinks[k].m_links[kk];
      if (i != j)
      {
       const unsigned	sum = adj[IDX(i, k)] + adj[IDX(k, j)];
       btAssert(sum == 2);
       if (adj[IDX(i, j)]>sum)
       {
        adj[IDX(i, j)] = adj[IDX(j, i)] = sum;
       }
      }

     }
    }
   }
  }
  else
  {
   ///generic Floyd's algorithm
   for (int k = 0; k<n; ++k)
   {
    for (j = 0; j<n; ++j)
    {
     for (i = j + 1; i<n; ++i)
     {
      const unsigned	sum = adj[IDX(i, k)] + adj[IDX(k, j)];
      if (adj[IDX(i, j)]>sum)
      {
       adj[IDX(i, j)] = adj[IDX(j, i)] = sum;
      }
     }
    }
   }
  }


  /* Build links	*/
  int	nlinks = 0;
  for (j = 0; j<n; ++j)
  {
   for (i = j + 1; i<n; ++i)
   {
    if (adj[IDX(i, j)] == (unsigned)distance)
    {
     appendLink(i, j, mat);
     m_links[m_links.size() - 1].m_bbending = 1;
     ++nlinks;
    }
   }
  }
  delete[] adj;
  return(nlinks);
  #undef IDX
 }
 
 return(0);
}

//
void			btSoftBody::randomizeConstraints()
{
 unsigned long	seed = 243703;
#define NEXTRAND (seed=(1664525L*seed+1013904223L)&0xffffffff)
 int i, ni;

 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  btSwap(m_links[i], m_links[NEXTRAND%ni]);
 }
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  btSwap(m_faces[i], m_faces[NEXTRAND%ni]);
 }
#undef NEXTRAND
}

//
void			btSoftBody::releaseCluster(int index)
{
 Cluster*	c = m_clusters[index];
 if (c->m_leaf) m_cdbvt.remove(c->m_leaf);
 c->~Cluster();
 btAlignedFree(c);
 m_clusters.remove(c);
}

//
void			btSoftBody::releaseClusters()
{
 while (m_clusters.size()>0) releaseCluster(0);
}

//
int				btSoftBody::generateClusters(int k, int maxiterations)
{
 int i;
 releaseClusters();
 m_clusters.resize(btMin(k, m_nodes.size()));
 for (i = 0; i<m_clusters.size(); ++i)
 {
  m_clusters[i] = new(btAlignedAlloc(sizeof(Cluster), 16)) Cluster();
  m_clusters[i]->m_collide = true;
 }
 k = m_clusters.size();
 if (k>0)
 {
  /* Initialize		*/
  btAlignedObjectArray<btVector3>	centers;
  btVector3						cog(0, 0, 0);
  int								i;
  for (i = 0; i<m_nodes.size(); ++i)
  {
   cog += m_nodes[i].m_x;
   m_clusters[(i * 29873) % m_clusters.size()]->m_nodes.push_back(&m_nodes[i]);
  }
  cog /= (btScalar)m_nodes.size();
  centers.resize(k, cog);
  /* Iterate			*/
  const btScalar	slope = 16;
  bool			changed;
  int				iterations = 0;
  do {
   const btScalar	w = 2 - btMin<btScalar>(1, iterations / slope);
   changed = false;
   iterations++;
   int i;

   for (i = 0; i<k; ++i)
   {
    btVector3	c(0, 0, 0);
    for (int j = 0; j<m_clusters[i]->m_nodes.size(); ++j)
    {
     c += m_clusters[i]->m_nodes[j]->m_x;
    }
    if (m_clusters[i]->m_nodes.size())
    {
     c /= (btScalar)m_clusters[i]->m_nodes.size();
     c = centers[i] + (c - centers[i])*w;
     changed |= ((c - centers[i]).length2()>SIMD_EPSILON);
     centers[i] = c;
     m_clusters[i]->m_nodes.resize(0);
    }
   }
   for (i = 0; i<m_nodes.size(); ++i)
   {
    const btVector3	nx = m_nodes[i].m_x;
    int				kbest = 0;
    btScalar		kdist = ClusterMetric(centers[0], nx);
    for (int j = 1; j<k; ++j)
    {
     const btScalar	d = ClusterMetric(centers[j], nx);
     if (d<kdist)
     {
      kbest = j;
      kdist = d;
     }
    }
    m_clusters[kbest]->m_nodes.push_back(&m_nodes[i]);
   }
  } while (changed && (iterations<maxiterations));
  /* Merge		*/
  btAlignedObjectArray<int>	cids;
  cids.resize(m_nodes.size(), -1);
  for (i = 0; i<m_clusters.size(); ++i)
  {
   for (int j = 0; j<m_clusters[i]->m_nodes.size(); ++j)
   {
    cids[int(m_clusters[i]->m_nodes[j] - &m_nodes[0])] = i;
   }
  }
  for (i = 0; i<m_faces.size(); ++i)
  {
   const int idx[] = { int(m_faces[i].m_n[0] - &m_nodes[0]),
    int(m_faces[i].m_n[1] - &m_nodes[0]),
    int(m_faces[i].m_n[2] - &m_nodes[0]) };
   for (int j = 0; j<3; ++j)
   {
    const int cid = cids[idx[j]];
    for (int q = 1; q<3; ++q)
    {
     const int kid = idx[(j + q) % 3];
     if (cids[kid] != cid)
     {
      if (m_clusters[cid]->m_nodes.findLinearSearch(&m_nodes[kid]) == m_clusters[cid]->m_nodes.size())
      {
       m_clusters[cid]->m_nodes.push_back(&m_nodes[kid]);
      }
     }
    }
   }
  }
  /* Master		*/
  if (m_clusters.size()>1)
  {
   Cluster*	pmaster = new(btAlignedAlloc(sizeof(Cluster), 16)) Cluster();
   pmaster->m_collide = false;
   pmaster->m_nodes.reserve(m_nodes.size());
   for (int i = 0; i<m_nodes.size(); ++i) pmaster->m_nodes.push_back(&m_nodes[i]);
   m_clusters.push_back(pmaster);
   btSwap(m_clusters[0], m_clusters[m_clusters.size() - 1]);
  }
  /* Terminate	*/
  for (i = 0; i<m_clusters.size(); ++i)
  {
   if (m_clusters[i]->m_nodes.size() == 0)
   {
    releaseCluster(i--);
   }
  }
 }
 else
 {
  //create a cluster for each tetrahedron (if tetrahedra exist) or each face
  if (m_tetras.size())
  {
   m_clusters.resize(m_tetras.size());
   for (i = 0; i<m_clusters.size(); ++i)
   {
    m_clusters[i] = new(btAlignedAlloc(sizeof(Cluster), 16)) Cluster();
    m_clusters[i]->m_collide = true;
   }
   for (i = 0; i<m_tetras.size(); i++)
   {
    for (int j = 0; j<4; j++)
    {
     m_clusters[i]->m_nodes.push_back(m_tetras[i].m_n[j]);
    }
   }

  }
  else
  {
   m_clusters.resize(m_faces.size());
   for (i = 0; i<m_clusters.size(); ++i)
   {
    m_clusters[i] = new(btAlignedAlloc(sizeof(Cluster), 16)) Cluster();
    m_clusters[i]->m_collide = true;
   }

   for (i = 0; i<m_faces.size(); ++i)
   {
    for (int j = 0; j<3; ++j)
    {
     m_clusters[i]->m_nodes.push_back(m_faces[i].m_n[j]);
    }
   }
  }
 }

 if (m_clusters.size())
 {
  initializeClusters();
  updateClusters();


  //for self-collision
  m_clusterConnectivity.resize(m_clusters.size()*m_clusters.size());
  {
   for (int c0 = 0; c0<m_clusters.size(); c0++)
   {
    m_clusters[c0]->m_clusterIndex = c0;
    for (int c1 = 0; c1<m_clusters.size(); c1++)
    {

     bool connected = false;
     Cluster* cla = m_clusters[c0];
     Cluster* clb = m_clusters[c1];
     for (int i = 0; !connected&&i<cla->m_nodes.size(); i++)
     {
      for (int j = 0; j<clb->m_nodes.size(); j++)
      {
       if (cla->m_nodes[i] == clb->m_nodes[j])
       {
        connected = true;
        break;
       }
      }
     }
     m_clusterConnectivity[c0 + c1*m_clusters.size()] = connected;
    }
   }
  }
 }

 return(m_clusters.size());
}

//
void			btSoftBody::refine(ImplicitFn* ifn, btScalar accurary, bool cut)
{
 const Node*			nbase = &m_nodes[0];
 int					ncount = m_nodes.size();
 btSymMatrix<int>	edges(ncount, -2);
 int					newnodes = 0;
 int i, j, k, ni;

 /* Filter out		*/
 for (i = 0; i<m_links.size(); ++i)
 {
  Link&	l = m_links[i];
  if (l.m_bbending)
  {
   if (!SameSign(ifn->Eval(l.m_n[0]->m_x), ifn->Eval(l.m_n[1]->m_x)))
   {
    btSwap(m_links[i], m_links[m_links.size() - 1]);
    m_links.pop_back(); --i;
   }
  }
 }
 /* Fill edges		*/
 for (i = 0; i<m_links.size(); ++i)
 {
  Link&	l = m_links[i];
  edges(int(l.m_n[0] - nbase), int(l.m_n[1] - nbase)) = -1;
 }
 for (i = 0; i<m_faces.size(); ++i)
 {
  Face&	f = m_faces[i];
  edges(int(f.m_n[0] - nbase), int(f.m_n[1] - nbase)) = -1;
  edges(int(f.m_n[1] - nbase), int(f.m_n[2] - nbase)) = -1;
  edges(int(f.m_n[2] - nbase), int(f.m_n[0] - nbase)) = -1;
 }
 /* Intersect		*/
 for (i = 0; i<ncount; ++i)
 {
  for (j = i + 1; j<ncount; ++j)
  {
   if (edges(i, j) == -1)
   {
    Node&			a = m_nodes[i];
    Node&			b = m_nodes[j];
    const btScalar	t = ImplicitSolve(ifn, a.m_x, b.m_x, accurary);
    if (t>0)
    {
     const btVector3	x = Lerp(a.m_x, b.m_x, t);
     const btVector3	v = Lerp(a.m_v, b.m_v, t);
     btScalar		m = 0;
     if (a.m_im>0)
     {
      if (b.m_im>0)
      {
       const btScalar	ma = 1 / a.m_im;
       const btScalar	mb = 1 / b.m_im;
       const btScalar	mc = Lerp(ma, mb, t);
       const btScalar	f = (ma + mb) / (ma + mb + mc);
       a.m_im = 1 / (ma*f);
       b.m_im = 1 / (mb*f);
       m = mc*f;
      }
      else
      {
       a.m_im /= 0.5f; m = 1 / a.m_im;
      }
     }
     else
     {
      if (b.m_im>0)
      {
       b.m_im /= 0.5f; m = 1 / b.m_im;
      }
      else
       m = 0;
     }
     appendNode(x, m);
     edges(i, j) = m_nodes.size() - 1;
     m_nodes[edges(i, j)].m_v = v;
     ++newnodes;
    }
   }
  }
 }
 nbase = &m_nodes[0];
 /* Refine links		*/
 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  Link&		feat = m_links[i];
  const int	idx[] = { int(feat.m_n[0] - nbase),
   int(feat.m_n[1] - nbase) };
  if ((idx[0]<ncount) && (idx[1]<ncount))
  {
   const int ni = edges(idx[0], idx[1]);
   if (ni>0)
   {
    appendLink(i);
    Link*		pft[] = { &m_links[i],
     &m_links[m_links.size() - 1] };
    pft[0]->m_n[0] = &m_nodes[idx[0]];
    pft[0]->m_n[1] = &m_nodes[ni];
    pft[1]->m_n[0] = &m_nodes[ni];
    pft[1]->m_n[1] = &m_nodes[idx[1]];
   }
  }
 }
 /* Refine faces		*/
 for (i = 0; i<m_faces.size(); ++i)
 {
  const Face&	feat = m_faces[i];
  const int	idx[] = { int(feat.m_n[0] - nbase),
   int(feat.m_n[1] - nbase),
   int(feat.m_n[2] - nbase) };
  for (j = 2, k = 0; k<3; j = k++)
  {
   if ((idx[j]<ncount) && (idx[k]<ncount))
   {
    const int ni = edges(idx[j], idx[k]);
    if (ni>0)
    {
     appendFace(i);
     const int	l = (k + 1) % 3;
     Face*		pft[] = { &m_faces[i],
      &m_faces[m_faces.size() - 1] };
     pft[0]->m_n[0] = &m_nodes[idx[l]];
     pft[0]->m_n[1] = &m_nodes[idx[j]];
     pft[0]->m_n[2] = &m_nodes[ni];
     pft[1]->m_n[0] = &m_nodes[ni];
     pft[1]->m_n[1] = &m_nodes[idx[k]];
     pft[1]->m_n[2] = &m_nodes[idx[l]];
     appendLink(ni, idx[l], pft[0]->m_material);
     --i; break;
    }
   }
  }
 }
 /* Cut				*/
 if (cut)
 {
  btAlignedObjectArray<int>	cnodes;
  const int					pcount = ncount;
  int							i;
  ncount = m_nodes.size();
  cnodes.resize(ncount, 0);
  /* Nodes		*/
  for (i = 0; i<ncount; ++i)
  {
   const btVector3	x = m_nodes[i].m_x;
   if ((i >= pcount) || (btFabs(ifn->Eval(x))<accurary))
   {
    const btVector3	v = m_nodes[i].m_v;
    btScalar		m = getMass(i);
    if (m>0) { m *= 0.5f; m_nodes[i].m_im /= 0.5f; }
    appendNode(x, m);
    cnodes[i] = m_nodes.size() - 1;
    m_nodes[cnodes[i]].m_v = v;
   }
  }
  nbase = &m_nodes[0];
  /* Links		*/
  for (i = 0, ni = m_links.size(); i<ni; ++i)
  {
   const int		id[] = { int(m_links[i].m_n[0] - nbase),
    int(m_links[i].m_n[1] - nbase) };
   int				todetach = 0;
   if (cnodes[id[0]] && cnodes[id[1]])
   {
    appendLink(i);
    todetach = m_links.size() - 1;
   }
   else
   {
    if (((ifn->Eval(m_nodes[id[0]].m_x)<accurary) &&
     (ifn->Eval(m_nodes[id[1]].m_x)<accurary)))
     todetach = i;
   }
   if (todetach)
   {
    Link&	l = m_links[todetach];
    for (int j = 0; j<2; ++j)
    {
     int cn = cnodes[int(l.m_n[j] - nbase)];
     if (cn) l.m_n[j] = &m_nodes[cn];
    }
   }
  }
  /* Faces		*/
  for (i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   Node**			n = m_faces[i].m_n;
   if ((ifn->Eval(n[0]->m_x)<accurary) &&
    (ifn->Eval(n[1]->m_x)<accurary) &&
    (ifn->Eval(n[2]->m_x)<accurary))
   {
    for (int j = 0; j<3; ++j)
    {
     int cn = cnodes[int(n[j] - nbase)];
     if (cn) n[j] = &m_nodes[cn];
    }
   }
  }
  /* Clean orphans	*/
  int							nnodes = m_nodes.size();
  btAlignedObjectArray<int>	ranks;
  btAlignedObjectArray<int>	todelete;
  ranks.resize(nnodes, 0);
  for (i = 0, ni = m_links.size(); i<ni; ++i)
  {
   for (int j = 0; j<2; ++j) ranks[int(m_links[i].m_n[j] - nbase)]++;
  }
  for (i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   for (int j = 0; j<3; ++j) ranks[int(m_faces[i].m_n[j] - nbase)]++;
  }
  for (i = 0; i<m_links.size(); ++i)
  {
   const int	id[] = { int(m_links[i].m_n[0] - nbase),
    int(m_links[i].m_n[1] - nbase) };
   const bool	sg[] = { ranks[id[0]] == 1,
    ranks[id[1]] == 1 };
   if (sg[0] || sg[1])
   {
    --ranks[id[0]];
    --ranks[id[1]];
    btSwap(m_links[i], m_links[m_links.size() - 1]);
    m_links.pop_back(); --i;
   }
  }
#if 0	
  for (i = nnodes - 1; i >= 0; --i)
  {
   if (!ranks[i]) todelete.push_back(i);
  }
  if (todelete.size())
  {
   btAlignedObjectArray<int>&	map = ranks;
   for (int i = 0; i<nnodes; ++i) map[i] = i;
   PointersToIndices(this);
   for (int i = 0, ni = todelete.size(); i<ni; ++i)
   {
    int		j = todelete[i];
    int&	a = map[j];
    int&	b = map[--nnodes];
    m_ndbvt.remove(m_nodes[a].m_leaf); m_nodes[a].m_leaf = 0;
    btSwap(m_nodes[a], m_nodes[b]);
    j = a; a = b; b = j;
   }
   IndicesToPointers(this, &map[0]);
   m_nodes.resize(nnodes);
  }
#endif
 }
 m_bUpdateRtCst = true;
}

//
bool			btSoftBody::cutLink(const Node* node0, const Node* node1, btScalar position)
{
 return(cutLink(int(node0 - &m_nodes[0]), int(node1 - &m_nodes[0]), position));
}

//
bool			btSoftBody::cutLink(int node0, int node1, btScalar position)
{
 bool			done = false;
 int i, ni;
 //	const btVector3	d=m_nodes[node0].m_x-m_nodes[node1].m_x;
 const btVector3	x = Lerp(m_nodes[node0].m_x, m_nodes[node1].m_x, position);
 const btVector3	v = Lerp(m_nodes[node0].m_v, m_nodes[node1].m_v, position);
 const btScalar	m = 1;
 appendNode(x, m);
 appendNode(x, m);
 Node*			pa = &m_nodes[node0];
 Node*			pb = &m_nodes[node1];
 Node*			pn[2] = { &m_nodes[m_nodes.size() - 2],
  &m_nodes[m_nodes.size() - 1] };
 pn[0]->m_v = v;
 pn[1]->m_v = v;
 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  const int mtch = MatchEdge(m_links[i].m_n[0], m_links[i].m_n[1], pa, pb);
  if (mtch != -1)
  {
   appendLink(i);
   Link*	pft[] = { &m_links[i],&m_links[m_links.size() - 1] };
   pft[0]->m_n[1] = pn[mtch];
   pft[1]->m_n[0] = pn[1 - mtch];
   done = true;
  }
 }
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  for (int k = 2, l = 0; l<3; k = l++)
  {
   const int mtch = MatchEdge(m_faces[i].m_n[k], m_faces[i].m_n[l], pa, pb);
   if (mtch != -1)
   {
    appendFace(i);
    Face*	pft[] = { &m_faces[i],&m_faces[m_faces.size() - 1] };
    pft[0]->m_n[l] = pn[mtch];
    pft[1]->m_n[k] = pn[1 - mtch];
    appendLink(pn[0], pft[0]->m_n[(l + 1) % 3], pft[0]->m_material, true);
    appendLink(pn[1], pft[0]->m_n[(l + 1) % 3], pft[0]->m_material, true);
   }
  }
 }
 if (!done)
 {
  m_ndbvt.remove(pn[0]->m_leaf);
  m_ndbvt.remove(pn[1]->m_leaf);
  m_nodes.pop_back();
  m_nodes.pop_back();
 }
 return(done);
}

//
bool			btSoftBody::rayTest(const btVector3& rayFrom,
 const btVector3& rayTo,
 sRayCast& results)
{
 if (m_faces.size() && m_fdbvt.empty())
  initializeFaceTree();

 results.body = this;
 results.fraction = 1.f;
 results.feature = eFeature::None;
 results.index = -1;

 return(rayTest(rayFrom, rayTo, results.fraction, results.feature, results.index, false) != 0);
}

//
void			btSoftBody::setSolver(eSolverPresets::_ preset)
{
 m_cfg.m_vsequence.clear();
 m_cfg.m_psequence.clear();
 m_cfg.m_dsequence.clear();
 switch (preset)
 {
 case	eSolverPresets::Positions:
  m_cfg.m_psequence.push_back(ePSolver::Anchors);
  m_cfg.m_psequence.push_back(ePSolver::RContacts);
  m_cfg.m_psequence.push_back(ePSolver::SContacts);
  m_cfg.m_psequence.push_back(ePSolver::Linear);
  break;
 case	eSolverPresets::Velocities:
  m_cfg.m_vsequence.push_back(eVSolver::Linear);

  m_cfg.m_psequence.push_back(ePSolver::Anchors);
  m_cfg.m_psequence.push_back(ePSolver::RContacts);
  m_cfg.m_psequence.push_back(ePSolver::SContacts);

  m_cfg.m_dsequence.push_back(ePSolver::Linear);
  break;
 }
}

//
void			btSoftBody::predictMotion(btScalar dt)
{

 int i, ni;

 /* Update				*/
 if (m_bUpdateRtCst)
 {
  m_bUpdateRtCst = false;
  updateConstants();
  m_fdbvt.clear();
  if (m_cfg.collisions&fCollision::VF_SS)
  {
   initializeFaceTree();
  }
 }

 /* Prepare				*/
 m_sst.sdt = dt*m_cfg.timescale;
 m_sst.isdt = 1 / m_sst.sdt;
 m_sst.velmrg = m_sst.sdt * 3;
 m_sst.radmrg = getCollisionShape()->getMargin();
 m_sst.updmrg = m_sst.radmrg*(btScalar)0.25;
 /* Forces				*/
 addVelocity(m_worldInfo->m_gravity*m_sst.sdt);
 applyForces();
 /* Integrate			*/
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  n.m_q = n.m_x;
  btVector3 deltaV = n.m_f*n.m_im*m_sst.sdt;
  {
   btScalar maxDisplacement = m_worldInfo->m_maxDisplacement;
   btScalar clampDeltaV = maxDisplacement / m_sst.sdt;
   for (int c = 0; c<3; c++)
   {
    if (deltaV[c]>clampDeltaV)
    {
     deltaV[c] = clampDeltaV;
    }
    if (deltaV[c]<-clampDeltaV)
    {
     deltaV[c] = -clampDeltaV;
    }
   }
  }
  n.m_v += deltaV;
  n.m_x += n.m_v*m_sst.sdt;
  n.m_f = btVector3(0, 0, 0);
 }
 /* Clusters				*/
 updateClusters();
 /* Bounds				*/
 updateBounds();
 /* Nodes				*/
 ATTRIBUTE_ALIGNED16(btDbvtVolume)	vol;
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  Node&	n = m_nodes[i];
  vol = btDbvtVolume::FromCR(n.m_x, m_sst.radmrg);
  m_ndbvt.update(n.m_leaf,
   vol,
   n.m_v*m_sst.velmrg,
   m_sst.updmrg);
 }
 /* Faces				*/
 if (!m_fdbvt.empty())
 {
  for (int i = 0; i<m_faces.size(); ++i)
  {
   Face&			f = m_faces[i];
   const btVector3	v = (f.m_n[0]->m_v +
    f.m_n[1]->m_v +
    f.m_n[2]->m_v) / 3;
   vol = VolumeOf(f, m_sst.radmrg);
   m_fdbvt.update(f.m_leaf,
    vol,
    v*m_sst.velmrg,
    m_sst.updmrg);
  }
 }
 /* Pose					*/
 updatePose();
 /* Match				*/
 if (m_pose.m_bframe && (m_cfg.kMT>0))
 {
  const btMatrix3x3	posetrs = m_pose.m_rot;
  for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   Node&	n = m_nodes[i];
   if (n.m_im>0)
   {
    const btVector3	x = posetrs*m_pose.m_pos[i] + m_pose.m_com;
    n.m_x = Lerp(n.m_x, x, m_cfg.kMT);
   }
  }
 }
 /* Clear contacts		*/
 m_rcontacts.resize(0);
 m_scontacts.resize(0);
 /* Optimize dbvt's		*/
 m_ndbvt.optimizeIncremental(1);
 m_fdbvt.optimizeIncremental(1);
 m_cdbvt.optimizeIncremental(1);
}

//
void			btSoftBody::solveConstraints()
{

 /* Apply clusters		*/
 applyClusters(false);
 /* Prepare links		*/

 int i, ni;

 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  Link&	l = m_links[i];
  l.m_c3 = l.m_n[1]->m_q - l.m_n[0]->m_q;
  l.m_c2 = 1 / (l.m_c3.length2()*l.m_c0);
 }
 /* Prepare anchors		*/
 for (i = 0, ni = m_anchors.size(); i<ni; ++i)
 {
  Anchor&			a = m_anchors[i];
  const btVector3	ra = a.m_body->getWorldTransform().getBasis()*a.m_local;
  a.m_c0 = ImpulseMatrix(m_sst.sdt,
   a.m_node->m_im,
   a.m_body->getInvMass(),
   a.m_body->getInvInertiaTensorWorld(),
   ra);
  a.m_c1 = ra;
  a.m_c2 = m_sst.sdt*a.m_node->m_im;
  a.m_body->activate();
 }
 /* Solve velocities		*/
 if (m_cfg.viterations>0)
 {
  /* Solve			*/
  for (int isolve = 0; isolve<m_cfg.viterations; ++isolve)
  {
   for (int iseq = 0; iseq<m_cfg.m_vsequence.size(); ++iseq)
   {
    getSolver(m_cfg.m_vsequence[iseq])(this, 1);
   }
  }
  /* Update			*/
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   Node&	n = m_nodes[i];
   n.m_x = n.m_q + n.m_v*m_sst.sdt;
  }
 }
 /* Solve positions		*/
 if (m_cfg.piterations>0)
 {
  for (int isolve = 0; isolve<m_cfg.piterations; ++isolve)
  {
   const btScalar ti = isolve / (btScalar)m_cfg.piterations;
   for (int iseq = 0; iseq<m_cfg.m_psequence.size(); ++iseq)
   {
    getSolver(m_cfg.m_psequence[iseq])(this, 1, ti);
   }
  }
  const btScalar	vc = m_sst.isdt*(1 - m_cfg.kDP);
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   Node&	n = m_nodes[i];
   n.m_v = (n.m_x - n.m_q)*vc;
   n.m_f = btVector3(0, 0, 0);
  }
 }
 /* Solve drift			*/
 if (m_cfg.diterations>0)
 {
  const btScalar	vcf = m_cfg.kVCF*m_sst.isdt;
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   Node&	n = m_nodes[i];
   n.m_q = n.m_x;
  }
  for (int idrift = 0; idrift<m_cfg.diterations; ++idrift)
  {
   for (int iseq = 0; iseq<m_cfg.m_dsequence.size(); ++iseq)
   {
    getSolver(m_cfg.m_dsequence[iseq])(this, 1, 0);
   }
  }
  for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   Node&	n = m_nodes[i];
   n.m_v += (n.m_x - n.m_q)*vcf;
  }
 }
 /* Apply clusters		*/
 dampClusters();
 applyClusters(true);
}

//
void			btSoftBody::staticSolve(int iterations)
{
 for (int isolve = 0; isolve<iterations; ++isolve)
 {
  for (int iseq = 0; iseq<m_cfg.m_psequence.size(); ++iseq)
  {
   getSolver(m_cfg.m_psequence[iseq])(this, 1, 0);
  }
 }
}

//
void			btSoftBody::solveCommonConstraints(btSoftBody** /*bodies*/, int /*count*/, int /*iterations*/)
{
 /// placeholder
}

//
void			btSoftBody::solveClusters(const btAlignedObjectArray<btSoftBody*>& bodies)
{
 const int	nb = bodies.size();
 int			iterations = 0;
 int i;

 for (i = 0; i<nb; ++i)
 {
  iterations = btMax(iterations, bodies[i]->m_cfg.citerations);
 }
 for (i = 0; i<nb; ++i)
 {
  bodies[i]->prepareClusters(iterations);
 }
 for (i = 0; i<iterations; ++i)
 {
  const btScalar sor = 1;
  for (int j = 0; j<nb; ++j)
  {
   bodies[j]->solveClusters(sor);
  }
 }
 for (i = 0; i<nb; ++i)
 {
  bodies[i]->cleanupClusters();
 }
}

//
void			btSoftBody::integrateMotion()
{
 /* Update			*/
 updateNormals();
}

//
btSoftBody::RayFromToCaster::RayFromToCaster(const btVector3& rayFrom, const btVector3& rayTo, btScalar mxt)
{
 m_rayFrom = rayFrom;
 m_rayNormalizedDirection = (rayTo - rayFrom);
 m_rayTo = rayTo;
 m_mint = mxt;
 m_face = 0;
 m_tests = 0;
}

//
void				btSoftBody::RayFromToCaster::Process(const btDbvtNode* leaf)
{
 btSoftBody::Face&	f = *(btSoftBody::Face*)leaf->data;
 const btScalar		t = rayFromToTriangle(m_rayFrom, m_rayTo, m_rayNormalizedDirection,
  f.m_n[0]->m_x,
  f.m_n[1]->m_x,
  f.m_n[2]->m_x,
  m_mint);
 if ((t>0) && (t<m_mint))
 {
  m_mint = t; m_face = &f;
 }
 ++m_tests;
}

//
btScalar			btSoftBody::RayFromToCaster::rayFromToTriangle(const btVector3& rayFrom,
 const btVector3& rayTo,
 const btVector3& rayNormalizedDirection,
 const btVector3& a,
 const btVector3& b,
 const btVector3& c,
 btScalar maxt)
{
 static const btScalar	ceps = -SIMD_EPSILON * 10;
 static const btScalar	teps = SIMD_EPSILON * 10;

 const btVector3			n = btCross(b - a, c - a);
 const btScalar			d = btDot(a, n);
 const btScalar			den = btDot(rayNormalizedDirection, n);
 if (!btFuzzyZero(den))
 {
  const btScalar		num = btDot(rayFrom, n) - d;
  const btScalar		t = -num / den;
  if ((t>teps) && (t<maxt))
  {
   const btVector3	hit = rayFrom + rayNormalizedDirection*t;
   if ((btDot(n, btCross(a - hit, b - hit))>ceps) &&
    (btDot(n, btCross(b - hit, c - hit))>ceps) &&
    (btDot(n, btCross(c - hit, a - hit))>ceps))
   {
    return(t);
   }
  }
 }
 return(-1);
}

//
void				btSoftBody::pointersToIndices()
{
#define	PTR2IDX(_p_,_b_)	reinterpret_cast<btSoftBody::Node*>((_p_)-(_b_))
 btSoftBody::Node*	base = m_nodes.size() ? &m_nodes[0] : 0;
 int i, ni;

 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  if (m_nodes[i].m_leaf)
  {
   m_nodes[i].m_leaf->data = *(void**)&i;
  }
 }
 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  m_links[i].m_n[0] = PTR2IDX(m_links[i].m_n[0], base);
  m_links[i].m_n[1] = PTR2IDX(m_links[i].m_n[1], base);
 }
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  m_faces[i].m_n[0] = PTR2IDX(m_faces[i].m_n[0], base);
  m_faces[i].m_n[1] = PTR2IDX(m_faces[i].m_n[1], base);
  m_faces[i].m_n[2] = PTR2IDX(m_faces[i].m_n[2], base);
  if (m_faces[i].m_leaf)
  {
   m_faces[i].m_leaf->data = *(void**)&i;
  }
 }
 for (i = 0, ni = m_anchors.size(); i<ni; ++i)
 {
  m_anchors[i].m_node = PTR2IDX(m_anchors[i].m_node, base);
 }
 for (i = 0, ni = m_notes.size(); i<ni; ++i)
 {
  for (int j = 0; j<m_notes[i].m_rank; ++j)
  {
   m_notes[i].m_nodes[j] = PTR2IDX(m_notes[i].m_nodes[j], base);
  }
 }
#undef	PTR2IDX
}

//
void				btSoftBody::indicesToPointers(const int* map)
{
#define	IDX2PTR(_p_,_b_)	map?(&(_b_)[map[(((char*)_p_)-(char*)0)]]):	\
	(&(_b_)[(((char*)_p_)-(char*)0)])
 btSoftBody::Node*	base = m_nodes.size() ? &m_nodes[0] : 0;
 int i, ni;

 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  if (m_nodes[i].m_leaf)
  {
   m_nodes[i].m_leaf->data = &m_nodes[i];
  }
 }
 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  m_links[i].m_n[0] = IDX2PTR(m_links[i].m_n[0], base);
  m_links[i].m_n[1] = IDX2PTR(m_links[i].m_n[1], base);
 }
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  m_faces[i].m_n[0] = IDX2PTR(m_faces[i].m_n[0], base);
  m_faces[i].m_n[1] = IDX2PTR(m_faces[i].m_n[1], base);
  m_faces[i].m_n[2] = IDX2PTR(m_faces[i].m_n[2], base);
  if (m_faces[i].m_leaf)
  {
   m_faces[i].m_leaf->data = &m_faces[i];
  }
 }
 for (i = 0, ni = m_anchors.size(); i<ni; ++i)
 {
  m_anchors[i].m_node = IDX2PTR(m_anchors[i].m_node, base);
 }
 for (i = 0, ni = m_notes.size(); i<ni; ++i)
 {
  for (int j = 0; j<m_notes[i].m_rank; ++j)
  {
   m_notes[i].m_nodes[j] = IDX2PTR(m_notes[i].m_nodes[j], base);
  }
 }
#undef	IDX2PTR
}

//
int					btSoftBody::rayTest(const btVector3& rayFrom, const btVector3& rayTo,
 btScalar& mint, eFeature::_& feature, int& index, bool bcountonly) const
{
 int	cnt = 0;
 btVector3 dir = rayTo - rayFrom;


 if (bcountonly || m_fdbvt.empty())
 {/* Full search	*/

  for (int i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   const btSoftBody::Face&	f = m_faces[i];

   const btScalar			t = RayFromToCaster::rayFromToTriangle(rayFrom, rayTo, dir,
    f.m_n[0]->m_x,
    f.m_n[1]->m_x,
    f.m_n[2]->m_x,
    mint);
   if (t>0)
   {
    ++cnt;
    if (!bcountonly)
    {
     feature = btSoftBody::eFeature::Face;
     index = i;
     mint = t;
    }
   }
  }
 }
 else
 {/* Use dbvt	*/
  RayFromToCaster	collider(rayFrom, rayTo, mint);

  btDbvt::rayTest(m_fdbvt.m_root, rayFrom, rayTo, collider);
  if (collider.m_face)
  {
   mint = collider.m_mint;
   feature = btSoftBody::eFeature::Face;
   index = (int)(collider.m_face - &m_faces[0]);
   cnt = 1;
  }
 }

 for (int i = 0; i<m_tetras.size(); i++)
 {
  const btSoftBody::Tetra& tet = m_tetras[i];
  int tetfaces[4][3] = { { 0,1,2 },{ 0,1,3 },{ 1,2,3 },{ 0,2,3 } };
  for (int f = 0; f<4; f++)
  {

   int index0 = tetfaces[f][0];
   int index1 = tetfaces[f][1];
   int index2 = tetfaces[f][2];
   btVector3 v0 = tet.m_n[index0]->m_x;
   btVector3 v1 = tet.m_n[index1]->m_x;
   btVector3 v2 = tet.m_n[index2]->m_x;


   const btScalar			t = RayFromToCaster::rayFromToTriangle(rayFrom, rayTo, dir,
    v0, v1, v2,
    mint);
   if (t>0)
   {
    ++cnt;
    if (!bcountonly)
    {
     feature = btSoftBody::eFeature::Tetra;
     index = i;
     mint = t;
    }
   }
  }
 }
 return(cnt);
}

//
void			btSoftBody::initializeFaceTree()
{
 m_fdbvt.clear();
 for (int i = 0; i<m_faces.size(); ++i)
 {
  Face&	f = m_faces[i];
  f.m_leaf = m_fdbvt.insert(VolumeOf(f, 0), &f);
 }
}

//
btVector3		btSoftBody::evaluateCom() const
{
 btVector3	com(0, 0, 0);
 if (m_pose.m_bframe)
 {
  for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   com += m_nodes[i].m_x*m_pose.m_wgh[i];
  }
 }
 return(com);
}

//
bool				btSoftBody::checkContact(const btCollisionObjectWrapper* colObjWrap,
 const btVector3& x,
 btScalar margin,
 btSoftBody::sCti& cti) const
{
 btVector3 nrm;
 const btCollisionShape *shp = colObjWrap->getCollisionShape();
 //	const btRigidBody *tmpRigid = btRigidBody::upcast(colObjWrap->getCollisionObject());
 //const btTransform &wtr = tmpRigid ? tmpRigid->getWorldTransform() : colObjWrap->getWorldTransform();
 const btTransform &wtr = colObjWrap->getWorldTransform();
 //todo: check which transform is needed here

 btScalar dst =
  m_worldInfo->m_sparsesdf.Evaluate(
   wtr.invXform(x),
   shp,
   nrm,
   margin);
 if (dst<0)
 {
  cti.m_colObj = colObjWrap->getCollisionObject();
  cti.m_normal = wtr.getBasis()*nrm;
  cti.m_offset = -btDot(cti.m_normal, x - cti.m_normal * dst);
  return(true);
 }
 return(false);
}

//
void					btSoftBody::updateNormals()
{

 const btVector3	zv(0, 0, 0);
 int i, ni;

 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  m_nodes[i].m_n = zv;
 }
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  btSoftBody::Face&	f = m_faces[i];
  const btVector3		n = btCross(f.m_n[1]->m_x - f.m_n[0]->m_x,
   f.m_n[2]->m_x - f.m_n[0]->m_x);
  f.m_normal = n.normalized();
  f.m_n[0]->m_n += n;
  f.m_n[1]->m_n += n;
  f.m_n[2]->m_n += n;
 }
 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  btScalar len = m_nodes[i].m_n.length();
  if (len>SIMD_EPSILON)
   m_nodes[i].m_n /= len;
 }
}

//
void					btSoftBody::updateBounds()
{
 /*if( m_acceleratedSoftBody )
 {
 // If we have an accelerated softbody we need to obtain the bounds correctly
 // For now (slightly hackily) just have a very large AABB
 // TODO: Write get bounds kernel
 // If that is updating in place, atomic collisions might be low (when the cloth isn't perfectly aligned to an axis) and we could
 // probably do a test and exchange reasonably efficiently.

 m_bounds[0] = btVector3(-1000, -1000, -1000);
 m_bounds[1] = btVector3(1000, 1000, 1000);

 } else {*/
 if (m_ndbvt.m_root)
 {
  const btVector3&	mins = m_ndbvt.m_root->volume.Mins();
  const btVector3&	maxs = m_ndbvt.m_root->volume.Maxs();
  const btScalar		csm = getCollisionShape()->getMargin();
  const btVector3		mrg = btVector3(csm,
   csm,
   csm) * 1; // ??? to investigate...
  m_bounds[0] = mins - mrg;
  m_bounds[1] = maxs + mrg;
  if (0 != getBroadphaseHandle())
  {
   m_worldInfo->m_broadphase->setAabb(getBroadphaseHandle(),
    m_bounds[0],
    m_bounds[1],
    m_worldInfo->m_dispatcher);
  }
 }
 else
 {
  m_bounds[0] =
   m_bounds[1] = btVector3(0, 0, 0);
 }
 //}
}


//
void					btSoftBody::updatePose()
{
 if (m_pose.m_bframe)
 {
  btSoftBody::Pose&	pose = m_pose;
  const btVector3		com = evaluateCom();
  /* Com			*/
  pose.m_com = com;
  /* Rotation		*/
  btMatrix3x3		Apq;
  const btScalar	eps = SIMD_EPSILON;
  Apq[0] = Apq[1] = Apq[2] = btVector3(0, 0, 0);
  Apq[0].setX(eps); Apq[1].setY(eps * 2); Apq[2].setZ(eps * 3);
  for (int i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   const btVector3		a = pose.m_wgh[i] * (m_nodes[i].m_x - com);
   const btVector3&	b = pose.m_pos[i];
   Apq[0] += a.x()*b;
   Apq[1] += a.y()*b;
   Apq[2] += a.z()*b;
  }
  btMatrix3x3		r, s;
  PolarDecompose(Apq, r, s);
  pose.m_rot = r;
  pose.m_scl = pose.m_aqq*r.transpose()*Apq;
  if (m_cfg.maxvolume>1)
  {
   const btScalar	idet = Clamp<btScalar>(1 / pose.m_scl.determinant(),
    1, m_cfg.maxvolume);
   pose.m_scl = Mul(pose.m_scl, idet);
  }

 }
}

//
void				btSoftBody::updateArea(bool averageArea)
{
 int i, ni;

 /* Face area		*/
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  Face&		f = m_faces[i];
  f.m_ra = AreaOf(f.m_n[0]->m_x, f.m_n[1]->m_x, f.m_n[2]->m_x);
 }

 /* Node area		*/

 if (averageArea)
 {
  btAlignedObjectArray<int>	counts;
  counts.resize(m_nodes.size(), 0);
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   m_nodes[i].m_area = 0;
  }
  for (i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   btSoftBody::Face&	f = m_faces[i];
   for (int j = 0; j<3; ++j)
   {
    const int index = (int)(f.m_n[j] - &m_nodes[0]);
    counts[index]++;
    f.m_n[j]->m_area += btFabs(f.m_ra);
   }
  }
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   if (counts[i]>0)
    m_nodes[i].m_area /= (btScalar)counts[i];
   else
    m_nodes[i].m_area = 0;
  }
 }
 else
 {
  // initialize node area as zero
  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   m_nodes[i].m_area = 0;
  }

  for (i = 0, ni = m_faces.size(); i<ni; ++i)
  {
   btSoftBody::Face&	f = m_faces[i];

   for (int j = 0; j<3; ++j)
   {
    f.m_n[j]->m_area += f.m_ra;
   }
  }

  for (i = 0, ni = m_nodes.size(); i<ni; ++i)
  {
   m_nodes[i].m_area *= 0.3333333f;
  }
 }
}


void				btSoftBody::updateLinkConstants()
{
 int i, ni;

 /* Links		*/
 for (i = 0, ni = m_links.size(); i<ni; ++i)
 {
  Link&		l = m_links[i];
  Material&	m = *l.m_material;
  l.m_c0 = (l.m_n[0]->m_im + l.m_n[1]->m_im) / m.m_kLST;
 }
}

void				btSoftBody::updateConstants()
{
 resetLinkRestLengths();
 updateLinkConstants();
 updateArea();
}



//
void					btSoftBody::initializeClusters()
{
 int i;

 for (i = 0; i<m_clusters.size(); ++i)
 {
  Cluster&	c = *m_clusters[i];
  c.m_imass = 0;
  c.m_masses.resize(c.m_nodes.size());
  for (int j = 0; j<c.m_nodes.size(); ++j)
  {
   if (c.m_nodes[j]->m_im == 0)
   {
    c.m_containsAnchor = true;
    c.m_masses[j] = BT_LARGE_FLOAT;
   }
   else
   {
    c.m_masses[j] = btScalar(1.) / c.m_nodes[j]->m_im;
   }
   c.m_imass += c.m_masses[j];
  }
  c.m_imass = btScalar(1.) / c.m_imass;
  c.m_com = btSoftBody::clusterCom(&c);
  c.m_lv = btVector3(0, 0, 0);
  c.m_av = btVector3(0, 0, 0);
  c.m_leaf = 0;
  /* Inertia	*/
  btMatrix3x3&	ii = c.m_locii;
  ii[0] = ii[1] = ii[2] = btVector3(0, 0, 0);
  {
   int i, ni;

   for (i = 0, ni = c.m_nodes.size(); i<ni; ++i)
   {
    const btVector3	k = c.m_nodes[i]->m_x - c.m_com;
    const btVector3	q = k*k;
    const btScalar	m = c.m_masses[i];
    ii[0][0] += m*(q[1] + q[2]);
    ii[1][1] += m*(q[0] + q[2]);
    ii[2][2] += m*(q[0] + q[1]);
    ii[0][1] -= m*k[0] * k[1];
    ii[0][2] -= m*k[0] * k[2];
    ii[1][2] -= m*k[1] * k[2];
   }
  }
  ii[1][0] = ii[0][1];
  ii[2][0] = ii[0][2];
  ii[2][1] = ii[1][2];

  ii = ii.inverse();

  /* Frame	*/
  c.m_framexform.setIdentity();
  c.m_framexform.setOrigin(c.m_com);
  c.m_framerefs.resize(c.m_nodes.size());
  {
   int i;
   for (i = 0; i<c.m_framerefs.size(); ++i)
   {
    c.m_framerefs[i] = c.m_nodes[i]->m_x - c.m_com;
   }
  }
 }
}

//
void					btSoftBody::updateClusters()
{
 BT_PROFILE("UpdateClusters");
 int i;

 for (i = 0; i<m_clusters.size(); ++i)
 {
  btSoftBody::Cluster&	c = *m_clusters[i];
  const int				n = c.m_nodes.size();
  //const btScalar			invn=1/(btScalar)n;
  if (n)
  {
   /* Frame				*/
   const btScalar	eps = btScalar(0.0001);
   btMatrix3x3		m, r, s;
   m[0] = m[1] = m[2] = btVector3(0, 0, 0);
   m[0][0] = eps * 1;
   m[1][1] = eps * 2;
   m[2][2] = eps * 3;
   c.m_com = clusterCom(&c);
   for (int i = 0; i<c.m_nodes.size(); ++i)
   {
    const btVector3		a = c.m_nodes[i]->m_x - c.m_com;
    const btVector3&	b = c.m_framerefs[i];
    m[0] += a[0] * b; m[1] += a[1] * b; m[2] += a[2] * b;
   }
   PolarDecompose(m, r, s);
   c.m_framexform.setOrigin(c.m_com);
   c.m_framexform.setBasis(r);
   /* Inertia			*/
#if 1/* Constant	*/ 
   c.m_invwi = c.m_framexform.getBasis()*c.m_locii*c.m_framexform.getBasis().transpose();
#else
#if 0/* Sphere	*/ 
   const btScalar	rk = (2 * c.m_extents.length2()) / (5 * c.m_imass);
   const btVector3	inertia(rk, rk, rk);
   const btVector3	iin(btFabs(inertia[0])>SIMD_EPSILON ? 1 / inertia[0] : 0,
    btFabs(inertia[1])>SIMD_EPSILON ? 1 / inertia[1] : 0,
    btFabs(inertia[2])>SIMD_EPSILON ? 1 / inertia[2] : 0);

   c.m_invwi = c.m_xform.getBasis().scaled(iin)*c.m_xform.getBasis().transpose();
#else/* Actual	*/ 		
   c.m_invwi[0] = c.m_invwi[1] = c.m_invwi[2] = btVector3(0, 0, 0);
   for (int i = 0; i<n; ++i)
   {
    const btVector3	k = c.m_nodes[i]->m_x - c.m_com;
    const btVector3		q = k*k;
    const btScalar		m = 1 / c.m_nodes[i]->m_im;
    c.m_invwi[0][0] += m*(q[1] + q[2]);
    c.m_invwi[1][1] += m*(q[0] + q[2]);
    c.m_invwi[2][2] += m*(q[0] + q[1]);
    c.m_invwi[0][1] -= m*k[0] * k[1];
    c.m_invwi[0][2] -= m*k[0] * k[2];
    c.m_invwi[1][2] -= m*k[1] * k[2];
   }
   c.m_invwi[1][0] = c.m_invwi[0][1];
   c.m_invwi[2][0] = c.m_invwi[0][2];
   c.m_invwi[2][1] = c.m_invwi[1][2];
   c.m_invwi = c.m_invwi.inverse();
#endif
#endif
   /* Velocities			*/
   c.m_lv = btVector3(0, 0, 0);
   c.m_av = btVector3(0, 0, 0);
   {
    int i;

    for (i = 0; i<n; ++i)
    {
     const btVector3	v = c.m_nodes[i]->m_v*c.m_masses[i];
     c.m_lv += v;
     c.m_av += btCross(c.m_nodes[i]->m_x - c.m_com, v);
    }
   }
   c.m_lv = c.m_imass*c.m_lv*(1 - c.m_ldamping);
   c.m_av = c.m_invwi*c.m_av*(1 - c.m_adamping);
   c.m_vimpulses[0] =
    c.m_vimpulses[1] = btVector3(0, 0, 0);
   c.m_dimpulses[0] =
    c.m_dimpulses[1] = btVector3(0, 0, 0);
   c.m_nvimpulses = 0;
   c.m_ndimpulses = 0;
   /* Matching				*/
   if (c.m_matching>0)
   {
    for (int j = 0; j<c.m_nodes.size(); ++j)
    {
     Node&			n = *c.m_nodes[j];
     const btVector3	x = c.m_framexform*c.m_framerefs[j];
     n.m_x = Lerp(n.m_x, x, c.m_matching);
    }
   }
   /* Dbvt					*/
   if (c.m_collide)
   {
    btVector3	mi = c.m_nodes[0]->m_x;
    btVector3	mx = mi;
    for (int j = 1; j<n; ++j)
    {
     mi.setMin(c.m_nodes[j]->m_x);
     mx.setMax(c.m_nodes[j]->m_x);
    }
    ATTRIBUTE_ALIGNED16(btDbvtVolume)	bounds = btDbvtVolume::FromMM(mi, mx);
    if (c.m_leaf)
     m_cdbvt.update(c.m_leaf, bounds, c.m_lv*m_sst.sdt * 3, m_sst.radmrg);
    else
     c.m_leaf = m_cdbvt.insert(bounds, &c);
   }
  }
 }


}




//
void					btSoftBody::cleanupClusters()
{
 for (int i = 0; i<m_joints.size(); ++i)
 {
  m_joints[i]->Terminate(m_sst.sdt);
  if (m_joints[i]->m_delete)
  {
   btAlignedFree(m_joints[i]);
   m_joints.remove(m_joints[i--]);
  }
 }
}

//
void					btSoftBody::prepareClusters(int iterations)
{
 for (int i = 0; i<m_joints.size(); ++i)
 {
  m_joints[i]->Prepare(m_sst.sdt, iterations);
 }
}


//
void					btSoftBody::solveClusters(btScalar sor)
{
 for (int i = 0, ni = m_joints.size(); i<ni; ++i)
 {
  m_joints[i]->Solve(m_sst.sdt, sor);
 }
}

//
void					btSoftBody::applyClusters(bool drift)
{
 BT_PROFILE("ApplyClusters");
 //	const btScalar					f0=m_sst.sdt;
 //const btScalar					f1=f0/2;
 btAlignedObjectArray<btVector3> deltas;
 btAlignedObjectArray<btScalar> weights;
 deltas.resize(m_nodes.size(), btVector3(0, 0, 0));
 weights.resize(m_nodes.size(), 0);
 int i;

 if (drift)
 {
  for (i = 0; i<m_clusters.size(); ++i)
  {
   Cluster&	c = *m_clusters[i];
   if (c.m_ndimpulses)
   {
    c.m_dimpulses[0] /= (btScalar)c.m_ndimpulses;
    c.m_dimpulses[1] /= (btScalar)c.m_ndimpulses;
   }
  }
 }

 for (i = 0; i<m_clusters.size(); ++i)
 {
  Cluster&	c = *m_clusters[i];
  if (0<(drift ? c.m_ndimpulses : c.m_nvimpulses))
  {
   const btVector3		v = (drift ? c.m_dimpulses[0] : c.m_vimpulses[0])*m_sst.sdt;
   const btVector3		w = (drift ? c.m_dimpulses[1] : c.m_vimpulses[1])*m_sst.sdt;
   for (int j = 0; j<c.m_nodes.size(); ++j)
   {
    const int			idx = int(c.m_nodes[j] - &m_nodes[0]);
    const btVector3&	x = c.m_nodes[j]->m_x;
    const btScalar		q = c.m_masses[j];
    deltas[idx] += (v + btCross(w, x - c.m_com))*q;
    weights[idx] += q;
   }
  }
 }
 for (i = 0; i<deltas.size(); ++i)
 {
  if (weights[i]>0)
  {
   m_nodes[i].m_x += deltas[i] / weights[i];
  }
 }
}

//
void					btSoftBody::dampClusters()
{
 int i;

 for (i = 0; i<m_clusters.size(); ++i)
 {
  Cluster&	c = *m_clusters[i];
  if (c.m_ndamping>0)
  {
   for (int j = 0; j<c.m_nodes.size(); ++j)
   {
    Node&			n = *c.m_nodes[j];
    if (n.m_im>0)
    {
     const btVector3	vx = c.m_lv + btCross(c.m_av, c.m_nodes[j]->m_q - c.m_com);
     if (vx.length2() <= n.m_v.length2())
     {
      n.m_v += c.m_ndamping*(vx - n.m_v);
     }
    }
   }
  }
 }
}

//
void				btSoftBody::Joint::Prepare(btScalar dt, int)
{
 m_bodies[0].activate();
 m_bodies[1].activate();
}

//
void				btSoftBody::LJoint::Prepare(btScalar dt, int iterations)
{
 static const btScalar	maxdrift = 4;
 Joint::Prepare(dt, iterations);
 m_rpos[0] = m_bodies[0].xform()*m_refs[0];
 m_rpos[1] = m_bodies[1].xform()*m_refs[1];
 m_drift = Clamp(m_rpos[0] - m_rpos[1], maxdrift)*m_erp / dt;
 m_rpos[0] -= m_bodies[0].xform().getOrigin();
 m_rpos[1] -= m_bodies[1].xform().getOrigin();
 m_massmatrix = ImpulseMatrix(m_bodies[0].invMass(), m_bodies[0].invWorldInertia(), m_rpos[0],
  m_bodies[1].invMass(), m_bodies[1].invWorldInertia(), m_rpos[1]);
 if (m_split>0)
 {
  m_sdrift = m_massmatrix*(m_drift*m_split);
  m_drift *= 1 - m_split;
 }
 m_drift /= (btScalar)iterations;
}

//
void				btSoftBody::LJoint::Solve(btScalar dt, btScalar sor)
{
 const btVector3		va = m_bodies[0].velocity(m_rpos[0]);
 const btVector3		vb = m_bodies[1].velocity(m_rpos[1]);
 const btVector3		vr = va - vb;
 btSoftBody::Impulse	impulse;
 impulse.m_asVelocity = 1;
 impulse.m_velocity = m_massmatrix*(m_drift + vr*m_cfm)*sor;
 m_bodies[0].applyImpulse(-impulse, m_rpos[0]);
 m_bodies[1].applyImpulse(impulse, m_rpos[1]);
}

//
void				btSoftBody::LJoint::Terminate(btScalar dt)
{
 if (m_split>0)
 {
  m_bodies[0].applyDImpulse(-m_sdrift, m_rpos[0]);
  m_bodies[1].applyDImpulse(m_sdrift, m_rpos[1]);
 }
}

//
void				btSoftBody::AJoint::Prepare(btScalar dt, int iterations)
{
 static const btScalar	maxdrift = SIMD_PI / 16;
 m_icontrol->Prepare(this);
 Joint::Prepare(dt, iterations);
 m_axis[0] = m_bodies[0].xform().getBasis()*m_refs[0];
 m_axis[1] = m_bodies[1].xform().getBasis()*m_refs[1];
 m_drift = NormalizeAny(btCross(m_axis[1], m_axis[0]));
 m_drift *= btMin(maxdrift, btAcos(Clamp<btScalar>(btDot(m_axis[0], m_axis[1]), -1, +1)));
 m_drift *= m_erp / dt;
 m_massmatrix = AngularImpulseMatrix(m_bodies[0].invWorldInertia(), m_bodies[1].invWorldInertia());
 if (m_split>0)
 {
  m_sdrift = m_massmatrix*(m_drift*m_split);
  m_drift *= 1 - m_split;
 }
 m_drift /= (btScalar)iterations;
}

//
void				btSoftBody::AJoint::Solve(btScalar dt, btScalar sor)
{
 const btVector3		va = m_bodies[0].angularVelocity();
 const btVector3		vb = m_bodies[1].angularVelocity();
 const btVector3		vr = va - vb;
 const btScalar		sp = btDot(vr, m_axis[0]);
 const btVector3		vc = vr - m_axis[0] * m_icontrol->Speed(this, sp);
 btSoftBody::Impulse	impulse;
 impulse.m_asVelocity = 1;
 impulse.m_velocity = m_massmatrix*(m_drift + vc*m_cfm)*sor;
 m_bodies[0].applyAImpulse(-impulse);
 m_bodies[1].applyAImpulse(impulse);
}

//
void				btSoftBody::AJoint::Terminate(btScalar dt)
{
 if (m_split>0)
 {
  m_bodies[0].applyDAImpulse(-m_sdrift);
  m_bodies[1].applyDAImpulse(m_sdrift);
 }
}

//
void				btSoftBody::CJoint::Prepare(btScalar dt, int iterations)
{
 Joint::Prepare(dt, iterations);
 const bool	dodrift = (m_life == 0);
 m_delete = (++m_life)>m_maxlife;
 if (dodrift)
 {
  m_drift = m_drift*m_erp / dt;
  if (m_split>0)
  {
   m_sdrift = m_massmatrix*(m_drift*m_split);
   m_drift *= 1 - m_split;
  }
  m_drift /= (btScalar)iterations;
 }
 else
 {
  m_drift = m_sdrift = btVector3(0, 0, 0);
 }
}

//
void				btSoftBody::CJoint::Solve(btScalar dt, btScalar sor)
{
 const btVector3		va = m_bodies[0].velocity(m_rpos[0]);
 const btVector3		vb = m_bodies[1].velocity(m_rpos[1]);
 const btVector3		vrel = va - vb;
 const btScalar		rvac = btDot(vrel, m_normal);
 btSoftBody::Impulse	impulse;
 impulse.m_asVelocity = 1;
 impulse.m_velocity = m_drift;
 if (rvac<0)
 {
  const btVector3	iv = m_normal*rvac;
  const btVector3	fv = vrel - iv;
  impulse.m_velocity += iv + fv*m_friction;
 }
 impulse.m_velocity = m_massmatrix*impulse.m_velocity*sor;

 if (m_bodies[0].m_soft == m_bodies[1].m_soft)
 {
  if ((impulse.m_velocity.getX() == impulse.m_velocity.getX()) && (impulse.m_velocity.getY() == impulse.m_velocity.getY()) &&
   (impulse.m_velocity.getZ() == impulse.m_velocity.getZ()))
  {
   if (impulse.m_asVelocity)
   {
    if (impulse.m_velocity.length() <m_bodies[0].m_soft->m_maxSelfCollisionImpulse)
    {

    }
    else
    {
     m_bodies[0].applyImpulse(-impulse*m_bodies[0].m_soft->m_selfCollisionImpulseFactor, m_rpos[0]);
     m_bodies[1].applyImpulse(impulse*m_bodies[0].m_soft->m_selfCollisionImpulseFactor, m_rpos[1]);
    }
   }
  }
 }
 else
 {
  m_bodies[0].applyImpulse(-impulse, m_rpos[0]);
  m_bodies[1].applyImpulse(impulse, m_rpos[1]);
 }
}

//
void				btSoftBody::CJoint::Terminate(btScalar dt)
{
 if (m_split>0)
 {
  m_bodies[0].applyDImpulse(-m_sdrift, m_rpos[0]);
  m_bodies[1].applyDImpulse(m_sdrift, m_rpos[1]);
 }
}

//
void				btSoftBody::applyForces()
{

 BT_PROFILE("SoftBody applyForces");
 //	const btScalar					dt =			m_sst.sdt;
 const btScalar					kLF = m_cfg.kLF;
 const btScalar					kDG = m_cfg.kDG;
 const btScalar					kPR = m_cfg.kPR;
 const btScalar					kVC = m_cfg.kVC;
 const bool						as_lift = kLF>0;
 const bool						as_drag = kDG>0;
 const bool						as_pressure = kPR != 0;
 const bool						as_volume = kVC>0;
 const bool						as_aero = as_lift ||
  as_drag;
 //const bool						as_vaero =		as_aero	&&
 //												(m_cfg.aeromodel < btSoftBody::eAeroModel::F_TwoSided);
 //const bool						as_faero =		as_aero	&&
 //												(m_cfg.aeromodel >= btSoftBody::eAeroModel::F_TwoSided);
 const bool						use_medium = as_aero;
 const bool						use_volume = as_pressure ||
  as_volume;
 btScalar						volume = 0;
 btScalar						ivolumetp = 0;
 btScalar						dvolumetv = 0;
 btSoftBody::sMedium	medium;
 if (use_volume)
 {
  volume = getVolume();
  ivolumetp = 1 / btFabs(volume)*kPR;
  dvolumetv = (m_pose.m_volume - volume)*kVC;
 }
 /* Per vertex forces			*/
 int i, ni;

 for (i = 0, ni = m_nodes.size(); i<ni; ++i)
 {
  btSoftBody::Node&	n = m_nodes[i];
  if (n.m_im>0)
  {
   if (use_medium)
   {
    /* Aerodynamics			*/
    addAeroForceToNode(m_windVelocity, i);
   }
   /* Pressure				*/
   if (as_pressure)
   {
    n.m_f += n.m_n*(n.m_area*ivolumetp);
   }
   /* Volume				*/
   if (as_volume)
   {
    n.m_f += n.m_n*(n.m_area*dvolumetv);
   }
  }
 }

 /* Per face forces				*/
 for (i = 0, ni = m_faces.size(); i<ni; ++i)
 {
  //	btSoftBody::Face&	f=m_faces[i];

  /* Aerodynamics			*/
  addAeroForceToFace(m_windVelocity, i);
 }
}

//
void				btSoftBody::PSolve_Anchors(btSoftBody* psb, btScalar kst, btScalar ti)
{
 BT_PROFILE("PSolve_Anchors");
 const btScalar	kAHR = psb->m_cfg.kAHR*kst;
 const btScalar	dt = psb->m_sst.sdt;
 for (int i = 0, ni = psb->m_anchors.size(); i<ni; ++i)
 {
  const Anchor&		a = psb->m_anchors[i];
  const btTransform&	t = a.m_body->getWorldTransform();
  Node&				n = *a.m_node;
  const btVector3		wa = t*a.m_local;
  const btVector3		va = a.m_body->getVelocityInLocalPoint(a.m_c1)*dt;
  const btVector3		vb = n.m_x - n.m_q;
  const btVector3		vr = (va - vb) + (wa - n.m_x)*kAHR;
  const btVector3		impulse = a.m_c0*vr*a.m_influence;
  n.m_x += impulse*a.m_c2;
  a.m_body->applyImpulse(-impulse, a.m_c1);
 }
}


//
void btSoftBody::PSolve_RContacts(btSoftBody* psb, btScalar kst, btScalar ti)
{
 BT_PROFILE("PSolve_RContacts");
 const btScalar	dt = psb->m_sst.sdt;
 const btScalar	mrg = psb->getCollisionShape()->getMargin();
 btMultiBodyJacobianData jacobianData;
 for (int i = 0, ni = psb->m_rcontacts.size(); i<ni; ++i)
 {
  const RContact&		c = psb->m_rcontacts[i];
  const sCti&			cti = c.m_cti;
  if (cti.m_colObj->hasContactResponse())
  {
   btVector3 va(0, 0, 0);
   btRigidBody* rigidCol = 0;
   btMultiBodyLinkCollider* multibodyLinkCol = 0;
   btScalar* deltaV = new btScalar();

   if (cti.m_colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY)
   {
    rigidCol = (btRigidBody*)btRigidBody::upcast(cti.m_colObj);
    va = rigidCol ? rigidCol->getVelocityInLocalPoint(c.m_c1)*dt : btVector3(0, 0, 0);
   }
   else if (cti.m_colObj->getInternalType() == btCollisionObject::CO_FEATHERSTONE_LINK)
   {
    multibodyLinkCol = (btMultiBodyLinkCollider*)btMultiBodyLinkCollider::upcast(cti.m_colObj);
    if (multibodyLinkCol)
    {
     const int ndof = multibodyLinkCol->m_multiBody->getNumDofs() + 6;
     jacobianData.m_jacobians.resize(ndof);
     jacobianData.m_deltaVelocitiesUnitImpulse.resize(ndof);
     btScalar* jac = &jacobianData.m_jacobians[0];

     multibodyLinkCol->m_multiBody->fillContactJacobianMultiDof(multibodyLinkCol->m_link, c.m_node->m_x, cti.m_normal, jac, jacobianData.scratch_r, jacobianData.scratch_v, jacobianData.scratch_m);
     deltaV = &jacobianData.m_deltaVelocitiesUnitImpulse[0];
     multibodyLinkCol->m_multiBody->calcAccelerationDeltasMultiDof(&jacobianData.m_jacobians[0], deltaV, jacobianData.scratch_r, jacobianData.scratch_v);

     btScalar vel = 0.0;
     for (int j = 0; j < ndof; ++j) {
      vel += multibodyLinkCol->m_multiBody->getVelocityVector()[j] * jac[j];
     }
     va = cti.m_normal*vel*dt;
    }
   }

   const btVector3		vb = c.m_node->m_x - c.m_node->m_q;
   const btVector3		vr = vb - va;
   const btScalar		dn = btDot(vr, cti.m_normal);
   if (dn <= SIMD_EPSILON)
   {
    const btScalar		dp = btMin((btDot(c.m_node->m_x, cti.m_normal) + cti.m_offset), mrg);
    const btVector3		fv = vr - (cti.m_normal * dn);
    // c0 is the impulse matrix, c3 is 1 - the friction coefficient or 0, c4 is the contact hardness coefficient
    const btVector3		impulse = c.m_c0 * ((vr - (fv * c.m_c3) + (cti.m_normal * (dp * c.m_c4))) * kst);
    c.m_node->m_x -= impulse * c.m_c2;

    if (cti.m_colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY)
    {
     if (rigidCol)
      rigidCol->applyImpulse(impulse, c.m_c1);
    }
    else if (cti.m_colObj->getInternalType() == btCollisionObject::CO_FEATHERSTONE_LINK)
    {
     if (multibodyLinkCol)
     {
      double multiplier = 0.5;
      multibodyLinkCol->m_multiBody->applyDeltaVeeMultiDof(deltaV, -impulse.length()*(btScalar)multiplier);
     }
    }
   }
  }
 }
}

//
void				btSoftBody::PSolve_SContacts(btSoftBody* psb, btScalar, btScalar ti)
{
 BT_PROFILE("PSolve_SContacts");

 for (int i = 0, ni = psb->m_scontacts.size(); i<ni; ++i)
 {
  const SContact&		c = psb->m_scontacts[i];
  const btVector3&	nr = c.m_normal;
  Node&				n = *c.m_node;
  Face&				f = *c.m_face;
  const btVector3		p = BaryEval(f.m_n[0]->m_x,
   f.m_n[1]->m_x,
   f.m_n[2]->m_x,
   c.m_weights);
  const btVector3		q = BaryEval(f.m_n[0]->m_q,
   f.m_n[1]->m_q,
   f.m_n[2]->m_q,
   c.m_weights);
  const btVector3		vr = (n.m_x - n.m_q) - (p - q);
  btVector3			corr(0, 0, 0);
  btScalar dot = btDot(vr, nr);
  if (dot<0)
  {
   const btScalar	j = c.m_margin - (btDot(nr, n.m_x) - btDot(nr, p));
   corr += c.m_normal*j;
  }
  corr -= ProjectOnPlane(vr, nr)*c.m_friction;
  n.m_x += corr*c.m_cfm[0];
  f.m_n[0]->m_x -= corr*(c.m_cfm[1] * c.m_weights.x());
  f.m_n[1]->m_x -= corr*(c.m_cfm[1] * c.m_weights.y());
  f.m_n[2]->m_x -= corr*(c.m_cfm[1] * c.m_weights.z());
 }
}

//
void				btSoftBody::PSolve_Links(btSoftBody* psb, btScalar kst, btScalar ti)
{
 BT_PROFILE("PSolve_Links");
 for (int i = 0, ni = psb->m_links.size(); i<ni; ++i)
 {
  Link&	l = psb->m_links[i];
  if (l.m_c0>0)
  {
   Node&			a = *l.m_n[0];
   Node&			b = *l.m_n[1];
   const btVector3	del = b.m_x - a.m_x;
   const btScalar	len = del.length2();
   if (l.m_c1 + len > SIMD_EPSILON)
   {
    const btScalar	k = ((l.m_c1 - len) / (l.m_c0*(l.m_c1 + len)))*kst;
    a.m_x -= del*(k*a.m_im);
    b.m_x += del*(k*b.m_im);
   }
  }
 }
}

//
void				btSoftBody::VSolve_Links(btSoftBody* psb, btScalar kst)
{
 BT_PROFILE("VSolve_Links");
 for (int i = 0, ni = psb->m_links.size(); i<ni; ++i)
 {
  Link&			l = psb->m_links[i];
  Node**			n = l.m_n;
  const btScalar	j = -btDot(l.m_c3, n[0]->m_v - n[1]->m_v)*l.m_c2*kst;
  n[0]->m_v += l.m_c3*(j*n[0]->m_im);
  n[1]->m_v -= l.m_c3*(j*n[1]->m_im);
 }
}

//
btSoftBody::psolver_t	btSoftBody::getSolver(ePSolver::_ solver)
{
 switch (solver)
 {
 case	ePSolver::Anchors:
  return(&btSoftBody::PSolve_Anchors);
 case	ePSolver::Linear:
  return(&btSoftBody::PSolve_Links);
 case	ePSolver::RContacts:
  return(&btSoftBody::PSolve_RContacts);
 case	ePSolver::SContacts:
  return(&btSoftBody::PSolve_SContacts);
 default:
 {
 }
 }
 return(0);
}

//
btSoftBody::vsolver_t	btSoftBody::getSolver(eVSolver::_ solver)
{
 switch (solver)
 {
 case	eVSolver::Linear:		return(&btSoftBody::VSolve_Links);
 default:
 {
 }
 }
 return(0);
}

//
void			btSoftBody::defaultCollisionHandler(const btCollisionObjectWrapper* pcoWrap)
{

 switch (m_cfg.collisions&fCollision::RVSmask)
 {
 case	fCollision::SDF_RS:
 {
  btSoftColliders::CollideSDF_RS	docollide;
  btRigidBody*		prb1 = (btRigidBody*)btRigidBody::upcast(pcoWrap->getCollisionObject());
  btTransform	wtr = pcoWrap->getWorldTransform();

  const btTransform	ctr = pcoWrap->getWorldTransform();
  const btScalar		timemargin = (wtr.getOrigin() - ctr.getOrigin()).length();
  const btScalar		basemargin = getCollisionShape()->getMargin();
  btVector3			mins;
  btVector3			maxs;
  ATTRIBUTE_ALIGNED16(btDbvtVolume)		volume;
  pcoWrap->getCollisionShape()->getAabb(pcoWrap->getWorldTransform(),
   mins,
   maxs);
  volume = btDbvtVolume::FromMM(mins, maxs);
  volume.Expand(btVector3(basemargin, basemargin, basemargin));
  docollide.psb = this;
  docollide.m_colObj1Wrap = pcoWrap;
  docollide.m_rigidBody = prb1;

  docollide.dynmargin = basemargin + timemargin;
  docollide.stamargin = basemargin;
  m_ndbvt.collideTV(m_ndbvt.m_root, volume, docollide);
 }
 break;
 case	fCollision::CL_RS:
 {
  btSoftColliders::CollideCL_RS	collider;
  collider.ProcessColObj(this, pcoWrap);
 }
 break;
 }
}

//
void			btSoftBody::defaultCollisionHandler(btSoftBody* psb)
{
 const int cf = m_cfg.collisions&psb->m_cfg.collisions;
 switch (cf&fCollision::SVSmask)
 {
 case	fCollision::CL_SS:
 {

  //support self-collision if CL_SELF flag set
  if (this != psb || psb->m_cfg.collisions&fCollision::CL_SELF)
  {
   btSoftColliders::CollideCL_SS	docollide;
   docollide.ProcessSoftSoft(this, psb);
  }

 }
 break;
 case	fCollision::VF_SS:
 {
  //only self-collision for Cluster, not Vertex-Face yet
  if (this != psb)
  {
   btSoftColliders::CollideVF_SS	docollide;
   /* common					*/
   docollide.mrg = getCollisionShape()->getMargin() +
    psb->getCollisionShape()->getMargin();
   /* psb0 nodes vs psb1 faces	*/
   docollide.psb[0] = this;
   docollide.psb[1] = psb;
   docollide.psb[0]->m_ndbvt.collideTT(docollide.psb[0]->m_ndbvt.m_root,
    docollide.psb[1]->m_fdbvt.m_root,
    docollide);
   /* psb1 nodes vs psb0 faces	*/
   docollide.psb[0] = psb;
   docollide.psb[1] = this;
   docollide.psb[0]->m_ndbvt.collideTT(docollide.psb[0]->m_ndbvt.m_root,
    docollide.psb[1]->m_fdbvt.m_root,
    docollide);
  }
 }
 break;
 default:
 {

 }
 }
}



void btSoftBody::setWindVelocity(const btVector3 &velocity)
{
 m_windVelocity = velocity;
}


const btVector3& btSoftBody::getWindVelocity()
{
 return m_windVelocity;
}



int	btSoftBody::calculateSerializeBufferSize()	const
{
 int sz = sizeof(btSoftBodyData);
 return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btSoftBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
 btSoftBodyData* sbd = (btSoftBodyData*)dataBuffer;

 btCollisionObject::serialize(&sbd->m_collisionObjectData, serializer);

 btHashMap<btHashPtr, int>	m_nodeIndexMap;

 sbd->m_numMaterials = m_materials.size();
 sbd->m_materials = sbd->m_numMaterials ? (SoftBodyMaterialData**)serializer->getUniquePointer((void*)&m_materials) : 0;

 if (sbd->m_materials)
 {
  int sz = sizeof(SoftBodyMaterialData*);
  int numElem = sbd->m_numMaterials;
  btChunk* chunk = serializer->allocate(sz, numElem);
  //SoftBodyMaterialData** memPtr = chunk->m_oldPtr;
  SoftBodyMaterialData** memPtr = (SoftBodyMaterialData**)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   btSoftBody::Material* mat = m_materials[i];
   *memPtr = mat ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)mat) : 0;
   if (!serializer->findPointer(mat))
   {
    //serialize it here
    btChunk* chunk = serializer->allocate(sizeof(SoftBodyMaterialData), 1);
    SoftBodyMaterialData* memPtr = (SoftBodyMaterialData*)chunk->m_oldPtr;
    memPtr->m_flags = mat->m_flags;
    memPtr->m_angularStiffness = mat->m_kAST;
    memPtr->m_linearStiffness = mat->m_kLST;
    memPtr->m_volumeStiffness = mat->m_kVST;
    serializer->finalizeChunk(chunk, "SoftBodyMaterialData", BT_SBMATERIAL_CODE, mat);
   }
  }
  serializer->finalizeChunk(chunk, "SoftBodyMaterialData", BT_ARRAY_CODE, (void*)&m_materials);
 }




 sbd->m_numNodes = m_nodes.size();
 sbd->m_nodes = sbd->m_numNodes ? (SoftBodyNodeData*)serializer->getUniquePointer((void*)&m_nodes) : 0;
 if (sbd->m_nodes)
 {
  int sz = sizeof(SoftBodyNodeData);
  int numElem = sbd->m_numNodes;
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftBodyNodeData* memPtr = (SoftBodyNodeData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   m_nodes[i].m_f.serializeFloat(memPtr->m_accumulatedForce);
   memPtr->m_area = m_nodes[i].m_area;
   memPtr->m_attach = m_nodes[i].m_battach;
   memPtr->m_inverseMass = m_nodes[i].m_im;
   memPtr->m_material = m_nodes[i].m_material ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)m_nodes[i].m_material) : 0;
   m_nodes[i].m_n.serializeFloat(memPtr->m_normal);
   m_nodes[i].m_x.serializeFloat(memPtr->m_position);
   m_nodes[i].m_q.serializeFloat(memPtr->m_previousPosition);
   m_nodes[i].m_v.serializeFloat(memPtr->m_velocity);
   m_nodeIndexMap.insert(&m_nodes[i], i);
  }
  serializer->finalizeChunk(chunk, "SoftBodyNodeData", BT_SBNODE_CODE, (void*)&m_nodes);
 }

 sbd->m_numLinks = m_links.size();
 sbd->m_links = sbd->m_numLinks ? (SoftBodyLinkData*)serializer->getUniquePointer((void*)&m_links[0]) : 0;
 if (sbd->m_links)
 {
  int sz = sizeof(SoftBodyLinkData);
  int numElem = sbd->m_numLinks;
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftBodyLinkData* memPtr = (SoftBodyLinkData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_bbending = m_links[i].m_bbending;
   memPtr->m_material = m_links[i].m_material ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)m_links[i].m_material) : 0;
   memPtr->m_nodeIndices[0] = m_links[i].m_n[0] ? m_links[i].m_n[0] - &m_nodes[0] : -1;
   memPtr->m_nodeIndices[1] = m_links[i].m_n[1] ? m_links[i].m_n[1] - &m_nodes[0] : -1;
   btAssert(memPtr->m_nodeIndices[0]<m_nodes.size());
   btAssert(memPtr->m_nodeIndices[1]<m_nodes.size());
   memPtr->m_restLength = m_links[i].m_rl;
  }
  serializer->finalizeChunk(chunk, "SoftBodyLinkData", BT_ARRAY_CODE, (void*)&m_links[0]);

 }


 sbd->m_numFaces = m_faces.size();
 sbd->m_faces = sbd->m_numFaces ? (SoftBodyFaceData*)serializer->getUniquePointer((void*)&m_faces[0]) : 0;
 if (sbd->m_faces)
 {
  int sz = sizeof(SoftBodyFaceData);
  int numElem = sbd->m_numFaces;
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftBodyFaceData* memPtr = (SoftBodyFaceData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_material = m_faces[i].m_material ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)m_faces[i].m_material) : 0;
   m_faces[i].m_normal.serializeFloat(memPtr->m_normal);
   for (int j = 0; j<3; j++)
   {
    memPtr->m_nodeIndices[j] = m_faces[i].m_n[j] ? m_faces[i].m_n[j] - &m_nodes[0] : -1;
   }
   memPtr->m_restArea = m_faces[i].m_ra;
  }
  serializer->finalizeChunk(chunk, "SoftBodyFaceData", BT_ARRAY_CODE, (void*)&m_faces[0]);
 }


 sbd->m_numTetrahedra = m_tetras.size();
 sbd->m_tetrahedra = sbd->m_numTetrahedra ? (SoftBodyTetraData*)serializer->getUniquePointer((void*)&m_tetras[0]) : 0;
 if (sbd->m_tetrahedra)
 {
  int sz = sizeof(SoftBodyTetraData);
  int numElem = sbd->m_numTetrahedra;
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftBodyTetraData* memPtr = (SoftBodyTetraData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   for (int j = 0; j<4; j++)
   {
    m_tetras[i].m_c0[j].serializeFloat(memPtr->m_c0[j]);
    memPtr->m_nodeIndices[j] = m_tetras[j].m_n[j] ? m_tetras[j].m_n[j] - &m_nodes[0] : -1;
   }
   memPtr->m_c1 = m_tetras[i].m_c1;
   memPtr->m_c2 = m_tetras[i].m_c2;
   memPtr->m_material = m_tetras[i].m_material ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)m_tetras[i].m_material) : 0;
   memPtr->m_restVolume = m_tetras[i].m_rv;
  }
  serializer->finalizeChunk(chunk, "SoftBodyTetraData", BT_ARRAY_CODE, (void*)&m_tetras[0]);
 }

 sbd->m_numAnchors = m_anchors.size();
 sbd->m_anchors = sbd->m_numAnchors ? (SoftRigidAnchorData*)serializer->getUniquePointer((void*)&m_anchors[0]) : 0;
 if (sbd->m_anchors)
 {
  int sz = sizeof(SoftRigidAnchorData);
  int numElem = sbd->m_numAnchors;
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftRigidAnchorData* memPtr = (SoftRigidAnchorData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   m_anchors[i].m_c0.serializeFloat(memPtr->m_c0);
   m_anchors[i].m_c1.serializeFloat(memPtr->m_c1);
   memPtr->m_c2 = m_anchors[i].m_c2;
   m_anchors[i].m_local.serializeFloat(memPtr->m_localFrame);
   memPtr->m_nodeIndex = m_anchors[i].m_node ? m_anchors[i].m_node - &m_nodes[0] : -1;

   memPtr->m_rigidBody = m_anchors[i].m_body ? (btRigidBodyData*)serializer->getUniquePointer((void*)m_anchors[i].m_body) : 0;
   btAssert(memPtr->m_nodeIndex < m_nodes.size());
  }
  serializer->finalizeChunk(chunk, "SoftRigidAnchorData", BT_ARRAY_CODE, (void*)&m_anchors[0]);
 }


 sbd->m_config.m_dynamicFriction = m_cfg.kDF;
 sbd->m_config.m_baumgarte = m_cfg.kVCF;
 sbd->m_config.m_pressure = m_cfg.kPR;
 sbd->m_config.m_aeroModel = this->m_cfg.aeromodel;
 sbd->m_config.m_lift = m_cfg.kLF;
 sbd->m_config.m_drag = m_cfg.kDG;
 sbd->m_config.m_positionIterations = m_cfg.piterations;
 sbd->m_config.m_driftIterations = m_cfg.diterations;
 sbd->m_config.m_clusterIterations = m_cfg.citerations;
 sbd->m_config.m_velocityIterations = m_cfg.viterations;
 sbd->m_config.m_maxVolume = m_cfg.maxvolume;
 sbd->m_config.m_damping = m_cfg.kDP;
 sbd->m_config.m_poseMatch = m_cfg.kMT;
 sbd->m_config.m_collisionFlags = m_cfg.collisions;
 sbd->m_config.m_volume = m_cfg.kVC;
 sbd->m_config.m_rigidContactHardness = m_cfg.kCHR;
 sbd->m_config.m_kineticContactHardness = m_cfg.kKHR;
 sbd->m_config.m_softContactHardness = m_cfg.kSHR;
 sbd->m_config.m_anchorHardness = m_cfg.kAHR;
 sbd->m_config.m_timeScale = m_cfg.timescale;
 sbd->m_config.m_maxVolume = m_cfg.maxvolume;
 sbd->m_config.m_softRigidClusterHardness = m_cfg.kSRHR_CL;
 sbd->m_config.m_softKineticClusterHardness = m_cfg.kSKHR_CL;
 sbd->m_config.m_softSoftClusterHardness = m_cfg.kSSHR_CL;
 sbd->m_config.m_softRigidClusterImpulseSplit = m_cfg.kSR_SPLT_CL;
 sbd->m_config.m_softKineticClusterImpulseSplit = m_cfg.kSK_SPLT_CL;
 sbd->m_config.m_softSoftClusterImpulseSplit = m_cfg.kSS_SPLT_CL;

 //pose for shape matching
 {
  sbd->m_pose = (SoftBodyPoseData*)serializer->getUniquePointer((void*)&m_pose);

  int sz = sizeof(SoftBodyPoseData);
  btChunk* chunk = serializer->allocate(sz, 1);
  SoftBodyPoseData* memPtr = (SoftBodyPoseData*)chunk->m_oldPtr;

  m_pose.m_aqq.serializeFloat(memPtr->m_aqq);
  memPtr->m_bframe = m_pose.m_bframe;
  memPtr->m_bvolume = m_pose.m_bvolume;
  m_pose.m_com.serializeFloat(memPtr->m_com);

  memPtr->m_numPositions = m_pose.m_pos.size();
  memPtr->m_positions = memPtr->m_numPositions ? (btVector3FloatData*)serializer->getUniquePointer((void*)&m_pose.m_pos[0]) : 0;
  if (memPtr->m_numPositions)
  {
   int numElem = memPtr->m_numPositions;
   int sz = sizeof(btVector3Data);
   btChunk* chunk = serializer->allocate(sz, numElem);
   btVector3FloatData* memPtr = (btVector3FloatData*)chunk->m_oldPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    m_pose.m_pos[i].serializeFloat(*memPtr);
   }
   serializer->finalizeChunk(chunk, "btVector3FloatData", BT_ARRAY_CODE, (void*)&m_pose.m_pos[0]);
  }
  memPtr->m_restVolume = m_pose.m_volume;
  m_pose.m_rot.serializeFloat(memPtr->m_rot);
  m_pose.m_scl.serializeFloat(memPtr->m_scale);

  memPtr->m_numWeigts = m_pose.m_wgh.size();
  memPtr->m_weights = memPtr->m_numWeigts ? (float*)serializer->getUniquePointer((void*)&m_pose.m_wgh[0]) : 0;
  if (memPtr->m_numWeigts)
  {

   int numElem = memPtr->m_numWeigts;
   int sz = sizeof(float);
   btChunk* chunk = serializer->allocate(sz, numElem);
   float* memPtr = (float*)chunk->m_oldPtr;
   for (int i = 0; i<numElem; i++, memPtr++)
   {
    *memPtr = m_pose.m_wgh[i];
   }
   serializer->finalizeChunk(chunk, "float", BT_ARRAY_CODE, (void*)&m_pose.m_wgh[0]);
  }

  serializer->finalizeChunk(chunk, "SoftBodyPoseData", BT_ARRAY_CODE, (void*)&m_pose);
 }

 //clusters for convex-cluster collision detection

 sbd->m_numClusters = m_clusters.size();
 sbd->m_clusters = sbd->m_numClusters ? (SoftBodyClusterData*)serializer->getUniquePointer((void*)m_clusters[0]) : 0;
 if (sbd->m_numClusters)
 {
  int numElem = sbd->m_numClusters;
  int sz = sizeof(SoftBodyClusterData);
  btChunk* chunk = serializer->allocate(sz, numElem);
  SoftBodyClusterData* memPtr = (SoftBodyClusterData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_adamping = m_clusters[i]->m_adamping;
   m_clusters[i]->m_av.serializeFloat(memPtr->m_av);
   memPtr->m_clusterIndex = m_clusters[i]->m_clusterIndex;
   memPtr->m_collide = m_clusters[i]->m_collide;
   m_clusters[i]->m_com.serializeFloat(memPtr->m_com);
   memPtr->m_containsAnchor = m_clusters[i]->m_containsAnchor;
   m_clusters[i]->m_dimpulses[0].serializeFloat(memPtr->m_dimpulses[0]);
   m_clusters[i]->m_dimpulses[1].serializeFloat(memPtr->m_dimpulses[1]);
   m_clusters[i]->m_framexform.serializeFloat(memPtr->m_framexform);
   memPtr->m_idmass = m_clusters[i]->m_idmass;
   memPtr->m_imass = m_clusters[i]->m_imass;
   m_clusters[i]->m_invwi.serializeFloat(memPtr->m_invwi);
   memPtr->m_ldamping = m_clusters[i]->m_ldamping;
   m_clusters[i]->m_locii.serializeFloat(memPtr->m_locii);
   m_clusters[i]->m_lv.serializeFloat(memPtr->m_lv);
   memPtr->m_matching = m_clusters[i]->m_matching;
   memPtr->m_maxSelfCollisionImpulse = m_clusters[i]->m_maxSelfCollisionImpulse;
   memPtr->m_ndamping = m_clusters[i]->m_ndamping;
   memPtr->m_ldamping = m_clusters[i]->m_ldamping;
   memPtr->m_adamping = m_clusters[i]->m_adamping;
   memPtr->m_selfCollisionImpulseFactor = m_clusters[i]->m_selfCollisionImpulseFactor;

   memPtr->m_numFrameRefs = m_clusters[i]->m_framerefs.size();
   memPtr->m_numMasses = m_clusters[i]->m_masses.size();
   memPtr->m_numNodes = m_clusters[i]->m_nodes.size();

   memPtr->m_nvimpulses = m_clusters[i]->m_nvimpulses;
   m_clusters[i]->m_vimpulses[0].serializeFloat(memPtr->m_vimpulses[0]);
   m_clusters[i]->m_vimpulses[1].serializeFloat(memPtr->m_vimpulses[1]);
   memPtr->m_ndimpulses = m_clusters[i]->m_ndimpulses;



   memPtr->m_framerefs = memPtr->m_numFrameRefs ? (btVector3FloatData*)serializer->getUniquePointer((void*)&m_clusters[i]->m_framerefs[0]) : 0;
   if (memPtr->m_framerefs)
   {
    int numElem = memPtr->m_numFrameRefs;
    int sz = sizeof(btVector3FloatData);
    btChunk* chunk = serializer->allocate(sz, numElem);
    btVector3FloatData* memPtr = (btVector3FloatData*)chunk->m_oldPtr;
    for (int j = 0; j<numElem; j++, memPtr++)
    {
     m_clusters[i]->m_framerefs[j].serializeFloat(*memPtr);
    }
    serializer->finalizeChunk(chunk, "btVector3FloatData", BT_ARRAY_CODE, (void*)&m_clusters[i]->m_framerefs[0]);
   }

   memPtr->m_masses = memPtr->m_numMasses ? (float*)serializer->getUniquePointer((void*)&m_clusters[i]->m_masses[0]) : 0;
   if (memPtr->m_masses)
   {
    int numElem = memPtr->m_numMasses;
    int sz = sizeof(float);
    btChunk* chunk = serializer->allocate(sz, numElem);
    float* memPtr = (float*)chunk->m_oldPtr;
    for (int j = 0; j<numElem; j++, memPtr++)
    {
     *memPtr = m_clusters[i]->m_masses[j];
    }
    serializer->finalizeChunk(chunk, "float", BT_ARRAY_CODE, (void*)&m_clusters[i]->m_masses[0]);
   }

   memPtr->m_nodeIndices = memPtr->m_numNodes ? (int*)serializer->getUniquePointer((void*)&m_clusters[i]->m_nodes) : 0;
   if (memPtr->m_nodeIndices)
   {
    int numElem = memPtr->m_numMasses;
    int sz = sizeof(int);
    btChunk* chunk = serializer->allocate(sz, numElem);
    int* memPtr = (int*)chunk->m_oldPtr;
    for (int j = 0; j<numElem; j++, memPtr++)
    {
     int* indexPtr = m_nodeIndexMap.find(m_clusters[i]->m_nodes[j]);
     btAssert(indexPtr);
     *memPtr = *indexPtr;
    }
    serializer->finalizeChunk(chunk, "int", BT_ARRAY_CODE, (void*)&m_clusters[i]->m_nodes);
   }
  }
  serializer->finalizeChunk(chunk, "SoftBodyClusterData", BT_ARRAY_CODE, (void*)m_clusters[0]);

 }



 sbd->m_numJoints = m_joints.size();
 sbd->m_joints = m_joints.size() ? (btSoftBodyJointData*)serializer->getUniquePointer((void*)&m_joints[0]) : 0;

 if (sbd->m_joints)
 {
  int sz = sizeof(btSoftBodyJointData);
  int numElem = m_joints.size();
  btChunk* chunk = serializer->allocate(sz, numElem);
  btSoftBodyJointData* memPtr = (btSoftBodyJointData*)chunk->m_oldPtr;

  for (int i = 0; i<numElem; i++, memPtr++)
  {
   memPtr->m_jointType = (int)m_joints[i]->Type();
   m_joints[i]->m_refs[0].serializeFloat(memPtr->m_refs[0]);
   m_joints[i]->m_refs[1].serializeFloat(memPtr->m_refs[1]);
   memPtr->m_cfm = m_joints[i]->m_cfm;
   memPtr->m_erp = float(m_joints[i]->m_erp);
   memPtr->m_split = float(m_joints[i]->m_split);
   memPtr->m_delete = m_joints[i]->m_delete;

   for (int j = 0; j<4; j++)
   {
    memPtr->m_relPosition[0].m_floats[j] = 0.f;
    memPtr->m_relPosition[1].m_floats[j] = 0.f;
   }
   memPtr->m_bodyA = 0;
   memPtr->m_bodyB = 0;
   if (m_joints[i]->m_bodies[0].m_soft)
   {
    memPtr->m_bodyAtype = BT_JOINT_SOFT_BODY_CLUSTER;
    memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_soft);
   }
   if (m_joints[i]->m_bodies[0].m_collisionObject)
   {
    memPtr->m_bodyAtype = BT_JOINT_COLLISION_OBJECT;
    memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_collisionObject);
   }
   if (m_joints[i]->m_bodies[0].m_rigid)
   {
    memPtr->m_bodyAtype = BT_JOINT_RIGID_BODY;
    memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_rigid);
   }

   if (m_joints[i]->m_bodies[1].m_soft)
   {
    memPtr->m_bodyBtype = BT_JOINT_SOFT_BODY_CLUSTER;
    memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_soft);
   }
   if (m_joints[i]->m_bodies[1].m_collisionObject)
   {
    memPtr->m_bodyBtype = BT_JOINT_COLLISION_OBJECT;
    memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_collisionObject);
   }
   if (m_joints[i]->m_bodies[1].m_rigid)
   {
    memPtr->m_bodyBtype = BT_JOINT_RIGID_BODY;
    memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_rigid);
   }
  }
  serializer->finalizeChunk(chunk, "btSoftBodyJointData", BT_ARRAY_CODE, (void*)&m_joints[0]);
 }


 return btSoftBodyDataName;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionShapes/btConcaveShape.h"
#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btTetrahedronShape.h"
#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"


#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletSoftBody/btSoftBody.h"

#define BT_SOFTBODY_TRIANGLE_EXTRUSION btScalar(0.06)//make this configurable

btSoftBodyConcaveCollisionAlgorithm::btSoftBodyConcaveCollisionAlgorithm(const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped)
 : btCollisionAlgorithm(ci),
 m_isSwapped(isSwapped),
 m_btSoftBodyTriangleCallback(ci.m_dispatcher1, body0Wrap, body1Wrap, isSwapped)
{
}



btSoftBodyConcaveCollisionAlgorithm::~btSoftBodyConcaveCollisionAlgorithm()
{
}



btSoftBodyTriangleCallback::btSoftBodyTriangleCallback(btDispatcher*  dispatcher, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped) :
 m_dispatcher(dispatcher),
 m_dispatchInfoPtr(0)
{
 m_softBody = (isSwapped ? (btSoftBody*)body1Wrap->getCollisionObject() : (btSoftBody*)body0Wrap->getCollisionObject());
 m_triBody = isSwapped ? body0Wrap->getCollisionObject() : body1Wrap->getCollisionObject();

 //
 // create the manifold from the dispatcher 'manifold pool'
 //
 //	  m_manifoldPtr = m_dispatcher->getNewManifold(m_convexBody,m_triBody);

 clearCache();
}

btSoftBodyTriangleCallback::~btSoftBodyTriangleCallback()
{
 clearCache();
 //	m_dispatcher->releaseManifold( m_manifoldPtr );

}


void	btSoftBodyTriangleCallback::clearCache()
{
 for (int i = 0; i<m_shapeCache.size(); i++)
 {
  btTriIndex* tmp = m_shapeCache.getAtIndex(i);
  btAssert(tmp);
  btAssert(tmp->m_childShape);
  m_softBody->getWorldInfo()->m_sparsesdf.RemoveReferences(tmp->m_childShape);//necessary?
  delete tmp->m_childShape;
 }
 m_shapeCache.clear();
}


void btSoftBodyTriangleCallback::processTriangle(btVector3* triangle, int partId, int triangleIndex)
{
 //just for debugging purposes
 //printf("triangle %d",m_triangleCount++);

 btCollisionAlgorithmConstructionInfo ci;
 ci.m_dispatcher1 = m_dispatcher;

 ///debug drawing of the overlapping triangles
 if (m_dispatchInfoPtr && m_dispatchInfoPtr->m_debugDraw && (m_dispatchInfoPtr->m_debugDraw->getDebugMode() &btIDebugDraw::DBG_DrawWireframe))
 {
  btVector3 color(1, 1, 0);
  const btTransform& tr = m_triBody->getWorldTransform();
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[0]), tr(triangle[1]), color);
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[1]), tr(triangle[2]), color);
  m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[2]), tr(triangle[0]), color);
 }

 btTriIndex	triIndex(partId, triangleIndex, 0);
 btHashKey<btTriIndex> triKey(triIndex.getUid());


 btTriIndex* shapeIndex = m_shapeCache[triKey];
 if (shapeIndex)
 {
  btCollisionShape* tm = shapeIndex->m_childShape;
  btAssert(tm);

  //copy over user pointers to temporary shape
  tm->setUserPointer(m_triBody->getCollisionShape()->getUserPointer());

  btCollisionObjectWrapper softBody(0, m_softBody->getCollisionShape(), m_softBody, m_softBody->getWorldTransform(), -1, -1);
  //btCollisionObjectWrapper triBody(0,tm, ob, btTransform::getIdentity());//ob->getWorldTransform());//??
  btCollisionObjectWrapper triBody(0, tm, m_triBody, m_triBody->getWorldTransform(), partId, triangleIndex);
  ebtDispatcherQueryType algoType = m_resultOut->m_closestPointDistanceThreshold > 0 ? BT_CLOSEST_POINT_ALGORITHMS : BT_CONTACT_POINT_ALGORITHMS;
  btCollisionAlgorithm* colAlgo = ci.m_dispatcher1->findAlgorithm(&softBody, &triBody, 0, algoType);//m_manifoldPtr);

  colAlgo->processCollision(&softBody, &triBody, *m_dispatchInfoPtr, m_resultOut);
  colAlgo->~btCollisionAlgorithm();
  ci.m_dispatcher1->freeCollisionAlgorithm(colAlgo);

  return;
 }

 //aabb filter is already applied!	

 //btCollisionObject* colObj = static_cast<btCollisionObject*>(m_convexProxy->m_clientObject);

 //	if (m_softBody->getCollisionShape()->getShapeType()==
 {
  //		btVector3 other;
  btVector3 normal = (triangle[1] - triangle[0]).cross(triangle[2] - triangle[0]);
  normal.normalize();
  normal *= BT_SOFTBODY_TRIANGLE_EXTRUSION;
  //		other=(triangle[0]+triangle[1]+triangle[2])*0.333333f;
  //		other+=normal*22.f;
  btVector3	pts[6] = { triangle[0] + normal,
   triangle[1] + normal,
   triangle[2] + normal,
   triangle[0] - normal,
   triangle[1] - normal,
   triangle[2] - normal };

  btConvexHullShape* tm = new btConvexHullShape(&pts[0].getX(), 6);


  //		btBU_Simplex1to4 tm(triangle[0],triangle[1],triangle[2],other);

  //btTriangleShape tm(triangle[0],triangle[1],triangle[2]);	
  //	tm.setMargin(m_collisionMarginTriangle);

  //copy over user pointers to temporary shape
  tm->setUserPointer(m_triBody->getCollisionShape()->getUserPointer());


  btCollisionObjectWrapper softBody(0, m_softBody->getCollisionShape(), m_softBody, m_softBody->getWorldTransform(), -1, -1);
  btCollisionObjectWrapper triBody(0, tm, m_triBody, m_triBody->getWorldTransform(), partId, triangleIndex);//btTransform::getIdentity());//??

  ebtDispatcherQueryType algoType = m_resultOut->m_closestPointDistanceThreshold > 0 ? BT_CLOSEST_POINT_ALGORITHMS : BT_CONTACT_POINT_ALGORITHMS;
  btCollisionAlgorithm* colAlgo = ci.m_dispatcher1->findAlgorithm(&softBody, &triBody, 0, algoType);//m_manifoldPtr);

  colAlgo->processCollision(&softBody, &triBody, *m_dispatchInfoPtr, m_resultOut);
  colAlgo->~btCollisionAlgorithm();
  ci.m_dispatcher1->freeCollisionAlgorithm(colAlgo);

  triIndex.m_childShape = tm;
  m_shapeCache.insert(triKey, triIndex);

 }



}



void	btSoftBodyTriangleCallback::setTimeStepAndCounters(btScalar collisionMarginTriangle, const btCollisionObjectWrapper* triBodyWrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 m_dispatchInfoPtr = &dispatchInfo;
 m_collisionMarginTriangle = collisionMarginTriangle + btScalar(BT_SOFTBODY_TRIANGLE_EXTRUSION);
 m_resultOut = resultOut;


 btVector3	aabbWorldSpaceMin, aabbWorldSpaceMax;
 m_softBody->getAabb(aabbWorldSpaceMin, aabbWorldSpaceMax);
 btVector3 halfExtents = (aabbWorldSpaceMax - aabbWorldSpaceMin)*btScalar(0.5);
 btVector3 softBodyCenter = (aabbWorldSpaceMax + aabbWorldSpaceMin)*btScalar(0.5);

 btTransform softTransform;
 softTransform.setIdentity();
 softTransform.setOrigin(softBodyCenter);

 btTransform convexInTriangleSpace;
 convexInTriangleSpace = triBodyWrap->getWorldTransform().inverse() * softTransform;
 btTransformAabb(halfExtents, m_collisionMarginTriangle, convexInTriangleSpace, m_aabbMin, m_aabbMax);
}

void btSoftBodyConcaveCollisionAlgorithm::clearCache()
{
 m_btSoftBodyTriangleCallback.clearCache();

}

void btSoftBodyConcaveCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{


 //btCollisionObject* convexBody = m_isSwapped ? body1 : body0;
 const btCollisionObjectWrapper* triBody = m_isSwapped ? body0Wrap : body1Wrap;

 if (triBody->getCollisionShape()->isConcave())
 {


  const btCollisionObject*	triOb = triBody->getCollisionObject();
  const btConcaveShape* concaveShape = static_cast<const btConcaveShape*>(triOb->getCollisionShape());

  //	if (convexBody->getCollisionShape()->isConvex())
  {
   btScalar collisionMarginTriangle = concaveShape->getMargin();

   //			resultOut->setPersistentManifold(m_btSoftBodyTriangleCallback.m_manifoldPtr);
   m_btSoftBodyTriangleCallback.setTimeStepAndCounters(collisionMarginTriangle, triBody, dispatchInfo, resultOut);


   concaveShape->processAllTriangles(&m_btSoftBodyTriangleCallback, m_btSoftBodyTriangleCallback.getAabbMin(), m_btSoftBodyTriangleCallback.getAabbMax());

   //	resultOut->refreshContactPoints();

  }

 }

}


btScalar btSoftBodyConcaveCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 btCollisionObject* convexbody = m_isSwapped ? body1 : body0;
 btCollisionObject* triBody = m_isSwapped ? body0 : body1;


 //quick approximation using raycast, todo: hook up to the continuous collision detection (one of the btConvexCast)

 //only perform CCD above a certain threshold, this prevents blocking on the long run
 //because object in a blocked ccd state (hitfraction<1) get their linear velocity halved each frame...
 btScalar squareMot0 = (convexbody->getInterpolationWorldTransform().getOrigin() - convexbody->getWorldTransform().getOrigin()).length2();
 if (squareMot0 < convexbody->getCcdSquareMotionThreshold())
 {
  return btScalar(1.);
 }

 //const btVector3& from = convexbody->m_worldTransform.getOrigin();
 //btVector3 to = convexbody->m_interpolationWorldTransform.getOrigin();
 //todo: only do if the motion exceeds the 'radius'

 btTransform triInv = triBody->getWorldTransform().inverse();
 btTransform convexFromLocal = triInv * convexbody->getWorldTransform();
 btTransform convexToLocal = triInv * convexbody->getInterpolationWorldTransform();

 struct LocalTriangleSphereCastCallback : public btTriangleCallback
 {
  btTransform m_ccdSphereFromTrans;
  btTransform m_ccdSphereToTrans;
  btTransform	m_meshTransform;

  btScalar	m_ccdSphereRadius;
  btScalar	m_hitFraction;


  LocalTriangleSphereCastCallback(const btTransform& from, const btTransform& to, btScalar ccdSphereRadius, btScalar hitFraction)
   :m_ccdSphereFromTrans(from),
   m_ccdSphereToTrans(to),
   m_ccdSphereRadius(ccdSphereRadius),
   m_hitFraction(hitFraction)
  {
  }


  virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
  {
   (void)partId;
   (void)triangleIndex;
   //do a swept sphere for now
   btTransform ident;
   ident.setIdentity();
   btConvexCast::CastResult castResult;
   castResult.m_fraction = m_hitFraction;
   btSphereShape	pointShape(m_ccdSphereRadius);
   btTriangleShape	triShape(triangle[0], triangle[1], triangle[2]);
   btVoronoiSimplexSolver	simplexSolver;
   btSubsimplexConvexCast convexCaster(&pointShape, &triShape, &simplexSolver);
   //GjkConvexCast	convexCaster(&pointShape,convexShape,&simplexSolver);
   //ContinuousConvexCollision convexCaster(&pointShape,convexShape,&simplexSolver,0);
   //local space?

   if (convexCaster.calcTimeOfImpact(m_ccdSphereFromTrans, m_ccdSphereToTrans,
    ident, ident, castResult))
   {
    if (m_hitFraction > castResult.m_fraction)
     m_hitFraction = castResult.m_fraction;
   }

  }

 };





 if (triBody->getCollisionShape()->isConcave())
 {
  btVector3 rayAabbMin = convexFromLocal.getOrigin();
  rayAabbMin.setMin(convexToLocal.getOrigin());
  btVector3 rayAabbMax = convexFromLocal.getOrigin();
  rayAabbMax.setMax(convexToLocal.getOrigin());
  btScalar ccdRadius0 = convexbody->getCcdSweptSphereRadius();
  rayAabbMin -= btVector3(ccdRadius0, ccdRadius0, ccdRadius0);
  rayAabbMax += btVector3(ccdRadius0, ccdRadius0, ccdRadius0);

  btScalar curHitFraction = btScalar(1.); //is this available?
  LocalTriangleSphereCastCallback raycastCallback(convexFromLocal, convexToLocal,
   convexbody->getCcdSweptSphereRadius(), curHitFraction);

  raycastCallback.m_hitFraction = convexbody->getHitFraction();

  btCollisionObject* concavebody = triBody;

  btConcaveShape* triangleMesh = (btConcaveShape*)concavebody->getCollisionShape();

  if (triangleMesh)
  {
   triangleMesh->processAllTriangles(&raycastCallback, rayAabbMin, rayAabbMax);
  }



  if (raycastCallback.m_hitFraction < convexbody->getHitFraction())
  {
   convexbody->setHitFraction(raycastCallback.m_hitFraction);
   return raycastCallback.m_hitFraction;
  }
 }

 return btScalar(1.);

}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
///btSoftBodyHelpers.cpp by Nathanael Presson

#include "BulletSoftBody/btSoftBodyInternals.h"
#include <stdio.h>
#include <string.h>
#include "BulletSoftBody/btSoftBodyHelpers.h"
#include "LinearMath/btConvexHull.h"
#include "LinearMath/btConvexHullComputer.h"


//
static void				drawVertex(btIDebugDraw* idraw,
 const btVector3& x, btScalar s, const btVector3& c)
{
 idraw->drawLine(x - btVector3(s, 0, 0), x + btVector3(s, 0, 0), c);
 idraw->drawLine(x - btVector3(0, s, 0), x + btVector3(0, s, 0), c);
 idraw->drawLine(x - btVector3(0, 0, s), x + btVector3(0, 0, s), c);
}

//
static void				drawBox(btIDebugDraw* idraw,
 const btVector3& mins,
 const btVector3& maxs,
 const btVector3& color)
{
 const btVector3	c[] = { btVector3(mins.x(),mins.y(),mins.z()),
  btVector3(maxs.x(),mins.y(),mins.z()),
  btVector3(maxs.x(),maxs.y(),mins.z()),
  btVector3(mins.x(),maxs.y(),mins.z()),
  btVector3(mins.x(),mins.y(),maxs.z()),
  btVector3(maxs.x(),mins.y(),maxs.z()),
  btVector3(maxs.x(),maxs.y(),maxs.z()),
  btVector3(mins.x(),maxs.y(),maxs.z()) };
 idraw->drawLine(c[0], c[1], color); idraw->drawLine(c[1], c[2], color);
 idraw->drawLine(c[2], c[3], color); idraw->drawLine(c[3], c[0], color);
 idraw->drawLine(c[4], c[5], color); idraw->drawLine(c[5], c[6], color);
 idraw->drawLine(c[6], c[7], color); idraw->drawLine(c[7], c[4], color);
 idraw->drawLine(c[0], c[4], color); idraw->drawLine(c[1], c[5], color);
 idraw->drawLine(c[2], c[6], color); idraw->drawLine(c[3], c[7], color);
}

//
static void				drawTree(btIDebugDraw* idraw,
 const btDbvtNode* node,
 int depth,
 const btVector3& ncolor,
 const btVector3& lcolor,
 int mindepth,
 int maxdepth)
{
 if (node)
 {
  if (node->isinternal() && ((depth<maxdepth) || (maxdepth<0)))
  {
   drawTree(idraw, node->childs[0], depth + 1, ncolor, lcolor, mindepth, maxdepth);
   drawTree(idraw, node->childs[1], depth + 1, ncolor, lcolor, mindepth, maxdepth);
  }
  if (depth >= mindepth)
  {
   const btScalar	scl = (btScalar)(node->isinternal() ? 1 : 1);
   const btVector3	mi = node->volume.Center() - node->volume.Extents()*scl;
   const btVector3	mx = node->volume.Center() + node->volume.Extents()*scl;
   drawBox(idraw, mi, mx, node->isleaf() ? lcolor : ncolor);
  }
 }
}

//
template <typename T>
static inline T				sum(const btAlignedObjectArray<T>& items)
{
 T	v;
 if (items.size())
 {
  v = items[0];
  for (int i = 1, ni = items.size(); i<ni; ++i)
  {
   v += items[i];
  }
 }
 return(v);
}

//
template <typename T, typename Q>
static inline void			add(btAlignedObjectArray<T>& items, const Q& value)
{
 for (int i = 0, ni = items.size(); i<ni; ++i)
 {
  items[i] += value;
 }
}

//
template <typename T, typename Q>
static inline void			mul(btAlignedObjectArray<T>& items, const Q& value)
{
 for (int i = 0, ni = items.size(); i<ni; ++i)
 {
  items[i] *= value;
 }
}

//
template <typename T>
static inline T				average(const btAlignedObjectArray<T>& items)
{
 const btScalar	n = (btScalar)(items.size()>0 ? items.size() : 1);
 return(sum(items) / n);
}

#if 0
//
inline static btScalar		tetravolume(const btVector3& x0,
 const btVector3& x1,
 const btVector3& x2,
 const btVector3& x3)
{
 const btVector3	a = x1 - x0;
 const btVector3	b = x2 - x0;
 const btVector3	c = x3 - x0;
 return(btDot(a, btCross(b, c)));
}
#endif

//
#if 0
static btVector3		stresscolor(btScalar stress)
{
 static const btVector3	spectrum[] = { btVector3(1,0,1),
  btVector3(0,0,1),
  btVector3(0,1,1),
  btVector3(0,1,0),
  btVector3(1,1,0),
  btVector3(1,0,0),
  btVector3(1,0,0) };
 static const int		ncolors = sizeof(spectrum) / sizeof(spectrum[0]) - 1;
 static const btScalar	one = 1;
 stress = btMax<btScalar>(0, btMin<btScalar>(1, stress))*ncolors;
 const int				sel = (int)stress;
 const btScalar			frc = stress - sel;
 return(spectrum[sel] + (spectrum[sel + 1] - spectrum[sel])*frc);
}
#endif

//
void			btSoftBodyHelpers::Draw(btSoftBody* psb,
 btIDebugDraw* idraw,
 int drawflags)
{
 const btScalar		scl = (btScalar)0.1;
 const btScalar		nscl = scl * 5;
 const btVector3		lcolor = btVector3(0, 0, 0);
 const btVector3		ncolor = btVector3(1, 1, 1);
 const btVector3		ccolor = btVector3(1, 0, 0);
 int i, j, nj;

 /* Clusters	*/
 if (0 != (drawflags&fDrawFlags::Clusters))
 {
  srand(1806);
  for (i = 0; i<psb->m_clusters.size(); ++i)
  {
   if (psb->m_clusters[i]->m_collide)
   {
    btVector3						color(rand() / (btScalar)RAND_MAX,
     rand() / (btScalar)RAND_MAX,
     rand() / (btScalar)RAND_MAX);
    color = color.normalized()*0.75;
    btAlignedObjectArray<btVector3>	vertices;
    vertices.resize(psb->m_clusters[i]->m_nodes.size());
    for (j = 0, nj = vertices.size(); j<nj; ++j)
    {
     vertices[j] = psb->m_clusters[i]->m_nodes[j]->m_x;
    }
#define USE_NEW_CONVEX_HULL_COMPUTER
#ifdef USE_NEW_CONVEX_HULL_COMPUTER
    btConvexHullComputer	computer;
    int stride = sizeof(btVector3);
    int count = vertices.size();
    btScalar shrink = 0.f;
    btScalar shrinkClamp = 0.f;
    computer.compute(&vertices[0].getX(), stride, count, shrink, shrinkClamp);
    for (int i = 0; i<computer.faces.size(); i++)
    {

     int face = computer.faces[i];
     //printf("face=%d\n",face);
     const btConvexHullComputer::Edge*  firstEdge = &computer.edges[face];
     const btConvexHullComputer::Edge*  edge = firstEdge->getNextEdgeOfFace();

     int v0 = firstEdge->getSourceVertex();
     int v1 = firstEdge->getTargetVertex();
     while (edge != firstEdge)
     {
      int v2 = edge->getTargetVertex();
      idraw->drawTriangle(computer.vertices[v0], computer.vertices[v1], computer.vertices[v2], color, 1);
      edge = edge->getNextEdgeOfFace();
      v0 = v1;
      v1 = v2;
     };
    }
#else

    HullDesc		hdsc(QF_TRIANGLES, vertices.size(), &vertices[0]);
    HullResult		hres;
    HullLibrary		hlib;
    hdsc.mMaxVertices = vertices.size();
    hlib.CreateConvexHull(hdsc, hres);
    const btVector3	center = average(hres.m_OutputVertices);
    add(hres.m_OutputVertices, -center);
    mul(hres.m_OutputVertices, (btScalar)1);
    add(hres.m_OutputVertices, center);
    for (j = 0; j<(int)hres.mNumFaces; ++j)
    {
     const int idx[] = { hres.m_Indices[j * 3 + 0],hres.m_Indices[j * 3 + 1],hres.m_Indices[j * 3 + 2] };
     idraw->drawTriangle(hres.m_OutputVertices[idx[0]],
      hres.m_OutputVertices[idx[1]],
      hres.m_OutputVertices[idx[2]],
      color, 1);
    }
    hlib.ReleaseResult(hres);
#endif

   }
   /* Velocities	*/
#if 0
   for (int j = 0; j<psb->m_clusters[i].m_nodes.size(); ++j)
   {
    const btSoftBody::Cluster&	c = psb->m_clusters[i];
    const btVector3				r = c.m_nodes[j]->m_x - c.m_com;
    const btVector3				v = c.m_lv + btCross(c.m_av, r);
    idraw->drawLine(c.m_nodes[j]->m_x, c.m_nodes[j]->m_x + v, btVector3(1, 0, 0));
   }
#endif
   /* Frame		*/
   //		btSoftBody::Cluster& c=*psb->m_clusters[i];
   //		idraw->drawLine(c.m_com,c.m_framexform*btVector3(10,0,0),btVector3(1,0,0));
   //		idraw->drawLine(c.m_com,c.m_framexform*btVector3(0,10,0),btVector3(0,1,0));
   //		idraw->drawLine(c.m_com,c.m_framexform*btVector3(0,0,10),btVector3(0,0,1));
  }
 }
 else
 {
  /* Nodes	*/
  if (0 != (drawflags&fDrawFlags::Nodes))
  {
   for (i = 0; i<psb->m_nodes.size(); ++i)
   {
    const btSoftBody::Node&	n = psb->m_nodes[i];
    if (0 == (n.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
    idraw->drawLine(n.m_x - btVector3(scl, 0, 0), n.m_x + btVector3(scl, 0, 0), btVector3(1, 0, 0));
    idraw->drawLine(n.m_x - btVector3(0, scl, 0), n.m_x + btVector3(0, scl, 0), btVector3(0, 1, 0));
    idraw->drawLine(n.m_x - btVector3(0, 0, scl), n.m_x + btVector3(0, 0, scl), btVector3(0, 0, 1));
   }
  }
  /* Links	*/
  if (0 != (drawflags&fDrawFlags::Links))
  {
   for (i = 0; i<psb->m_links.size(); ++i)
   {
    const btSoftBody::Link&	l = psb->m_links[i];
    if (0 == (l.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
    idraw->drawLine(l.m_n[0]->m_x, l.m_n[1]->m_x, lcolor);
   }
  }
  /* Normals	*/
  if (0 != (drawflags&fDrawFlags::Normals))
  {
   for (i = 0; i<psb->m_nodes.size(); ++i)
   {
    const btSoftBody::Node&	n = psb->m_nodes[i];
    if (0 == (n.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
    const btVector3			d = n.m_n*nscl;
    idraw->drawLine(n.m_x, n.m_x + d, ncolor);
    idraw->drawLine(n.m_x, n.m_x - d, ncolor*0.5);
   }
  }
  /* Contacts	*/
  if (0 != (drawflags&fDrawFlags::Contacts))
  {
   static const btVector3		axis[] = { btVector3(1,0,0),
    btVector3(0,1,0),
    btVector3(0,0,1) };
   for (i = 0; i<psb->m_rcontacts.size(); ++i)
   {
    const btSoftBody::RContact&	c = psb->m_rcontacts[i];
    const btVector3				o = c.m_node->m_x - c.m_cti.m_normal*
     (btDot(c.m_node->m_x, c.m_cti.m_normal) + c.m_cti.m_offset);
    const btVector3				x = btCross(c.m_cti.m_normal, axis[c.m_cti.m_normal.minAxis()]).normalized();
    const btVector3				y = btCross(x, c.m_cti.m_normal).normalized();
    idraw->drawLine(o - x*nscl, o + x*nscl, ccolor);
    idraw->drawLine(o - y*nscl, o + y*nscl, ccolor);
    idraw->drawLine(o, o + c.m_cti.m_normal*nscl * 3, btVector3(1, 1, 0));
   }
  }
  /* Faces	*/
  if (0 != (drawflags&fDrawFlags::Faces))
  {
   const btScalar	scl = (btScalar)0.8;
   const btScalar	alp = (btScalar)1;
   const btVector3	col(0, (btScalar)0.7, 0);
   for (i = 0; i<psb->m_faces.size(); ++i)
   {
    const btSoftBody::Face&	f = psb->m_faces[i];
    if (0 == (f.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
    const btVector3			x[] = { f.m_n[0]->m_x,f.m_n[1]->m_x,f.m_n[2]->m_x };
    const btVector3			c = (x[0] + x[1] + x[2]) / 3;
    idraw->drawTriangle((x[0] - c)*scl + c,
     (x[1] - c)*scl + c,
     (x[2] - c)*scl + c,
     col, alp);
   }
  }
  /* Tetras	*/
  if (0 != (drawflags&fDrawFlags::Tetras))
  {
   const btScalar	scl = (btScalar)0.8;
   const btScalar	alp = (btScalar)1;
   const btVector3	col((btScalar)0.3, (btScalar)0.3, (btScalar)0.7);
   for (int i = 0; i<psb->m_tetras.size(); ++i)
   {
    const btSoftBody::Tetra&	t = psb->m_tetras[i];
    if (0 == (t.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
    const btVector3				x[] = { t.m_n[0]->m_x,t.m_n[1]->m_x,t.m_n[2]->m_x,t.m_n[3]->m_x };
    const btVector3				c = (x[0] + x[1] + x[2] + x[3]) / 4;
    idraw->drawTriangle((x[0] - c)*scl + c, (x[1] - c)*scl + c, (x[2] - c)*scl + c, col, alp);
    idraw->drawTriangle((x[0] - c)*scl + c, (x[1] - c)*scl + c, (x[3] - c)*scl + c, col, alp);
    idraw->drawTriangle((x[1] - c)*scl + c, (x[2] - c)*scl + c, (x[3] - c)*scl + c, col, alp);
    idraw->drawTriangle((x[2] - c)*scl + c, (x[0] - c)*scl + c, (x[3] - c)*scl + c, col, alp);
   }
  }
 }
 /* Anchors	*/
 if (0 != (drawflags&fDrawFlags::Anchors))
 {
  for (i = 0; i<psb->m_anchors.size(); ++i)
  {
   const btSoftBody::Anchor&	a = psb->m_anchors[i];
   const btVector3				q = a.m_body->getWorldTransform()*a.m_local;
   drawVertex(idraw, a.m_node->m_x, 0.25, btVector3(1, 0, 0));
   drawVertex(idraw, q, 0.25, btVector3(0, 1, 0));
   idraw->drawLine(a.m_node->m_x, q, btVector3(1, 1, 1));
  }
  for (i = 0; i<psb->m_nodes.size(); ++i)
  {
   const btSoftBody::Node&	n = psb->m_nodes[i];
   if (0 == (n.m_material->m_flags&btSoftBody::fMaterial::DebugDraw)) continue;
   if (n.m_im <= 0)
   {
    drawVertex(idraw, n.m_x, 0.25, btVector3(1, 0, 0));
   }
  }
 }


 /* Notes	*/
 if (0 != (drawflags&fDrawFlags::Notes))
 {
  for (i = 0; i<psb->m_notes.size(); ++i)
  {
   const btSoftBody::Note&	n = psb->m_notes[i];
   btVector3				p = n.m_offset;
   for (int j = 0; j<n.m_rank; ++j)
   {
    p += n.m_nodes[j]->m_x*n.m_coords[j];
   }
   idraw->draw3dText(p, n.m_text);
  }
 }
 /* Node tree	*/
 if (0 != (drawflags&fDrawFlags::NodeTree))		DrawNodeTree(psb, idraw);
 /* Face tree	*/
 if (0 != (drawflags&fDrawFlags::FaceTree))		DrawFaceTree(psb, idraw);
 /* Cluster tree	*/
 if (0 != (drawflags&fDrawFlags::ClusterTree))	DrawClusterTree(psb, idraw);
 /* Joints		*/
 if (0 != (drawflags&fDrawFlags::Joints))
 {
  for (i = 0; i<psb->m_joints.size(); ++i)
  {
   const btSoftBody::Joint*	pj = psb->m_joints[i];
   switch (pj->Type())
   {
   case	btSoftBody::Joint::eType::Linear:
   {
    const btSoftBody::LJoint*	pjl = (const btSoftBody::LJoint*)pj;
    const btVector3	a0 = pj->m_bodies[0].xform()*pjl->m_refs[0];
    const btVector3	a1 = pj->m_bodies[1].xform()*pjl->m_refs[1];
    idraw->drawLine(pj->m_bodies[0].xform().getOrigin(), a0, btVector3(1, 1, 0));
    idraw->drawLine(pj->m_bodies[1].xform().getOrigin(), a1, btVector3(0, 1, 1));
    drawVertex(idraw, a0, 0.25, btVector3(1, 1, 0));
    drawVertex(idraw, a1, 0.25, btVector3(0, 1, 1));
   }
   break;
   case	btSoftBody::Joint::eType::Angular:
   {
    //const btSoftBody::AJoint*	pja=(const btSoftBody::AJoint*)pj;
    const btVector3	o0 = pj->m_bodies[0].xform().getOrigin();
    const btVector3	o1 = pj->m_bodies[1].xform().getOrigin();
    const btVector3	a0 = pj->m_bodies[0].xform().getBasis()*pj->m_refs[0];
    const btVector3	a1 = pj->m_bodies[1].xform().getBasis()*pj->m_refs[1];
    idraw->drawLine(o0, o0 + a0 * 10, btVector3(1, 1, 0));
    idraw->drawLine(o0, o0 + a1 * 10, btVector3(1, 1, 0));
    idraw->drawLine(o1, o1 + a0 * 10, btVector3(0, 1, 1));
    idraw->drawLine(o1, o1 + a1 * 10, btVector3(0, 1, 1));
    break;
   }
   default:
   {
   }

   }
  }
 }
}

//
void			btSoftBodyHelpers::DrawInfos(btSoftBody* psb,
 btIDebugDraw* idraw,
 bool masses,
 bool areas,
 bool /*stress*/)
{
 for (int i = 0; i<psb->m_nodes.size(); ++i)
 {
  const btSoftBody::Node&	n = psb->m_nodes[i];
  char					text[2048] = { 0 };
  char					buff[1024];
  if (masses)
  {
   sprintf(buff, " M(%.2f)", 1 / n.m_im);
   strcat(text, buff);
  }
  if (areas)
  {
   sprintf(buff, " A(%.2f)", n.m_area);
   strcat(text, buff);
  }
  if (text[0]) idraw->draw3dText(n.m_x, text);
 }
}

//
void			btSoftBodyHelpers::DrawNodeTree(btSoftBody* psb,
 btIDebugDraw* idraw,
 int mindepth,
 int maxdepth)
{
 drawTree(idraw, psb->m_ndbvt.m_root, 0, btVector3(1, 0, 1), btVector3(1, 1, 1), mindepth, maxdepth);
}

//
void			btSoftBodyHelpers::DrawFaceTree(btSoftBody* psb,
 btIDebugDraw* idraw,
 int mindepth,
 int maxdepth)
{
 drawTree(idraw, psb->m_fdbvt.m_root, 0, btVector3(0, 1, 0), btVector3(1, 0, 0), mindepth, maxdepth);
}

//
void			btSoftBodyHelpers::DrawClusterTree(btSoftBody* psb,
 btIDebugDraw* idraw,
 int mindepth,
 int maxdepth)
{
 drawTree(idraw, psb->m_cdbvt.m_root, 0, btVector3(0, 1, 1), btVector3(1, 0, 0), mindepth, maxdepth);
}


//The btSoftBody object from the BulletSDK includes an array of Nodes and Links. These links appear
// to be first set up to connect a node to between 5 and 6 of its neighbors [480 links], 
//and then to the rest of the nodes after the execution of the Floyd-Warshall graph algorithm 
//[another 930 links]. 
//The way the links are stored by default, we have a number of cases where adjacent links share a node in common
// - this leads to the creation of a data dependency through memory. 
//The PSolve_Links() function reads and writes nodes as it iterates over each link. 
//So, we now have the possibility of a data dependency between iteration X 
//that processes link L with iteration X+1 that processes link L+1 
//because L and L+1 have one node in common, and iteration X updates the positions of that node, 
//and iteration X+1 reads in the position of that shared node.
//
//Such a memory dependency limits the ability of a modern CPU to speculate beyond 
//a certain point because it has to respect a possible dependency 
//- this prevents the CPU from making full use of its out-of-order resources. 
//If we re-order the links such that we minimize the cases where a link L and L+1 share a common node, 
//we create a temporal gap between when the node position is written, 
//and when it is subsequently read. This in turn allows the CPU to continue execution without 
//risking a dependency violation. Such a reordering would result in significant speedups on 
//modern CPUs with lots of execution resources. 
//In our testing, we see it have a tremendous impact not only on the A7, 
//but also on all x86 cores that ship with modern Macs. 
//The attached source file includes a single function (ReoptimizeLinkOrder) which can be called on a 
//btSoftBody object in the solveConstraints() function before the actual solver is invoked, 
//or right after generateBendingConstraints() once we have all 1410 links.


//===================================================================
//
//
// This function takes in a list of interdependent Links and tries 
// to maximize the distance between calculation
// of dependent links.  This increases the amount of parallelism that can
// be exploited by out-of-order instruction processors with large but
// (inevitably) finite instruction windows.
//
//===================================================================

// A small structure to track lists of dependent link calculations
class LinkDeps_t {
public:
 int value;			// A link calculation that is dependent on this one
              // Positive values = "input A" while negative values = "input B"
 LinkDeps_t *next;	// Next dependence in the list
};
typedef LinkDeps_t *LinkDepsPtr_t;

// Dependency list constants
#define REOP_NOT_DEPENDENT	-1
#define REOP_NODE_COMPLETE	-2	// Must be less than REOP_NOT_DEPENDENT


void btSoftBodyHelpers::ReoptimizeLinkOrder(btSoftBody *psb /* This can be replaced by a btSoftBody pointer */)
{
 int i, nLinks = psb->m_links.size(), nNodes = psb->m_nodes.size();
 btSoftBody::Link *lr;
 int ar, br;
 btSoftBody::Node *node0 = &(psb->m_nodes[0]);
 btSoftBody::Node *node1 = &(psb->m_nodes[1]);
 LinkDepsPtr_t linkDep;
 int readyListHead, readyListTail, linkNum, linkDepFrees, depLink;

 // Allocate temporary buffers
 int *nodeWrittenAt = new int[nNodes + 1];	// What link calculation produced this node's current values?
 int *linkDepA = new int[nLinks];			// Link calculation input is dependent upon prior calculation #N
 int *linkDepB = new int[nLinks];
 int *readyList = new int[nLinks];		// List of ready-to-process link calculations (# of links, maximum)
 LinkDeps_t *linkDepFreeList = new LinkDeps_t[2 * nLinks];		// Dependent-on-me list elements (2x# of links, maximum)
 LinkDepsPtr_t *linkDepListStarts = new LinkDepsPtr_t[nLinks];	// Start nodes of dependent-on-me lists, one for each link

                                                               // Copy the original, unsorted links to a side buffer
 btSoftBody::Link *linkBuffer = new btSoftBody::Link[nLinks];
 memcpy(linkBuffer, &(psb->m_links[0]), sizeof(btSoftBody::Link)*nLinks);

 // Clear out the node setup and ready list
 for (i = 0; i < nNodes + 1; i++) {
  nodeWrittenAt[i] = REOP_NOT_DEPENDENT;
 }
 for (i = 0; i < nLinks; i++) {
  linkDepListStarts[i] = NULL;
 }
 readyListHead = readyListTail = linkDepFrees = 0;

 // Initial link analysis to set up data structures
 for (i = 0; i < nLinks; i++) {

  // Note which prior link calculations we are dependent upon & build up dependence lists
  lr = &(psb->m_links[i]);
  ar = (lr->m_n[0] - node0) / (node1 - node0);
  br = (lr->m_n[1] - node0) / (node1 - node0);
  if (nodeWrittenAt[ar] > REOP_NOT_DEPENDENT) {
   linkDepA[i] = nodeWrittenAt[ar];
   linkDep = &linkDepFreeList[linkDepFrees++];
   linkDep->value = i;
   linkDep->next = linkDepListStarts[nodeWrittenAt[ar]];
   linkDepListStarts[nodeWrittenAt[ar]] = linkDep;
  }
  else {
   linkDepA[i] = REOP_NOT_DEPENDENT;
  }
  if (nodeWrittenAt[br] > REOP_NOT_DEPENDENT) {
   linkDepB[i] = nodeWrittenAt[br];
   linkDep = &linkDepFreeList[linkDepFrees++];
   linkDep->value = -(i + 1);
   linkDep->next = linkDepListStarts[nodeWrittenAt[br]];
   linkDepListStarts[nodeWrittenAt[br]] = linkDep;
  }
  else {
   linkDepB[i] = REOP_NOT_DEPENDENT;
  }

  // Add this link to the initial ready list, if it is not dependent on any other links
  if ((linkDepA[i] == REOP_NOT_DEPENDENT) && (linkDepB[i] == REOP_NOT_DEPENDENT)) {
   readyList[readyListTail++] = i;
   linkDepA[i] = linkDepB[i] = REOP_NODE_COMPLETE;	// Probably not needed now
  }

  // Update the nodes to mark which ones are calculated by this link
  nodeWrittenAt[ar] = nodeWrittenAt[br] = i;
 }

 // Process the ready list and create the sorted list of links
 // -- By treating the ready list as a queue, we maximize the distance between any
 //    inter-dependent node calculations
 // -- All other (non-related) nodes in the ready list will automatically be inserted
 //    in between each set of inter-dependent link calculations by this loop
 i = 0;
 while (readyListHead != readyListTail) {
  // Use ready list to select the next link to process
  linkNum = readyList[readyListHead++];
  // Copy the next-to-calculate link back into the original link array
  psb->m_links[i++] = linkBuffer[linkNum];

  // Free up any link inputs that are dependent on this one
  linkDep = linkDepListStarts[linkNum];
  while (linkDep) {
   depLink = linkDep->value;
   if (depLink >= 0) {
    linkDepA[depLink] = REOP_NOT_DEPENDENT;
   }
   else {
    depLink = -depLink - 1;
    linkDepB[depLink] = REOP_NOT_DEPENDENT;
   }
   // Add this dependent link calculation to the ready list if *both* inputs are clear
   if ((linkDepA[depLink] == REOP_NOT_DEPENDENT) && (linkDepB[depLink] == REOP_NOT_DEPENDENT)) {
    readyList[readyListTail++] = depLink;
    linkDepA[depLink] = linkDepB[depLink] = REOP_NODE_COMPLETE;	// Probably not needed now
   }
   linkDep = linkDep->next;
  }
 }

 // Delete the temporary buffers
 delete[] nodeWrittenAt;
 delete[] linkDepA;
 delete[] linkDepB;
 delete[] readyList;
 delete[] linkDepFreeList;
 delete[] linkDepListStarts;
 delete[] linkBuffer;
}


//
void			btSoftBodyHelpers::DrawFrame(btSoftBody* psb,
 btIDebugDraw* idraw)
{
 if (psb->m_pose.m_bframe)
 {
  static const btScalar	ascl = 10;
  static const btScalar	nscl = (btScalar)0.1;
  const btVector3			com = psb->m_pose.m_com;
  const btMatrix3x3		trs = psb->m_pose.m_rot*psb->m_pose.m_scl;
  const btVector3			Xaxis = (trs*btVector3(1, 0, 0)).normalized();
  const btVector3			Yaxis = (trs*btVector3(0, 1, 0)).normalized();
  const btVector3			Zaxis = (trs*btVector3(0, 0, 1)).normalized();
  idraw->drawLine(com, com + Xaxis*ascl, btVector3(1, 0, 0));
  idraw->drawLine(com, com + Yaxis*ascl, btVector3(0, 1, 0));
  idraw->drawLine(com, com + Zaxis*ascl, btVector3(0, 0, 1));
  for (int i = 0; i<psb->m_pose.m_pos.size(); ++i)
  {
   const btVector3	x = com + trs*psb->m_pose.m_pos[i];
   drawVertex(idraw, x, nscl, btVector3(1, 0, 1));
  }
 }
}

//
btSoftBody*		btSoftBodyHelpers::CreateRope(btSoftBodyWorldInfo& worldInfo, const btVector3& from,
 const btVector3& to,
 int res,
 int fixeds)
{
 /* Create nodes	*/
 const int		r = res + 2;
 btVector3*		x = new btVector3[r];
 btScalar*		m = new btScalar[r];
 int i;

 for (i = 0; i<r; ++i)
 {
  const btScalar	t = i / (btScalar)(r - 1);
  x[i] = lerp(from, to, t);
  m[i] = 1;
 }
 btSoftBody*		psb = new btSoftBody(&worldInfo, r, x, m);
 if (fixeds & 1) psb->setMass(0, 0);
 if (fixeds & 2) psb->setMass(r - 1, 0);
 delete[] x;
 delete[] m;
 /* Create links	*/
 for (i = 1; i<r; ++i)
 {
  psb->appendLink(i - 1, i);
 }
 /* Finished		*/
 return(psb);
}

//
btSoftBody*		btSoftBodyHelpers::CreatePatch(btSoftBodyWorldInfo& worldInfo, const btVector3& corner00,
 const btVector3& corner10,
 const btVector3& corner01,
 const btVector3& corner11,
 int resx,
 int resy,
 int fixeds,
 bool gendiags)
{
#define IDX(_x_,_y_)	((_y_)*rx+(_x_))
 /* Create nodes	*/
 if ((resx<2) || (resy<2)) return(0);
 const int	rx = resx;
 const int	ry = resy;
 const int	tot = rx*ry;
 btVector3*	x = new btVector3[tot];
 btScalar*	m = new btScalar[tot];
 int iy;

 for (iy = 0; iy<ry; ++iy)
 {
  const btScalar	ty = iy / (btScalar)(ry - 1);
  const btVector3	py0 = lerp(corner00, corner01, ty);
  const btVector3	py1 = lerp(corner10, corner11, ty);
  for (int ix = 0; ix<rx; ++ix)
  {
   const btScalar	tx = ix / (btScalar)(rx - 1);
   x[IDX(ix, iy)] = lerp(py0, py1, tx);
   m[IDX(ix, iy)] = 1;
  }
 }
 btSoftBody*		psb = new btSoftBody(&worldInfo, tot, x, m);
 if (fixeds & 1)	psb->setMass(IDX(0, 0), 0);
 if (fixeds & 2)	psb->setMass(IDX(rx - 1, 0), 0);
 if (fixeds & 4)	psb->setMass(IDX(0, ry - 1), 0);
 if (fixeds & 8)	psb->setMass(IDX(rx - 1, ry - 1), 0);
 delete[] x;
 delete[] m;
 /* Create links	and faces */
 for (iy = 0; iy<ry; ++iy)
 {
  for (int ix = 0; ix<rx; ++ix)
  {
   const int	idx = IDX(ix, iy);
   const bool	mdx = (ix + 1)<rx;
   const bool	mdy = (iy + 1)<ry;
   if (mdx) psb->appendLink(idx, IDX(ix + 1, iy));
   if (mdy) psb->appendLink(idx, IDX(ix, iy + 1));
   if (mdx&&mdy)
   {
    if ((ix + iy) & 1)
    {
     psb->appendFace(IDX(ix, iy), IDX(ix + 1, iy), IDX(ix + 1, iy + 1));
     psb->appendFace(IDX(ix, iy), IDX(ix + 1, iy + 1), IDX(ix, iy + 1));
     if (gendiags)
     {
      psb->appendLink(IDX(ix, iy), IDX(ix + 1, iy + 1));
     }
    }
    else
    {
     psb->appendFace(IDX(ix, iy + 1), IDX(ix, iy), IDX(ix + 1, iy));
     psb->appendFace(IDX(ix, iy + 1), IDX(ix + 1, iy), IDX(ix + 1, iy + 1));
     if (gendiags)
     {
      psb->appendLink(IDX(ix + 1, iy), IDX(ix, iy + 1));
     }
    }
   }
  }
 }
 /* Finished		*/
#undef IDX
 return(psb);
}

//
btSoftBody*		btSoftBodyHelpers::CreatePatchUV(btSoftBodyWorldInfo& worldInfo,
 const btVector3& corner00,
 const btVector3& corner10,
 const btVector3& corner01,
 const btVector3& corner11,
 int resx,
 int resy,
 int fixeds,
 bool gendiags,
 float* tex_coords)
{

 /*
 *
 *  corners:
 *
 *  [0][0]     corner00 ------- corner01   [resx][0]
 *                |                |
 *                |                |
 *  [0][resy]  corner10 -------- corner11  [resx][resy]
 *
 *
 *
 *
 *
 *
 *   "fixedgs" map:
 *
 *  corner00     -->   +1
 *  corner01     -->   +2
 *  corner10     -->   +4
 *  corner11     -->   +8
 *  upper middle -->  +16
 *  left middle  -->  +32
 *  right middle -->  +64
 *  lower middle --> +128
 *  center       --> +256
 *
 *
 *   tex_coords size   (resx-1)*(resy-1)*12
 *
 *
 *
 *     SINGLE QUAD INTERNALS
 *
 *  1) btSoftBody's nodes and links,
 *     diagonal link is optional ("gendiags")
 *
 *
 *    node00 ------ node01
 *      | .
 *      |   .
 *      |     .
 *      |       .
 *      |         .
 *    node10        node11
 *
 *
 *
 *   2) Faces:
 *      two triangles,
 *      UV Coordinates (hier example for single quad)
 *
 *     (0,1)          (0,1)  (1,1)
 *     1 |\            3 \-----| 2
 *       | \              \    |
 *       |  \              \   |
 *       |   \              \  |
 *       |    \              \ |
 *     2 |-----\ 3            \| 1
 *     (0,0)    (1,0)       (1,0)
 *
 *
 *
 *
 *
 *
 */

#define IDX(_x_,_y_)	((_y_)*rx+(_x_))
 /* Create nodes		*/
 if ((resx<2) || (resy<2)) return(0);
 const int	rx = resx;
 const int	ry = resy;
 const int	tot = rx*ry;
 btVector3*	x = new btVector3[tot];
 btScalar*	m = new btScalar[tot];

 int iy;

 for (iy = 0; iy<ry; ++iy)
 {
  const btScalar	ty = iy / (btScalar)(ry - 1);
  const btVector3	py0 = lerp(corner00, corner01, ty);
  const btVector3	py1 = lerp(corner10, corner11, ty);
  for (int ix = 0; ix<rx; ++ix)
  {
   const btScalar	tx = ix / (btScalar)(rx - 1);
   x[IDX(ix, iy)] = lerp(py0, py1, tx);
   m[IDX(ix, iy)] = 1;
  }
 }
 btSoftBody*	psb = new btSoftBody(&worldInfo, tot, x, m);
 if (fixeds & 1)		psb->setMass(IDX(0, 0), 0);
 if (fixeds & 2)		psb->setMass(IDX(rx - 1, 0), 0);
 if (fixeds & 4)		psb->setMass(IDX(0, ry - 1), 0);
 if (fixeds & 8)		psb->setMass(IDX(rx - 1, ry - 1), 0);
 if (fixeds & 16)		psb->setMass(IDX((rx - 1) / 2, 0), 0);
 if (fixeds & 32)		psb->setMass(IDX(0, (ry - 1) / 2), 0);
 if (fixeds & 64)		psb->setMass(IDX(rx - 1, (ry - 1) / 2), 0);
 if (fixeds & 128)		psb->setMass(IDX((rx - 1) / 2, ry - 1), 0);
 if (fixeds & 256)		psb->setMass(IDX((rx - 1) / 2, (ry - 1) / 2), 0);
 delete[] x;
 delete[] m;


 int z = 0;
 /* Create links	and faces	*/
 for (iy = 0; iy<ry; ++iy)
 {
  for (int ix = 0; ix<rx; ++ix)
  {
   const bool	mdx = (ix + 1)<rx;
   const bool	mdy = (iy + 1)<ry;

   int node00 = IDX(ix, iy);
   int node01 = IDX(ix + 1, iy);
   int node10 = IDX(ix, iy + 1);
   int node11 = IDX(ix + 1, iy + 1);

   if (mdx) psb->appendLink(node00, node01);
   if (mdy) psb->appendLink(node00, node10);
   if (mdx&&mdy)
   {
    psb->appendFace(node00, node10, node11);
    if (tex_coords) {
     tex_coords[z + 0] = CalculateUV(resx, resy, ix, iy, 0);
     tex_coords[z + 1] = CalculateUV(resx, resy, ix, iy, 1);
     tex_coords[z + 2] = CalculateUV(resx, resy, ix, iy, 0);
     tex_coords[z + 3] = CalculateUV(resx, resy, ix, iy, 2);
     tex_coords[z + 4] = CalculateUV(resx, resy, ix, iy, 3);
     tex_coords[z + 5] = CalculateUV(resx, resy, ix, iy, 2);
    }
    psb->appendFace(node11, node01, node00);
    if (tex_coords) {
     tex_coords[z + 6] = CalculateUV(resx, resy, ix, iy, 3);
     tex_coords[z + 7] = CalculateUV(resx, resy, ix, iy, 2);
     tex_coords[z + 8] = CalculateUV(resx, resy, ix, iy, 3);
     tex_coords[z + 9] = CalculateUV(resx, resy, ix, iy, 1);
     tex_coords[z + 10] = CalculateUV(resx, resy, ix, iy, 0);
     tex_coords[z + 11] = CalculateUV(resx, resy, ix, iy, 1);
    }
    if (gendiags) psb->appendLink(node00, node11);
    z += 12;
   }
  }
 }
 /* Finished	*/
#undef IDX
 return(psb);
}

float   btSoftBodyHelpers::CalculateUV(int resx, int resy, int ix, int iy, int id)
{

 /*
 *
 *
 *    node00 --- node01
 *      |          |
 *    node10 --- node11
 *
 *
 *   ID map:
 *
 *   node00 s --> 0
 *   node00 t --> 1
 *
 *   node01 s --> 3
 *   node01 t --> 1
 *
 *   node10 s --> 0
 *   node10 t --> 2
 *
 *   node11 s --> 3
 *   node11 t --> 2
 *
 *
 */

 float tc = 0.0f;
 if (id == 0) {
  tc = (1.0f / ((resx - 1))*ix);
 }
 else if (id == 1) {
  tc = (1.0f / ((resy - 1))*(resy - 1 - iy));
 }
 else if (id == 2) {
  tc = (1.0f / ((resy - 1))*(resy - 1 - iy - 1));
 }
 else if (id == 3) {
  tc = (1.0f / ((resx - 1))*(ix + 1));
 }
 return tc;
}
//
btSoftBody*		btSoftBodyHelpers::CreateEllipsoid(btSoftBodyWorldInfo& worldInfo, const btVector3& center,
 const btVector3& radius,
 int res)
{
 struct	Hammersley
 {
  static void	Generate(btVector3* x, int n)
  {
   for (int i = 0; i<n; i++)
   {
    btScalar	p = 0.5, t = 0;
    for (int j = i; j; p *= 0.5, j >>= 1) if (j & 1) t += p;
    btScalar	w = 2 * t - 1;
    btScalar	a = (SIMD_PI + 2 * i*SIMD_PI) / n;
    btScalar	s = btSqrt(1 - w*w);
    *x++ = btVector3(s*btCos(a), s*btSin(a), w);
   }
  }
 };
 btAlignedObjectArray<btVector3>	vtx;
 vtx.resize(3 + res);
 Hammersley::Generate(&vtx[0], vtx.size());
 for (int i = 0; i<vtx.size(); ++i)
 {
  vtx[i] = vtx[i] * radius + center;
 }
 return(CreateFromConvexHull(worldInfo, &vtx[0], vtx.size()));
}



//
btSoftBody*		btSoftBodyHelpers::CreateFromTriMesh(btSoftBodyWorldInfo& worldInfo, const btScalar*	vertices,
 const int* triangles,
 int ntriangles, bool randomizeConstraints)
{
 int		maxidx = 0;
 int i, j, ni;

 for (i = 0, ni = ntriangles * 3; i<ni; ++i)
 {
  maxidx = btMax(triangles[i], maxidx);
 }
 ++maxidx;
 btAlignedObjectArray<bool>		chks;
 btAlignedObjectArray<btVector3>	vtx;
 chks.resize(maxidx*maxidx, false);
 vtx.resize(maxidx);
 for (i = 0, j = 0, ni = maxidx * 3; i<ni; ++j, i += 3)
 {
  vtx[j] = btVector3(vertices[i], vertices[i + 1], vertices[i + 2]);
 }
 btSoftBody*		psb = new btSoftBody(&worldInfo, vtx.size(), &vtx[0], 0);
 for (i = 0, ni = ntriangles * 3; i<ni; i += 3)
 {
  const int idx[] = { triangles[i],triangles[i + 1],triangles[i + 2] };
#define IDX(_x_,_y_) ((_y_)*maxidx+(_x_))
  for (int j = 2, k = 0; k<3; j = k++)
  {
   if (!chks[IDX(idx[j], idx[k])])
   {
    chks[IDX(idx[j], idx[k])] = true;
    chks[IDX(idx[k], idx[j])] = true;
    psb->appendLink(idx[j], idx[k]);
   }
  }
#undef IDX
  psb->appendFace(idx[0], idx[1], idx[2]);
 }

 if (randomizeConstraints)
 {
  psb->randomizeConstraints();
 }

 return(psb);
}

//
btSoftBody*		btSoftBodyHelpers::CreateFromConvexHull(btSoftBodyWorldInfo& worldInfo, const btVector3* vertices,
 int nvertices, bool randomizeConstraints)
{
 HullDesc		hdsc(QF_TRIANGLES, nvertices, vertices);
 HullResult		hres;
 HullLibrary		hlib;/*??*/
 hdsc.mMaxVertices = nvertices;
 hlib.CreateConvexHull(hdsc, hres);
 btSoftBody*		psb = new btSoftBody(&worldInfo, (int)hres.mNumOutputVertices,
  &hres.m_OutputVertices[0], 0);
 for (int i = 0; i<(int)hres.mNumFaces; ++i)
 {
  const int idx[] = { static_cast<int>(hres.m_Indices[i * 3 + 0]),
   static_cast<int>(hres.m_Indices[i * 3 + 1]),
   static_cast<int>(hres.m_Indices[i * 3 + 2]) };
  if (idx[0]<idx[1]) psb->appendLink(idx[0], idx[1]);
  if (idx[1]<idx[2]) psb->appendLink(idx[1], idx[2]);
  if (idx[2]<idx[0]) psb->appendLink(idx[2], idx[0]);
  psb->appendFace(idx[0], idx[1], idx[2]);
 }
 hlib.ReleaseResult(hres);
 if (randomizeConstraints)
 {
  psb->randomizeConstraints();
 }
 return(psb);
}




static int nextLine(const char* buffer)
{
 int numBytesRead = 0;

 while (*buffer != '\n')
 {
  buffer++;
  numBytesRead++;
 }


 if (buffer[0] == 0x0a)
 {
  buffer++;
  numBytesRead++;
 }
 return numBytesRead;
}

/* Create from TetGen .ele, .face, .node data							*/
btSoftBody*	btSoftBodyHelpers::CreateFromTetGenData(btSoftBodyWorldInfo& worldInfo,
 const char* ele,
 const char* face,
 const char* node,
 bool bfacelinks,
 bool btetralinks,
 bool bfacesfromtetras)
{
 btAlignedObjectArray<btVector3>	pos;
 int								nnode = 0;
 int								ndims = 0;
 int								nattrb = 0;
 int								hasbounds = 0;
 int result = sscanf(node, "%d %d %d %d", &nnode, &ndims, &nattrb, &hasbounds);
 result = sscanf(node, "%d %d %d %d", &nnode, &ndims, &nattrb, &hasbounds);
 node += nextLine(node);

 pos.resize(nnode);
 for (int i = 0; i<pos.size(); ++i)
 {
  int			index = 0;
  //int			bound=0;
  float	x, y, z;
  sscanf(node, "%d %f %f %f", &index, &x, &y, &z);

  //	sn>>index;
  //	sn>>x;sn>>y;sn>>z;
  node += nextLine(node);

  //for(int j=0;j<nattrb;++j) 
  //	sn>>a;

  //if(hasbounds) 
  //	sn>>bound;

  pos[index].setX(btScalar(x));
  pos[index].setY(btScalar(y));
  pos[index].setZ(btScalar(z));
 }
 btSoftBody*						psb = new btSoftBody(&worldInfo, nnode, &pos[0], 0);
#if 0
 if (face&&face[0])
 {
  int								nface = 0;
  sf >> nface; sf >> hasbounds;
  for (int i = 0; i<nface; ++i)
  {
   int			index = 0;
   int			bound = 0;
   int			ni[3];
   sf >> index;
   sf >> ni[0]; sf >> ni[1]; sf >> ni[2];
   sf >> bound;
   psb->appendFace(ni[0], ni[1], ni[2]);
   if (btetralinks)
   {
    psb->appendLink(ni[0], ni[1], 0, true);
    psb->appendLink(ni[1], ni[2], 0, true);
    psb->appendLink(ni[2], ni[0], 0, true);
   }
  }
 }
#endif

 if (ele&&ele[0])
 {
  int								ntetra = 0;
  int								ncorner = 0;
  int								neattrb = 0;
  sscanf(ele, "%d %d %d", &ntetra, &ncorner, &neattrb);
  ele += nextLine(ele);

  //se>>ntetra;se>>ncorner;se>>neattrb;
  for (int i = 0; i<ntetra; ++i)
  {
   int			index = 0;
   int			ni[4];

   //se>>index;
   //se>>ni[0];se>>ni[1];se>>ni[2];se>>ni[3];
   sscanf(ele, "%d %d %d %d %d", &index, &ni[0], &ni[1], &ni[2], &ni[3]);
   ele += nextLine(ele);
   //for(int j=0;j<neattrb;++j) 
   //	se>>a;
   psb->appendTetra(ni[0], ni[1], ni[2], ni[3]);
   if (btetralinks)
   {
    psb->appendLink(ni[0], ni[1], 0, true);
    psb->appendLink(ni[1], ni[2], 0, true);
    psb->appendLink(ni[2], ni[0], 0, true);
    psb->appendLink(ni[0], ni[3], 0, true);
    psb->appendLink(ni[1], ni[3], 0, true);
    psb->appendLink(ni[2], ni[3], 0, true);
   }
  }
 }
 printf("Nodes:  %u\r\n", psb->m_nodes.size());
 printf("Links:  %u\r\n", psb->m_links.size());
 printf("Faces:  %u\r\n", psb->m_faces.size());
 printf("Tetras: %u\r\n", psb->m_tetras.size());
 return(psb);
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletSoftBody/btSoftBodyRigidBodyCollisionConfiguration.h"
#include "BulletSoftBody/btSoftRigidCollisionAlgorithm.h"
#include "BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h"
#include "BulletSoftBody/btSoftSoftCollisionAlgorithm.h"

#include "LinearMath/btPoolAllocator.h"

#define ENABLE_SOFTBODY_CONCAVE_COLLISIONS 1

btSoftBodyRigidBodyCollisionConfiguration::btSoftBodyRigidBodyCollisionConfiguration(const btDefaultCollisionConstructionInfo& constructionInfo)
 :btDefaultCollisionConfiguration(constructionInfo)
{
 void* mem;

 mem = btAlignedAlloc(sizeof(btSoftSoftCollisionAlgorithm::CreateFunc), 16);
 m_softSoftCreateFunc = new(mem) btSoftSoftCollisionAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btSoftRigidCollisionAlgorithm::CreateFunc), 16);
 m_softRigidConvexCreateFunc = new(mem) btSoftRigidCollisionAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btSoftRigidCollisionAlgorithm::CreateFunc), 16);
 m_swappedSoftRigidConvexCreateFunc = new(mem) btSoftRigidCollisionAlgorithm::CreateFunc;
 m_swappedSoftRigidConvexCreateFunc->m_swapped = true;

#ifdef ENABLE_SOFTBODY_CONCAVE_COLLISIONS
 mem = btAlignedAlloc(sizeof(btSoftBodyConcaveCollisionAlgorithm::CreateFunc), 16);
 m_softRigidConcaveCreateFunc = new(mem) btSoftBodyConcaveCollisionAlgorithm::CreateFunc;

 mem = btAlignedAlloc(sizeof(btSoftBodyConcaveCollisionAlgorithm::CreateFunc), 16);
 m_swappedSoftRigidConcaveCreateFunc = new(mem) btSoftBodyConcaveCollisionAlgorithm::SwappedCreateFunc;
 m_swappedSoftRigidConcaveCreateFunc->m_swapped = true;
#endif

 //replace pool by a new one, with potential larger size

 if (m_ownsCollisionAlgorithmPool && m_collisionAlgorithmPool)
 {
  int curElemSize = m_collisionAlgorithmPool->getElementSize();
  ///calculate maximum element size, big enough to fit any collision algorithm in the memory pool


  int maxSize0 = sizeof(btSoftSoftCollisionAlgorithm);
  int maxSize1 = sizeof(btSoftRigidCollisionAlgorithm);
  int maxSize2 = sizeof(btSoftBodyConcaveCollisionAlgorithm);

  int	collisionAlgorithmMaxElementSize = btMax(maxSize0, maxSize1);
  collisionAlgorithmMaxElementSize = btMax(collisionAlgorithmMaxElementSize, maxSize2);

  if (collisionAlgorithmMaxElementSize > curElemSize)
  {
   m_collisionAlgorithmPool->~btPoolAllocator();
   btAlignedFree(m_collisionAlgorithmPool);
   void* mem = btAlignedAlloc(sizeof(btPoolAllocator), 16);
   m_collisionAlgorithmPool = new(mem) btPoolAllocator(collisionAlgorithmMaxElementSize, constructionInfo.m_defaultMaxCollisionAlgorithmPoolSize);
  }
 }

}

btSoftBodyRigidBodyCollisionConfiguration::~btSoftBodyRigidBodyCollisionConfiguration()
{
 m_softSoftCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_softSoftCreateFunc);

 m_softRigidConvexCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_softRigidConvexCreateFunc);

 m_swappedSoftRigidConvexCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_swappedSoftRigidConvexCreateFunc);

#ifdef ENABLE_SOFTBODY_CONCAVE_COLLISIONS
 m_softRigidConcaveCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_softRigidConcaveCreateFunc);

 m_swappedSoftRigidConcaveCreateFunc->~btCollisionAlgorithmCreateFunc();
 btAlignedFree(m_swappedSoftRigidConcaveCreateFunc);
#endif
}

///creation of soft-soft and soft-rigid, and otherwise fallback to base class implementation
btCollisionAlgorithmCreateFunc* btSoftBodyRigidBodyCollisionConfiguration::getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1)
{

 ///try to handle the softbody interactions first

 if ((proxyType0 == SOFTBODY_SHAPE_PROXYTYPE) && (proxyType1 == SOFTBODY_SHAPE_PROXYTYPE))
 {
  return	m_softSoftCreateFunc;
 }

 ///softbody versus convex
 if (proxyType0 == SOFTBODY_SHAPE_PROXYTYPE  && btBroadphaseProxy::isConvex(proxyType1))
 {
  return	m_softRigidConvexCreateFunc;
 }

 ///convex versus soft body
 if (btBroadphaseProxy::isConvex(proxyType0) && proxyType1 == SOFTBODY_SHAPE_PROXYTYPE)
 {
  return	m_swappedSoftRigidConvexCreateFunc;
 }

#ifdef ENABLE_SOFTBODY_CONCAVE_COLLISIONS
 ///softbody versus convex
 if (proxyType0 == SOFTBODY_SHAPE_PROXYTYPE  && btBroadphaseProxy::isConcave(proxyType1))
 {
  return	m_softRigidConcaveCreateFunc;
 }

 ///convex versus soft body
 if (btBroadphaseProxy::isConcave(proxyType0) && proxyType1 == SOFTBODY_SHAPE_PROXYTYPE)
 {
  return	m_swappedSoftRigidConcaveCreateFunc;
 }
#endif

 ///fallback to the regular rigid collision shape
 return btDefaultCollisionConfiguration::getCollisionAlgorithmCreateFunc(proxyType0, proxyType1);
}
/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletSoftBody/btSoftMultiBodyDynamicsWorld.h"
#include "LinearMath/btQuickprof.h"

//softbody & helpers
#include "BulletSoftBody/btSoftBody.h"
#include "BulletSoftBody/btSoftBodyHelpers.h"
#include "BulletSoftBody/btSoftBodySolvers.h"
#include "BulletSoftBody/btDefaultSoftBodySolver.h"
#include "LinearMath/btSerializer.h"


btSoftMultiBodyDynamicsWorld::btSoftMultiBodyDynamicsWorld(
 btDispatcher* dispatcher,
 btBroadphaseInterface* pairCache,
 btMultiBodyConstraintSolver* constraintSolver,
 btCollisionConfiguration* collisionConfiguration,
 btSoftBodySolver *softBodySolver) :
 btMultiBodyDynamicsWorld(dispatcher, pairCache, constraintSolver, collisionConfiguration),
 m_softBodySolver(softBodySolver),
 m_ownsSolver(false)
{
 if (!m_softBodySolver)
 {
  void* ptr = btAlignedAlloc(sizeof(btDefaultSoftBodySolver), 16);
  m_softBodySolver = new(ptr) btDefaultSoftBodySolver();
  m_ownsSolver = true;
 }

 m_drawFlags = fDrawFlags::Std;
 m_drawNodeTree = true;
 m_drawFaceTree = false;
 m_drawClusterTree = false;
 m_sbi.m_broadphase = pairCache;
 m_sbi.m_dispatcher = dispatcher;
 m_sbi.m_sparsesdf.Initialize();
 m_sbi.m_sparsesdf.Reset();

 m_sbi.air_density = (btScalar)1.2;
 m_sbi.water_density = 0;
 m_sbi.water_offset = 0;
 m_sbi.water_normal = btVector3(0, 0, 0);
 m_sbi.m_gravity.setValue(0, -10, 0);

 m_sbi.m_sparsesdf.Initialize();


}

btSoftMultiBodyDynamicsWorld::~btSoftMultiBodyDynamicsWorld()
{
 if (m_ownsSolver)
 {
  m_softBodySolver->~btSoftBodySolver();
  btAlignedFree(m_softBodySolver);
 }
}

void	btSoftMultiBodyDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
 btDiscreteDynamicsWorld::predictUnconstraintMotion(timeStep);
 {
  BT_PROFILE("predictUnconstraintMotionSoftBody");
  m_softBodySolver->predictMotion(float(timeStep));
 }
}

void	btSoftMultiBodyDynamicsWorld::internalSingleStepSimulation(btScalar timeStep)
{

 // Let the solver grab the soft bodies and if necessary optimize for it
 m_softBodySolver->optimize(getSoftBodyArray());

 if (!m_softBodySolver->checkInitialized())
 {
  btAssert("Solver initialization failed\n");
 }

 btDiscreteDynamicsWorld::internalSingleStepSimulation(timeStep);

 ///solve soft bodies constraints
 solveSoftBodiesConstraints(timeStep);

 //self collisions
 for (int i = 0; i<m_softBodies.size(); i++)
 {
  btSoftBody*	psb = (btSoftBody*)m_softBodies[i];
  psb->defaultCollisionHandler(psb);
 }

 ///update soft bodies
 m_softBodySolver->updateSoftBodies();

 // End solver-wise simulation step
 // ///////////////////////////////

}

void	btSoftMultiBodyDynamicsWorld::solveSoftBodiesConstraints(btScalar timeStep)
{
 BT_PROFILE("solveSoftConstraints");

 if (m_softBodies.size())
 {
  btSoftBody::solveClusters(m_softBodies);
 }

 // Solve constraints solver-wise
 m_softBodySolver->solveConstraints(timeStep * m_softBodySolver->getTimeScale());

}

void	btSoftMultiBodyDynamicsWorld::addSoftBody(btSoftBody* body, int collisionFilterGroup, int collisionFilterMask)
{
 m_softBodies.push_back(body);

 // Set the soft body solver that will deal with this body
 // to be the world's solver
 body->setSoftBodySolver(m_softBodySolver);

 btCollisionWorld::addCollisionObject(body,
  collisionFilterGroup,
  collisionFilterMask);

}

void	btSoftMultiBodyDynamicsWorld::removeSoftBody(btSoftBody* body)
{
 m_softBodies.remove(body);

 btCollisionWorld::removeCollisionObject(body);
}

void	btSoftMultiBodyDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
 btSoftBody* body = btSoftBody::upcast(collisionObject);
 if (body)
  removeSoftBody(body);
 else
  btDiscreteDynamicsWorld::removeCollisionObject(collisionObject);
}

void	btSoftMultiBodyDynamicsWorld::debugDrawWorld()
{
 btDiscreteDynamicsWorld::debugDrawWorld();

 if (getDebugDrawer())
 {
  int i;
  for (i = 0; i<this->m_softBodies.size(); i++)
  {
   btSoftBody*	psb = (btSoftBody*)this->m_softBodies[i];
   if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe)))
   {
    btSoftBodyHelpers::DrawFrame(psb, m_debugDrawer);
    btSoftBodyHelpers::Draw(psb, m_debugDrawer, m_drawFlags);
   }

   if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
   {
    if (m_drawNodeTree)		btSoftBodyHelpers::DrawNodeTree(psb, m_debugDrawer);
    if (m_drawFaceTree)		btSoftBodyHelpers::DrawFaceTree(psb, m_debugDrawer);
    if (m_drawClusterTree)	btSoftBodyHelpers::DrawClusterTree(psb, m_debugDrawer);
   }
  }
 }
}




struct btSoftSingleRayCallback : public btBroadphaseRayCallback
{
 btVector3	m_rayFromWorld;
 btVector3	m_rayToWorld;
 btTransform	m_rayFromTrans;
 btTransform	m_rayToTrans;
 btVector3	m_hitNormal;

 const btSoftMultiBodyDynamicsWorld*	m_world;
 btCollisionWorld::RayResultCallback&	m_resultCallback;

 btSoftSingleRayCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld, const btSoftMultiBodyDynamicsWorld* world, btCollisionWorld::RayResultCallback& resultCallback)
  :m_rayFromWorld(rayFromWorld),
  m_rayToWorld(rayToWorld),
  m_world(world),
  m_resultCallback(resultCallback)
 {
  m_rayFromTrans.setIdentity();
  m_rayFromTrans.setOrigin(m_rayFromWorld);
  m_rayToTrans.setIdentity();
  m_rayToTrans.setOrigin(m_rayToWorld);

  btVector3 rayDir = (rayToWorld - rayFromWorld);

  rayDir.normalize();
  ///what about division by zero? --> just set rayDirection[i] to INF/1e30
  m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[0];
  m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[1];
  m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[2];
  m_signs[0] = m_rayDirectionInverse[0] < 0.0;
  m_signs[1] = m_rayDirectionInverse[1] < 0.0;
  m_signs[2] = m_rayDirectionInverse[2] < 0.0;

  m_lambda_max = rayDir.dot(m_rayToWorld - m_rayFromWorld);

 }



 virtual bool	process(const btBroadphaseProxy* proxy)
 {
  ///terminate further ray tests, once the closestHitFraction reached zero
  if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
   return false;

  btCollisionObject*	collisionObject = (btCollisionObject*)proxy->m_clientObject;

  //only perform raycast if filterMask matches
  if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
  {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   //btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
#if 0
#ifdef RECALCULATE_AABB
   btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
   collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
#else
   //getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
   const btVector3& collisionObjectAabbMin = collisionObject->getBroadphaseHandle()->m_aabbMin;
   const btVector3& collisionObjectAabbMax = collisionObject->getBroadphaseHandle()->m_aabbMax;
#endif
#endif
   //btScalar hitLambda = m_resultCallback.m_closestHitFraction;
   //culling already done by broadphase
   //if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
   {
    m_world->rayTestSingle(m_rayFromTrans, m_rayToTrans,
     collisionObject,
     collisionObject->getCollisionShape(),
     collisionObject->getWorldTransform(),
     m_resultCallback);
   }
  }
  return true;
 }
};

void	btSoftMultiBodyDynamicsWorld::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const
{
 BT_PROFILE("rayTest");
 /// use the broadphase to accelerate the search for objects, based on their aabb
 /// and for each object with ray-aabb overlap, perform an exact ray test
 btSoftSingleRayCallback rayCB(rayFromWorld, rayToWorld, this, resultCallback);

#ifndef USE_BRUTEFORCE_RAYBROADPHASE
 m_broadphasePairCache->rayTest(rayFromWorld, rayToWorld, rayCB);
#else
 for (int i = 0; i<this->getNumCollisionObjects(); i++)
 {
  rayCB.process(m_collisionObjects[i]->getBroadphaseHandle());
 }
#endif //USE_BRUTEFORCE_RAYBROADPHASE

}


void	btSoftMultiBodyDynamicsWorld::rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
 btCollisionObject* collisionObject,
 const btCollisionShape* collisionShape,
 const btTransform& colObjWorldTransform,
 RayResultCallback& resultCallback)
{
 if (collisionShape->isSoftBody()) {
  btSoftBody* softBody = btSoftBody::upcast(collisionObject);
  if (softBody) {
   btSoftBody::sRayCast softResult;
   if (softBody->rayTest(rayFromTrans.getOrigin(), rayToTrans.getOrigin(), softResult))
   {

    if (softResult.fraction <= resultCallback.m_closestHitFraction)
    {

     btCollisionWorld::LocalShapeInfo shapeInfo;
     shapeInfo.m_shapePart = 0;
     shapeInfo.m_triangleIndex = softResult.index;
     // get the normal
     btVector3 rayDir = rayToTrans.getOrigin() - rayFromTrans.getOrigin();
     btVector3 normal = -rayDir;
     normal.normalize();

     if (softResult.feature == btSoftBody::eFeature::Face)
     {
      normal = softBody->m_faces[softResult.index].m_normal;
      if (normal.dot(rayDir) > 0) {
       // normal always point toward origin of the ray
       normal = -normal;
      }
     }

     btCollisionWorld::LocalRayResult rayResult
     (collisionObject,
      &shapeInfo,
      normal,
      softResult.fraction);
     bool	normalInWorldSpace = true;
     resultCallback.addSingleResult(rayResult, normalInWorldSpace);
    }
   }
  }
 }
 else {
  btCollisionWorld::rayTestSingle(rayFromTrans, rayToTrans, collisionObject, collisionShape, colObjWorldTransform, resultCallback);
 }
}


void	btSoftMultiBodyDynamicsWorld::serializeSoftBodies(btSerializer* serializer)
{
 int i;
 //serialize all collision objects
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  if (colObj->getInternalType() & btCollisionObject::CO_SOFT_BODY)
  {
   int len = colObj->calculateSerializeBufferSize();
   btChunk* chunk = serializer->allocate(len, 1);
   const char* structType = colObj->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_SOFTBODY_CODE, colObj);
  }
 }

}

void	btSoftMultiBodyDynamicsWorld::serialize(btSerializer* serializer)
{

 serializer->startSerialization();

 serializeDynamicsWorldInfo(serializer);

 serializeSoftBodies(serializer);

 serializeRigidBodies(serializer);

 serializeCollisionObjects(serializer);

 serializer->finishSerialization();
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletSoftBody/btSoftRigidCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletSoftBody/btSoftBody.h"
#include "BulletSoftBody/btSoftBodySolvers.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

///TODO: include all the shapes that the softbody can collide with
///alternatively, implement special case collision algorithms (just like for rigid collision shapes)

//#include <stdio.h>

btSoftRigidCollisionAlgorithm::btSoftRigidCollisionAlgorithm(btPersistentManifold* /*mf*/, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper*, const btCollisionObjectWrapper*, bool isSwapped)
 : btCollisionAlgorithm(ci),
 //m_ownManifold(false),
 //m_manifoldPtr(mf),
 m_isSwapped(isSwapped)
{
}


btSoftRigidCollisionAlgorithm::~btSoftRigidCollisionAlgorithm()
{

 //m_softBody->m_overlappingRigidBodies.remove(m_rigidCollisionObject);

 /*if (m_ownManifold)
 {
 if (m_manifoldPtr)
 m_dispatcher->releaseManifold(m_manifoldPtr);
 }
 */

}


#include <stdio.h>

void btSoftRigidCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)dispatchInfo;
 (void)resultOut;
 //printf("btSoftRigidCollisionAlgorithm\n");
 //	const btCollisionObjectWrapper* softWrap = m_isSwapped?body1Wrap:body0Wrap;
 //	const btCollisionObjectWrapper* rigidWrap = m_isSwapped?body0Wrap:body1Wrap;
 btSoftBody* softBody = m_isSwapped ? (btSoftBody*)body1Wrap->getCollisionObject() : (btSoftBody*)body0Wrap->getCollisionObject();
 const btCollisionObjectWrapper* rigidCollisionObjectWrap = m_isSwapped ? body0Wrap : body1Wrap;

 if (softBody->m_collisionDisabledObjects.findLinearSearch(rigidCollisionObjectWrap->getCollisionObject()) == softBody->m_collisionDisabledObjects.size())
 {
  softBody->getSoftBodySolver()->processCollision(softBody, rigidCollisionObjectWrap);
 }


}

btScalar btSoftRigidCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* col0, btCollisionObject* col1, const btDispatcherInfo& dispatchInfo, btManifoldResult* resultOut)
{
 (void)resultOut;
 (void)dispatchInfo;
 (void)col0;
 (void)col1;

 //not yet
 return btScalar(1.);
}



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletSoftBody/btSoftRigidDynamicsWorld.h"
#include "LinearMath/btQuickprof.h"

//softbody & helpers
#include "BulletSoftBody/btSoftBody.h"
#include "BulletSoftBody/btSoftBodyHelpers.h"
#include "BulletSoftBody/btSoftBodySolvers.h"
#include "BulletSoftBody/btDefaultSoftBodySolver.h"
#include "LinearMath/btSerializer.h"


btSoftRigidDynamicsWorld::btSoftRigidDynamicsWorld(
 btDispatcher* dispatcher,
 btBroadphaseInterface* pairCache,
 btConstraintSolver* constraintSolver,
 btCollisionConfiguration* collisionConfiguration,
 btSoftBodySolver *softBodySolver) :
 btDiscreteDynamicsWorld(dispatcher, pairCache, constraintSolver, collisionConfiguration),
 m_softBodySolver(softBodySolver),
 m_ownsSolver(false)
{
 if (!m_softBodySolver)
 {
  void* ptr = btAlignedAlloc(sizeof(btDefaultSoftBodySolver), 16);
  m_softBodySolver = new(ptr) btDefaultSoftBodySolver();
  m_ownsSolver = true;
 }

 m_drawFlags = fDrawFlags::Std;
 m_drawNodeTree = true;
 m_drawFaceTree = false;
 m_drawClusterTree = false;
 m_sbi.m_broadphase = pairCache;
 m_sbi.m_dispatcher = dispatcher;
 m_sbi.m_sparsesdf.Initialize();
 m_sbi.m_sparsesdf.Reset();

 m_sbi.air_density = (btScalar)1.2;
 m_sbi.water_density = 0;
 m_sbi.water_offset = 0;
 m_sbi.water_normal = btVector3(0, 0, 0);
 m_sbi.m_gravity.setValue(0, -10, 0);

 m_sbi.m_sparsesdf.Initialize();


}

btSoftRigidDynamicsWorld::~btSoftRigidDynamicsWorld()
{
 if (m_ownsSolver)
 {
  m_softBodySolver->~btSoftBodySolver();
  btAlignedFree(m_softBodySolver);
 }
}

void	btSoftRigidDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
 btDiscreteDynamicsWorld::predictUnconstraintMotion(timeStep);
 {
  BT_PROFILE("predictUnconstraintMotionSoftBody");
  m_softBodySolver->predictMotion(float(timeStep));
 }
}

void	btSoftRigidDynamicsWorld::internalSingleStepSimulation(btScalar timeStep)
{

 // Let the solver grab the soft bodies and if necessary optimize for it
 m_softBodySolver->optimize(getSoftBodyArray());

 if (!m_softBodySolver->checkInitialized())
 {
  btAssert("Solver initialization failed\n");
 }

 btDiscreteDynamicsWorld::internalSingleStepSimulation(timeStep);

 ///solve soft bodies constraints
 solveSoftBodiesConstraints(timeStep);

 //self collisions
 for (int i = 0; i<m_softBodies.size(); i++)
 {
  btSoftBody*	psb = (btSoftBody*)m_softBodies[i];
  psb->defaultCollisionHandler(psb);
 }

 ///update soft bodies
 m_softBodySolver->updateSoftBodies();

 // End solver-wise simulation step
 // ///////////////////////////////

}

void	btSoftRigidDynamicsWorld::solveSoftBodiesConstraints(btScalar timeStep)
{
 BT_PROFILE("solveSoftConstraints");

 if (m_softBodies.size())
 {
  btSoftBody::solveClusters(m_softBodies);
 }

 // Solve constraints solver-wise
 m_softBodySolver->solveConstraints(timeStep * m_softBodySolver->getTimeScale());

}

void	btSoftRigidDynamicsWorld::addSoftBody(btSoftBody* body, int collisionFilterGroup, int collisionFilterMask)
{
 m_softBodies.push_back(body);

 // Set the soft body solver that will deal with this body
 // to be the world's solver
 body->setSoftBodySolver(m_softBodySolver);

 btCollisionWorld::addCollisionObject(body,
  collisionFilterGroup,
  collisionFilterMask);

}

void	btSoftRigidDynamicsWorld::removeSoftBody(btSoftBody* body)
{
 m_softBodies.remove(body);

 btCollisionWorld::removeCollisionObject(body);
}

void	btSoftRigidDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
 btSoftBody* body = btSoftBody::upcast(collisionObject);
 if (body)
  removeSoftBody(body);
 else
  btDiscreteDynamicsWorld::removeCollisionObject(collisionObject);
}

void	btSoftRigidDynamicsWorld::debugDrawWorld()
{
 btDiscreteDynamicsWorld::debugDrawWorld();

 if (getDebugDrawer())
 {
  int i;
  for (i = 0; i<this->m_softBodies.size(); i++)
  {
   btSoftBody*	psb = (btSoftBody*)this->m_softBodies[i];
   if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe)))
   {
    btSoftBodyHelpers::DrawFrame(psb, m_debugDrawer);
    btSoftBodyHelpers::Draw(psb, m_debugDrawer, m_drawFlags);
   }

   if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
   {
    if (m_drawNodeTree)		btSoftBodyHelpers::DrawNodeTree(psb, m_debugDrawer);
    if (m_drawFaceTree)		btSoftBodyHelpers::DrawFaceTree(psb, m_debugDrawer);
    if (m_drawClusterTree)	btSoftBodyHelpers::DrawClusterTree(psb, m_debugDrawer);
   }
  }
 }
}




struct btSoftSingleRayCallbackRigid : public btBroadphaseRayCallback
{
 btVector3	m_rayFromWorld;
 btVector3	m_rayToWorld;
 btTransform	m_rayFromTrans;
 btTransform	m_rayToTrans;
 btVector3	m_hitNormal;

 const btSoftRigidDynamicsWorld*	m_world;
 btCollisionWorld::RayResultCallback&	m_resultCallback;

 btSoftSingleRayCallbackRigid(const btVector3& rayFromWorld, const btVector3& rayToWorld, const btSoftRigidDynamicsWorld* world, btCollisionWorld::RayResultCallback& resultCallback)
  :m_rayFromWorld(rayFromWorld),
  m_rayToWorld(rayToWorld),
  m_world(world),
  m_resultCallback(resultCallback)
 {
  m_rayFromTrans.setIdentity();
  m_rayFromTrans.setOrigin(m_rayFromWorld);
  m_rayToTrans.setIdentity();
  m_rayToTrans.setOrigin(m_rayToWorld);

  btVector3 rayDir = (rayToWorld - rayFromWorld);

  rayDir.normalize();
  ///what about division by zero? --> just set rayDirection[i] to INF/1e30
  m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[0];
  m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[1];
  m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(1e30) : btScalar(1.0) / rayDir[2];
  m_signs[0] = m_rayDirectionInverse[0] < 0.0;
  m_signs[1] = m_rayDirectionInverse[1] < 0.0;
  m_signs[2] = m_rayDirectionInverse[2] < 0.0;

  m_lambda_max = rayDir.dot(m_rayToWorld - m_rayFromWorld);

 }



 virtual bool	process(const btBroadphaseProxy* proxy)
 {
  ///terminate further ray tests, once the closestHitFraction reached zero
  if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
   return false;

  btCollisionObject*	collisionObject = (btCollisionObject*)proxy->m_clientObject;

  //only perform raycast if filterMask matches
  if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
  {
   //RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
   //btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
#if 0
#ifdef RECALCULATE_AABB
   btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
   collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
#else
   //getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
   const btVector3& collisionObjectAabbMin = collisionObject->getBroadphaseHandle()->m_aabbMin;
   const btVector3& collisionObjectAabbMax = collisionObject->getBroadphaseHandle()->m_aabbMax;
#endif
#endif
   //btScalar hitLambda = m_resultCallback.m_closestHitFraction;
   //culling already done by broadphase
   //if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
   {
    m_world->rayTestSingle(m_rayFromTrans, m_rayToTrans,
     collisionObject,
     collisionObject->getCollisionShape(),
     collisionObject->getWorldTransform(),
     m_resultCallback);
   }
  }
  return true;
 }
};

void	btSoftRigidDynamicsWorld::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const
{
 BT_PROFILE("rayTest");
 /// use the broadphase to accelerate the search for objects, based on their aabb
 /// and for each object with ray-aabb overlap, perform an exact ray test
 btSoftSingleRayCallbackRigid rayCB(rayFromWorld, rayToWorld, this, resultCallback);

#ifndef USE_BRUTEFORCE_RAYBROADPHASE
 m_broadphasePairCache->rayTest(rayFromWorld, rayToWorld, rayCB);
#else
 for (int i = 0; i<this->getNumCollisionObjects(); i++)
 {
  rayCB.process(m_collisionObjects[i]->getBroadphaseHandle());
 }
#endif //USE_BRUTEFORCE_RAYBROADPHASE

}


void	btSoftRigidDynamicsWorld::rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
 btCollisionObject* collisionObject,
 const btCollisionShape* collisionShape,
 const btTransform& colObjWorldTransform,
 RayResultCallback& resultCallback)
{
 if (collisionShape->isSoftBody()) {
  btSoftBody* softBody = btSoftBody::upcast(collisionObject);
  if (softBody) {
   btSoftBody::sRayCast softResult;
   if (softBody->rayTest(rayFromTrans.getOrigin(), rayToTrans.getOrigin(), softResult))
   {

    if (softResult.fraction <= resultCallback.m_closestHitFraction)
    {

     btCollisionWorld::LocalShapeInfo shapeInfo;
     shapeInfo.m_shapePart = 0;
     shapeInfo.m_triangleIndex = softResult.index;
     // get the normal
     btVector3 rayDir = rayToTrans.getOrigin() - rayFromTrans.getOrigin();
     btVector3 normal = -rayDir;
     normal.normalize();

     if (softResult.feature == btSoftBody::eFeature::Face)
     {
      normal = softBody->m_faces[softResult.index].m_normal;
      if (normal.dot(rayDir) > 0) {
       // normal always point toward origin of the ray
       normal = -normal;
      }
     }

     btCollisionWorld::LocalRayResult rayResult
     (collisionObject,
      &shapeInfo,
      normal,
      softResult.fraction);
     bool	normalInWorldSpace = true;
     resultCallback.addSingleResult(rayResult, normalInWorldSpace);
    }
   }
  }
 }
 else {
  btCollisionWorld::rayTestSingle(rayFromTrans, rayToTrans, collisionObject, collisionShape, colObjWorldTransform, resultCallback);
 }
}


void	btSoftRigidDynamicsWorld::serializeSoftBodies(btSerializer* serializer)
{
 int i;
 //serialize all collision objects
 for (i = 0; i<m_collisionObjects.size(); i++)
 {
  btCollisionObject* colObj = m_collisionObjects[i];
  if (colObj->getInternalType() & btCollisionObject::CO_SOFT_BODY)
  {
   int len = colObj->calculateSerializeBufferSize();
   btChunk* chunk = serializer->allocate(len, 1);
   const char* structType = colObj->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_SOFTBODY_CODE, colObj);
  }
 }

}

void	btSoftRigidDynamicsWorld::serialize(btSerializer* serializer)
{

 serializer->startSerialization();

 serializeDynamicsWorldInfo(serializer);

 serializeSoftBodies(serializer);

 serializeRigidBodies(serializer);

 serializeCollisionObjects(serializer);

 serializer->finishSerialization();
}


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletSoftBody/btSoftSoftCollisionAlgorithm.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletSoftBody/btSoftBodySolvers.h"
#include "BulletSoftBody/btSoftBody.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

#define USE_PERSISTENT_CONTACTS 1

btSoftSoftCollisionAlgorithm::btSoftSoftCollisionAlgorithm(btPersistentManifold* /*mf*/, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* /*obj0*/, const btCollisionObjectWrapper* /*obj1*/)
 : btCollisionAlgorithm(ci)
 //m_ownManifold(false),
 //m_manifoldPtr(mf)
{
}

btSoftSoftCollisionAlgorithm::~btSoftSoftCollisionAlgorithm()
{
}

void btSoftSoftCollisionAlgorithm::processCollision(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
{
 btSoftBody* soft0 = (btSoftBody*)body0Wrap->getCollisionObject();
 btSoftBody* soft1 = (btSoftBody*)body1Wrap->getCollisionObject();
 soft0->getSoftBodySolver()->processCollision(soft0, soft1);
}

btScalar btSoftSoftCollisionAlgorithm::calculateTimeOfImpact(btCollisionObject* /*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
{
 //not yet
 return 1.f;
}

/*
* PURPOSE:
*   Class representing an articulated rigid body. Stores the body's
*   current state, allows forces and torques to be set, handles
*   timestepping and implements Featherstone's algorithm.
*
* COPYRIGHT:
*   Copyright (C) Stephen Thompson, <stephen@solarflare.org.uk>, 2011-2013
*   Portions written By Erwin Coumans: connection to LCP solver, various multibody constraints, replacing Eigen math library by Bullet LinearMath and a dedicated 6x6 matrix inverse (solveImatrix)
*   Portions written By Jakub Stepien: support for multi-DOF constraints, introduction of spatial algebra and several other improvements

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

*/


#include "BulletDynamics/Featherstone/btMultiBody.h"
#include "BulletDynamics/Featherstone/btMultiBodyLink.h"
#include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"
#include "BulletDynamics/Featherstone/btMultiBodyJointFeedback.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btSerializer.h"
//#include "Bullet3Common/b3Logging.h"
// #define INCLUDE_GYRO_TERM 

///todo: determine if we need these options. If so, make a proper API, otherwise delete those globals
bool gJointFeedbackInWorldSpace = false;
bool gJointFeedbackInJointFrame = false;

namespace {
 const btScalar SLEEP_EPSILON = btScalar(0.05);  // this is a squared velocity (m^2 s^-2)
 const btScalar SLEEP_TIMEOUT = btScalar(2);     // in seconds
}

namespace {
 void SpatialTransform(const btMatrix3x3 &rotation_matrix,  // rotates vectors in 'from' frame to vectors in 'to' frame
  const btVector3 &displacement,     // vector from origin of 'from' frame to origin of 'to' frame, in 'to' coordinates
  const btVector3 &top_in,       // top part of input vector
  const btVector3 &bottom_in,    // bottom part of input vector
  btVector3 &top_out,         // top part of output vector
  btVector3 &bottom_out)      // bottom part of output vector
 {
  top_out = rotation_matrix * top_in;
  bottom_out = -displacement.cross(top_out) + rotation_matrix * bottom_in;
 }

#if 0
 void InverseSpatialTransform(const btMatrix3x3 &rotation_matrix,
  const btVector3 &displacement,
  const btVector3 &top_in,
  const btVector3 &bottom_in,
  btVector3 &top_out,
  btVector3 &bottom_out)
 {
  top_out = rotation_matrix.transpose() * top_in;
  bottom_out = rotation_matrix.transpose() * (bottom_in + displacement.cross(top_in));
 }

 btScalar SpatialDotProduct(const btVector3 &a_top,
  const btVector3 &a_bottom,
  const btVector3 &b_top,
  const btVector3 &b_bottom)
 {
  return a_bottom.dot(b_top) + a_top.dot(b_bottom);
 }

 void SpatialCrossProduct(const btVector3 &a_top,
  const btVector3 &a_bottom,
  const btVector3 &b_top,
  const btVector3 &b_bottom,
  btVector3 &top_out,
  btVector3 &bottom_out)
 {
  top_out = a_top.cross(b_top);
  bottom_out = a_bottom.cross(b_top) + a_top.cross(b_bottom);
 }
#endif

}


//
// Implementation of class btMultiBody
//

btMultiBody::btMultiBody(int n_links,
 btScalar mass,
 const btVector3 &inertia,
 bool fixedBase,
 bool canSleep,
 bool /*deprecatedUseMultiDof*/)
 :
 m_baseCollider(0),
 m_baseName(0),
 m_basePos(0, 0, 0),
 m_baseQuat(0, 0, 0, 1),
 m_baseMass(mass),
 m_baseInertia(inertia),

 m_fixedBase(fixedBase),
 m_awake(true),
 m_canSleep(canSleep),
 m_sleepTimer(0),
 m_userObjectPointer(0),
 m_userIndex2(-1),
 m_userIndex(-1),
 m_linearDamping(0.04f),
 m_angularDamping(0.04f),
 m_useGyroTerm(true),
 m_maxAppliedImpulse(1000.f),
 m_maxCoordinateVelocity(100.f),
 m_hasSelfCollision(true),
 __posUpdated(false),
 m_dofCount(0),
 m_posVarCnt(0),
 m_useRK4(false),
 m_useGlobalVelocities(false),
 m_internalNeedsJointFeedback(false)
{
 m_cachedInertiaTopLeft.setValue(0, 0, 0, 0, 0, 0, 0, 0, 0);
 m_cachedInertiaTopRight.setValue(0, 0, 0, 0, 0, 0, 0, 0, 0);
 m_cachedInertiaLowerLeft.setValue(0, 0, 0, 0, 0, 0, 0, 0, 0);
 m_cachedInertiaLowerRight.setValue(0, 0, 0, 0, 0, 0, 0, 0, 0);
 m_cachedInertiaValid = false;

 m_links.resize(n_links);
 m_matrixBuf.resize(n_links + 1);

 m_baseForce.setValue(0, 0, 0);
 m_baseTorque.setValue(0, 0, 0);
}

btMultiBody::~btMultiBody()
{
}

void btMultiBody::setupFixed(int i,
 btScalar mass,
 const btVector3 &inertia,
 int parent,
 const btQuaternion &rotParentToThis,
 const btVector3 &parentComToThisPivotOffset,
 const btVector3 &thisPivotToThisComOffset, bool /*deprecatedDisableParentCollision*/)
{

 m_links[i].m_mass = mass;
 m_links[i].m_inertiaLocal = inertia;
 m_links[i].m_parent = parent;
 m_links[i].setAxisTop(0, 0., 0., 0.);
 m_links[i].setAxisBottom(0, btVector3(0, 0, 0));
 m_links[i].m_zeroRotParentToThis = rotParentToThis;
 m_links[i].m_dVector = thisPivotToThisComOffset;
 m_links[i].m_eVector = parentComToThisPivotOffset;

 m_links[i].m_jointType = btMultibodyLink::eFixed;
 m_links[i].m_dofCount = 0;
 m_links[i].m_posVarCount = 0;

 m_links[i].m_flags |= BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION;

 m_links[i].updateCacheMultiDof();

 updateLinksDofOffsets();

}


void btMultiBody::setupPrismatic(int i,
 btScalar mass,
 const btVector3 &inertia,
 int parent,
 const btQuaternion &rotParentToThis,
 const btVector3 &jointAxis,
 const btVector3 &parentComToThisPivotOffset,
 const btVector3 &thisPivotToThisComOffset,
 bool disableParentCollision)
{
 m_dofCount += 1;
 m_posVarCnt += 1;

 m_links[i].m_mass = mass;
 m_links[i].m_inertiaLocal = inertia;
 m_links[i].m_parent = parent;
 m_links[i].m_zeroRotParentToThis = rotParentToThis;
 m_links[i].setAxisTop(0, 0., 0., 0.);
 m_links[i].setAxisBottom(0, jointAxis);
 m_links[i].m_eVector = parentComToThisPivotOffset;
 m_links[i].m_dVector = thisPivotToThisComOffset;
 m_links[i].m_cachedRotParentToThis = rotParentToThis;

 m_links[i].m_jointType = btMultibodyLink::ePrismatic;
 m_links[i].m_dofCount = 1;
 m_links[i].m_posVarCount = 1;
 m_links[i].m_jointPos[0] = 0.f;
 m_links[i].m_jointTorque[0] = 0.f;

 if (disableParentCollision)
  m_links[i].m_flags |= BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION;
 //

 m_links[i].updateCacheMultiDof();

 updateLinksDofOffsets();
}

void btMultiBody::setupRevolute(int i,
 btScalar mass,
 const btVector3 &inertia,
 int parent,
 const btQuaternion &rotParentToThis,
 const btVector3 &jointAxis,
 const btVector3 &parentComToThisPivotOffset,
 const btVector3 &thisPivotToThisComOffset,
 bool disableParentCollision)
{
 m_dofCount += 1;
 m_posVarCnt += 1;

 m_links[i].m_mass = mass;
 m_links[i].m_inertiaLocal = inertia;
 m_links[i].m_parent = parent;
 m_links[i].m_zeroRotParentToThis = rotParentToThis;
 m_links[i].setAxisTop(0, jointAxis);
 m_links[i].setAxisBottom(0, jointAxis.cross(thisPivotToThisComOffset));
 m_links[i].m_dVector = thisPivotToThisComOffset;
 m_links[i].m_eVector = parentComToThisPivotOffset;

 m_links[i].m_jointType = btMultibodyLink::eRevolute;
 m_links[i].m_dofCount = 1;
 m_links[i].m_posVarCount = 1;
 m_links[i].m_jointPos[0] = 0.f;
 m_links[i].m_jointTorque[0] = 0.f;

 if (disableParentCollision)
  m_links[i].m_flags |= BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION;
 //
 m_links[i].updateCacheMultiDof();
 //
 updateLinksDofOffsets();
}



void btMultiBody::setupSpherical(int i,
 btScalar mass,
 const btVector3 &inertia,
 int parent,
 const btQuaternion &rotParentToThis,
 const btVector3 &parentComToThisPivotOffset,
 const btVector3 &thisPivotToThisComOffset,
 bool disableParentCollision)
{

 m_dofCount += 3;
 m_posVarCnt += 4;

 m_links[i].m_mass = mass;
 m_links[i].m_inertiaLocal = inertia;
 m_links[i].m_parent = parent;
 m_links[i].m_zeroRotParentToThis = rotParentToThis;
 m_links[i].m_dVector = thisPivotToThisComOffset;
 m_links[i].m_eVector = parentComToThisPivotOffset;

 m_links[i].m_jointType = btMultibodyLink::eSpherical;
 m_links[i].m_dofCount = 3;
 m_links[i].m_posVarCount = 4;
 m_links[i].setAxisTop(0, 1.f, 0.f, 0.f);
 m_links[i].setAxisTop(1, 0.f, 1.f, 0.f);
 m_links[i].setAxisTop(2, 0.f, 0.f, 1.f);
 m_links[i].setAxisBottom(0, m_links[i].getAxisTop(0).cross(thisPivotToThisComOffset));
 m_links[i].setAxisBottom(1, m_links[i].getAxisTop(1).cross(thisPivotToThisComOffset));
 m_links[i].setAxisBottom(2, m_links[i].getAxisTop(2).cross(thisPivotToThisComOffset));
 m_links[i].m_jointPos[0] = m_links[i].m_jointPos[1] = m_links[i].m_jointPos[2] = 0.f; m_links[i].m_jointPos[3] = 1.f;
 m_links[i].m_jointTorque[0] = m_links[i].m_jointTorque[1] = m_links[i].m_jointTorque[2] = 0.f;


 if (disableParentCollision)
  m_links[i].m_flags |= BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION;
 //
 m_links[i].updateCacheMultiDof();
 //
 updateLinksDofOffsets();
}

void btMultiBody::setupPlanar(int i,
 btScalar mass,
 const btVector3 &inertia,
 int parent,
 const btQuaternion &rotParentToThis,
 const btVector3 &rotationAxis,
 const btVector3 &parentComToThisComOffset,
 bool disableParentCollision)
{

 m_dofCount += 3;
 m_posVarCnt += 3;

 m_links[i].m_mass = mass;
 m_links[i].m_inertiaLocal = inertia;
 m_links[i].m_parent = parent;
 m_links[i].m_zeroRotParentToThis = rotParentToThis;
 m_links[i].m_dVector.setZero();
 m_links[i].m_eVector = parentComToThisComOffset;

 //
 btVector3 vecNonParallelToRotAxis(1, 0, 0);
 if (rotationAxis.normalized().dot(vecNonParallelToRotAxis) > 0.999)
  vecNonParallelToRotAxis.setValue(0, 1, 0);
 //

 m_links[i].m_jointType = btMultibodyLink::ePlanar;
 m_links[i].m_dofCount = 3;
 m_links[i].m_posVarCount = 3;
 btVector3 n = rotationAxis.normalized();
 m_links[i].setAxisTop(0, n[0], n[1], n[2]);
 m_links[i].setAxisTop(1, 0, 0, 0);
 m_links[i].setAxisTop(2, 0, 0, 0);
 m_links[i].setAxisBottom(0, 0, 0, 0);
 btVector3 cr = m_links[i].getAxisTop(0).cross(vecNonParallelToRotAxis);
 m_links[i].setAxisBottom(1, cr[0], cr[1], cr[2]);
 cr = m_links[i].getAxisBottom(1).cross(m_links[i].getAxisTop(0));
 m_links[i].setAxisBottom(2, cr[0], cr[1], cr[2]);
 m_links[i].m_jointPos[0] = m_links[i].m_jointPos[1] = m_links[i].m_jointPos[2] = 0.f;
 m_links[i].m_jointTorque[0] = m_links[i].m_jointTorque[1] = m_links[i].m_jointTorque[2] = 0.f;

 if (disableParentCollision)
  m_links[i].m_flags |= BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION;
 //
 m_links[i].updateCacheMultiDof();
 //
 updateLinksDofOffsets();
}

void btMultiBody::finalizeMultiDof()
{
 m_deltaV.resize(0);
 m_deltaV.resize(6 + m_dofCount);
 m_realBuf.resize(6 + m_dofCount + m_dofCount*m_dofCount + 6 + m_dofCount);			//m_dofCount for joint-space vels + m_dofCount^2 for "D" matrices + delta-pos vector (6 base "vels" + joint "vels")
 m_vectorBuf.resize(2 * m_dofCount);													//two 3-vectors (i.e. one six-vector) for each system dof	("h" matrices)

 updateLinksDofOffsets();
}

int btMultiBody::getParent(int i) const
{
 return m_links[i].m_parent;
}

btScalar btMultiBody::getLinkMass(int i) const
{
 return m_links[i].m_mass;
}

const btVector3 & btMultiBody::getLinkInertia(int i) const
{
 return m_links[i].m_inertiaLocal;
}

btScalar btMultiBody::getJointPos(int i) const
{
 return m_links[i].m_jointPos[0];
}

btScalar btMultiBody::getJointVel(int i) const
{
 return m_realBuf[6 + m_links[i].m_dofOffset];
}

btScalar * btMultiBody::getJointPosMultiDof(int i)
{
 return &m_links[i].m_jointPos[0];
}

btScalar * btMultiBody::getJointVelMultiDof(int i)
{
 return &m_realBuf[6 + m_links[i].m_dofOffset];
}

const btScalar * btMultiBody::getJointPosMultiDof(int i) const
{
 return &m_links[i].m_jointPos[0];
}

const btScalar * btMultiBody::getJointVelMultiDof(int i) const
{
 return &m_realBuf[6 + m_links[i].m_dofOffset];
}


void btMultiBody::setJointPos(int i, btScalar q)
{
 m_links[i].m_jointPos[0] = q;
 m_links[i].updateCacheMultiDof();
}

void btMultiBody::setJointPosMultiDof(int i, btScalar *q)
{
 for (int pos = 0; pos < m_links[i].m_posVarCount; ++pos)
  m_links[i].m_jointPos[pos] = q[pos];

 m_links[i].updateCacheMultiDof();
}

void btMultiBody::setJointVel(int i, btScalar qdot)
{
 m_realBuf[6 + m_links[i].m_dofOffset] = qdot;
}

void btMultiBody::setJointVelMultiDof(int i, btScalar *qdot)
{
 for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  m_realBuf[6 + m_links[i].m_dofOffset + dof] = qdot[dof];
}

const btVector3 & btMultiBody::getRVector(int i) const
{
 return m_links[i].m_cachedRVector;
}

const btQuaternion & btMultiBody::getParentToLocalRot(int i) const
{
 return m_links[i].m_cachedRotParentToThis;
}

btVector3 btMultiBody::localPosToWorld(int i, const btVector3 &local_pos) const
{
 btAssert(i >= -1);
 btAssert(i<m_links.size());
 if ((i<-1) || (i >= m_links.size()))
 {
  return btVector3(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
 }

 btVector3 result = local_pos;
 while (i != -1) {
  // 'result' is in frame i. transform it to frame parent(i)
  result += getRVector(i);
  result = quatRotate(getParentToLocalRot(i).inverse(), result);
  i = getParent(i);
 }

 // 'result' is now in the base frame. transform it to world frame
 result = quatRotate(getWorldToBaseRot().inverse(), result);
 result += getBasePos();

 return result;
}

btVector3 btMultiBody::worldPosToLocal(int i, const btVector3 &world_pos) const
{
 btAssert(i >= -1);
 btAssert(i<m_links.size());
 if ((i<-1) || (i >= m_links.size()))
 {
  return btVector3(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
 }

 if (i == -1) {
  // world to base
  return quatRotate(getWorldToBaseRot(), (world_pos - getBasePos()));
 }
 else {
  // find position in parent frame, then transform to current frame
  return quatRotate(getParentToLocalRot(i), worldPosToLocal(getParent(i), world_pos)) - getRVector(i);
 }
}

btVector3 btMultiBody::localDirToWorld(int i, const btVector3 &local_dir) const
{
 btAssert(i >= -1);
 btAssert(i<m_links.size());
 if ((i<-1) || (i >= m_links.size()))
 {
  return btVector3(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
 }


 btVector3 result = local_dir;
 while (i != -1) {
  result = quatRotate(getParentToLocalRot(i).inverse(), result);
  i = getParent(i);
 }
 result = quatRotate(getWorldToBaseRot().inverse(), result);
 return result;
}

btVector3 btMultiBody::worldDirToLocal(int i, const btVector3 &world_dir) const
{
 btAssert(i >= -1);
 btAssert(i<m_links.size());
 if ((i<-1) || (i >= m_links.size()))
 {
  return btVector3(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
 }

 if (i == -1) {
  return quatRotate(getWorldToBaseRot(), world_dir);
 }
 else {
  return quatRotate(getParentToLocalRot(i), worldDirToLocal(getParent(i), world_dir));
 }
}

btMatrix3x3 btMultiBody::localFrameToWorld(int i, const btMatrix3x3 &local_frame) const
{
 btMatrix3x3 result = local_frame;
 btVector3 frameInWorld0 = localDirToWorld(i, local_frame.getColumn(0));
 btVector3 frameInWorld1 = localDirToWorld(i, local_frame.getColumn(1));
 btVector3 frameInWorld2 = localDirToWorld(i, local_frame.getColumn(2));
 result.setValue(frameInWorld0[0], frameInWorld1[0], frameInWorld2[0], frameInWorld0[1], frameInWorld1[1], frameInWorld2[1], frameInWorld0[2], frameInWorld1[2], frameInWorld2[2]);
 return result;
}

void btMultiBody::compTreeLinkVelocities(btVector3 *omega, btVector3 *vel) const
{
 int num_links = getNumLinks();
 // Calculates the velocities of each link (and the base) in its local frame
 omega[0] = quatRotate(m_baseQuat, getBaseOmega());
 vel[0] = quatRotate(m_baseQuat, getBaseVel());

 for (int i = 0; i < num_links; ++i)
 {
  const int parent = m_links[i].m_parent;

  // transform parent vel into this frame, store in omega[i+1], vel[i+1]
  SpatialTransform(btMatrix3x3(m_links[i].m_cachedRotParentToThis), m_links[i].m_cachedRVector,
   omega[parent + 1], vel[parent + 1],
   omega[i + 1], vel[i + 1]);

  // now add qidot * shat_i
  //only supported for revolute/prismatic joints, todo: spherical and planar joints
  switch (m_links[i].m_jointType)
  {
  case btMultibodyLink::ePrismatic:
  case btMultibodyLink::eRevolute:
  {
   btVector3 axisTop = m_links[i].getAxisTop(0);
   btVector3 axisBottom = m_links[i].getAxisBottom(0);
   btScalar jointVel = getJointVel(i);
   omega[i + 1] += jointVel * axisTop;
   vel[i + 1] += jointVel * axisBottom;
   break;
  }
  default:
  {
  }
  }
 }
}

btScalar btMultiBody::getKineticEnergy() const
{
 int num_links = getNumLinks();
 // TODO: would be better not to allocate memory here
 btAlignedObjectArray<btVector3> omega; omega.resize(num_links + 1);
 btAlignedObjectArray<btVector3> vel; vel.resize(num_links + 1);
 compTreeLinkVelocities(&omega[0], &vel[0]);

 // we will do the factor of 0.5 at the end
 btScalar result = m_baseMass * vel[0].dot(vel[0]);
 result += omega[0].dot(m_baseInertia * omega[0]);

 for (int i = 0; i < num_links; ++i) {
  result += m_links[i].m_mass * vel[i + 1].dot(vel[i + 1]);
  result += omega[i + 1].dot(m_links[i].m_inertiaLocal * omega[i + 1]);
 }

 return 0.5f * result;
}

btVector3 btMultiBody::getAngularMomentum() const
{
 int num_links = getNumLinks();
 // TODO: would be better not to allocate memory here
 btAlignedObjectArray<btVector3> omega; omega.resize(num_links + 1);
 btAlignedObjectArray<btVector3> vel; vel.resize(num_links + 1);
 btAlignedObjectArray<btQuaternion> rot_from_world; rot_from_world.resize(num_links + 1);
 compTreeLinkVelocities(&omega[0], &vel[0]);

 rot_from_world[0] = m_baseQuat;
 btVector3 result = quatRotate(rot_from_world[0].inverse(), (m_baseInertia * omega[0]));

 for (int i = 0; i < num_links; ++i) {
  rot_from_world[i + 1] = m_links[i].m_cachedRotParentToThis * rot_from_world[m_links[i].m_parent + 1];
  result += (quatRotate(rot_from_world[i + 1].inverse(), (m_links[i].m_inertiaLocal * omega[i + 1])));
 }

 return result;
}

void btMultiBody::clearConstraintForces()
{
 m_baseConstraintForce.setValue(0, 0, 0);
 m_baseConstraintTorque.setValue(0, 0, 0);


 for (int i = 0; i < getNumLinks(); ++i) {
  m_links[i].m_appliedConstraintForce.setValue(0, 0, 0);
  m_links[i].m_appliedConstraintTorque.setValue(0, 0, 0);
 }
}
void btMultiBody::clearForcesAndTorques()
{
 m_baseForce.setValue(0, 0, 0);
 m_baseTorque.setValue(0, 0, 0);


 for (int i = 0; i < getNumLinks(); ++i) {
  m_links[i].m_appliedForce.setValue(0, 0, 0);
  m_links[i].m_appliedTorque.setValue(0, 0, 0);
  m_links[i].m_jointTorque[0] = m_links[i].m_jointTorque[1] = m_links[i].m_jointTorque[2] = m_links[i].m_jointTorque[3] = m_links[i].m_jointTorque[4] = m_links[i].m_jointTorque[5] = 0.f;
 }
}

void btMultiBody::clearVelocities()
{
 for (int i = 0; i < 6 + getNumDofs(); ++i)
 {
  m_realBuf[i] = 0.f;
 }
}
void btMultiBody::addLinkForce(int i, const btVector3 &f)
{
 m_links[i].m_appliedForce += f;
}

void btMultiBody::addLinkTorque(int i, const btVector3 &t)
{
 m_links[i].m_appliedTorque += t;
}

void btMultiBody::addLinkConstraintForce(int i, const btVector3 &f)
{
 m_links[i].m_appliedConstraintForce += f;
}

void btMultiBody::addLinkConstraintTorque(int i, const btVector3 &t)
{
 m_links[i].m_appliedConstraintTorque += t;
}



void btMultiBody::addJointTorque(int i, btScalar Q)
{
 m_links[i].m_jointTorque[0] += Q;
}

void btMultiBody::addJointTorqueMultiDof(int i, int dof, btScalar Q)
{
 m_links[i].m_jointTorque[dof] += Q;
}

void btMultiBody::addJointTorqueMultiDof(int i, const btScalar *Q)
{
 for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  m_links[i].m_jointTorque[dof] = Q[dof];
}

const btVector3 & btMultiBody::getLinkForce(int i) const
{
 return m_links[i].m_appliedForce;
}

const btVector3 & btMultiBody::getLinkTorque(int i) const
{
 return m_links[i].m_appliedTorque;
}

btScalar btMultiBody::getJointTorque(int i) const
{
 return m_links[i].m_jointTorque[0];
}

btScalar * btMultiBody::getJointTorqueMultiDof(int i)
{
 return &m_links[i].m_jointTorque[0];
}

inline btMatrix3x3 outerProduct(const btVector3& v0, const btVector3& v1)				//renamed it from vecMulVecTranspose (http://en.wikipedia.org/wiki/Outer_product); maybe it should be moved to btVector3 like dot and cross?
{
 btVector3 row0 = btVector3(
  v0.x() * v1.x(),
  v0.x() * v1.y(),
  v0.x() * v1.z());
 btVector3 row1 = btVector3(
  v0.y() * v1.x(),
  v0.y() * v1.y(),
  v0.y() * v1.z());
 btVector3 row2 = btVector3(
  v0.z() * v1.x(),
  v0.z() * v1.y(),
  v0.z() * v1.z());

 btMatrix3x3 m(row0[0], row0[1], row0[2],
  row1[0], row1[1], row1[2],
  row2[0], row2[1], row2[2]);
 return m;
}

#define vecMulVecTranspose(v0, v1Transposed) outerProduct(v0, v1Transposed)
//

void btMultiBody::computeAccelerationsArticulatedBodyAlgorithmMultiDof(btScalar dt,
 btAlignedObjectArray<btScalar> &scratch_r,
 btAlignedObjectArray<btVector3> &scratch_v,
 btAlignedObjectArray<btMatrix3x3> &scratch_m,
 bool isConstraintPass)
{
 // Implement Featherstone's algorithm to calculate joint accelerations (q_double_dot)
 // and the base linear & angular accelerations.

 // We apply damping forces in this routine as well as any external forces specified by the 
 // caller (via addBaseForce etc).

 // output should point to an array of 6 + num_links reals.
 // Format is: 3 angular accelerations (in world frame), 3 linear accelerations (in world frame),
 // num_links joint acceleration values.

 // We added support for multi degree of freedom (multi dof) joints.
 // In addition we also can compute the joint reaction forces. This is performed in a second pass,
 // so that we can include the effect of the constraint solver forces (computed in the PGS LCP solver)

 m_internalNeedsJointFeedback = false;

 int num_links = getNumLinks();

 const btScalar DAMPING_K1_LINEAR = m_linearDamping;
 const btScalar DAMPING_K2_LINEAR = m_linearDamping;

 const btScalar DAMPING_K1_ANGULAR = m_angularDamping;
 const btScalar DAMPING_K2_ANGULAR = m_angularDamping;

 btVector3 base_vel = getBaseVel();
 btVector3 base_omega = getBaseOmega();

 // Temporary matrices/vectors -- use scratch space from caller
 // so that we don't have to keep reallocating every frame

 scratch_r.resize(2 * m_dofCount + 6);				//multidof? ("Y"s use it and it is used to store qdd) => 2 x m_dofCount
 scratch_v.resize(8 * num_links + 6);
 scratch_m.resize(4 * num_links + 4);

 //btScalar * r_ptr = &scratch_r[0];
 btScalar * output = &scratch_r[m_dofCount];  // "output" holds the q_double_dot results
 btVector3 * v_ptr = &scratch_v[0];

 // vhat_i  (top = angular, bottom = linear part)	
 btSpatialMotionVector *spatVel = (btSpatialMotionVector *)v_ptr;
 v_ptr += num_links * 2 + 2;
 //
 // zhat_i^A    
 btSpatialForceVector * zeroAccSpatFrc = (btSpatialForceVector *)v_ptr;
 v_ptr += num_links * 2 + 2;
 //
 // chat_i  (note NOT defined for the base)    
 btSpatialMotionVector * spatCoriolisAcc = (btSpatialMotionVector *)v_ptr;
 v_ptr += num_links * 2;
 //
 // Ihat_i^A.    
 btSymmetricSpatialDyad * spatInertia = (btSymmetricSpatialDyad *)&scratch_m[num_links + 1];

 // Cached 3x3 rotation matrices from parent frame to this frame.
 btMatrix3x3 * rot_from_parent = &m_matrixBuf[0];
 btMatrix3x3 * rot_from_world = &scratch_m[0];

 // hhat_i, ahat_i
 // hhat is NOT stored for the base (but ahat is)    
 btSpatialForceVector * h = (btSpatialForceVector *)(m_dofCount > 0 ? &m_vectorBuf[0] : 0);
 btSpatialMotionVector * spatAcc = (btSpatialMotionVector *)v_ptr;
 v_ptr += num_links * 2 + 2;
 //
 // Y_i, invD_i
 btScalar * invD = m_dofCount > 0 ? &m_realBuf[6 + m_dofCount] : 0;
 btScalar * Y = &scratch_r[0];
 //
 //aux variables	
 btSpatialMotionVector spatJointVel;					//spatial velocity due to the joint motion (i.e. without predecessors' influence)
 btScalar D[36];										//"D" matrix; it's dofxdof for each body so asingle 6x6 D matrix will do	
 btScalar invD_times_Y[6];							//D^{-1} * Y [dofxdof x dofx1 = dofx1] <=> D^{-1} * u; better moved to buffers since it is recalced in calcAccelerationDeltasMultiDof; num_dof of btScalar would cover all bodies	
 btSpatialMotionVector result;							//holds results of the SolveImatrix op; it is a spatial motion vector (accel)
 btScalar Y_minus_hT_a[6];							//Y - h^{T} * a; it's dofx1 for each body so a single 6x1 temp is enough	
 btSpatialForceVector spatForceVecTemps[6];				//6 temporary spatial force vectors
 btSpatialTransformationMatrix fromParent;				//spatial transform from parent to child
 btSymmetricSpatialDyad dyadTemp;						//inertia matrix temp
 btSpatialTransformationMatrix fromWorld;
 fromWorld.m_trnVec.setZero();
 /////////////////

 // ptr to the joint accel part of the output
 btScalar * joint_accel = output + 6;

 // Start of the algorithm proper.

 // First 'upward' loop.
 // Combines CompTreeLinkVelocities and InitTreeLinks from Mirtich.

 rot_from_parent[0] = btMatrix3x3(m_baseQuat);				//m_baseQuat assumed to be alias!?

                                                  //create the vector of spatial velocity of the base by transforming global-coor linear and angular velocities into base-local coordinates
 spatVel[0].setVector(rot_from_parent[0] * base_omega, rot_from_parent[0] * base_vel);

 if (m_fixedBase)
 {
  zeroAccSpatFrc[0].setZero();
 }
 else
 {
  btVector3 baseForce = isConstraintPass ? m_baseConstraintForce : m_baseForce;
  btVector3 baseTorque = isConstraintPass ? m_baseConstraintTorque : m_baseTorque;
  //external forces		
  zeroAccSpatFrc[0].setVector(-(rot_from_parent[0] * baseTorque), -(rot_from_parent[0] * baseForce));

  //adding damping terms (only)
  btScalar linDampMult = 1., angDampMult = 1.;
  zeroAccSpatFrc[0].addVector(angDampMult * m_baseInertia * spatVel[0].getAngular() * (DAMPING_K1_ANGULAR + DAMPING_K2_ANGULAR * spatVel[0].getAngular().safeNorm()),
   linDampMult * m_baseMass * spatVel[0].getLinear() * (DAMPING_K1_LINEAR + DAMPING_K2_LINEAR * spatVel[0].getLinear().safeNorm()));

  //
  //p += vhat x Ihat vhat - done in a simpler way
  if (m_useGyroTerm)
   zeroAccSpatFrc[0].addAngular(spatVel[0].getAngular().cross(m_baseInertia * spatVel[0].getAngular()));
  //
  zeroAccSpatFrc[0].addLinear(m_baseMass * spatVel[0].getAngular().cross(spatVel[0].getLinear()));
 }


 //init the spatial AB inertia (it has the simple form thanks to choosing local body frames origins at their COMs)
 spatInertia[0].setMatrix(btMatrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0),
  //
  btMatrix3x3(m_baseMass, 0, 0,
   0, m_baseMass, 0,
   0, 0, m_baseMass),
  //
  btMatrix3x3(m_baseInertia[0], 0, 0,
   0, m_baseInertia[1], 0,
   0, 0, m_baseInertia[2])
 );

 rot_from_world[0] = rot_from_parent[0];

 //
 for (int i = 0; i < num_links; ++i) {
  const int parent = m_links[i].m_parent;
  rot_from_parent[i + 1] = btMatrix3x3(m_links[i].m_cachedRotParentToThis);
  rot_from_world[i + 1] = rot_from_parent[i + 1] * rot_from_world[parent + 1];

  fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;
  fromWorld.m_rotMat = rot_from_world[i + 1];
  fromParent.transform(spatVel[parent + 1], spatVel[i + 1]);

  // now set vhat_i to its true value by doing
  // vhat_i += qidot * shat_i			
  if (!m_useGlobalVelocities)
  {
   spatJointVel.setZero();

   for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
    spatJointVel += m_links[i].m_axes[dof] * getJointVelMultiDof(i)[dof];

   // remember vhat_i is really vhat_p(i) (but in current frame) at this point	=> we need to add velocity across the inboard joint
   spatVel[i + 1] += spatJointVel;

   //
   // vhat_i is vhat_p(i) transformed to local coors + the velocity across the i-th inboard joint
   //spatVel[i+1] = fromParent * spatVel[parent+1] + spatJointVel;

  }
  else
  {
   fromWorld.transformRotationOnly(m_links[i].m_absFrameTotVelocity, spatVel[i + 1]);
   fromWorld.transformRotationOnly(m_links[i].m_absFrameLocVelocity, spatJointVel);
  }

  // we can now calculate chat_i 		
  spatVel[i + 1].cross(spatJointVel, spatCoriolisAcc[i]);

  // calculate zhat_i^A
  //
  //external forces		
  btVector3 linkAppliedForce = isConstraintPass ? m_links[i].m_appliedConstraintForce : m_links[i].m_appliedForce;
  btVector3 linkAppliedTorque = isConstraintPass ? m_links[i].m_appliedConstraintTorque : m_links[i].m_appliedTorque;

  zeroAccSpatFrc[i + 1].setVector(-(rot_from_world[i + 1] * linkAppliedTorque), -(rot_from_world[i + 1] * linkAppliedForce));

#if 0	
  {

   b3Printf("stepVelocitiesMultiDof zeroAccSpatFrc[%d] linear:%f,%f,%f, angular:%f,%f,%f",
    i + 1,
    zeroAccSpatFrc[i + 1].m_topVec[0],
    zeroAccSpatFrc[i + 1].m_topVec[1],
    zeroAccSpatFrc[i + 1].m_topVec[2],

    zeroAccSpatFrc[i + 1].m_bottomVec[0],
    zeroAccSpatFrc[i + 1].m_bottomVec[1],
    zeroAccSpatFrc[i + 1].m_bottomVec[2]);
  }
#endif
  //
  //adding damping terms (only)
  btScalar linDampMult = 1., angDampMult = 1.;
  zeroAccSpatFrc[i + 1].addVector(angDampMult * m_links[i].m_inertiaLocal * spatVel[i + 1].getAngular() * (DAMPING_K1_ANGULAR + DAMPING_K2_ANGULAR * spatVel[i + 1].getAngular().safeNorm()),
   linDampMult * m_links[i].m_mass * spatVel[i + 1].getLinear() * (DAMPING_K1_LINEAR + DAMPING_K2_LINEAR * spatVel[i + 1].getLinear().safeNorm()));

  // calculate Ihat_i^A
  //init the spatial AB inertia (it has the simple form thanks to choosing local body frames origins at their COMs)
  spatInertia[i + 1].setMatrix(btMatrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0),
   //
   btMatrix3x3(m_links[i].m_mass, 0, 0,
    0, m_links[i].m_mass, 0,
    0, 0, m_links[i].m_mass),
   //
   btMatrix3x3(m_links[i].m_inertiaLocal[0], 0, 0,
    0, m_links[i].m_inertiaLocal[1], 0,
    0, 0, m_links[i].m_inertiaLocal[2])
  );
  //
  //p += vhat x Ihat vhat - done in a simpler way
  if (m_useGyroTerm)
   zeroAccSpatFrc[i + 1].addAngular(spatVel[i + 1].getAngular().cross(m_links[i].m_inertiaLocal * spatVel[i + 1].getAngular()));
  //		
  zeroAccSpatFrc[i + 1].addLinear(m_links[i].m_mass * spatVel[i + 1].getAngular().cross(spatVel[i + 1].getLinear()));
  //btVector3 temp = m_links[i].m_mass * spatVel[i+1].getAngular().cross(spatVel[i+1].getLinear());
  ////clamp parent's omega
  //btScalar parOmegaMod = temp.length();
  //btScalar parOmegaModMax = 1000;
  //if(parOmegaMod > parOmegaModMax)
  //	temp *= parOmegaModMax / parOmegaMod;
  //zeroAccSpatFrc[i+1].addLinear(temp);
  //printf("|zeroAccSpatFrc[%d]| = %.4f\n", i+1, temp.length());
  //temp = spatCoriolisAcc[i].getLinear();
  //printf("|spatCoriolisAcc[%d]| = %.4f\n", i+1, temp.length());



  //printf("w[%d] = [%.4f %.4f %.4f]\n", i, vel_top_angular[i+1].x(), vel_top_angular[i+1].y(), vel_top_angular[i+1].z());
  //printf("v[%d] = [%.4f %.4f %.4f]\n", i, vel_bottom_linear[i+1].x(), vel_bottom_linear[i+1].y(), vel_bottom_linear[i+1].z());		
  //printf("c[%d] = [%.4f %.4f %.4f]\n", i, coriolis_bottom_linear[i].x(), coriolis_bottom_linear[i].y(), coriolis_bottom_linear[i].z());
 }

 // 'Downward' loop.
 // (part of TreeForwardDynamics in Mirtich.)
 for (int i = num_links - 1; i >= 0; --i)
 {
  const int parent = m_links[i].m_parent;
  fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //
   hDof = spatInertia[i + 1] * m_links[i].m_axes[dof];
   //
   Y[m_links[i].m_dofOffset + dof] = m_links[i].m_jointTorque[dof]
    - m_links[i].m_axes[dof].dot(zeroAccSpatFrc[i + 1])
    - spatCoriolisAcc[i].dot(hDof)
    ;
  }

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   btScalar *D_row = &D[dof * m_links[i].m_dofCount];
   for (int dof2 = 0; dof2 < m_links[i].m_dofCount; ++dof2)
   {
    btSpatialForceVector &hDof2 = h[m_links[i].m_dofOffset + dof2];
    D_row[dof2] = m_links[i].m_axes[dof].dot(hDof2);
   }
  }

  btScalar *invDi = &invD[m_links[i].m_dofOffset*m_links[i].m_dofOffset];
  switch (m_links[i].m_jointType)
  {
  case btMultibodyLink::ePrismatic:
  case btMultibodyLink::eRevolute:
  {
   invDi[0] = 1.0f / D[0];
   break;
  }
  case btMultibodyLink::eSpherical:
  case btMultibodyLink::ePlanar:
  {
   btMatrix3x3 D3x3; D3x3.setValue(D[0], D[1], D[2], D[3], D[4], D[5], D[6], D[7], D[8]);
   btMatrix3x3 invD3x3; invD3x3 = D3x3.inverse();

   //unroll the loop?
   for (int row = 0; row < 3; ++row)
   {
    for (int col = 0; col < 3; ++col)
    {
     invDi[row * 3 + col] = invD3x3[row][col];
    }
   }

   break;
  }
  default:
  {

  }
  }

  //determine h*D^{-1}
  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   spatForceVecTemps[dof].setZero();

   for (int dof2 = 0; dof2 < m_links[i].m_dofCount; ++dof2)
   {
    btSpatialForceVector &hDof2 = h[m_links[i].m_dofOffset + dof2];
    //				
    spatForceVecTemps[dof] += hDof2 * invDi[dof2 * m_links[i].m_dofCount + dof];
   }
  }

  dyadTemp = spatInertia[i + 1];

  //determine (h*D^{-1}) * h^{T}
  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //
   dyadTemp -= symmetricSpatialOuterProduct(hDof, spatForceVecTemps[dof]);
  }

  fromParent.transformInverse(dyadTemp, spatInertia[parent + 1], btSpatialTransformationMatrix::Add);

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   invD_times_Y[dof] = 0.f;

   for (int dof2 = 0; dof2 < m_links[i].m_dofCount; ++dof2)
   {
    invD_times_Y[dof] += invDi[dof * m_links[i].m_dofCount + dof2] * Y[m_links[i].m_dofOffset + dof2];
   }
  }

  spatForceVecTemps[0] = zeroAccSpatFrc[i + 1] + spatInertia[i + 1] * spatCoriolisAcc[i];

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //
   spatForceVecTemps[0] += hDof * invD_times_Y[dof];
  }

  fromParent.transformInverse(spatForceVecTemps[0], spatForceVecTemps[1]);

  zeroAccSpatFrc[parent + 1] += spatForceVecTemps[1];
 }


 // Second 'upward' loop
 // (part of TreeForwardDynamics in Mirtich)

 if (m_fixedBase)
 {
  spatAcc[0].setZero();
 }
 else
 {
  if (num_links > 0)
  {
   m_cachedInertiaValid = true;
   m_cachedInertiaTopLeft = spatInertia[0].m_topLeftMat;
   m_cachedInertiaTopRight = spatInertia[0].m_topRightMat;
   m_cachedInertiaLowerLeft = spatInertia[0].m_bottomLeftMat;
   m_cachedInertiaLowerRight = spatInertia[0].m_topLeftMat.transpose();

  }

  solveImatrix(zeroAccSpatFrc[0], result);
  spatAcc[0] = -result;
 }


 // now do the loop over the m_links
 for (int i = 0; i < num_links; ++i)
 {
  //	qdd = D^{-1} * (Y - h^{T}*apar) = (S^{T}*I*S)^{-1} * (tau - S^{T}*I*cor - S^{T}*zeroAccFrc - S^{T}*I*apar)
  //	a = apar + cor + Sqdd
  //or
  //	qdd = D^{-1} * (Y - h^{T}*(apar+cor))
  //	a = apar + Sqdd

  const int parent = m_links[i].m_parent;
  fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;

  fromParent.transform(spatAcc[parent + 1], spatAcc[i + 1]);

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //			
   Y_minus_hT_a[dof] = Y[m_links[i].m_dofOffset + dof] - spatAcc[i + 1].dot(hDof);
  }

  btScalar *invDi = &invD[m_links[i].m_dofOffset*m_links[i].m_dofOffset];
  //D^{-1} * (Y - h^{T}*apar)
  mulMatrix(invDi, Y_minus_hT_a, m_links[i].m_dofCount, m_links[i].m_dofCount, m_links[i].m_dofCount, 1, &joint_accel[m_links[i].m_dofOffset]);

  spatAcc[i + 1] += spatCoriolisAcc[i];

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
   spatAcc[i + 1] += m_links[i].m_axes[dof] * joint_accel[m_links[i].m_dofOffset + dof];

  if (m_links[i].m_jointFeedback)
  {
   m_internalNeedsJointFeedback = true;

   btVector3 angularBotVec = (spatInertia[i + 1] * spatAcc[i + 1] + zeroAccSpatFrc[i + 1]).m_bottomVec;
   btVector3 linearTopVec = (spatInertia[i + 1] * spatAcc[i + 1] + zeroAccSpatFrc[i + 1]).m_topVec;

   if (gJointFeedbackInJointFrame)
   {
    //shift the reaction forces to the joint frame
    //linear (force) component is the same
    //shift the angular (torque, moment) component using the relative position,  m_links[i].m_dVector
    angularBotVec = angularBotVec - linearTopVec.cross(m_links[i].m_dVector);
   }


   if (gJointFeedbackInWorldSpace)
   {
    if (isConstraintPass)
    {
     m_links[i].m_jointFeedback->m_reactionForces.m_bottomVec += m_links[i].m_cachedWorldTransform.getBasis()*angularBotVec;
     m_links[i].m_jointFeedback->m_reactionForces.m_topVec += m_links[i].m_cachedWorldTransform.getBasis()*linearTopVec;
    }
    else
    {
     m_links[i].m_jointFeedback->m_reactionForces.m_bottomVec = m_links[i].m_cachedWorldTransform.getBasis()*angularBotVec;
     m_links[i].m_jointFeedback->m_reactionForces.m_topVec = m_links[i].m_cachedWorldTransform.getBasis()*linearTopVec;
    }
   }
   else
   {
    if (isConstraintPass)
    {
     m_links[i].m_jointFeedback->m_reactionForces.m_bottomVec += angularBotVec;
     m_links[i].m_jointFeedback->m_reactionForces.m_topVec += linearTopVec;

    }
    else
    {
     m_links[i].m_jointFeedback->m_reactionForces.m_bottomVec = angularBotVec;
     m_links[i].m_jointFeedback->m_reactionForces.m_topVec = linearTopVec;
    }
   }
  }

 }

 // transform base accelerations back to the world frame.
 btVector3 omegadot_out = rot_from_parent[0].transpose() * spatAcc[0].getAngular();
 output[0] = omegadot_out[0];
 output[1] = omegadot_out[1];
 output[2] = omegadot_out[2];

 btVector3 vdot_out = rot_from_parent[0].transpose() * (spatAcc[0].getLinear() + spatVel[0].getAngular().cross(spatVel[0].getLinear()));
 output[3] = vdot_out[0];
 output[4] = vdot_out[1];
 output[5] = vdot_out[2];

 /////////////////
 //printf("q = [");
 //printf("%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f ", m_baseQuat.x(), m_baseQuat.y(), m_baseQuat.z(), m_baseQuat.w(), m_basePos.x(), m_basePos.y(), m_basePos.z());
 //for(int link = 0; link < getNumLinks(); ++link)
 //	for(int dof = 0; dof < m_links[link].m_dofCount; ++dof)
 //		printf("%.6f ", m_links[link].m_jointPos[dof]);
 //printf("]\n");
 ////
 //printf("qd = [");
 //for(int dof = 0; dof < getNumDofs() + 6; ++dof)
 //	printf("%.6f ", m_realBuf[dof]);
 //printf("]\n");
 //printf("qdd = [");
 //for(int dof = 0; dof < getNumDofs() + 6; ++dof)
 //	printf("%.6f ", output[dof]);
 //printf("]\n");
 /////////////////

 // Final step: add the accelerations (times dt) to the velocities.

 if (!isConstraintPass)
 {
  if (dt > 0.)
   applyDeltaVeeMultiDof(output, dt);

 }
 /////
 //btScalar angularThres = 1;
 //btScalar maxAngVel = 0.;		
 //bool scaleDown = 1.;
 //for(int link = 0; link < m_links.size(); ++link)
 //{		
 //	if(spatVel[link+1].getAngular().length() > maxAngVel)
 //	{
 //		maxAngVel = spatVel[link+1].getAngular().length();
 //		scaleDown = angularThres / spatVel[link+1].getAngular().length();
 //		break;
 //	}		
 //}

 //if(scaleDown != 1.)
 //{
 //	for(int link = 0; link < m_links.size(); ++link)
 //	{
 //		if(m_links[link].m_jointType == btMultibodyLink::eRevolute || m_links[link].m_jointType == btMultibodyLink::eSpherical)
 //		{
 //			for(int dof = 0; dof < m_links[link].m_dofCount; ++dof)
 //				getJointVelMultiDof(link)[dof] *= scaleDown;
 //		}
 //	}
 //}
 /////

 /////////////////////
 if (m_useGlobalVelocities)
 {
  for (int i = 0; i < num_links; ++i)
  {
   const int parent = m_links[i].m_parent;
   //rot_from_parent[i+1] = btMatrix3x3(m_links[i].m_cachedRotParentToThis);    /// <- done
   //rot_from_world[i+1] = rot_from_parent[i+1] * rot_from_world[parent+1];		/// <- done

   fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;
   fromWorld.m_rotMat = rot_from_world[i + 1];

   // vhat_i = i_xhat_p(i) * vhat_p(i)		
   fromParent.transform(spatVel[parent + 1], spatVel[i + 1]);
   //nice alternative below (using operator *) but it generates temps
   /////////////////////////////////////////////////////////////

   // now set vhat_i to its true value by doing
   // vhat_i += qidot * shat_i			
   spatJointVel.setZero();

   for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
    spatJointVel += m_links[i].m_axes[dof] * getJointVelMultiDof(i)[dof];

   // remember vhat_i is really vhat_p(i) (but in current frame) at this point	=> we need to add velocity across the inboard joint
   spatVel[i + 1] += spatJointVel;


   fromWorld.transformInverseRotationOnly(spatVel[i + 1], m_links[i].m_absFrameTotVelocity);
   fromWorld.transformInverseRotationOnly(spatJointVel, m_links[i].m_absFrameLocVelocity);
  }
 }

}



void btMultiBody::solveImatrix(const btVector3& rhs_top, const btVector3& rhs_bot, btScalar result[6]) const
{
 int num_links = getNumLinks();
 ///solve I * x = rhs, so the result = invI * rhs
 if (num_links == 0)
 {
  // in the case of 0 m_links (i.e. a plain rigid body, not a multibody) rhs * invI is easier
  result[0] = rhs_bot[0] / m_baseInertia[0];
  result[1] = rhs_bot[1] / m_baseInertia[1];
  result[2] = rhs_bot[2] / m_baseInertia[2];
  result[3] = rhs_top[0] / m_baseMass;
  result[4] = rhs_top[1] / m_baseMass;
  result[5] = rhs_top[2] / m_baseMass;
 }
 else
 {
  if (!m_cachedInertiaValid)
  {
   for (int i = 0; i<6; i++)
   {
    result[i] = 0.f;
   }
   return;
  }
  /// Special routine for calculating the inverse of a spatial inertia matrix
  ///the 6x6 matrix is stored as 4 blocks of 3x3 matrices
  btMatrix3x3 Binv = m_cachedInertiaTopRight.inverse()*-1.f;
  btMatrix3x3 tmp = m_cachedInertiaLowerRight * Binv;
  btMatrix3x3 invIupper_right = (tmp * m_cachedInertiaTopLeft + m_cachedInertiaLowerLeft).inverse();
  tmp = invIupper_right * m_cachedInertiaLowerRight;
  btMatrix3x3 invI_upper_left = (tmp * Binv);
  btMatrix3x3 invI_lower_right = (invI_upper_left).transpose();
  tmp = m_cachedInertiaTopLeft  * invI_upper_left;
  tmp[0][0] -= 1.0;
  tmp[1][1] -= 1.0;
  tmp[2][2] -= 1.0;
  btMatrix3x3 invI_lower_left = (Binv * tmp);

  //multiply result = invI * rhs
  {
   btVector3 vtop = invI_upper_left*rhs_top;
   btVector3 tmp;
   tmp = invIupper_right * rhs_bot;
   vtop += tmp;
   btVector3 vbot = invI_lower_left*rhs_top;
   tmp = invI_lower_right * rhs_bot;
   vbot += tmp;
   result[0] = vtop[0];
   result[1] = vtop[1];
   result[2] = vtop[2];
   result[3] = vbot[0];
   result[4] = vbot[1];
   result[5] = vbot[2];
  }

 }
}
void btMultiBody::solveImatrix(const btSpatialForceVector &rhs, btSpatialMotionVector &result) const
{
 int num_links = getNumLinks();
 ///solve I * x = rhs, so the result = invI * rhs
 if (num_links == 0)
 {
  // in the case of 0 m_links (i.e. a plain rigid body, not a multibody) rhs * invI is easier
  result.setAngular(rhs.getAngular() / m_baseInertia);
  result.setLinear(rhs.getLinear() / m_baseMass);
 }
 else
 {
  /// Special routine for calculating the inverse of a spatial inertia matrix
  ///the 6x6 matrix is stored as 4 blocks of 3x3 matrices
  if (!m_cachedInertiaValid)
  {
   result.setLinear(btVector3(0, 0, 0));
   result.setAngular(btVector3(0, 0, 0));
   result.setVector(btVector3(0, 0, 0), btVector3(0, 0, 0));
   return;
  }
  btMatrix3x3 Binv = m_cachedInertiaTopRight.inverse()*-1.f;
  btMatrix3x3 tmp = m_cachedInertiaLowerRight * Binv;
  btMatrix3x3 invIupper_right = (tmp * m_cachedInertiaTopLeft + m_cachedInertiaLowerLeft).inverse();
  tmp = invIupper_right * m_cachedInertiaLowerRight;
  btMatrix3x3 invI_upper_left = (tmp * Binv);
  btMatrix3x3 invI_lower_right = (invI_upper_left).transpose();
  tmp = m_cachedInertiaTopLeft  * invI_upper_left;
  tmp[0][0] -= 1.0;
  tmp[1][1] -= 1.0;
  tmp[2][2] -= 1.0;
  btMatrix3x3 invI_lower_left = (Binv * tmp);

  //multiply result = invI * rhs
  {
   btVector3 vtop = invI_upper_left*rhs.getLinear();
   btVector3 tmp;
   tmp = invIupper_right * rhs.getAngular();
   vtop += tmp;
   btVector3 vbot = invI_lower_left*rhs.getLinear();
   tmp = invI_lower_right * rhs.getAngular();
   vbot += tmp;
   result.setVector(vtop, vbot);
  }

 }
}

void btMultiBody::mulMatrix(btScalar *pA, btScalar *pB, int rowsA, int colsA, int rowsB, int colsB, btScalar *pC) const
{
 for (int row = 0; row < rowsA; row++)
 {
  for (int col = 0; col < colsB; col++)
  {
   pC[row * colsB + col] = 0.f;
   for (int inner = 0; inner < rowsB; inner++)
   {
    pC[row * colsB + col] += pA[row * colsA + inner] * pB[col + inner * colsB];
   }
  }
 }
}

void btMultiBody::calcAccelerationDeltasMultiDof(const btScalar *force, btScalar *output,
 btAlignedObjectArray<btScalar> &scratch_r, btAlignedObjectArray<btVector3> &scratch_v) const
{
 // Temporary matrices/vectors -- use scratch space from caller
 // so that we don't have to keep reallocating every frame


 int num_links = getNumLinks();
 scratch_r.resize(m_dofCount);
 scratch_v.resize(4 * num_links + 4);

 btScalar * r_ptr = m_dofCount ? &scratch_r[0] : 0;
 btVector3 * v_ptr = &scratch_v[0];

 // zhat_i^A (scratch space)
 btSpatialForceVector * zeroAccSpatFrc = (btSpatialForceVector *)v_ptr;
 v_ptr += num_links * 2 + 2;

 // rot_from_parent (cached from calcAccelerations)
 const btMatrix3x3 * rot_from_parent = &m_matrixBuf[0];

 // hhat (cached), accel (scratch)
 // hhat is NOT stored for the base (but ahat is) 
 const btSpatialForceVector * h = (btSpatialForceVector *)(m_dofCount > 0 ? &m_vectorBuf[0] : 0);
 btSpatialMotionVector * spatAcc = (btSpatialMotionVector *)v_ptr;
 v_ptr += num_links * 2 + 2;

 // Y_i (scratch), invD_i (cached)
 const btScalar * invD = m_dofCount > 0 ? &m_realBuf[6 + m_dofCount] : 0;
 btScalar * Y = r_ptr;
 ////////////////
 //aux variables
 btScalar invD_times_Y[6];							//D^{-1} * Y [dofxdof x dofx1 = dofx1] <=> D^{-1} * u; better moved to buffers since it is recalced in calcAccelerationDeltasMultiDof; num_dof of btScalar would cover all bodies
 btSpatialMotionVector result;							//holds results of the SolveImatrix op; it is a spatial motion vector (accel)
 btScalar Y_minus_hT_a[6];							//Y - h^{T} * a; it's dofx1 for each body so a single 6x1 temp is enough	
 btSpatialForceVector spatForceVecTemps[6];				//6 temporary spatial force vectors
 btSpatialTransformationMatrix fromParent;
 /////////////////

 // First 'upward' loop.
 // Combines CompTreeLinkVelocities and InitTreeLinks from Mirtich.

 // Fill in zero_acc
 // -- set to force/torque on the base, zero otherwise
 if (m_fixedBase)
 {
  zeroAccSpatFrc[0].setZero();
 }
 else
 {
  //test forces
  fromParent.m_rotMat = rot_from_parent[0];
  fromParent.transformRotationOnly(btSpatialForceVector(-force[0], -force[1], -force[2], -force[3], -force[4], -force[5]), zeroAccSpatFrc[0]);
 }
 for (int i = 0; i < num_links; ++i)
 {
  zeroAccSpatFrc[i + 1].setZero();
 }

 // 'Downward' loop.
 // (part of TreeForwardDynamics in Mirtich.)
 for (int i = num_links - 1; i >= 0; --i)
 {
  const int parent = m_links[i].m_parent;
  fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   Y[m_links[i].m_dofOffset + dof] = force[6 + m_links[i].m_dofOffset + dof]
    - m_links[i].m_axes[dof].dot(zeroAccSpatFrc[i + 1])
    ;
  }

  btVector3 in_top, in_bottom, out_top, out_bottom;
  const btScalar *invDi = &invD[m_links[i].m_dofOffset*m_links[i].m_dofOffset];

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   invD_times_Y[dof] = 0.f;

   for (int dof2 = 0; dof2 < m_links[i].m_dofCount; ++dof2)
   {
    invD_times_Y[dof] += invDi[dof * m_links[i].m_dofCount + dof2] * Y[m_links[i].m_dofOffset + dof2];
   }
  }

  // Zp += pXi * (Zi + hi*Yi/Di)
  spatForceVecTemps[0] = zeroAccSpatFrc[i + 1];

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   const btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //
   spatForceVecTemps[0] += hDof * invD_times_Y[dof];
  }


  fromParent.transformInverse(spatForceVecTemps[0], spatForceVecTemps[1]);

  zeroAccSpatFrc[parent + 1] += spatForceVecTemps[1];
 }

 // ptr to the joint accel part of the output
 btScalar * joint_accel = output + 6;


 // Second 'upward' loop
 // (part of TreeForwardDynamics in Mirtich)

 if (m_fixedBase)
 {
  spatAcc[0].setZero();
 }
 else
 {
  solveImatrix(zeroAccSpatFrc[0], result);
  spatAcc[0] = -result;

 }

 // now do the loop over the m_links
 for (int i = 0; i < num_links; ++i)
 {
  const int parent = m_links[i].m_parent;
  fromParent.m_rotMat = rot_from_parent[i + 1]; fromParent.m_trnVec = m_links[i].m_cachedRVector;

  fromParent.transform(spatAcc[parent + 1], spatAcc[i + 1]);

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
  {
   const btSpatialForceVector &hDof = h[m_links[i].m_dofOffset + dof];
   //			
   Y_minus_hT_a[dof] = Y[m_links[i].m_dofOffset + dof] - spatAcc[i + 1].dot(hDof);
  }

  const btScalar *invDi = &invD[m_links[i].m_dofOffset*m_links[i].m_dofOffset];
  mulMatrix(const_cast<btScalar*>(invDi), Y_minus_hT_a, m_links[i].m_dofCount, m_links[i].m_dofCount, m_links[i].m_dofCount, 1, &joint_accel[m_links[i].m_dofOffset]);

  for (int dof = 0; dof < m_links[i].m_dofCount; ++dof)
   spatAcc[i + 1] += m_links[i].m_axes[dof] * joint_accel[m_links[i].m_dofOffset + dof];
 }

 // transform base accelerations back to the world frame.
 btVector3 omegadot_out;
 omegadot_out = rot_from_parent[0].transpose() * spatAcc[0].getAngular();
 output[0] = omegadot_out[0];
 output[1] = omegadot_out[1];
 output[2] = omegadot_out[2];

 btVector3 vdot_out;
 vdot_out = rot_from_parent[0].transpose() * spatAcc[0].getLinear();
 output[3] = vdot_out[0];
 output[4] = vdot_out[1];
 output[5] = vdot_out[2];

 /////////////////
 //printf("delta = [");
 //for(int dof = 0; dof < getNumDofs() + 6; ++dof)
 //	printf("%.2f ", output[dof]);
 //printf("]\n");
 /////////////////
}




void btMultiBody::stepPositionsMultiDof(btScalar dt, btScalar *pq, btScalar *pqd)
{
 int num_links = getNumLinks();
 // step position by adding dt * velocity
 //btVector3 v = getBaseVel();	
 //m_basePos += dt * v;
 //
 btScalar *pBasePos = (pq ? &pq[4] : m_basePos);
 btScalar *pBaseVel = (pqd ? &pqd[3] : &m_realBuf[3]);			//note: the !pqd case assumes m_realBuf holds with base velocity at 3,4,5 (should be wrapped for safety)
                                                         //	
 pBasePos[0] += dt * pBaseVel[0];
 pBasePos[1] += dt * pBaseVel[1];
 pBasePos[2] += dt * pBaseVel[2];

 ///////////////////////////////
 //local functor for quaternion integration (to avoid error prone redundancy)
 struct
 {
  //"exponential map" based on btTransformUtil::integrateTransform(..)
  void operator() (const btVector3 &omega, btQuaternion &quat, bool baseBody, btScalar dt)
  {
   //baseBody	=>	quat is alias and omega is global coor
   //!baseBody	=>	quat is alibi and omega is local coor	

   btVector3 axis;
   btVector3 angvel;

   if (!baseBody)
    angvel = quatRotate(quat, omega);				//if quat is not m_baseQuat, it is alibi => ok			
   else
    angvel = omega;

   btScalar fAngle = angvel.length();
   //limit the angular motion
   if (fAngle * dt > ANGULAR_MOTION_THRESHOLD)
   {
    fAngle = btScalar(0.5)*SIMD_HALF_PI / dt;
   }

   if (fAngle < btScalar(0.001))
   {
    // use Taylor's expansions of sync function
    axis = angvel*(btScalar(0.5)*dt - (dt*dt*dt)*(btScalar(0.020833333333))*fAngle*fAngle);
   }
   else
   {
    // sync(fAngle) = sin(c*fAngle)/t
    axis = angvel*(btSin(btScalar(0.5)*fAngle*dt) / fAngle);
   }

   if (!baseBody)
    quat = btQuaternion(axis.x(), axis.y(), axis.z(), btCos(fAngle*dt*btScalar(0.5))) * quat;
   else
    quat = quat * btQuaternion(-axis.x(), -axis.y(), -axis.z(), btCos(fAngle*dt*btScalar(0.5)));
   //equivalent to: quat = (btQuaternion(axis.x(),axis.y(),axis.z(),btCos( fAngle*dt*btScalar(0.5) )) * quat.inverse()).inverse();			

   quat.normalize();
  }
 } pQuatUpdateFun;
 ///////////////////////////////

 //pQuatUpdateFun(getBaseOmega(), m_baseQuat, true, dt);
 //	
 btScalar *pBaseQuat = pq ? pq : m_baseQuat;
 btScalar *pBaseOmega = pqd ? pqd : &m_realBuf[0];		//note: the !pqd case assumes m_realBuf starts with base omega (should be wrapped for safety)
                                                    //
 btQuaternion baseQuat; baseQuat.setValue(pBaseQuat[0], pBaseQuat[1], pBaseQuat[2], pBaseQuat[3]);
 btVector3 baseOmega; baseOmega.setValue(pBaseOmega[0], pBaseOmega[1], pBaseOmega[2]);
 pQuatUpdateFun(baseOmega, baseQuat, true, dt);
 pBaseQuat[0] = baseQuat.x();
 pBaseQuat[1] = baseQuat.y();
 pBaseQuat[2] = baseQuat.z();
 pBaseQuat[3] = baseQuat.w();


 //printf("pBaseOmega = %.4f %.4f %.4f\n", pBaseOmega->x(), pBaseOmega->y(), pBaseOmega->z());
 //printf("pBaseVel = %.4f %.4f %.4f\n", pBaseVel->x(), pBaseVel->y(), pBaseVel->z());
 //printf("baseQuat = %.4f %.4f %.4f %.4f\n", pBaseQuat->x(), pBaseQuat->y(), pBaseQuat->z(), pBaseQuat->w());

 if (pq)
  pq += 7;
 if (pqd)
  pqd += 6;

 // Finally we can update m_jointPos for each of the m_links
 for (int i = 0; i < num_links; ++i)
 {
  btScalar *pJointPos = (pq ? pq : &m_links[i].m_jointPos[0]);
  btScalar *pJointVel = (pqd ? pqd : getJointVelMultiDof(i));

  switch (m_links[i].m_jointType)
  {
  case btMultibodyLink::ePrismatic:
  case btMultibodyLink::eRevolute:
  {
   btScalar jointVel = pJointVel[0];
   pJointPos[0] += dt * jointVel;
   break;
  }
  case btMultibodyLink::eSpherical:
  {
   btVector3 jointVel; jointVel.setValue(pJointVel[0], pJointVel[1], pJointVel[2]);
   btQuaternion jointOri; jointOri.setValue(pJointPos[0], pJointPos[1], pJointPos[2], pJointPos[3]);
   pQuatUpdateFun(jointVel, jointOri, false, dt);
   pJointPos[0] = jointOri.x(); pJointPos[1] = jointOri.y(); pJointPos[2] = jointOri.z(); pJointPos[3] = jointOri.w();
   break;
  }
  case btMultibodyLink::ePlanar:
  {
   pJointPos[0] += dt * getJointVelMultiDof(i)[0];

   btVector3 q0_coors_qd1qd2 = getJointVelMultiDof(i)[1] * m_links[i].getAxisBottom(1) + getJointVelMultiDof(i)[2] * m_links[i].getAxisBottom(2);
   btVector3 no_q0_coors_qd1qd2 = quatRotate(btQuaternion(m_links[i].getAxisTop(0), pJointPos[0]), q0_coors_qd1qd2);
   pJointPos[1] += m_links[i].getAxisBottom(1).dot(no_q0_coors_qd1qd2) * dt;
   pJointPos[2] += m_links[i].getAxisBottom(2).dot(no_q0_coors_qd1qd2) * dt;

   break;
  }
  default:
  {
  }

  }

  m_links[i].updateCacheMultiDof(pq);

  if (pq)
   pq += m_links[i].m_posVarCount;
  if (pqd)
   pqd += m_links[i].m_dofCount;
 }
}

void btMultiBody::fillConstraintJacobianMultiDof(int link,
 const btVector3 &contact_point,
 const btVector3 &normal_ang,
 const btVector3 &normal_lin,
 btScalar *jac,
 btAlignedObjectArray<btScalar> &scratch_r,
 btAlignedObjectArray<btVector3> &scratch_v,
 btAlignedObjectArray<btMatrix3x3> &scratch_m) const
{
 // temporary space
 int num_links = getNumLinks();
 int m_dofCount = getNumDofs();
 scratch_v.resize(3 * num_links + 3);			//(num_links + base) offsets + (num_links + base) normals_lin + (num_links + base) normals_ang
 scratch_m.resize(num_links + 1);

 btVector3 * v_ptr = &scratch_v[0];
 btVector3 * p_minus_com_local = v_ptr; v_ptr += num_links + 1;
 btVector3 * n_local_lin = v_ptr; v_ptr += num_links + 1;
 btVector3 * n_local_ang = v_ptr; v_ptr += num_links + 1;
 btAssert(v_ptr - &scratch_v[0] == scratch_v.size());

 scratch_r.resize(m_dofCount);
 btScalar * results = m_dofCount > 0 ? &scratch_r[0] : 0;

 btMatrix3x3 * rot_from_world = &scratch_m[0];

 const btVector3 p_minus_com_world = contact_point - m_basePos;
 const btVector3 &normal_lin_world = normal_lin;							//convenience
 const btVector3 &normal_ang_world = normal_ang;

 rot_from_world[0] = btMatrix3x3(m_baseQuat);

 // omega coeffients first.
 btVector3 omega_coeffs_world;
 omega_coeffs_world = p_minus_com_world.cross(normal_lin_world);
 jac[0] = omega_coeffs_world[0] + normal_ang_world[0];
 jac[1] = omega_coeffs_world[1] + normal_ang_world[1];
 jac[2] = omega_coeffs_world[2] + normal_ang_world[2];
 // then v coefficients
 jac[3] = normal_lin_world[0];
 jac[4] = normal_lin_world[1];
 jac[5] = normal_lin_world[2];

 //create link-local versions of p_minus_com and normal
 p_minus_com_local[0] = rot_from_world[0] * p_minus_com_world;
 n_local_lin[0] = rot_from_world[0] * normal_lin_world;
 n_local_ang[0] = rot_from_world[0] * normal_ang_world;

 // Set remaining jac values to zero for now.
 for (int i = 6; i < 6 + m_dofCount; ++i)
 {
  jac[i] = 0;
 }

 // Qdot coefficients, if necessary.
 if (num_links > 0 && link > -1) {

  // TODO: speed this up -- don't calculate for m_links we don't need.
  // (Also, we are making 3 separate calls to this function, for the normal & the 2 friction directions,
  // which is resulting in repeated work being done...)

  // calculate required normals & positions in the local frames.
  for (int i = 0; i < num_links; ++i) {

   // transform to local frame
   const int parent = m_links[i].m_parent;
   const btMatrix3x3 mtx(m_links[i].m_cachedRotParentToThis);
   rot_from_world[i + 1] = mtx * rot_from_world[parent + 1];

   n_local_lin[i + 1] = mtx * n_local_lin[parent + 1];
   n_local_ang[i + 1] = mtx * n_local_ang[parent + 1];
   p_minus_com_local[i + 1] = mtx * p_minus_com_local[parent + 1] - m_links[i].m_cachedRVector;

   // calculate the jacobian entry
   switch (m_links[i].m_jointType)
   {
   case btMultibodyLink::eRevolute:
   {
    results[m_links[i].m_dofOffset] = n_local_lin[i + 1].dot(m_links[i].getAxisTop(0).cross(p_minus_com_local[i + 1]) + m_links[i].getAxisBottom(0));
    results[m_links[i].m_dofOffset] += n_local_ang[i + 1].dot(m_links[i].getAxisTop(0));
    break;
   }
   case btMultibodyLink::ePrismatic:
   {
    results[m_links[i].m_dofOffset] = n_local_lin[i + 1].dot(m_links[i].getAxisBottom(0));
    break;
   }
   case btMultibodyLink::eSpherical:
   {
    results[m_links[i].m_dofOffset + 0] = n_local_lin[i + 1].dot(m_links[i].getAxisTop(0).cross(p_minus_com_local[i + 1]) + m_links[i].getAxisBottom(0));
    results[m_links[i].m_dofOffset + 1] = n_local_lin[i + 1].dot(m_links[i].getAxisTop(1).cross(p_minus_com_local[i + 1]) + m_links[i].getAxisBottom(1));
    results[m_links[i].m_dofOffset + 2] = n_local_lin[i + 1].dot(m_links[i].getAxisTop(2).cross(p_minus_com_local[i + 1]) + m_links[i].getAxisBottom(2));

    results[m_links[i].m_dofOffset + 0] += n_local_ang[i + 1].dot(m_links[i].getAxisTop(0));
    results[m_links[i].m_dofOffset + 1] += n_local_ang[i + 1].dot(m_links[i].getAxisTop(1));
    results[m_links[i].m_dofOffset + 2] += n_local_ang[i + 1].dot(m_links[i].getAxisTop(2));

    break;
   }
   case btMultibodyLink::ePlanar:
   {
    results[m_links[i].m_dofOffset + 0] = n_local_lin[i + 1].dot(m_links[i].getAxisTop(0).cross(p_minus_com_local[i + 1]));// + m_links[i].getAxisBottom(0));
    results[m_links[i].m_dofOffset + 1] = n_local_lin[i + 1].dot(m_links[i].getAxisBottom(1));
    results[m_links[i].m_dofOffset + 2] = n_local_lin[i + 1].dot(m_links[i].getAxisBottom(2));

    break;
   }
   default:
   {
   }
   }

  }

  // Now copy through to output.
  //printf("jac[%d] = ", link);
  while (link != -1)
  {
   for (int dof = 0; dof < m_links[link].m_dofCount; ++dof)
   {
    jac[6 + m_links[link].m_dofOffset + dof] = results[m_links[link].m_dofOffset + dof];
    //printf("%.2f\t", jac[6 + m_links[link].m_dofOffset + dof]);
   }

   link = m_links[link].m_parent;
  }
  //printf("]\n");
 }
}


void btMultiBody::wakeUp()
{
 m_awake = true;
}

void btMultiBody::goToSleep()
{
 m_awake = false;
}

void btMultiBody::checkMotionAndSleepIfRequired(btScalar timestep)
{
 extern bool gDisableDeactivation;
 if (!m_canSleep || gDisableDeactivation)
 {
  m_awake = true;
  m_sleepTimer = 0;
  return;
 }

 // motion is computed as omega^2 + v^2 + (sum of squares of joint velocities)
 btScalar motion = 0;
 {
  for (int i = 0; i < 6 + m_dofCount; ++i)
   motion += m_realBuf[i] * m_realBuf[i];
 }


 if (motion < SLEEP_EPSILON) {
  m_sleepTimer += timestep;
  if (m_sleepTimer > SLEEP_TIMEOUT) {
   goToSleep();
  }
 }
 else {
  m_sleepTimer = 0;
  if (!m_awake)
   wakeUp();
 }
}


void	btMultiBody::forwardKinematics(btAlignedObjectArray<btQuaternion>& world_to_local, btAlignedObjectArray<btVector3>& local_origin)
{

 int num_links = getNumLinks();

 // Cached 3x3 rotation matrices from parent frame to this frame.
 btMatrix3x3* rot_from_parent = (btMatrix3x3 *)&m_matrixBuf[0];

 rot_from_parent[0] = btMatrix3x3(m_baseQuat);				//m_baseQuat assumed to be alias!?

 for (int i = 0; i < num_links; ++i)
 {
  rot_from_parent[i + 1] = btMatrix3x3(m_links[i].m_cachedRotParentToThis);
 }

 int nLinks = getNumLinks();
 ///base + num m_links
 world_to_local.resize(nLinks + 1);
 local_origin.resize(nLinks + 1);

 world_to_local[0] = getWorldToBaseRot();
 local_origin[0] = getBasePos();

 for (int k = 0; k<getNumLinks(); k++)
 {
  const int parent = getParent(k);
  world_to_local[k + 1] = getParentToLocalRot(k) * world_to_local[parent + 1];
  local_origin[k + 1] = local_origin[parent + 1] + (quatRotate(world_to_local[k + 1].inverse(), getRVector(k)));
 }

 for (int link = 0; link<getNumLinks(); link++)
 {
  int index = link + 1;

  btVector3 posr = local_origin[index];
  btScalar quat[4] = { -world_to_local[index].x(),-world_to_local[index].y(),-world_to_local[index].z(),world_to_local[index].w() };
  btTransform tr;
  tr.setIdentity();
  tr.setOrigin(posr);
  tr.setRotation(btQuaternion(quat[0], quat[1], quat[2], quat[3]));
  getLink(link).m_cachedWorldTransform = tr;

 }

}

void	btMultiBody::updateCollisionObjectWorldTransforms(btAlignedObjectArray<btQuaternion>& world_to_local, btAlignedObjectArray<btVector3>& local_origin)
{
 world_to_local.resize(getNumLinks() + 1);
 local_origin.resize(getNumLinks() + 1);

 world_to_local[0] = getWorldToBaseRot();
 local_origin[0] = getBasePos();

 if (getBaseCollider())
 {
  btVector3 posr = local_origin[0];
  //	float pos[4]={posr.x(),posr.y(),posr.z(),1};
  btScalar quat[4] = { -world_to_local[0].x(),-world_to_local[0].y(),-world_to_local[0].z(),world_to_local[0].w() };
  btTransform tr;
  tr.setIdentity();
  tr.setOrigin(posr);
  tr.setRotation(btQuaternion(quat[0], quat[1], quat[2], quat[3]));

  getBaseCollider()->setWorldTransform(tr);

 }

 for (int k = 0; k<getNumLinks(); k++)
 {
  const int parent = getParent(k);
  world_to_local[k + 1] = getParentToLocalRot(k) * world_to_local[parent + 1];
  local_origin[k + 1] = local_origin[parent + 1] + (quatRotate(world_to_local[k + 1].inverse(), getRVector(k)));
 }


 for (int m = 0; m<getNumLinks(); m++)
 {
  btMultiBodyLinkCollider* col = getLink(m).m_collider;
  if (col)
  {
   int link = col->m_link;
   btAssert(link == m);

   int index = link + 1;

   btVector3 posr = local_origin[index];
   //			float pos[4]={posr.x(),posr.y(),posr.z(),1};
   btScalar quat[4] = { -world_to_local[index].x(),-world_to_local[index].y(),-world_to_local[index].z(),world_to_local[index].w() };
   btTransform tr;
   tr.setIdentity();
   tr.setOrigin(posr);
   tr.setRotation(btQuaternion(quat[0], quat[1], quat[2], quat[3]));

   col->setWorldTransform(tr);
  }
 }
}

int	btMultiBody::calculateSerializeBufferSize()	const
{
 int sz = sizeof(btMultiBodyData);
 return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char*	btMultiBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
 btMultiBodyData* mbd = (btMultiBodyData*)dataBuffer;
 getBaseWorldTransform().serialize(mbd->m_baseWorldTransform);
 mbd->m_baseMass = this->getBaseMass();
 getBaseInertia().serialize(mbd->m_baseInertia);
 {
  char* name = (char*)serializer->findNameForPointer(m_baseName);
  mbd->m_baseName = (char*)serializer->getUniquePointer(name);
  if (mbd->m_baseName)
  {
   serializer->serializeName(name);
  }
 }
 mbd->m_numLinks = this->getNumLinks();
 if (mbd->m_numLinks)
 {
  int sz = sizeof(btMultiBodyLinkData);
  int numElem = mbd->m_numLinks;
  btChunk* chunk = serializer->allocate(sz, numElem);
  btMultiBodyLinkData* memPtr = (btMultiBodyLinkData*)chunk->m_oldPtr;
  for (int i = 0; i<numElem; i++, memPtr++)
  {

   memPtr->m_jointType = getLink(i).m_jointType;
   memPtr->m_dofCount = getLink(i).m_dofCount;
   memPtr->m_posVarCount = getLink(i).m_posVarCount;

   getLink(i).m_inertiaLocal.serialize(memPtr->m_linkInertia);
   memPtr->m_linkMass = getLink(i).m_mass;
   memPtr->m_parentIndex = getLink(i).m_parent;
   memPtr->m_jointDamping = getLink(i).m_jointDamping;
   memPtr->m_jointFriction = getLink(i).m_jointFriction;
   memPtr->m_jointLowerLimit = getLink(i).m_jointLowerLimit;
   memPtr->m_jointUpperLimit = getLink(i).m_jointUpperLimit;
   memPtr->m_jointMaxForce = getLink(i).m_jointMaxForce;
   memPtr->m_jointMaxVelocity = getLink(i).m_jointMaxVelocity;

   getLink(i).m_eVector.serialize(memPtr->m_parentComToThisComOffset);
   getLink(i).m_dVector.serialize(memPtr->m_thisPivotToThisComOffset);
   getLink(i).m_zeroRotParentToThis.serialize(memPtr->m_zeroRotParentToThis);
   btAssert(memPtr->m_dofCount <= 3);
   for (int dof = 0; dof<getLink(i).m_dofCount; dof++)
   {
    getLink(i).getAxisBottom(dof).serialize(memPtr->m_jointAxisBottom[dof]);
    getLink(i).getAxisTop(dof).serialize(memPtr->m_jointAxisTop[dof]);

    memPtr->m_jointTorque[dof] = getLink(i).m_jointTorque[dof];
    memPtr->m_jointVel[dof] = getJointVelMultiDof(i)[dof];

   }
   int numPosVar = getLink(i).m_posVarCount;
   for (int posvar = 0; posvar < numPosVar; posvar++)
   {
    memPtr->m_jointPos[posvar] = getLink(i).m_jointPos[posvar];
   }


   {
    char* name = (char*)serializer->findNameForPointer(m_links[i].m_linkName);
    memPtr->m_linkName = (char*)serializer->getUniquePointer(name);
    if (memPtr->m_linkName)
    {
     serializer->serializeName(name);
    }
   }
   {
    char* name = (char*)serializer->findNameForPointer(m_links[i].m_jointName);
    memPtr->m_jointName = (char*)serializer->getUniquePointer(name);
    if (memPtr->m_jointName)
    {
     serializer->serializeName(name);
    }
   }
   memPtr->m_linkCollider = (btCollisionObjectData*)serializer->getUniquePointer(getLink(i).m_collider);

  }
  serializer->finalizeChunk(chunk, btMultiBodyLinkDataName, BT_ARRAY_CODE, (void*)&m_links[0]);
 }
 mbd->m_links = mbd->m_numLinks ? (btMultiBodyLinkData*)serializer->getUniquePointer((void*)&m_links[0]) : 0;

 // Fill padding with zeros to appease msan.
#ifdef BT_USE_DOUBLE_PRECISION
 memset(mbd->m_padding, 0, sizeof(mbd->m_padding));
#endif

 return btMultiBodyDataName;
}

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Featherstone/btMultiBodyDynamicsWorld.h"
#include "BulletDynamics/Featherstone/btMultiBodyConstraintSolver.h"
#include "BulletDynamics/Featherstone/btMultiBody.h"
#include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "LinearMath/btQuickprof.h"
#include "BulletDynamics/Featherstone/btMultiBodyConstraint.h"
#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btSerializer.h"


void	btMultiBodyDynamicsWorld::addMultiBody(btMultiBody* body, int group, int mask)
{
 m_multiBodies.push_back(body);

}

void	btMultiBodyDynamicsWorld::removeMultiBody(btMultiBody* body)
{
 m_multiBodies.remove(body);
}

void	btMultiBodyDynamicsWorld::calculateSimulationIslands()
{
 BT_PROFILE("calculateSimulationIslands");

 getSimulationIslandManager()->updateActivationState(getCollisionWorld(), getCollisionWorld()->getDispatcher());

 {
  //merge islands based on speculative contact manifolds too
  for (int i = 0; i<this->m_predictiveManifolds.size(); i++)
  {
   btPersistentManifold* manifold = m_predictiveManifolds[i];

   const btCollisionObject* colObj0 = manifold->getBody0();
   const btCollisionObject* colObj1 = manifold->getBody1();

   if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
    ((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
   {
    getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
   }
  }
 }

 {
  int i;
  int numConstraints = int(m_constraints.size());
  for (i = 0; i< numConstraints; i++)
  {
   btTypedConstraint* constraint = m_constraints[i];
   if (constraint->isEnabled())
   {
    const btRigidBody* colObj0 = &constraint->getRigidBodyA();
    const btRigidBody* colObj1 = &constraint->getRigidBodyB();

    if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
     ((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
    {
     getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
    }
   }
  }
 }

 //merge islands linked by Featherstone link colliders
 for (int i = 0; i<m_multiBodies.size(); i++)
 {
  btMultiBody* body = m_multiBodies[i];
  {
   btMultiBodyLinkCollider* prev = body->getBaseCollider();

   for (int b = 0; b<body->getNumLinks(); b++)
   {
    btMultiBodyLinkCollider* cur = body->getLink(b).m_collider;

    if (((cur) && (!(cur)->isStaticOrKinematicObject())) &&
     ((prev) && (!(prev)->isStaticOrKinematicObject())))
    {
     int tagPrev = prev->getIslandTag();
     int tagCur = cur->getIslandTag();
     getSimulationIslandManager()->getUnionFind().unite(tagPrev, tagCur);
    }
    if (cur && !cur->isStaticOrKinematicObject())
     prev = cur;

   }
  }
 }

 //merge islands linked by multibody constraints
 {
  for (int i = 0; i<this->m_multiBodyConstraints.size(); i++)
  {
   btMultiBodyConstraint* c = m_multiBodyConstraints[i];
   int tagA = c->getIslandIdA();
   int tagB = c->getIslandIdB();
   if (tagA >= 0 && tagB >= 0)
    getSimulationIslandManager()->getUnionFind().unite(tagA, tagB);
  }
 }

 //Store the island id in each body
 getSimulationIslandManager()->storeIslandActivationState(getCollisionWorld());

}


void	btMultiBodyDynamicsWorld::updateActivationState(btScalar timeStep)
{
 BT_PROFILE("btMultiBodyDynamicsWorld::updateActivationState");



 for (int i = 0; i<m_multiBodies.size(); i++)
 {
  btMultiBody* body = m_multiBodies[i];
  if (body)
  {
   body->checkMotionAndSleepIfRequired(timeStep);
   if (!body->isAwake())
   {
    btMultiBodyLinkCollider* col = body->getBaseCollider();
    if (col && col->getActivationState() == ACTIVE_TAG)
    {
     col->setActivationState(WANTS_DEACTIVATION);
     col->setDeactivationTime(0.f);
    }
    for (int b = 0; b<body->getNumLinks(); b++)
    {
     btMultiBodyLinkCollider* col = body->getLink(b).m_collider;
     if (col && col->getActivationState() == ACTIVE_TAG)
     {
      col->setActivationState(WANTS_DEACTIVATION);
      col->setDeactivationTime(0.f);
     }
    }
   }
   else
   {
    btMultiBodyLinkCollider* col = body->getBaseCollider();
    if (col && col->getActivationState() != DISABLE_DEACTIVATION)
     col->setActivationState(ACTIVE_TAG);

    for (int b = 0; b<body->getNumLinks(); b++)
    {
     btMultiBodyLinkCollider* col = body->getLink(b).m_collider;
     if (col && col->getActivationState() != DISABLE_DEACTIVATION)
      col->setActivationState(ACTIVE_TAG);
    }
   }

  }
 }

 btDiscreteDynamicsWorld::updateActivationState(timeStep);
}


SIMD_FORCE_INLINE	int	btGetConstraintIslandId2(const btTypedConstraint* lhs)
{
 int islandId;

 const btCollisionObject& rcolObj0 = lhs->getRigidBodyA();
 const btCollisionObject& rcolObj1 = lhs->getRigidBodyB();
 islandId = rcolObj0.getIslandTag() >= 0 ? rcolObj0.getIslandTag() : rcolObj1.getIslandTag();
 return islandId;

}


class btSortConstraintOnIslandPredicate2
{
public:

 bool operator() (const btTypedConstraint* lhs, const btTypedConstraint* rhs) const
 {
  int rIslandId0, lIslandId0;
  rIslandId0 = btGetConstraintIslandId2(rhs);
  lIslandId0 = btGetConstraintIslandId2(lhs);
  return lIslandId0 < rIslandId0;
 }
};



SIMD_FORCE_INLINE	int	btGetMultiBodyConstraintIslandId(const btMultiBodyConstraint* lhs)
{
 int islandId;

 int islandTagA = lhs->getIslandIdA();
 int islandTagB = lhs->getIslandIdB();
 islandId = islandTagA >= 0 ? islandTagA : islandTagB;
 return islandId;

}


class btSortMultiBodyConstraintOnIslandPredicate
{
public:

 bool operator() (const btMultiBodyConstraint* lhs, const btMultiBodyConstraint* rhs) const
 {
  int rIslandId0, lIslandId0;
  rIslandId0 = btGetMultiBodyConstraintIslandId(rhs);
  lIslandId0 = btGetMultiBodyConstraintIslandId(lhs);
  return lIslandId0 < rIslandId0;
 }
};

struct MultiBodyInplaceSolverIslandCallback : public btSimulationIslandManager::IslandCallback
{
 btContactSolverInfo*	m_solverInfo;
 btMultiBodyConstraintSolver*		m_solver;
 btMultiBodyConstraint**		m_multiBodySortedConstraints;
 int							m_numMultiBodyConstraints;

 btTypedConstraint**		m_sortedConstraints;
 int						m_numConstraints;
 btIDebugDraw*			m_debugDrawer;
 btDispatcher*			m_dispatcher;

 btAlignedObjectArray<btCollisionObject*> m_bodies;
 btAlignedObjectArray<btPersistentManifold*> m_manifolds;
 btAlignedObjectArray<btTypedConstraint*> m_constraints;
 btAlignedObjectArray<btMultiBodyConstraint*> m_multiBodyConstraints;


 MultiBodyInplaceSolverIslandCallback(btMultiBodyConstraintSolver*	solver,
  btDispatcher* dispatcher)
  :m_solverInfo(NULL),
  m_solver(solver),
  m_multiBodySortedConstraints(NULL),
  m_numConstraints(0),
  m_debugDrawer(NULL),
  m_dispatcher(dispatcher)
 {

 }

 MultiBodyInplaceSolverIslandCallback& operator=(MultiBodyInplaceSolverIslandCallback& other)
 {
  btAssert(0);
  (void)other;
  return *this;
 }

 SIMD_FORCE_INLINE void setup(btContactSolverInfo* solverInfo, btTypedConstraint** sortedConstraints, int numConstraints, btMultiBodyConstraint** sortedMultiBodyConstraints, int	numMultiBodyConstraints, btIDebugDraw* debugDrawer)
 {
  btAssert(solverInfo);
  m_solverInfo = solverInfo;

  m_multiBodySortedConstraints = sortedMultiBodyConstraints;
  m_numMultiBodyConstraints = numMultiBodyConstraints;
  m_sortedConstraints = sortedConstraints;
  m_numConstraints = numConstraints;

  m_debugDrawer = debugDrawer;
  m_bodies.resize(0);
  m_manifolds.resize(0);
  m_constraints.resize(0);
  m_multiBodyConstraints.resize(0);
 }


 virtual	void	processIsland(btCollisionObject** bodies, int numBodies, btPersistentManifold**	manifolds, int numManifolds, int islandId)
 {
  if (islandId<0)
  {
   ///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
   m_solver->solveMultiBodyGroup(bodies, numBodies, manifolds, numManifolds, m_sortedConstraints, m_numConstraints, &m_multiBodySortedConstraints[0], m_numConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
  }
  else
  {
   //also add all non-contact constraints/joints for this island
   btTypedConstraint** startConstraint = 0;
   btMultiBodyConstraint** startMultiBodyConstraint = 0;

   int numCurConstraints = 0;
   int numCurMultiBodyConstraints = 0;

   int i;

   //find the first constraint for this island

   for (i = 0; i<m_numConstraints; i++)
   {
    if (btGetConstraintIslandId2(m_sortedConstraints[i]) == islandId)
    {
     startConstraint = &m_sortedConstraints[i];
     break;
    }
   }
   //count the number of constraints in this island
   for (; i<m_numConstraints; i++)
   {
    if (btGetConstraintIslandId2(m_sortedConstraints[i]) == islandId)
    {
     numCurConstraints++;
    }
   }

   for (i = 0; i<m_numMultiBodyConstraints; i++)
   {
    if (btGetMultiBodyConstraintIslandId(m_multiBodySortedConstraints[i]) == islandId)
    {

     startMultiBodyConstraint = &m_multiBodySortedConstraints[i];
     break;
    }
   }
   //count the number of multi body constraints in this island
   for (; i<m_numMultiBodyConstraints; i++)
   {
    if (btGetMultiBodyConstraintIslandId(m_multiBodySortedConstraints[i]) == islandId)
    {
     numCurMultiBodyConstraints++;
    }
   }

   //if (m_solverInfo->m_minimumSolverBatchSize<=1)
   //{
   //	m_solver->solveGroup( bodies,numBodies,manifolds, numManifolds,startConstraint,numCurConstraints,*m_solverInfo,m_debugDrawer,m_dispatcher);
   //} else
   {

    for (i = 0; i<numBodies; i++)
     m_bodies.push_back(bodies[i]);
    for (i = 0; i<numManifolds; i++)
     m_manifolds.push_back(manifolds[i]);
    for (i = 0; i<numCurConstraints; i++)
     m_constraints.push_back(startConstraint[i]);

    for (i = 0; i<numCurMultiBodyConstraints; i++)
     m_multiBodyConstraints.push_back(startMultiBodyConstraint[i]);

    if ((m_constraints.size() + m_manifolds.size())>m_solverInfo->m_minimumSolverBatchSize)
    {
     processConstraints();
    }
    else
    {
     //printf("deferred\n");
    }
   }
  }
 }
 void	processConstraints()
 {

  btCollisionObject** bodies = m_bodies.size() ? &m_bodies[0] : 0;
  btPersistentManifold** manifold = m_manifolds.size() ? &m_manifolds[0] : 0;
  btTypedConstraint** constraints = m_constraints.size() ? &m_constraints[0] : 0;
  btMultiBodyConstraint** multiBodyConstraints = m_multiBodyConstraints.size() ? &m_multiBodyConstraints[0] : 0;

  //printf("mb contacts = %d, mb constraints = %d\n", mbContacts, m_multiBodyConstraints.size());

  m_solver->solveMultiBodyGroup(bodies, m_bodies.size(), manifold, m_manifolds.size(), constraints, m_constraints.size(), multiBodyConstraints, m_multiBodyConstraints.size(), *m_solverInfo, m_debugDrawer, m_dispatcher);
  m_bodies.resize(0);
  m_manifolds.resize(0);
  m_constraints.resize(0);
  m_multiBodyConstraints.resize(0);
 }

};



btMultiBodyDynamicsWorld::btMultiBodyDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btMultiBodyConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration)
 :btDiscreteDynamicsWorld(dispatcher, pairCache, constraintSolver, collisionConfiguration),
 m_multiBodyConstraintSolver(constraintSolver)
{
 //split impulse is not yet supported for Featherstone hierarchies
 //	getSolverInfo().m_splitImpulse = false;
 getSolverInfo().m_solverMode |= SOLVER_USE_2_FRICTION_DIRECTIONS;
 m_solverMultiBodyIslandCallback = new MultiBodyInplaceSolverIslandCallback(constraintSolver, dispatcher);
}

btMultiBodyDynamicsWorld::~btMultiBodyDynamicsWorld()
{
 delete m_solverMultiBodyIslandCallback;
}

void	btMultiBodyDynamicsWorld::forwardKinematics()
{

 for (int b = 0; b<m_multiBodies.size(); b++)
 {
  btMultiBody* bod = m_multiBodies[b];
  bod->forwardKinematics(m_scratch_world_to_local, m_scratch_local_origin);
 }
}
void	btMultiBodyDynamicsWorld::solveConstraints(btContactSolverInfo& solverInfo)
{
 forwardKinematics();



 BT_PROFILE("solveConstraints");

 m_sortedConstraints.resize(m_constraints.size());
 int i;
 for (i = 0; i<getNumConstraints(); i++)
 {
  m_sortedConstraints[i] = m_constraints[i];
 }
 m_sortedConstraints.quickSort(btSortConstraintOnIslandPredicate2());
 btTypedConstraint** constraintsPtr = getNumConstraints() ? &m_sortedConstraints[0] : 0;

 m_sortedMultiBodyConstraints.resize(m_multiBodyConstraints.size());
 for (i = 0; i<m_multiBodyConstraints.size(); i++)
 {
  m_sortedMultiBodyConstraints[i] = m_multiBodyConstraints[i];
 }
 m_sortedMultiBodyConstraints.quickSort(btSortMultiBodyConstraintOnIslandPredicate());

 btMultiBodyConstraint** sortedMultiBodyConstraints = m_sortedMultiBodyConstraints.size() ? &m_sortedMultiBodyConstraints[0] : 0;


 m_solverMultiBodyIslandCallback->setup(&solverInfo, constraintsPtr, m_sortedConstraints.size(), sortedMultiBodyConstraints, m_sortedMultiBodyConstraints.size(), getDebugDrawer());
 m_constraintSolver->prepareSolve(getCollisionWorld()->getNumCollisionObjects(), getCollisionWorld()->getDispatcher()->getNumManifolds());

 /// solve all the constraints for this island
 m_islandManager->buildAndProcessIslands(getCollisionWorld()->getDispatcher(), getCollisionWorld(), m_solverMultiBodyIslandCallback);

#ifndef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
 {
  BT_PROFILE("btMultiBody addForce");
  for (int i = 0; i<this->m_multiBodies.size(); i++)
  {
   btMultiBody* bod = m_multiBodies[i];

   bool isSleeping = false;

   if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
   {
    isSleeping = true;
   }
   for (int b = 0; b<bod->getNumLinks(); b++)
   {
    if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
     isSleeping = true;
   }

   if (!isSleeping)
   {
    //useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
    m_scratch_r.resize(bod->getNumLinks() + 1);			//multidof? ("Y"s use it and it is used to store qdd)
    m_scratch_v.resize(bod->getNumLinks() + 1);
    m_scratch_m.resize(bod->getNumLinks() + 1);

    bod->addBaseForce(m_gravity * bod->getBaseMass());

    for (int j = 0; j < bod->getNumLinks(); ++j)
    {
     bod->addLinkForce(j, m_gravity * bod->getLinkMass(j));
    }
   }//if (!isSleeping)
  }
 }
#endif //BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY


 {
  BT_PROFILE("btMultiBody stepVelocities");
  for (int i = 0; i<this->m_multiBodies.size(); i++)
  {
   btMultiBody* bod = m_multiBodies[i];

   bool isSleeping = false;

   if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
   {
    isSleeping = true;
   }
   for (int b = 0; b<bod->getNumLinks(); b++)
   {
    if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
     isSleeping = true;
   }

   if (!isSleeping)
   {
    //useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
    m_scratch_r.resize(bod->getNumLinks() + 1);			//multidof? ("Y"s use it and it is used to store qdd)
    m_scratch_v.resize(bod->getNumLinks() + 1);
    m_scratch_m.resize(bod->getNumLinks() + 1);
    bool doNotUpdatePos = false;

    {
     if (!bod->isUsingRK4Integration())
     {
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(solverInfo.m_timeStep, m_scratch_r, m_scratch_v, m_scratch_m);
     }
     else
     {
      //
      int numDofs = bod->getNumDofs() + 6;
      int numPosVars = bod->getNumPosVars() + 7;
      btAlignedObjectArray<btScalar> scratch_r2; scratch_r2.resize(2 * numPosVars + 8 * numDofs);
      //convenience
      btScalar *pMem = &scratch_r2[0];
      btScalar *scratch_q0 = pMem; pMem += numPosVars;
      btScalar *scratch_qx = pMem; pMem += numPosVars;
      btScalar *scratch_qd0 = pMem; pMem += numDofs;
      btScalar *scratch_qd1 = pMem; pMem += numDofs;
      btScalar *scratch_qd2 = pMem; pMem += numDofs;
      btScalar *scratch_qd3 = pMem; pMem += numDofs;
      btScalar *scratch_qdd0 = pMem; pMem += numDofs;
      btScalar *scratch_qdd1 = pMem; pMem += numDofs;
      btScalar *scratch_qdd2 = pMem; pMem += numDofs;
      btScalar *scratch_qdd3 = pMem; pMem += numDofs;
      btAssert((pMem - (2 * numPosVars + 8 * numDofs)) == &scratch_r2[0]);

      /////						
      //copy q0 to scratch_q0 and qd0 to scratch_qd0
      scratch_q0[0] = bod->getWorldToBaseRot().x();
      scratch_q0[1] = bod->getWorldToBaseRot().y();
      scratch_q0[2] = bod->getWorldToBaseRot().z();
      scratch_q0[3] = bod->getWorldToBaseRot().w();
      scratch_q0[4] = bod->getBasePos().x();
      scratch_q0[5] = bod->getBasePos().y();
      scratch_q0[6] = bod->getBasePos().z();
      //
      for (int link = 0; link < bod->getNumLinks(); ++link)
      {
       for (int dof = 0; dof < bod->getLink(link).m_posVarCount; ++dof)
        scratch_q0[7 + bod->getLink(link).m_cfgOffset + dof] = bod->getLink(link).m_jointPos[dof];
      }
      //
      for (int dof = 0; dof < numDofs; ++dof)
       scratch_qd0[dof] = bod->getVelocityVector()[dof];
      ////
      struct
      {
       btMultiBody *bod;
       btScalar *scratch_qx, *scratch_q0;

       void operator()()
       {
        for (int dof = 0; dof < bod->getNumPosVars() + 7; ++dof)
         scratch_qx[dof] = scratch_q0[dof];
       }
      } pResetQx = { bod, scratch_qx, scratch_q0 };
      //
      struct
      {
       void operator()(btScalar dt, const btScalar *pDer, const btScalar *pCurVal, btScalar *pVal, int size)
       {
        for (int i = 0; i < size; ++i)
         pVal[i] = pCurVal[i] + dt * pDer[i];
       }

      } pEulerIntegrate;
      //
      struct
      {
       void operator()(btMultiBody *pBody, const btScalar *pData)
       {
        btScalar *pVel = const_cast<btScalar*>(pBody->getVelocityVector());

        for (int i = 0; i < pBody->getNumDofs() + 6; ++i)
         pVel[i] = pData[i];

       }
      } pCopyToVelocityVector;
      //
      struct
      {
       void operator()(const btScalar *pSrc, btScalar *pDst, int start, int size)
       {
        for (int i = 0; i < size; ++i)
         pDst[i] = pSrc[start + i];
       }
      } pCopy;
      //

      btScalar h = solverInfo.m_timeStep;
#define output &m_scratch_r[bod->getNumDofs()]
      //calc qdd0 from: q0 & qd0	
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
      pCopy(output, scratch_qdd0, 0, numDofs);
      //calc q1 = q0 + h/2 * qd0
      pResetQx();
      bod->stepPositionsMultiDof(btScalar(.5)*h, scratch_qx, scratch_qd0);
      //calc qd1 = qd0 + h/2 * qdd0
      pEulerIntegrate(btScalar(.5)*h, scratch_qdd0, scratch_qd0, scratch_qd1, numDofs);
      //
      //calc qdd1 from: q1 & qd1
      pCopyToVelocityVector(bod, scratch_qd1);
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
      pCopy(output, scratch_qdd1, 0, numDofs);
      //calc q2 = q0 + h/2 * qd1
      pResetQx();
      bod->stepPositionsMultiDof(btScalar(.5)*h, scratch_qx, scratch_qd1);
      //calc qd2 = qd0 + h/2 * qdd1
      pEulerIntegrate(btScalar(.5)*h, scratch_qdd1, scratch_qd0, scratch_qd2, numDofs);
      //
      //calc qdd2 from: q2 & qd2
      pCopyToVelocityVector(bod, scratch_qd2);
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
      pCopy(output, scratch_qdd2, 0, numDofs);
      //calc q3 = q0 + h * qd2
      pResetQx();
      bod->stepPositionsMultiDof(h, scratch_qx, scratch_qd2);
      //calc qd3 = qd0 + h * qdd2
      pEulerIntegrate(h, scratch_qdd2, scratch_qd0, scratch_qd3, numDofs);
      //
      //calc qdd3 from: q3 & qd3
      pCopyToVelocityVector(bod, scratch_qd3);
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
      pCopy(output, scratch_qdd3, 0, numDofs);

      //
      //calc q = q0 + h/6(qd0 + 2*(qd1 + qd2) + qd3)
      //calc qd = qd0 + h/6(qdd0 + 2*(qdd1 + qdd2) + qdd3)						
      btAlignedObjectArray<btScalar> delta_q; delta_q.resize(numDofs);
      btAlignedObjectArray<btScalar> delta_qd; delta_qd.resize(numDofs);
      for (int i = 0; i < numDofs; ++i)
      {
       delta_q[i] = h / btScalar(6.)*(scratch_qd0[i] + 2 * scratch_qd1[i] + 2 * scratch_qd2[i] + scratch_qd3[i]);
       delta_qd[i] = h / btScalar(6.)*(scratch_qdd0[i] + 2 * scratch_qdd1[i] + 2 * scratch_qdd2[i] + scratch_qdd3[i]);
       //delta_q[i] = h*scratch_qd0[i];
       //delta_qd[i] = h*scratch_qdd0[i];
      }
      //
      pCopyToVelocityVector(bod, scratch_qd0);
      bod->applyDeltaVeeMultiDof(&delta_qd[0], 1);
      //
      if (!doNotUpdatePos)
      {
       btScalar *pRealBuf = const_cast<btScalar *>(bod->getVelocityVector());
       pRealBuf += 6 + bod->getNumDofs() + bod->getNumDofs()*bod->getNumDofs();

       for (int i = 0; i < numDofs; ++i)
        pRealBuf[i] = delta_q[i];

       //bod->stepPositionsMultiDof(1, 0, &delta_q[0]);
       bod->setPosUpdated(true);
      }

      //ugly hack which resets the cached data to t0 (needed for constraint solver)
      {
       for (int link = 0; link < bod->getNumLinks(); ++link)
        bod->getLink(link).updateCacheMultiDof();
       bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(0, m_scratch_r, m_scratch_v, m_scratch_m);
      }

     }
    }

#ifndef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
    bod->clearForcesAndTorques();
#endif //BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
   }//if (!isSleeping)
  }
 }

 clearMultiBodyConstraintForces();

 m_solverMultiBodyIslandCallback->processConstraints();

 m_constraintSolver->allSolved(solverInfo, m_debugDrawer);

 {
  BT_PROFILE("btMultiBody stepVelocities");
  for (int i = 0; i<this->m_multiBodies.size(); i++)
  {
   btMultiBody* bod = m_multiBodies[i];

   bool isSleeping = false;

   if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
   {
    isSleeping = true;
   }
   for (int b = 0; b<bod->getNumLinks(); b++)
   {
    if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
     isSleeping = true;
   }

   if (!isSleeping)
   {
    //useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
    m_scratch_r.resize(bod->getNumLinks() + 1);                 //multidof? ("Y"s use it and it is used to store qdd)
    m_scratch_v.resize(bod->getNumLinks() + 1);
    m_scratch_m.resize(bod->getNumLinks() + 1);


    {
     if (!bod->isUsingRK4Integration())
     {
      bool isConstraintPass = true;
      bod->computeAccelerationsArticulatedBodyAlgorithmMultiDof(solverInfo.m_timeStep, m_scratch_r, m_scratch_v, m_scratch_m, isConstraintPass);
     }
    }
   }
  }
 }

 for (int i = 0; i<this->m_multiBodies.size(); i++)
 {
  btMultiBody* bod = m_multiBodies[i];
  bod->processDeltaVeeMultiDof2();
 }

}

void	btMultiBodyDynamicsWorld::integrateTransforms(btScalar timeStep)
{
 btDiscreteDynamicsWorld::integrateTransforms(timeStep);

 {
  BT_PROFILE("btMultiBody stepPositions");
  //integrate and update the Featherstone hierarchies

  for (int b = 0; b<m_multiBodies.size(); b++)
  {
   btMultiBody* bod = m_multiBodies[b];
   bool isSleeping = false;
   if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
   {
    isSleeping = true;
   }
   for (int b = 0; b<bod->getNumLinks(); b++)
   {
    if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
     isSleeping = true;
   }


   if (!isSleeping)
   {
    int nLinks = bod->getNumLinks();

    ///base + num m_links


    {
     if (!bod->isPosUpdated())
      bod->stepPositionsMultiDof(timeStep);
     else
     {
      btScalar *pRealBuf = const_cast<btScalar *>(bod->getVelocityVector());
      pRealBuf += 6 + bod->getNumDofs() + bod->getNumDofs()*bod->getNumDofs();

      bod->stepPositionsMultiDof(1, 0, pRealBuf);
      bod->setPosUpdated(false);
     }
    }

    m_scratch_world_to_local.resize(nLinks + 1);
    m_scratch_local_origin.resize(nLinks + 1);

    bod->updateCollisionObjectWorldTransforms(m_scratch_world_to_local, m_scratch_local_origin);

   }
   else
   {
    bod->clearVelocities();
   }
  }
 }
}



void	btMultiBodyDynamicsWorld::addMultiBodyConstraint(btMultiBodyConstraint* constraint)
{
 m_multiBodyConstraints.push_back(constraint);
}

void	btMultiBodyDynamicsWorld::removeMultiBodyConstraint(btMultiBodyConstraint* constraint)
{
 m_multiBodyConstraints.remove(constraint);
}

void btMultiBodyDynamicsWorld::debugDrawMultiBodyConstraint(btMultiBodyConstraint* constraint)
{
 constraint->debugDraw(getDebugDrawer());
}


void	btMultiBodyDynamicsWorld::debugDrawWorld()
{
 BT_PROFILE("btMultiBodyDynamicsWorld debugDrawWorld");

 btDiscreteDynamicsWorld::debugDrawWorld();

 bool drawConstraints = false;
 if (getDebugDrawer())
 {
  int mode = getDebugDrawer()->getDebugMode();
  if (mode  & (btIDebugDraw::DBG_DrawConstraints | btIDebugDraw::DBG_DrawConstraintLimits))
  {
   drawConstraints = true;
  }

  if (drawConstraints)
  {
   BT_PROFILE("btMultiBody debugDrawWorld");


   for (int c = 0; c<m_multiBodyConstraints.size(); c++)
   {
    btMultiBodyConstraint* constraint = m_multiBodyConstraints[c];
    debugDrawMultiBodyConstraint(constraint);
   }

   for (int b = 0; b<m_multiBodies.size(); b++)
   {
    btMultiBody* bod = m_multiBodies[b];
    bod->forwardKinematics(m_scratch_world_to_local1, m_scratch_local_origin1);

    getDebugDrawer()->drawTransform(bod->getBaseWorldTransform(), (btScalar)0.1);


    for (int m = 0; m<bod->getNumLinks(); m++)
    {

     const btTransform& tr = bod->getLink(m).m_cachedWorldTransform;

     getDebugDrawer()->drawTransform(tr, (btScalar)0.1);

     //draw the joint axis
     if (bod->getLink(m).m_jointType == btMultibodyLink::eRevolute)
     {
      btVector3 vec = quatRotate(tr.getRotation(), bod->getLink(m).m_axes[0].m_topVec);

      btVector4 color(0, 0, 0, 1);//1,1,1);
      btVector3 from = vec + tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      btVector3 to = tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      getDebugDrawer()->drawLine(from, to, color);
     }
     if (bod->getLink(m).m_jointType == btMultibodyLink::eFixed)
     {
      btVector3 vec = quatRotate(tr.getRotation(), bod->getLink(m).m_axes[0].m_bottomVec);

      btVector4 color(0, 0, 0, 1);//1,1,1);
      btVector3 from = vec + tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      btVector3 to = tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      getDebugDrawer()->drawLine(from, to, color);
     }
     if (bod->getLink(m).m_jointType == btMultibodyLink::ePrismatic)
     {
      btVector3 vec = quatRotate(tr.getRotation(), bod->getLink(m).m_axes[0].m_bottomVec);

      btVector4 color(0, 0, 0, 1);//1,1,1);
      btVector3 from = vec + tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      btVector3 to = tr.getOrigin() - quatRotate(tr.getRotation(), bod->getLink(m).m_dVector);
      getDebugDrawer()->drawLine(from, to, color);
     }

    }
   }
  }
 }


}



void btMultiBodyDynamicsWorld::applyGravity()
{
 btDiscreteDynamicsWorld::applyGravity();
#ifdef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
 BT_PROFILE("btMultiBody addGravity");
 for (int i = 0; i<this->m_multiBodies.size(); i++)
 {
  btMultiBody* bod = m_multiBodies[i];

  bool isSleeping = false;

  if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
  {
   isSleeping = true;
  }
  for (int b = 0; b<bod->getNumLinks(); b++)
  {
   if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
    isSleeping = true;
  }

  if (!isSleeping)
  {
   bod->addBaseForce(m_gravity * bod->getBaseMass());

   for (int j = 0; j < bod->getNumLinks(); ++j)
   {
    bod->addLinkForce(j, m_gravity * bod->getLinkMass(j));
   }
  }//if (!isSleeping)
 }
#endif //BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
}

void btMultiBodyDynamicsWorld::clearMultiBodyConstraintForces()
{
 for (int i = 0; i<this->m_multiBodies.size(); i++)
 {
  btMultiBody* bod = m_multiBodies[i];
  bod->clearConstraintForces();
 }
}
void btMultiBodyDynamicsWorld::clearMultiBodyForces()
{
 {
  // BT_PROFILE("clearMultiBodyForces");
  for (int i = 0; i<this->m_multiBodies.size(); i++)
  {
   btMultiBody* bod = m_multiBodies[i];

   bool isSleeping = false;

   if (bod->getBaseCollider() && bod->getBaseCollider()->getActivationState() == ISLAND_SLEEPING)
   {
    isSleeping = true;
   }
   for (int b = 0; b<bod->getNumLinks(); b++)
   {
    if (bod->getLink(b).m_collider && bod->getLink(b).m_collider->getActivationState() == ISLAND_SLEEPING)
     isSleeping = true;
   }

   if (!isSleeping)
   {
    btMultiBody* bod = m_multiBodies[i];
    bod->clearForcesAndTorques();
   }
  }
 }

}
void btMultiBodyDynamicsWorld::clearForces()
{
 btDiscreteDynamicsWorld::clearForces();

#ifdef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
 clearMultiBodyForces();
#endif
}




void	btMultiBodyDynamicsWorld::serialize(btSerializer* serializer)
{

 serializer->startSerialization();

 serializeDynamicsWorldInfo(serializer);

 serializeMultiBodies(serializer);

 serializeRigidBodies(serializer);

 serializeCollisionObjects(serializer);

 serializer->finishSerialization();
}

void	btMultiBodyDynamicsWorld::serializeMultiBodies(btSerializer* serializer)
{
 int i;
 //serialize all collision objects
 for (i = 0; i<m_multiBodies.size(); i++)
 {
  btMultiBody* mb = m_multiBodies[i];
  {
   int len = mb->calculateSerializeBufferSize();
   btChunk* chunk = serializer->allocate(len, 1);
   const char* structType = mb->serialize(chunk->m_oldPtr, serializer);
   serializer->finalizeChunk(chunk, structType, BT_MULTIBODY_CODE, mb);
  }
 }

}